//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION
#include "..\..\Class\_CanOpenMng\_CanOpenMng.h"

(*!
<Class
	Name               = "_CanOpenMng"
	Revision           = "1.11"
	GUID               = "{0A05AA61-B3BC-4701-8699-7B43E82560B1}"
	RealtimeTask       = "true"
	DefRealtime        = "2 ms"
	CyclicTask         = "true"
	DefCyclictime      = "2 ms"
	BackgroundTask     = "true"
	DefBackground      = "10 ms"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\_CanOpenMng\Drive1.ico"
	SharedCommandTable = "true"
	Objectsize         = "(800,120)"
	Comment            = "This Class functions as a Manager for _CanOpenBasicDS301-Objects connected to it. It also functions as a CanOpen-Master by Sending SYNC, HEARTBEAT and NMT-messages to the CanOpen-Nodes.">
	<Channels>
		<Server Name="CycleTime" GUID="{3322F0DE-F84E-4CE7-8E44-E34EC11AD282}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the cyclic time of the Class (ms)"/>
		<Server Name="DeviceState" GUID="{22FB5230-433A-49D6-A395-CB43E604A36C}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the state of the Master/Mng"/>
		<Client Name="_CanOpenMngLSS" Required="true" Internal="true"/>
		<Client Name="ActivateCanBasicObject" Required="false" Internal="false" Comment="Set as initvalue&#13;&#10;set for creating a CanBasicObject and not individual CAN-Objects.&#13;&#10;&#13;&#10;With isochronous CAN-interface, the PDOs are nevertheless created as individual CAN-Objects."/>
		<Client Name="BaudrateCan" Required="true" Internal="false" DefValue="1" Comment="set baudrate for interface as initvalue&#13;&#10;&#13;&#10;0...615kBit/s&#13;&#10;1...500kBit/s&#13;&#10;2...250kBit/s&#13;&#10;3...125kBit/s&#13;&#10;4...100kBit/s&#13;&#10;5....50kBit/s&#13;&#10;6....20kBit/s&#13;&#10;7..1000kBit/s"/>
		<Client Name="CanInterfaceReady" Required="false" Internal="false" Comment="If a VaranCan interface is used, connect this client to the Online-Server of the Varan-Device.&#13;&#10;If local interface is used, leave this client unconnected."/>
		<Client Name="CanLib" Required="false" Internal="false" Comment="must connect to object from class _CanLib"/>
		<Client Name="CanLibIso" Required="false" Internal="false" Comment="Can be connected to a isocronous CAN-interface (e.g. CCA111).&#13;&#10;If connected the PDOs are sent/received over ISO-channel.&#13;&#10;SDOs, NG, HB and EMCY are still asyncronous."/>
		<Client Name="HeartBeatMult" Required="true" Internal="false" DefValue="0" Comment="Set as initvalue:&#13;&#10;0 ... No heartbeat is send from PLC&#13;&#10;&gt;0 ... A heartbeat is send from PLC. &#13;&#10;Heartbeat Period [ms] = HeartBeatMult X CycleTime [ms]"/>
		<Client Name="MasterId" Required="true" Internal="false" DefValue="1" Comment="Set as initvalue:&#13;&#10;CanOpen Id of the Master (used for the CanOpen devices which are consumers for the Heartbeat)&#13;&#10;Not used if HeartBeatMult = 0"/>
		<Client Name="SyncActive" Required="true" Internal="false" DefValue="1" Comment="Set function of sync message as init value&#13;&#10;0 .. Sending sync is inactive&#13;&#10;1 .. Sending the sync with datalength 1 byte which contains the counter.  The counter counts from 1 up to SyncCounter value.&#13;&#10;2 .. Sending sync with datalength 0 byte"/>
		<Client Name="SyncCounter" Required="true" Internal="false" DefValue="1" Comment="Sets the maximal value for the sync counter if the client SyncActive = 1, as init value.&#13;&#10;  1 to 240 .. Sending the sync with datalength 1 byte which contains the counter.  The counter counts from 1 up to SyncCounter value.&#13;&#10;241 to 255 .. reserved &#13;&#10;&#13;&#10;The  value  used  shall  be  the  least  common  multiple  of  all  the  TPDO  transmission  types &#13;&#10;(1 &lt; n &lt;= 240) used. This ensures that periodic SYNC events always happen in the SYNC cycles &#13;&#10;with the same counter value."/>
		<Client Name="TaskObjectCtrl" Required="false" Internal="false" Comment="Client is connected automatically to class _TaskObjectControl"/>
		<Client Name="To_StdLib" Required="false" Internal="false" Comment="Client is connected automatically to class _StdLib"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\_CanOpenMng\_CanOpenMng.h" Include="true"/>
			<File Path=".\Class\DiasMaster\DIASMaster.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="Roskri"/>
		<Dokumentation Revision="1.11" Date="25.06.2020" Author="PieSte" Company="Sigmatek" Description="Add LSS (Layer Setting Service) functions for internal use.&#13;&#10;Changed behavior at waiting for connected classes to avoid timeout error because of to long wait time."/>
		<Dokumentation Revision="1.10" Date="20.01.2020" Author="HaeTho" Company="Sigmatek" Description="Add some defines for _CanOpenBasicDS301 for segment transfer"/>
		<Dokumentation Revision="1.9" Date="08.10.2019" Author="PieSte" Company="Sigmatek" Description="Add state &quot;_CAN_NODE_DISABLED&quot; for can open nodes.&#13;&#10;Add a trace message if logging is not supported."/>
		<Dokumentation Revision="1.8" Date="04.07.2019" Author="EisMic" Company="Sigmatek" Description="A compiler warning has been disabled, which occurs since version 53 when compiling."/>
		<Dokumentation Revision="1.7" Date="11.09.2018" Author="PieSte" Company="Sigmatek" Description="Add Background() task and LogError(), LogValue() function for logging.&#13;&#10;Extend the options for &quot;SyncActive&quot; to send a sync message without length or a sync message with sync counter.&#13;&#10;Add logging entrys for errors at initialisation."/>
		<Dokumentation Revision="1.6" Date="16.04.2018" Author="RamAnd" Company="Sigmatek" Description="Added possibility to use ony CanLibIso (e.g. for VRI011, CIV521)."/>
		<Dokumentation Revision="1.5" Date="19.10.2017" Author="FurDom" Company="Sigmatek" Description="Added Client ActivateCanBasicObject. Set for creating a CanBasicObject and not individual CAN-Objects.&#13;&#10;Initvalue is 0 = deactivated&#13;&#10;Added function BasicCAN_IRQ"/>
		<Dokumentation Revision="1.4" Date="2017-07-19" Author="Roskri" Company="Sigmatek" Description="Client HeartBeatMult initvalue is changed to 0&#13;&#10;The Initialization of all CanOpenBasicDS301-objects is done in the Init-method of this class instead of in RT-method"/>
		<Dokumentation Revision="1.3" Date="2016-10-11" Author="Roskri" Company="Sigmatek" Description="All CanOpenBasicDS301-object connected to this class and not only the objects with client Required = 1 will finish their initialization before the objects are set in operational by this class."/>
		<Dokumentation Revision="1.2" Date="07.09.2016" Author="EisMic" Company="Sigmatek" Description="Reworked definitions to avoid identical redefinitions."/>
		<Dokumentation Revision="1.1" Date="2016-06-30" Author="Roskri" Company="Sigmatek" Description="Correction: Delay for checking the device-states during initialization is changed to the maximum heartbeat-time or lifetime of the required devices."/>
		<Dokumentation Revision="1.0" Date="2016-06-20" Author="Roskri" Company="Sigmatek" Description="Class Created"/>
	</RevDoku>
	<Network Name="_CanOpenMng">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_CanOpenMngLSS"
				GUID       = "{77C9BD3B-6B68-425D-BF4F-5CEEC4C5ABC9}"
				Class      = "_CanOpenLSS"
				Position   = "(240,180)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="ClassState"/>
					<Client Name="Can"/>
					<Client Name="ResponseTimeout" Value="500"/>
				</Channels>
				<AdditionalData>
					<Entry Name="DeviceType" Value="_CanOpenLSS"/>
				</AdditionalData>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this._CanOpenMngLSS" Destination="_CanOpenMngLSS.ClassState"/>
			<Connection Source="_CanOpenMngLSS.Can" Destination="this.CanLib" Vertices="(240,270),(38,270),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
_CanOpenMng : CLASS
	TYPE
	  _CAN_MNG_MODE :
	  (
	    _MNG_INITOBJECTS,
	    _MNG_WAIT_FOR_OBJECTS,
	    _MNG_OPERATIONAL,
	    _MNG_WAIT_FOR_SYNC,
	    _MNG_ERROR
	  )$UDINT;
	  _CAN_OPEN_DEVICE_STATE_EXT :  //! <Type Public="true" Name="_CAN_OPEN_DEVICE_STATE_EXT"/>
	  (
	    _CAN_BOOT_UP,  //! <Type Comment="Device is in NMT-State Bootup/Initialising or no NodeGuarding or Heartbeat is activated." Name="_CAN_OPEN_DEVICE_STATE_EXT._CAN_BOOT_UP"/>
	    _CAN_STOPPED,  //! <Type Comment="Device is in NMT-State Stopped" Name="_CAN_OPEN_DEVICE_STATE_EXT._CAN_STOPPED"/>
	    _CAN_OPERATIONAL,  //! <Type Comment="Device is in NMT-State Operational" Name="_CAN_OPEN_DEVICE_STATE_EXT._CAN_OPERATIONAL"/>
	    _CAN_PRE_OPERATIONAL,  //! <Type Comment="Device is in NMT-State Pre-Operational" Name="_CAN_OPEN_DEVICE_STATE_EXT._CAN_PRE_OPERATIONAL"/>
	    _CAN_NGERROR,  //! <Type Comment=" Node Guarding error occurred, e.g. connection disconnected, wrong baudrate" Name="_CAN_OPEN_DEVICE_STATE_EXT._CAN_NGERROR"/>
	    _CAN_HBERROR,  //! <Type Comment="Heartbeat error occurred, e.g. connection disconnected, wrong baudrate" Name="_CAN_OPEN_DEVICE_STATE_EXT._CAN_HBERROR"/>
	    _CAN_COMERROR,  //! <Type Comment="Communication Error, e.g SDO-Transfer or Rx Timeout(CheckRxPdo)" Name="_CAN_OPEN_DEVICE_STATE_EXT._CAN_COMERROR"/>
	    _CAN_LOGINERROR,  //! <Type Comment="Failed to login to manager" Name="_CAN_OPEN_DEVICE_STATE_EXT._CAN_LOGINERROR"/>
	    _CAN_CONFIGERROR,  //! <Type Comment="Failed to load configuration from xdc file." Name="_CAN_OPEN_DEVICE_STATE_EXT._CAN_CONFIGERROR"/>
	    _CAN_NODE_DISABLED,  //! <Type Comment="Object is disabled over &quot;Place&quot; setting DEACTIVATED_LSL.&#13;&#10;" Name="_CAN_OPEN_DEVICE_STATE_EXT._CAN_NODE_DISABLED"/>
	    _CAN_NODE_WRONG_HW:=10  //! <Type Comment="Check of Can device failed." Name="_CAN_OPEN_DEVICE_STATE_EXT._CAN_NODE_WRONG_HW"/>
	  )$UDINT;
#pragma pack(push, 1)
	  _CAN_OPEN_OBJECT : STRUCT
	    thisPointer : ^_CanOpenBasicDS301;
	    Index : DINT;
	    Required : DINT;
	  END_STRUCT;
#pragma pack(pop)
	  pHwcLogging : ^HwcLogging;
	  t_CanAvailability : BSINT
	  [
	    1 IsoCan,
	    2 AsyCan,
	    3 Bit3,
	    4 Bit4,
	    5 Bit5,
	    6 Bit6,
	    7 Bit7,
	    8 Bit8,
	  ];
#pragma pack(push, 1)
	  t_s_CallbackList : STRUCT
	    ThisPointer : ^void;
	    ActionPtr : ^void;
	    ObjNr : DINT;
	    pNext : ^t_s_CallbackList;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	DeviceState 	: SvrChCmd__CAN_OPEN_DEVICE_STATE_EXT_PTofCls__CanOpenMng;
	CycleTime 	: SvrCh_DINT;
  //Clients:
	To_StdLib 	: CltChCmd__StdLib;
	CanLib 	: CltChCmd__CanLib;
	CanLibIso 	: CltChCmd__CanLib;
	CanInterfaceReady 	: CltCh_DINT;
	TaskObjectCtrl 	: CltChCmd__TaskObjectControl;
	BaudrateCan 	: CltCh_UDINT;
	HeartBeatMult 	: CltCh_DINT;
	MasterId 	: CltCh_UDINT;
	SyncActive 	: CltCh_DINT;
	SyncCounter 	: CltCh_DINT;
	ActivateCanBasicObject 	: CltCh_DINT;
	_CanOpenMngLSS 	: CltChCmd__CanOpenLSS;
  //Variables:
		CanOpenObjects : ARRAY [0..CO_MAX_CAN_OBJECTS-1] OF _CAN_OPEN_OBJECT;

		NbrOfCanObjects 	: DINT;
		SyncValue 	: USINT;
		HeartBeatValue 	: DINT;
		firstscan 	: DINT;
		HeartBeatID 	: INT;
		RetCodeTx 	: DINT;
		HeartBeatMultCount 	: DINT;
		OpModeMaster 	: _CAN_MNG_MODE;
		RetCodeBaudSet 	: DINT;
		bStartup 	: BOOL;
		MaxObjIndex 	: DINT;
		udWaitForSyncTime 	: UDINT;
		udWaitForSyncTime2 	: UDINT;
		MaximumWaitTime 	: UDINT;
		bFirstInitDone 	: DINT;
		pCallbackList 	: ^t_s_CallbackList;
		pActFunctionPtr 	: pVoid;
		RXCAN_Data : ARRAY [0..10] OF USINT;

		CanAvailability 	: t_CanAvailability;
		usSyncDataLength 	: USINT;
		bLoggingNotSupported 	: BOOL;
		bManagerInactive 	: BOOL;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="Default function called from Cyclic task." Name="CyWork"/>
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="Default function called from Realtime task." Name="RtWork"/>
	FUNCTION VIRTUAL GLOBAL RtWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="Default function called from Background task." Name="Background"/>
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="Method for sending Nmt to a node or all nodes" Name="SetNmt"/>
	FUNCTION VIRTUAL GLOBAL SetNmt
		VAR_INPUT
			Para 	: HSINT;			//! <Variable Comment="Commands of the Nmt:&#13;&#10;16#01  // Start Remote Node&#13;&#10;16#02  // Stop Remote Node&#13;&#10;16#80  // Reset Node in Pre-Operational&#13;&#10;16#81  // Reset Node&#13;&#10;16#82  // Reset Communication" Name="SetNmt.Para"/>
			ID 	: DINT;			//! <Variable Comment="ID of the Node (CanID). For Value 0, command will be send to all nodes." Name="SetNmt.ID"/>
		END_VAR
		VAR_OUTPUT
			RetVal 	: DINT;			//! <Variable Comment="0: OK&#13;&#10;1: wrong CAN interface (1 of 2) &#13;&#10;2: Data length greater than 8 of ObjNr greater than 2047 &#13;&#10;4: Buffer full" Name="SetNmt.RetVal"/>
		END_VAR;
				//! <Function Comment="_CanOpenBaiscDS301 will be logged in to Manager" Name="LoginCanObj"/>
	FUNCTION VIRTUAL GLOBAL LoginCanObj
		VAR_INPUT
			pObj 	: ^_CanOpenBasicDS301;			//! <Variable Comment="Thispointer of _CanOpenBasicDS301 to be logged in." Name="LoginCanObj.pObj"/>
		END_VAR
		VAR_OUTPUT
			retCode 	: DINT;			//! <Variable Comment="0 ... No error&#13;&#10;-1... To Many _CanOpenBasicDS301-Objects&#13;&#10;-2... NIL-pointer&#13;&#10;-3... Object already logged in" Name="LoginCanObj.retCode"/>
		END_VAR;
				//! <Function Comment="Method for Checking if the CanOpen-Objects are initialised." Name="CheckInitDone"/>
	FUNCTION VIRTUAL CheckInitDone
		VAR_OUTPUT
			retCode 	: BOOL;			//! <Variable Comment="TRUE  ... Objects are initialized: Required devices have successfully finished their initialization. Not required devices have finished their initialization (either successfully or not successfully)&#13;&#10;FALSE ... Objects are not initialized:  Devices are not yet done with their initialization or required devices failed their initialization." Name="CheckInitDone.retCode"/>
		END_VAR;
				//! <Function Comment="Sets the Remote Transmit Request Flag of the receiving object.  this sends a request to the corresponding send object. after the object is received, the RTR flag is reset." Name="SetFlagNG"/>
	FUNCTION VIRTUAL GLOBAL SetFlagNG
		VAR_INPUT
			handle 	: DINT;			//! <Variable Comment="Number of the  Can-Object used (return value of the AddCanObj function)" Name="SetFlagNG.handle"/>
		END_VAR
		VAR_OUTPUT
			retCode 	: DINT;			//! <Variable Comment="0 = OK&#13;&#10;-1 = wrong handle" Name="SetFlagNG.retCode"/>
		END_VAR;
				//! <Function Comment="Sends an object to the CAN bus." Name="CanTxObj"/>
	FUNCTION VIRTUAL GLOBAL CanTxObj
		VAR_INPUT
			ObjNr 	: INT;			//! <Variable Comment="Object number (max. 2047)." Name="CanTxObj.ObjNr"/>
			length 	: USINT;			//! <Variable Comment="Data length (max. 8) ." Name="CanTxObj.length"/>
			data 	: pVoid;			//! <Variable Comment="Data pointer." Name="CanTxObj.data"/>
			UseIso 	: BOOL;			//! <Variable Comment="TRUE...If an isocronous CAN-interface is connected, it should be used.&#13;&#10;FALSE... If an isocronous CAN-interface is connected, it should not be used." Name="CanTxObj.UseIso"/>
		END_VAR
		VAR_OUTPUT
			retval 	: INT;			//! <Variable Comment="0: OK&#13;&#10;1: wrong CAN interface (1 of 2) &#13;&#10;2: Data length greater than 8 of ObjNr greater than 2047 &#13;&#10;4: Buffer full" Name="CanTxObj.retval"/>
		END_VAR;
				//! <Function Comment="Adds an object to the CAN bus. For Rx-Objects." Name="AddCanObjRx"/>
	FUNCTION VIRTUAL GLOBAL AddCanObjRx
		VAR_INPUT
			ObjNr 	: INT;			//! <Variable Comment="Object number (max. 2047)." Name="AddCanObjRx.ObjNr"/>
			Length 	: USINT;			//! <Variable Comment="Data length (max. 8) ." Name="AddCanObjRx.Length"/>
			Mode 	: USINT := 1;			//! <Variable Comment="0: RX without Interrupt&#13;&#10;1: RX with Interrupt&#13;&#10;" Name="AddCanObjRx.Mode"/>
			ActionPtr 	: pVoid;			//! <Variable Comment="Pointer to the function called by the Interrupt." Name="AddCanObjRx.ActionPtr"/>
			ThisPointer 	: pVoid;			//! <Variable Comment="Thispointer." Name="AddCanObjRx.ThisPointer"/>
			UseIso 	: BOOL;			//! <Variable Comment="TRUE...If an isocronous CAN-interface is connected, it should be used.&#13;&#10;FALSE... If an isocronous CAN-interface is connected, it should not be used." Name="AddCanObjRx.UseIso"/>
		END_VAR
		VAR_OUTPUT
			retVal 	: DINT;			//! <Variable Comment="0-11: Nr. CAN-Objects used &#13;&#10;-2: Length &gt; 8&#13;&#10;-3: ObjNr &gt; 2047&#13;&#10;-4: Mode &gt; 2&#13;&#10;-5: No User CAN-Object available" Name="AddCanObjRx.retVal"/>
		END_VAR;
				//! <Function Comment="Adds an object to the CAN bus. Tx-Objects for an isocronous CAN-interface." Name="AddCanObjTx"/>
	FUNCTION VIRTUAL GLOBAL AddCanObjTx
		VAR_INPUT
			ObjNr 	: INT;			//! <Variable Comment="Object number (max. 2047)." Name="AddCanObjTx.ObjNr"/>
			Length 	: USINT;			//! <Variable Comment="Data length (max. 8) ." Name="AddCanObjTx.Length"/>
			Mode 	: USINT := 2;			//! <Variable Comment="2: Tx (use function CanTxObject)" Name="AddCanObjTx.Mode"/>
			ActionPtr 	: pVoid := NIL;			//! <Variable Comment="Pointer to the function called by the Interrupt." Name="AddCanObjTx.ActionPtr"/>
			ThisPointer 	: pVoid := NIL;			//! <Variable Comment="Thispointer." Name="AddCanObjTx.ThisPointer"/>
		END_VAR
		VAR_OUTPUT
			retVal 	: DINT;			//! <Variable Comment="0-11: Nr. CAN-Objects used &#13;&#10;-2: Length &gt; 8&#13;&#10;-3: ObjNr &gt; 2047&#13;&#10;-4: Mode &gt; 2&#13;&#10;-5: No User CAN-Object available&#13;&#10;-10: An isocronous CAN-interface is not connected" Name="AddCanObjTx.retVal"/>
		END_VAR;
				//! <Function Comment="Method for Checking if the CanOpen-Objects with Required = 1 is in mode equal to desired state (input)" Name="CheckDeviceState"/>
	FUNCTION VIRTUAL CheckDeviceState
		VAR_INPUT
			state 	: _CAN_OPEN_DEVICE_STATE_EXT;			//! <Variable Comment="State to be compared to with DeviceState on the devices" Name="CheckDeviceState.state"/>
		END_VAR
		VAR_OUTPUT
			retCode 	: BOOL;			//! <Variable Comment="TRUE  ...  All required devices were in the desired state&#13;&#10;FALSE ... Not all required devices were in the desired state" Name="CheckDeviceState.retCode"/>
		END_VAR;
				//! <Function Comment="Method for checking the maximum nodeguarding time or heartbeat time on the required CanOpen-Devices" Name="GetMaxHBorNGTime"/>
	FUNCTION VIRTUAL GetMaxHBorNGTime
		VAR_OUTPUT
			MaxTime 	: UDINT;			//! <Variable Comment="Maximum nodeguarding or heartbeat time of the connected CanOpen-Devices" Name="GetMaxHBorNGTime.MaxTime"/>
		END_VAR;
				//! <Function Comment="get each interrupt from each CAN Modul, which send the RX in the defined objects" Name="BasicCAN_IRQ"/>
	FUNCTION GLOBAL BasicCAN_IRQ
		VAR_INPUT
			piCanPtr 	: ^SINT;			//! <Variable Comment="Pointer to can data." Name="BasicCAN_IRQ.piCanPtr"/>
			rxDataPtr 	: ^USINT;			//! <Variable Comment="Pointer to can data." Name="BasicCAN_IRQ.rxDataPtr"/>
			ThisPointer 	: DINT;			//! <Variable Comment="This pointer - must be set to this pointer of object." Name="BasicCAN_IRQ.ThisPointer"/>
		END_VAR;
				//! <Function Comment="prototype of called functions&#13;&#10;[&gt;pThispointer] pointer to the called class (this)&#13;&#10;[&gt;rxDataPtr] pointer to the CAN-Data" Name="function_call"/>
	FUNCTION GLOBAL function_call
		VAR_INPUT
			piCanPtr 	: ^SINT;			//! <Variable Comment="Pointer to can data." Name="function_call.piCanPtr"/>
			rxDataPtr 	: ^USINT;			//! <Variable Comment="Pointer to can data." Name="function_call.rxDataPtr"/>
			ThisPointer 	: pVoid;			//! <Variable Comment="This pointer - must be set to this pointer of object." Name="function_call.ThisPointer"/>
		END_VAR;
				//! <Function Comment="This function is used to add can rx object to callback list." Name="AddCanObjToList"/>
	FUNCTION AddCanObjToList
		VAR_INPUT
			ThisPointer 	: pVoid;			//! <Variable Comment="This pointer to class object." Name="AddCanObjToList.ThisPointer"/>
			ActionPtr 	: pVoid;			//! <Variable Comment="Pointer to callback function." Name="AddCanObjToList.ActionPtr"/>
			ObjNr 	: DINT;			//! <Variable Comment="Object number of can rx object." Name="AddCanObjToList.ObjNr"/>
		END_VAR
		VAR_OUTPUT
			retVal 	: DINT;			//! <Variable Comment="Return value of function.&#13;&#10; 1 .. ok&#13;&#10;-5 .. add of can object to list failed." Name="AddCanObjToList.retVal"/>
		END_VAR;
				//! <Function Comment="Method to log errors." Name="LogError"/>
	FUNCTION GLOBAL LogError
		VAR_INPUT
			pMsg 	: ^CHAR;			//! <Variable Comment="Pointer which contans string for logging." Name="LogError.pMsg"/>
		END_VAR;
				//! <Function Comment="Method to log errors with values." Name="LogValue"/>
	FUNCTION GLOBAL LogValue
		VAR_INPUT
			pString 	: ^CHAR;			//! <Variable Comment="Pointer which contans string for logging." Name="LogValue.pString"/>
			udValue 	: UDINT;			//! <Variable Comment="Value which is displayed as string at logging." Name="LogValue.udValue"/>
			udValue2 	: UDINT := 0xFFFFFFFF;			//! <Variable Comment="Value which is displayed as string at logging." Name="LogValue.udValue2"/>
			udValue3 	: UDINT := 0xFFFFFFFF;			//! <Variable Comment="Value which is displayed as string at logging." Name="LogValue.udValue3"/>
		END_VAR;
				//! <Function Comment="Switch all LSS slaves to wait or config mode (can be used to switch all to wait mode before picking one to configure with SwitchStateSelective).&#13;&#10;The state of the process as well as it&apos;s result can be checked via GetStatus()." Name="LSSSwitchStateGlobal"/>
	FUNCTION GLOBAL LSSSwitchStateGlobal
		VAR_INPUT
			NewState 	: USINT;			//! <Variable Comment="The State all connected LSS slaves should change to&#13;&#10;0..wait state&#13;&#10;1..config state" Name="LSSSwitchStateGlobal.NewState"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="Returncode to indicate success or errors of the call&#13;&#10;&#13;&#10;0...Successful&#13;&#10;-1...Class not ready&#13;&#10;-2...Invalid parameter&#13;&#10;" Name="LSSSwitchStateGlobal.retcode"/>
		END_VAR;
				//! <Function Comment="Set a new baud rate (LSS slave has to be in config state)&#13;&#10;The state of the process as well as it&apos;s result can be checked via GetStatus()." Name="LSSConfigureBitTiming"/>
	FUNCTION GLOBAL LSSConfigureBitTiming
		VAR_INPUT
			NewBaudrate 	: UINT;			//! <Variable Comment="New baudrate in kbps. Valid baudrates are:&#13;&#10;1000&#13;&#10;500&#13;&#10;250&#13;&#10;125&#13;&#10;50&#13;&#10;20" Name="LSSConfigureBitTiming.NewBaudrate"/>
			SwitchDelay 	: UINT := 0;			//! <Variable Comment="This delay in [ms] has to be waited twice by the network participants after receiving this message.&#13;&#10;Once before and once after switching to the new bit timing.&#13;&#10;&#13;&#10;If this value is set &gt; 0 the new bit timing is automatically stored (StoreConfiguration() is automatically executed) and activated (ActivateBitTiming executed) with this delay.&#13;&#10;If this value is 0, those steps have to be done manually.&#13;&#10;&#13;&#10;ATTENTION: If this is set, the baudrate of the PLC CAN interface will also be changed to the new baudrate!&#13;&#10;" Name="LSSConfigureBitTiming.SwitchDelay"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="Returncode to indicate success or errors of the call&#13;&#10;&#13;&#10;0...Successful&#13;&#10;-1...Class not ready&#13;&#10;-2...Invalid parameter&#13;&#10;" Name="LSSConfigureBitTiming.retcode"/>
		END_VAR;
				//! <Function Comment="Set a new node ID (LSS slave has to be in config state) with the option to directly store it in the node (StoreConfiguration() does not have to be called separately)&#13;&#10;The state of the process as well as it&apos;s result can be checked via GetStatus()." Name="LSSConfigureNodeID"/>
	FUNCTION GLOBAL LSSConfigureNodeID
		VAR_INPUT
			NewNodeID 	: USINT;			//! <Variable Comment="Defines the new node ID between 1 and 127" Name="LSSConfigureNodeID.NewNodeID"/>
			AutoStoreConfig 	: BOOL := TRUE;			//! <Variable Comment="This value defines if the node id should be automatically stored after setting it. (Default: TRUE)" Name="LSSConfigureNodeID.AutoStoreConfig"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="Returncode to indicate success or errors of the call&#13;&#10;&#13;&#10;0...Successful&#13;&#10;-1...Class not ready&#13;&#10;-2...Invalid parameter&#13;&#10;" Name="LSSConfigureNodeID.retcode"/>
		END_VAR;
				//! <Function Comment="Get device information of a LSS slave (has to be in config state)." Name="LSSInquireDeviceInfos"/>
	FUNCTION GLOBAL LSSInquireDeviceInfos
		VAR_INPUT
			InquireOptions 	: _CanOpenLSS::t_LSS_InquireOptions := 2#11111;			//! <Variable Comment="If not all infos needed, with this parameter the needed informations can be chosen" Name="LSSInquireDeviceInfos.InquireOptions"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="Returncode to indicate success or errors of the call&#13;&#10;&#13;&#10;0...Successful&#13;&#10;-1...Class not ready" Name="LSSInquireDeviceInfos.retcode"/>
		END_VAR;
				//! <Function Comment="Get the device infos requested by calling InquireDeviceInfos.&#13;&#10;If the command has been executed successfully on the CAN bus the information of the valid pointers will be filled." Name="LSSGetInquiredDeviceInfos"/>
	FUNCTION GLOBAL LSSGetInquiredDeviceInfos
		VAR_INPUT
			pVendorID 	: ^UDINT := NIL;			//! <Variable Comment="Provide the address of a variable (if the option for the VendorID has been set at the InquireDeviceInfos() call) to get the value of the received VendorID." Name="LSSGetInquiredDeviceInfos.pVendorID"/>
			pProductCode 	: ^UDINT := NIL;			//! <Variable Comment="Provide the address of a variable (if the option for the ProductCode has been set at the InquireDeviceInfos() call) to get the value of the received ProductCode." Name="LSSGetInquiredDeviceInfos.pProductCode"/>
			pRevisionNumber 	: ^UDINT := NIL;			//! <Variable Comment="Provide the address of a variable (if the option for the RevisionNumber has been set at the InquireDeviceInfos() call) to get the value of the received RevisionNumber." Name="LSSGetInquiredDeviceInfos.pRevisionNumber"/>
			pSerialNumber 	: ^UDINT := NIL;			//! <Variable Comment="Provide the address of a variable (if the option for the SerialNumber has been set at the InquireDeviceInfos() call) to get the value of the received SerialNumber." Name="LSSGetInquiredDeviceInfos.pSerialNumber"/>
			pNodeID 	: ^USINT := NIL;			//! <Variable Comment="Provide the address of a variable (if the option for the NodeID has been set at the InquireDeviceInfos() call) to get the value of the received NodeID." Name="LSSGetInquiredDeviceInfos.pNodeID"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="Returncode to indicate success or errors of the call&#13;&#10;&#13;&#10;0...Successful&#13;&#10;-1...Class not ready&#13;&#10;-2...Invalid parameter&#13;&#10;" Name="LSSGetInquiredDeviceInfos.retcode"/>
		END_VAR;
				//! <Function Comment="This method provides informations about the state of the last started task as well as details on errors if it failed." Name="LSSGetStatus"/>
	FUNCTION GLOBAL LSSGetStatus
		VAR_INPUT
			pErrorCode 	: ^_CanOpenLSS::t_LSS_ErrorCode;			//! <Variable Comment="Provide the address of a variable, so the method can store the error code details on it." Name="LSSGetStatus.pErrorCode"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: iprStates;			//! <Variable Comment="Returncode indicates the current state of the class.&#13;&#10;&#13;&#10;READY...The class is ready for a new task (Never had a task or completed the last task successfully)&#13;&#10;BUSY...The class is busy with a task&#13;&#10;ERROR...The last task resulted in an error&#13;&#10;" Name="LSSGetStatus.retcode"/>
		END_VAR;
				//! <Function Comment="Activate the bit timing which has been set via ConfigureBitTiming for all LSS slaves (LSS slave has to be in config state)&#13;&#10;After switching the baud rate for the slaves it is recommended also to switch the baud rate for the used CAN interface to be able to store the new configuration via StoreConfiguration()&#13;&#10;The state of the process as well as it&apos;s result can be checked via GetStatus()." Name="LSSActivateBitTiming"/>
	FUNCTION GLOBAL LSSActivateBitTiming
		VAR_INPUT
			SwitchDelay 	: UINT;			//! <Variable Comment="This delay in [ms] has to be waited twice by the network participants after receiving this message.&#13;&#10;Once before and once after switching to the new bit timing." Name="LSSActivateBitTiming.SwitchDelay"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="Returncode to indicate success or errors of the call&#13;&#10;&#13;&#10;0...Successful&#13;&#10;-1...Class not ready" Name="LSSActivateBitTiming.retcode"/>
		END_VAR;
				//! <Function Comment="Methode to change baudrate of connected CAN-Interface." Name="IFChangeBaudrate"/>
	FUNCTION GLOBAL IFChangeBaudrate
		VAR_INPUT
			Baudrate 	: USINT;			//! <Variable Comment="0: 615 kBit/s&#13;&#10;1: 500 kBit/s&#13;&#10;2: 250 kBit/s &#13;&#10;3: 125 kBit/s&#13;&#10;4: 100 kBit/s&#13;&#10;5: 50 kBit/s&#13;&#10;6: 20 kBit/s &#13;&#10;7: 1 MBit/s" Name="IFChangeBaudrate.Baudrate"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="0 = Function successful, otherwise error code." Name="IFChangeBaudrate.retcode"/>
		END_VAR;
				//! <Function Comment="Methode to get actual baudrate of CAN-Interface." Name="IFGetActBaudrate"/>
	FUNCTION GLOBAL IFGetActBaudrate
		VAR_OUTPUT
			Baudrate 	: USINT;			//! <Variable Comment="1: 500 kBit/s&#13;&#10;2: 250 kBit/s &#13;&#10;3: 125 kBit/s&#13;&#10;4: 100 kBit/s&#13;&#10;5: 50 kBit/s&#13;&#10;6: 20 kBit/s &#13;&#10;7: 1 MBit/s" Name="IFGetActBaudrate.Baudrate"/>
		END_VAR;
				//! <Function Comment="Method to stop realtime communication of manager." Name="StopStartMng"/>
	FUNCTION GLOBAL StopStartMng
		VAR_INPUT
			bStopStart 	: BOOL;			//! <Variable Comment="false .. manager realtime is not stopped&#13;&#10;true .. manager realtime is stopped" Name="StopStartMng.bStopStart"/>
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using _CanOpenLSS
#pragma usingLtd _CanLib
#pragma usingLtd _StdLib
#pragma usingLtd _TaskObjectControl


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _CanOpenMng::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__CANOPENMNG
1$UINT, 11$UINT, (SIZEOF(::_CanOpenMng))$UINT, 
2$UINT, 12$UINT, 0$UINT, 
TO_UDINT(2879897165), "_CanOpenMng", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::_CanOpenMng.DeviceState.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(4203537714), "DeviceState", 
(::_CanOpenMng.CycleTime.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2924485542), "CycleTime", 
//Clients:
(::_CanOpenMng.To_StdLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2139173287), "To_StdLib", TO_UDINT(3689364044), "_StdLib", 0$UINT, 0$UINT, 
(::_CanOpenMng.CanLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000100$UINT, TO_UDINT(3871287234), "CanLib", TO_UDINT(529317953), "_CanLib", 1$UINT, 10$UINT, 
(::_CanOpenMng.CanLibIso.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3838796667), "CanLibIso", TO_UDINT(529317953), "_CanLib", 1$UINT, 10$UINT, 
(::_CanOpenMng.CanInterfaceReady.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2524979304), "CanInterfaceReady", 
(::_CanOpenMng.TaskObjectCtrl.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1369227892), "TaskObjectCtrl", TO_UDINT(1584830088), "_TaskObjectControl", 1$UINT, 1$UINT, 
(::_CanOpenMng.BaudrateCan.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(436499563), "BaudrateCan", 
(::_CanOpenMng.HeartBeatMult.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2189202007), "HeartBeatMult", 
(::_CanOpenMng.MasterId.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3786884830), "MasterId", 
(::_CanOpenMng.SyncActive.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(747144972), "SyncActive", 
(::_CanOpenMng.SyncCounter.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(496177100), "SyncCounter", 
(::_CanOpenMng.ActivateCanBasicObject.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3443188535), "ActivateCanBasicObject", 
(::_CanOpenMng._CanOpenMngLSS.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2944600106), "_CanOpenMngLSS", TO_UDINT(1339255835), "_CanOpenLSS", 1$UINT, 1$UINT, 
END_FUNCTION


#define USER_CNT__CanOpenMng 10

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__CanOpenMng] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _CanOpenMng::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT__CanOpenMng, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
	vmt.CmdTable.RtWork		:= #RtWork();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #SetNmt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #LoginCanObj();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #CheckInitDone();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #SetFlagNG();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #CanTxObj();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #AddCanObjRx();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #AddCanObjTx();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #CheckDeviceState();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #GetMaxHBorNGTime();

#pragma warning (default : 74)
	DeviceState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF DeviceState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

#pragma usingLtd _CanOpenBasicDS301
#pragma usingLtd HwcLogging

//{{LSL_IMPLEMENTATION

#define FUNCTIONCALL(piCanPtr,rxDataPtr,ThisPointer) pActFunctionPtr $ function_Call(piCanPtr,rxDataPtr,ThisPointer)

FUNCTION VIRTUAL GLOBAL _CanOpenMng::Init
  VAR   
    ObjInfo : LSLOBJ_INFO;
  	i             : USINT;
    retVal : DINT;
  END_VAR

	   
  if firstscan = 0 then
    // Get Realtime time
    retVal := TaskObjectCtrl.GetObjectInfo( this,
                                            2, //for Realtime
                                           #ObjInfo);
              
    if retVal = 0 then
      CycleTime$UDINT := ObjInfo.period;
      //check for cycle time as µs
      if (CycleTime$HDINT and 0x80000000) then
        //convert cycletime from µs to ms
        CycleTime := (CycleTime and 0x7FFFFFFF) / 1000;
        if CycleTime = 0 then
          //cycle Time must be at least greater than zero
          CycleTime := 1;          
          LogError("@0408 (_CanOpenMng::Init) Realtimetask Object time is smaller than 1ms.");
        end_if;
      end_if;
    else
      //error getting cycle Time
      LogError("@0423 (_CanOpenMng::Init) Failed to get realtimetask object time.");
    end_if;


  elsif firstscan = 1 then 
    MasterId      := MasterId.Read();
    BaudrateCan   := BaudrateCan.Read();
    HeartBeatMult := HeartBeatMult.Read();
    SyncActive    := SyncActive.Read();
    SyncCounter   := SyncCounter.Read();
    ActivateCanBasicObject := ActivateCanBasicObject.Read();
    CanInterfaceReady := IsClientConnected(#CanInterfaceReady) <> 1; // if not connected say ready

    HeartBeatID := 16#700 + to_int(MasterId);        
    
(*
  3 valid connection scenarios:
  
  Asy & Iso: Sync and PDOs are handled in ISO, the rest in ASY
    CanAvailability bits show ASY and ISO;
        
  Only Iso: Everything handled in ISO (add 
    CanAvailability bits show only ISO;

  Only Asy:
    CanAvailability bits show only ASY;    
*)

    if SyncCounter < 1 | SyncCounter > 255 then
      //the sync counter value is not in possible range - set it to default value
      SyncCounter := 1;
    end_if;
    
    //First sync-value to be send
    SyncValue := 1;
     
    //check Sync Setting    
    if SyncActive = 1 then
      usSyncDataLength := 1;
    elsif SyncActive = 2 then
      usSyncDataLength := 0;
    else
      //set to deactivate if 0 or invalid value
      SyncActive := 0;
      usSyncDataLength := 0;
    end_if;
    
    if IsClientConnected(#CanLib) & IsClientConnected(#CanLibIso) then
    
      RetcodeBaudSet := CanLib.SetBaudrate(TO_USINT(BaudrateCan)); 
      
      CanAvailability := t_CanAvailability.IsoCan OR t_CanAvailability.AsyCan;
      
    elsif IsClientConnected(#CanLib) then

      RetcodeBaudSet := CanLib.SetBaudrate(TO_USINT(BaudrateCan)); 

      CanAvailability := t_CanAvailability.AsyCan;
      
    elsif IsClientConnected(#CanLibIso) then

      RetcodeBaudSet := CanLibIso.SetBaudrate(TO_USINT(BaudrateCan)); 

      CanAvailability := t_CanAvailability.IsoCan;
      
    else
      // no canlib connected => Error
      LogError("@0409 (_CanOpenMng::Init) There is no CanLib connected! _CanOpenMng is not working.");
//      CanAvailability := 0; // stays 0
    end_if;
    
    //check returncode for error
    if RetCodeBaudSet <> 0 then
      // no canlib connected => Error
      LogError("@06FF(_CanOpenMng::Init) Change of Baudrate was not successful!");    
    end_if;

    if CanAvailability.AsyCan = FALSE then
      // can basic object only possible on asy can
      ActivateCanBasicObject := 0;
    end_if;
    
    HeartBeatValue := CO_HB_OPERATIONAL; //value of HeartBeat;
    HeartBeatMultCount := -1;
    bStartup := TRUE;

  elsif firstscan = 2 then
    if NbrOfCanObjects < 1  then
      OpModeMaster := _MNG_ERROR;
      DeviceState := _CAN_STOPPED;
      LogError("@040A (_CanOpenMng::Init) There is no can object logged in. _CanOpenMng is not working.");      
    else
      
      //create nmt data object and sync/heart beat if configured and isochronous sending is used
      if CanAvailability.IsoCan then
        // only if there is no asynchronous can we need to create the asynchronous objects on the ISO can
        if CanAvailability.AsyCan = FALSE then
          // nmt
          retval := CanLibIso.AddCanObj(ObjNr:=0, Length:=2, Mode:=2, ActionPtr:=NIL, ThisPointer:=NIL);
          if retval < 0 then
            //adding can object has failed
            LogError("@040B (_CanOpenMng::Init) Failed to add isochronous can transmit object for nmt with COB-ID 0x000.");
          end_if;
          
          // heart beat
          retval := CanLibIso.AddCanObj(ObjNr:=HeartBeatID, Length:=1, Mode:=2, ActionPtr:=NIL, ThisPointer:=NIL);
          if retval < 0 then
            //adding can object has failed
            LogValue("@040C (_CanOpenMng::Init) Failed to add isochronous can transmit object for heartbeat with COB-ID 0x{0}.",HeartBeatID$HINT);
          end_if;
        end_if;
        
        // sync is always iso if possible
        if SyncActive then
          retval := CanLibIso.AddCanObj(ObjNr:=CO_SYNC_OBJNR, Length:=usSyncDataLength, Mode:=2, ActionPtr:=NIL, ThisPointer:=NIL);
          if retval < 0 then
            //adding can object has failed
            LogValue("@040C (_CanOpenMng::Init) Failed to add isochronous can transmit object for sync with COB-ID 0x{0}.",CO_SYNC_OBJNR);
          end_if;
        end_if;  
      end_if;      
     
      //create BasicCanObject
      if ActivateCanBasicObject = 1 then
        retVal := CanLib.InitBasicCanObject(ObjNr:=0, mask:=16#0000, ActionPointer:=#BasicCAN_IRQ(), ThisPointer:= this);
      end_if;
        
      for i:= 0 to MaxObjIndex  do
        // Initialize the global settings
        CanOpenObjects[i].thisPointer^.ObjectInit();
        // add the Can Objects
        CanOpenObjects[i].thisPointer^.AddCanObjects();
      end_for;
    
    end_If;
  end_if;
  
  
  firstscan += 1;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _CanOpenMng::RtWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
  VAR
  	i             : USINT;
  END_VAR
  
  if bManagerInactive = TRUE then
//    DeviceState := _CAN_BOOT_UP;
    return;
  end_if;
  
  CanInterfaceReady := CanInterfaceReady.Read();
  if CanInterfaceReady | (DeviceState <> _CAN_BOOT_UP) then
  
    if NbrOfCanObjects > 0  then
      for i:= 0 to MaxObjIndex  do
        CanOpenObjects[i].thisPointer^.CanControl();
      end_for; 
    end_if;
    
    //******************************************************************************************************
    // Device mode of Master/Mng STATE MACHINE
    //******************************************************************************************************
    
    case DeviceState of
      
      //******************************************************************************************************  
      _CAN_BOOT_UP:
        DeviceState := _CAN_PRE_OPERATIONAL;
        
      //******************************************************************************************************    
      _CAN_PRE_OPERATIONAL:
      
      //******************************************************************************************************
      // Internal OpMode of Master/Mng STATE MACHINE
      //******************************************************************************************************
      
        case OpModeMaster of
        
        //******************************************************************************************************  
        _MNG_INITOBJECTS:
        
          if NbrOfCanObjects < 1  then
            OpModeMaster := _MNG_ERROR;
            DeviceState := _CAN_STOPPED;
          else
          
            //initialization of canobject moved to init. roskri 19.07.2017
            OpModeMaster := _MNG_WAIT_FOR_OBJECTS;
            
          end_If;
          
        //******************************************************************************************************    
        _MNG_WAIT_FOR_OBJECTS:
        
          if CheckInitDone() = TRUE then
            //when devices with Required = 1 is in operational the slaves should reset communication
            for i:= 0 to MaxObjIndex do
              CanOpenObjects[i].thisPointer^.SetOpMode(_CanOpenBasicDS301::_CAN_NETENABLE);
            end_for;
            
            OpModeMaster := _MNG_WAIT_FOR_SYNC;
            DeviceState := _CAN_OPERATIONAL;
            if HeartBeatMult > 0 then
              HeartBeatMultCount := 0;            
            end_if;
            
            //Sync-value has to start with 1
            SyncValue := 1;
            
            udWaitForSyncTime  := ops.tAbsolute;
            udWaitForSyncTime2 := ops.tAbsolute;
            
            //send StartRemoteNode to all nodes
            SetNmt(CO_STARTREMOTENODE,0); //all nodes
            bStartup := FALSE;
            bFirstInitDone := TRUE; 
            MaximumWaitTime := GetMaxHBorNGTime() + CO_WAIT_FOR_SYNC; //delaytime for checking if the CanOpen-devices are in Operational
                        
          end_if; 
          
        end_case;
        
        //******************************************************************************************************
        // END Internal OpMode of Master/Mng STATE MACHINE
        //******************************************************************************************************
          
      _CAN_OPERATIONAL:
      
        //******************************************************************************************************
        // Internal OpMode of Master/Mng STATE MACHINE
        //******************************************************************************************************
          
        case OpModeMaster of
        
        //******************************************************************************************************
        _MNG_OPERATIONAL:
        
          if CheckDeviceState(_CAN_OPERATIONAL) = TRUE then
            
            //Send Sync
            if SyncActive then
              if CanAvailability.IsoCan then
                RetcodeTx:= CanLibIso.CanTxObj(CO_SYNC_OBJNR ,usSyncDataLength, #SyncValue); 
              elsif CanAvailability.AsyCan then
                RetcodeTx:= CanLib.CanTxObj(CO_SYNC_OBJNR, usSyncDataLength, #SyncValue); 
              end_if;
              //check sync counter for overflow
              if SyncValue < SyncCounter then              
                SyncValue += 1;
              else
                SyncValue := 1;
              end_if;
            end_if;

            //Send HeartBeat
            if HeartBeatMultCount = 0 then
              if CanAvailability.AsyCan then
                RetcodeTx :=  CanLib.CanTxObj(HeartBeatID,1,#HeartBeatValue);
              elsif CanAvailability.IsoCan then
                RetcodeTx :=  CanLibIso.CanTxObj(HeartBeatID,1,#HeartBeatValue);
              end_if;
            end_if;            
            
          else
            OpModeMaster := _MNG_WAIT_FOR_OBJECTS;
            DeviceState := _CAN_PRE_OPERATIONAL;
            HeartBeatMultCount := -1;
            
            //set pre-operational to all:
            SetNmt(CO_SETPREOPERATIONAL,0);
          end_if;
          
        
        //******************************************************************************************************  
        _MNG_WAIT_FOR_SYNC:          
                 
          //nmt was send, have to wait a while to check the devices
          
          if (ops.tAbsolute - udWaitForSyncTime) > (MaximumWaitTime) then          

            if CheckDeviceState(_CAN_OPERATIONAL) = TRUE then
              OpModeMaster := _MNG_OPERATIONAL;
              if HeartBeatMult > 0 then
                HeartBeatMultCount := 0;            
              end_if;
              
            else
              OpModeMaster := _MNG_WAIT_FOR_OBJECTS;
              DeviceState := _CAN_PRE_OPERATIONAL;
              HeartBeatMultCount := -1;
              
              //set pre-operational to all:
              SetNmt(CO_SETPREOPERATIONAL,0);
            end_if;
          //check state of classes during wait time because they could be available sooner  
          elsif (ops.tAbsolute - udWaitForSyncTime2) > (MaximumWaitTime/4) then
            if CheckDeviceState(_CAN_OPERATIONAL) = TRUE then
              OpModeMaster := _MNG_OPERATIONAL;
              if HeartBeatMult > 0 then
                HeartBeatMultCount := 0;            
              end_if;
            end_if;
            udWaitForSyncTime2 := ops.tAbsolute;            
          end_if;
          
        end_case;        
          
        //******************************************************************************************************
        // END Internal OpMode of Master/Mng STATE MACHINE
        //******************************************************************************************************
          
          
    end_case;
    
    //******************************************************************************************************
    // Device mode of Master/Mng STATE MACHINE
    //******************************************************************************************************
  
  
    if HeartBeatMultCount >= 0 then      
      HeartBeatMultCount += 1;
      if HeartBeatMultCount = HeartBeatMult then
        HeartBeatMultCount := 0;
      end_if;
    end_if;
  end_if;

	state:= READY;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL _CanOpenMng::CyWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
  VAR
  	uiTmpCnt : UINT;
  END_VAR

  //call connected classes for logging
  if NbrOfCanObjects then
    for uiTmpCnt := 0 to MaxObjIndex do
      CanOpenObjects[uiTmpCnt].thisPointer^.CanControlCy();
    end_for;  
  end_if;
    
  state := _CanOpenMngLSS.CyWork(EAX);

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _CanOpenMng::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
  VAR
  	uiTmpCnt : UINT;
  END_VAR

  //call connected classes for logging
  if NbrOfCanObjects then
    for uiTmpCnt := 0 to MaxObjIndex do
      CanOpenObjects[uiTmpCnt].thisPointer^.Background(EAX);
    end_for;  
  end_if;

	state := READY;

END_FUNCTION



FUNCTION VIRTUAL GLOBAL _CanOpenMng::SetNmt
	VAR_INPUT
		Para 	: HSINT;
		ID 	: DINT;
	END_VAR
	VAR_OUTPUT
		RetVal 	: DINT;
	END_VAR
  VAR
    TxBuffer : ARRAY[0..1] of HSINT;
  END_VAR
  
  TxBuffer[0] := Para;
  TxBuffer[1] := ID$USINT;
  
  if CanAvailability.AsyCan then
    RetVal := CanLib.CanTxObj( ObjNr  := 0, 
                               length := 2, 
                               data   := #TxBuffer);
  elsif CanAvailability.IsoCan then
    RetVal := CanLibIso.CanTxObj( ObjNr  := 0, 
                                  length := 2, 
                                  data   := #TxBuffer);    
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _CanOpenMng::LoginCanObj
	VAR_INPUT
		pObj 	: ^_CanOpenBasicDS301;
	END_VAR
	VAR_OUTPUT
		retCode 	: DINT;
	END_VAR
  VAR
  	i         : USINT;
    CanObj : _CAN_OPEN_OBJECT;
    tmpCanobj : _CAN_OPEN_OBJECT;
    tmpMaxobjIndex : UDINT;
  END_VAR 
  
  tmpMaxobjIndex := CO_MAX_CAN_OBJECTS - 1;
  
  retCode := 0;
  
  if NbrOfCanObjects >= CO_MAX_CAN_OBJECTS then
    retCode := -1;
    return; //to many objects
  end_if;
  
  if CanOpenObjects[NbrOfCanObjects].thisPointer <> NIL then  
    retcode := -2;
    return; //something with objectcounter went wrong
  end_if;

  for i:= 0 to tmpMaxobjIndex do    
    if CanOpenObjects[i].thisPointer = pObj$^void  then
      retCode := -3;
      return;
    end_if;    
  end_for;  
  
  CanObj.thisPointer := pObj;
  CanObj.Index := pObj^.Index;
  CanObj.Required := pObj^.Required;  
  
  //sort Device with lower priority first ( Index >= 0) and no priority last (index < 0)
  if CanObj.Index >= 0 then
    for i:= 0 to NbrOfCanObjects do
      if NbrOfCanObjects > 0 & i < NbrOfCanObjects then
          if (CanOpenObjects[i].Index > Canobj.Index | CanOpenObjects[i].Index < 0 ) &  Canobj.Index >= 0   then
            tmpCanObj := CanOpenObjects[i];
            CanOpenObjects[i] := CanObj;
            CanObj := tmpCanObj;
          end_if;    
      else
        CanOpenObjects[i] := CanObj;
      end_if;
    end_for;
  else
    CanOpenObjects[NbrOfCanObjects] := CanObj;
  end_if;

  MaxObjIndex := NbrOfCanObjects;
  NbrOfCanObjects += 1;  

END_FUNCTION


FUNCTION VIRTUAL _CanOpenMng::CheckInitDone
	VAR_OUTPUT
		retCode 	: BOOL;
	END_VAR  
  VAR
  	i         : USINT;
    tmpstate  : _CAN_OPEN_DEVICE_STATE_EXT;
  END_VAR

	retcode := True;

  if NbrOfCanObjects then
    for i:= 0 to MaxObjIndex  do
      
      //check required object
      if CanOpenObjects[i].Required = 1 then

        if CanOpenObjects[i].thisPointer^.CheckInitDone() = TRUE then
          retcode := retcode AND 1;
        else
          retcode := False;
        end_if;
      
      else //not required devices manager is waiting until initialisation is done (failed (_Can_Comerror) also means that the initialization is done (since they are not required on the bus))
        tmpstate := CanOpenObjects[i].thisPointer^.devicestate.Read();
        if (CanOpenObjects[i].thisPointer^.CheckInitDone() = TRUE) | (tmpstate = _CAN_COMERROR) | bFirstInitDone = TRUE then 
          retcode := retcode AND 1;
        else
          retcode := FALSE;
        end_if;
      end_if;      
    end_for;
  else
    retcode := FALSE;
    OpModeMaster := _MNG_ERROR;
    DeviceState := _CAN_STOPPED;  
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _CanOpenMng::SetFlagNG
	VAR_INPUT
		handle 	: DINT;
	END_VAR
	VAR_OUTPUT
		retCode 	: DINT;
	END_VAR
  
  if CanAvailability.AsyCan then
    CanLib.Set_RTR_Flag(handle:=handle);
  else
    // remote transmit request not possible on iso can
    retCode := -2;
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL _CanOpenMng::CanTxObj
	VAR_INPUT
		ObjNr 	: INT;
		length 	: USINT;
		data 	: pVoid;
		UseIso 	: BOOL;
	END_VAR
	VAR_OUTPUT
		retval 	: INT;
	END_VAR
  
  if UseIso = TRUE then
  
    if CanAvailability.IsoCan then
      retval := CanLibIso.CanTxObj(ObjNr,length,data);
    elsif CanAvailability.AsyCan then
      retval := CanLib.CanTxObj(ObjNr,length,data);
    end_if;
    
  else
    if CanAvailability.AsyCan then
      retval := CanLib.CanTxObj(ObjNr,length,data);
    elsif CanAvailability.IsoCan then
      retval := CanLibIso.CanTxObj(ObjNr,length,data);
    end_if;
  end_if;    

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _CanOpenMng::AddCanObjRx
	VAR_INPUT
		ObjNr 	: INT;
		Length 	: USINT;
		Mode 	: USINT;(* := 1 *)
		ActionPtr 	: pVoid;
		ThisPointer 	: pVoid;
		UseIso 	: BOOL;
	END_VAR
	VAR_OUTPUT
		retVal 	: DINT;
	END_VAR
  
  if UseIso & CanAvailability.IsoCan then
    retval := CanLibIso.AddCanObj(ObjNr, Length, Mode, ActionPtr, ThisPointer);
    if retval < 0 then
      //adding can object has failed
      LogVAlue("@040E (_CanOpenMng::AddCanObjRx) Failed to add isochronous can receive object with COB-ID 0x{0}.",ObjNr$HINT);
    end_if;          
  elsif CanAvailability then
    if ActivateCanBasicObject = 0 then
      if CanAvailability.AsyCan then
        retval := CanLib.AddCanObj(ObjNr, Length, Mode, ActionPtr, ThisPointer);
      else // since can is available and asy is not => has to be iso
        retval := CanLibIso.AddCanObj(ObjNr, Length, Mode, ActionPtr, ThisPointer);
        if retval < 0 then
          //adding can object has failed
          LogVAlue("@040E (_CanOpenMng::AddCanObjRx) Failed to add isochronous can receive object with COB-ID 0x{0}.",ObjNr$HINT);
        end_if;          
      end_if;
    else
      retVal := AddCanObjToList(ThisPointer, ActionPtr, ObjNr);
      if retval < 0 then
        //adding can object has failed
        LogVAlue("@040F (_CanOpenMng::AddCanObjRx) Failed to add asynchronous can receive object with COB-ID 0x{0}.",ObjNr$HINT);
      end_if;          
    end_if;
//  else
    // no can available
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _CanOpenMng::AddCanObjTx
	VAR_INPUT
		ObjNr 	: INT;
		Length 	: USINT;
		Mode 	: USINT;(* := 2 *)
		ActionPtr 	: pVoid;(* := NIL *)
		ThisPointer 	: pVoid;(* := NIL *)
	END_VAR
	VAR_OUTPUT
		retVal 	: DINT;
	END_VAR
  
  if CanAvailability.IsoCan then
    //only mode 2 is allowed for can tx object
    Mode   := 2;
    retVal := CanLibIso.AddCanObj(ObjNr, Length, Mode, ActionPtr, ThisPointer);
    if retval < 0 then
      //adding can object has failed
      LogVAlue("@0411 (_CanOpenMng::AddCanObjTx) Failed to add isochronous can transmit object with COB-ID 0x{0}.",ObjNr$HINT);
    end_if;          
  else
    // no iso interface connected
    retVal := -10;   
  end_if;

END_FUNCTION


FUNCTION VIRTUAL _CanOpenMng::CheckDeviceState
	VAR_INPUT
		state 	: _CAN_OPEN_DEVICE_STATE_EXT;
	END_VAR
	VAR_OUTPUT
		retCode 	: BOOL;
	END_VAR
  VAR
  	i         : USINT;
  END_VAR

  retcode := True;

  
    for i:= 0 to MaxObjIndex  do
      
      //check only required CanOpen-Objects
      if CanOpenObjects[i].Required = 1 then

        if CanOpenObjects[i].thisPointer^.DeviceState.read() = state then
          retcode := retcode AND 1;
        else
          retcode := False;
        end_if;
      
      else
         retcode := retcode AND 1;
      end_if;
      
    end_for;

END_FUNCTION


FUNCTION VIRTUAL _CanOpenMng::GetMaxHBorNGTime
	VAR_OUTPUT
		MaxTime 	: UDINT;
	END_VAR
  VAR
  	tempTime    : UDINT;
    tempMaxTime : UDINT;
    i           : USINT;
  END_VAR
  
    tempTime := 0;
    tempMaxTime := 0;

  
  for i:= 0 to MaxObjIndex  do
      
    //check only required CanOpen-Objects
    if CanOpenObjects[i].Required = 1 then
    
      tempTime := CanOpenObjects[i].thisPointer^.GetNGorHBTime();
      
      if tempTime > tempMaxTime then
        tempMaxTime := tempTime;
      end_if;
      
    end_if;
    
  end_for;
  
  maxTime := tempMaxTime;
END_FUNCTION


FUNCTION GLOBAL _CanOpenMng::BasicCAN_IRQ
	VAR_INPUT
		piCanPtr 	: ^SINT;
		rxDataPtr 	: ^USINT;
		ThisPointer 	: DINT;
	END_VAR
  VAR
  	RXObjNr : INT;
    pHelpPtr : ^t_s_CallbackList;
  END_VAR
  
  //load my own thispointer
  this := ThisPointer$^_CanOpenMng;
  
  //Here we get the date
  _memcpy(#RXCAN_Data[0]$USINT, rxDataPtr, sizeof(RXCAN_Data));
  
  // Byte 0..7: Data
  // Byte 8: Data length
  // Byte 9..10: CAN-object Number
  RXObjNr := RXCAN_Data[9]$INT;
    
  pHelpPtr := pCallbackList;

  while pHelpPtr do      
    if pHelpPtr^.ObjNr = RXObjNr then
      
      pActFunctionPtr :=pHelpPtr^.ActionPtr;
      FUNCTIONCALL(piCanPtr,rxDataPtr,pHelpPtr^.ThisPointer);     //Call Cywork of module
       
      exit;
    end_if;
    
    pHelpPtr := pHelpPtr^.pNext;
  end_while;   

END_FUNCTION

#pragma warning(disable: 0073 )

FUNCTION GLOBAL _CanOpenMng::function_call
	VAR_INPUT
		piCanPtr 	: ^SINT;
		rxDataPtr 	: ^USINT;
		ThisPointer 	: pVoid;
	END_VAR


END_FUNCTION

#pragma warning(default: 0073 )

FUNCTION _CanOpenMng::AddCanObjToList
	VAR_INPUT
		ThisPointer 	: pVoid;
		ActionPtr 	: pVoid;
		ObjNr 	: DINT;
	END_VAR
	VAR_OUTPUT
		retVal 	: DINT;
	END_VAR

  VAR
  	tmpPrt : ^t_s_CallbackList;
  END_VAR  
  
  if pCallbackList = NIL then
    pCallbackList$pVoid := To_StdLib.Malloc(size:=sizeof(t_s_CallbackList));
    tmpPrt := pCallbackList;
  else
    tmpPrt := pCallbackList;
    while tmpPrt^.pNext do
      tmpPrt := tmpPrt^.pNext;
    end_while;
    tmpPrt^.pNext$pVoid := To_StdLib.Malloc(size:=sizeof(t_s_CallbackList));
    tmpPrt := tmpPrt^.pNext;        
  end_if;
  
  if tmpPrt <> NIL then
    tmpPrt^.ThisPointer := ThisPointer;
    tmpPrt^.ActionPtr := ActionPtr;
    tmpPrt^.ObjNr := ObjNr;
    tmpPrt^.pNext := NIL;
    retVal := 1;
  else
    retVal := -5;
  end_if;

END_FUNCTION


FUNCTION GLOBAL _CanOpenMng::LogError
	VAR_INPUT
		pMsg 	: ^CHAR;
	END_VAR

#ifdef HWC_LogError
  HWC_LogError(this, pMsg);
#else
  if bLoggingNotSupported = FALSE then
    TRACE("Logging is not supported, HWControl version 4.13 or above must be placed!");
    bLoggingNotSupported := TRUE;
  end_if;
#endif

END_FUNCTION


FUNCTION GLOBAL _CanOpenMng::LogValue
	VAR_INPUT
		pString 	: ^CHAR;
		udValue 	: UDINT;
		udValue2 	: UDINT;(* := 0xFFFFFFFF *)
		udValue3 	: UDINT;(* := 0xFFFFFFFF *)
	END_VAR

#ifdef HWC_LogValue3
  HWC_LogValue3(this, pString, udValue, udValue2, udValue3);
#else
  if bLoggingNotSupported = FALSE then
    TRACE("Logging is not supported, HWControl version 4.13 or above must be placed!");
    bLoggingNotSupported := TRUE;
  end_if;
#endif
  
END_FUNCTION


FUNCTION GLOBAL _CanOpenMng::LSSSwitchStateGlobal
	VAR_INPUT
		NewState 	: USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  
  retcode := _CanOpenMngLSS.SwitchStateGlobal(NewState:=NewState);

END_FUNCTION


FUNCTION GLOBAL _CanOpenMng::LSSConfigureBitTiming
	VAR_INPUT
		NewBaudrate 	: UINT;
		SwitchDelay 	: UINT;(* := 0 *)
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR

  retcode := _CanOpenMngLSS.ConfigureBitTiming(NewBaudrate:=NewBaudrate, SwitchDelay:=SwitchDelay);

END_FUNCTION


FUNCTION GLOBAL _CanOpenMng::LSSConfigureNodeID
	VAR_INPUT
		NewNodeID 	: USINT;
		AutoStoreConfig 	: BOOL;(* := TRUE *)
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR

  retcode := _CanOpenMngLSS.ConfigureNodeID(NewNodeID:=NewNodeID, AutoStoreConfig:=AutoStoreConfig);

END_FUNCTION


FUNCTION GLOBAL _CanOpenMng::LSSInquireDeviceInfos
	VAR_INPUT
		InquireOptions 	: _CanOpenLSS::t_LSS_InquireOptions;(* := 2#11111 *)
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  
  retcode := _CanOpenMngLSS.InquireDeviceInfos(InquireOptions:=InquireOptions);

END_FUNCTION


FUNCTION GLOBAL _CanOpenMng::LSSGetInquiredDeviceInfos
	VAR_INPUT
		pVendorID 	: ^UDINT;(* := NIL *)
		pProductCode 	: ^UDINT;(* := NIL *)
		pRevisionNumber 	: ^UDINT;(* := NIL *)
		pSerialNumber 	: ^UDINT;(* := NIL *)
		pNodeID 	: ^USINT;(* := NIL *)
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  
  retcode := _CanOpenMngLSS.GetInquiredDeviceInfos(pVendorID:=pVendorID
                                                  , pProductCode:=pProductCode
                                                  , pRevisionNumber:=pRevisionNumber
                                                  , pSerialNumber:=pSerialNumber
                                                  , pNodeID:=pNodeID);

END_FUNCTION


FUNCTION GLOBAL _CanOpenMng::LSSGetStatus
	VAR_INPUT
		pErrorCode 	: ^_CanOpenLSS::t_LSS_ErrorCode;
	END_VAR
	VAR_OUTPUT
		retcode 	: iprStates;
	END_VAR
  
  retcode := _CanOpenMngLSS.GetStatus(pErrorCode:=pErrorCode);

END_FUNCTION


FUNCTION GLOBAL _CanOpenMng::IFChangeBaudrate
	VAR_INPUT
		Baudrate 	: USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
    
  if IsClientConnected(#CanLib) & IsClientConnected(#CanLibIso) then
  
    retcode := CanLib.SetBaudrate(Baudrate);
    
    //if iso can is connected to same can interface theres only the last setted baudrate is used
    //this is only needed if for example Canlib is connected to OS Can and CanLibIso to ICA0xx IsoCan which is not the normal application
    //retcode := CanLibIso.SetBaudrate(Baudrate:=Baudrate);
    
  elsif IsClientConnected(#CanLib) then

    retcode := CanLib.SetBaudrate(Baudrate); 
    
  elsif IsClientConnected(#CanLibIso) then

    retcode := CanLibIso.SetBaudrate(Baudrate);
    
  else
    //no canlib connected => Error
    retcode := -1;
  end_if;
  
  if retcode = 0 then
    BaudrateCan := Baudrate;
  end_if;
    
END_FUNCTION


FUNCTION GLOBAL _CanOpenMng::IFGetActBaudrate
	VAR_OUTPUT
		Baudrate 	: USINT;
	END_VAR
  
  Baudrate := BaudrateCan$USINT;
  
END_FUNCTION


FUNCTION GLOBAL _CanOpenMng::LSSActivateBitTiming
	VAR_INPUT
		SwitchDelay 	: UINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  
  retcode := _CanOpenMngLSS.ActivateBitTiming(SwitchDelay:=SwitchDelay);
  
END_FUNCTION


FUNCTION GLOBAL _CanOpenMng::StopStartMng
	VAR_INPUT
		bStopStart 	: BOOL;
	END_VAR
  
  bManagerInactive := bStopStart;

END_FUNCTION