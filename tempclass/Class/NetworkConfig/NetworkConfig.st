//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES

// defines for writing in an external file
#define MAX_LENGTH_CREATE_EXTFILE 370
#define MAX_LENGTH_CONFIG_STRING  105

#define HEADER_LINE1_EXTFILE "REM +---------------------------------------------+$0A"
#define HEADER_LINE2_EXTFILE "REM |         IP Settings in External File        |$0A"
#define HEADER_LINE3_EXTFILE "REM |    S i g m a t e k   G m b H  & C o K G     |$0A"
#define HEADER_LINE4_EXTFILE "REM |              www.sigmatek.at                |$0A"
#define HEADER_LINE5_EXTFILE "REM +---------------------------------------------+$0A$0A"
#define NEWLINE "$0A"

//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "NetworkConfig"
	Revision           = "1.38"
	GUID               = "{C47A4F1B-D744-4F26-882F-1AF550460DCE}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "true"
	DefBackground      = "100 ms"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(750,480)"
	Comment            = "Class handles the Networkconfiguration for one Interface">
	<Channels>
		<Server Name="ClassSvr" GUID="{59A390F3-91B7-4B2D-A6E0-6468470AC799}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="  0 = OK&#13;&#10;-1 = separ&#13;&#10;"/>
		<Server Name="GetConfig" GUID="{87A4A343-AFC5-45CE-853D-9B5CA0A54E53}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Call Write-Methode to get the actual IP-Configuration&#13;&#10;&#13;&#10;1..read from the autoexec.lsl&#13;&#10;2..read from the OS Interface&#13;&#10;3..read from the external file given in the included string object&#13;&#10;-&gt; if the file does not exist or the station is not entered, the representing servers get set to 0"/>
		<Server Name="GWAddress" GUID="{EE2DDCE3-4FD5-4E3F-AF95-F1DBE3EB3B4E}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Network Configuration: Gateway-Address"/>
		<Server Name="IPAddress" GUID="{DA86FB94-E449-4814-B15F-2A7B43620705}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Network Configuration: IP-Address"/>
		<Server Name="MACAddress" GUID="{5B4B6B5C-22B9-4CAE-9B92-D3DE0E58CD33}" Class="String" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="MAC Address of the selected Interface (Client Interface).&#13;&#10;If the Interface is not located on the CPU, a message &quot;Error&quot; will be shown."/>
		<Server Name="SetConfig" GUID="{0ED76C1A-D93C-491F-B0FD-FFACFDFE9CE6}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Call Write-Methode to set the actual IP-Configuration&#13;&#10;&#13;&#10;1..write the configuration to the autoexec.lsl&#13;&#10;2..set configuration with the OS Interface&#13;&#10;3..write at first the configuration to the autoexec.lsl and afterwards change it with the OS Interface&#13;&#10;4..write the configuration to the external file with the path of the included string object&#13;&#10;-&gt; folders of the file must exist, if file is not there, it will get created"/>
		<Server Name="SNMask" GUID="{17FF7BCD-F401-46C6-9904-236CE2A5B038}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Network Configuration: Subnet-Mask"/>
		<Client Name="coFileSys" Required="false" Internal="false" Comment="Objectchannel to class _FileSys"/>
		<Client Name="coIP" Required="false" Internal="false" Comment="Objectchannel to class _IP"/>
		<Client Name="coSigCLib" Required="false" Internal="false" Comment="Objectchannel to class SigCLib"/>
		<Client Name="coStdLib" Required="false" Internal="false" Comment="Objectchannel to class _StdLib"/>
		<Client Name="FileDNPE" Required="true" Internal="true"/>
		<Client Name="Interface" Required="true" Internal="false" Comment="Write the number of the IP Interface to this client!&#13;&#10;The given number will be changed.&#13;&#10;If the value is 0 the class looks for no interface number!"/>
		<Client Name="StringMAC" Required="true" Internal="true"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="VicAug"/>
		<Dokumentation Revision="1.38" Date="2021-07-23" Author="MolMat" Company="Sigmatek" Description="Special: GetMACOS() should only be called at init and when the interface number changes"/>
		<Dokumentation Revision="1.37" Date="2020-09-24" Author="HasHan" Company="Sigmatek" Description="Improvement: the MAC address will now be displayed as string"/>
		<Dokumentation Revision="1.36" Date="2020-07-30" Author="KaiAnd" Company="Sigmatek" Description="-- GetIPEXT() now returns &quot;retcode&quot; bitwise for IP, Subnet and Gateway&#13;&#10;-- ParseNumber() optimized for case of an address entry without following bytes in file"/>
		<Dokumentation Revision="1.35" Date="2020-06-29" Author="VicAug" Company="Sigmatek" Description="Bug Fix.&#13;&#10;- read and write in autoexec.lsl for the IP commands without the interface number for interface 1&#13;&#10;- read and write on the Extfile for the IP commands without the interface number for the interface 1&#13;&#10;- the client interface 0 is changed to interface 1 to return the parameters of interface 1  "/>
		<Dokumentation Revision="1.34" Date="2020-03-05" Author="KaiAnd" Company="Sigmatek" Description="GetIPEXT() now has an output &quot;retcode&quot; for returning the success status"/>
		<Dokumentation Revision="1.33" Date="2019-10-14" Author="KruAle" Company="Sigmatek" Description="Bugfix: error handling of invalid ip commands"/>
		<Dokumentation Revision="1.32" Date="2019-07-12" Author="FurLuk" Company="Sigmatek" Description="added functionality that the IP-settings can be stored and loaded via an external file given in the internal string object"/>
		<Dokumentation Revision="1.31" Date="2015-07-09" Author="LeiChr&#13;&#10;FriHer" Company="Sigmatek" Description="- changed the setConfig and GetConfig to background&#13;&#10;- Interface numbers &gt;9 also work now"/>
		<Dokumentation Revision="1.30" Date="2013-10-01" Author="spimar" Company="Sigmatek" Description="Improvement: if ip adress is read from autoexec, the interface number is only necessary if it is greater 1"/>
		<Dokumentation Revision="1.20" Date="2013-07-12" Author="spimar" Company="Sigmatek" Description="- Changed call of method from SigCLib, because of compiler errror;&#13;&#10;- Removed not needed memset() for performance gain"/>
		<Dokumentation Revision="1.10" Date="2012-12-19" Author="SpiMar" Company="Sigmatek" Description="Bugfix: now the correct number of chars is set if there is no interface number given.&#13;&#10;Improvement: now a complete line is ignored if there is a rem in front of the line.&#13;&#10;Bugfix: now the handling of the Interface client is correct."/>
		<Dokumentation Revision="1.0" Date="2012-12-06" Author="ObeChr" Company="Sigmatek" Description="Initial Version"/>
	</RevDoku>
	<Network Name="NetworkConfig">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "FileDNPE"
				GUID       = "{1A65A910-AF1A-49D4-9F8D-321973BC52A4}"
				Class      = "String"
				Position   = "(180,210)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Data" Value="&quot;C:\network.conf&quot;"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "StringMAC"
				GUID       = "{94F317D8-CBC5-4B7A-8374-EC5353113CB7}"
				Class      = "String"
				Position   = "(180,390)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.FileDNPE" Destination="FileDNPE.Data"/>
			<Connection Source="this.StringMAC" Destination="StringMAC.Data"/>
			<Connection Source="this.MACAddress" Destination="StringMAC.Data" Vertices="(668,570),(496,480),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
NetworkConfig : CLASS
	TYPE
	  e_GetOptions :  //! <Type Public="true" Name="e_GetOptions"/>
	  (
	    GET_IDLE,
	    GET_AUTOEXEC,
	    GET_OS,
	    GET_EXTFILE
	  )$UDINT;
	  e_SetOptions :  //! <Type Public="true" Name="e_SetOptions"/>
	  (
	    SET_IDLE,
	    SET_AUTOEXEC,
	    SET_OS,
	    SET_BOTH,
	    SET_EXTFILE
	  )$UDINT;
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
	IPAddress 	: SvrCh_HDINT;
	SNMask 	: SvrCh_HDINT;
	GWAddress 	: SvrCh_HDINT;
	SetConfig 	: SvrCh_e_SetOptions_PTofCls_NetworkConfig;
	GetConfig 	: SvrCh_e_GetOptions_PTofCls_NetworkConfig;
	MACAddress 	: SvrChCmd_UDINT;
  //Clients:
	Interface 	: CltCh_DINT;
	coFileSys 	: CltChCmd__FileSys;
	coStdLib 	: CltChCmd__StdLib;
	coSigCLib 	: CltChCmd_SigCLib;
	coIP 	: CltChCmd__IP;
	FileDNPE 	: CltChCmd_String;
	StringMAC 	: CltChCmd_String;
  //Variables:
		udIPAddress 	: UDINT;			//! <Variable Comment="IP address" Name="udIPAddress"/>
		udSubnetMask 	: UDINT;			//! <Variable Comment="Subnet mask" Name="udSubnetMask"/>
		udGateway 	: UDINT;			//! <Variable Comment="Gateway" Name="udGateway"/>
		aIPAddress : ARRAY [0..19] OF CHAR;
			//! <Variable Comment="String IP Address" Name="aIPAddress"/>
		aSubnetMask : ARRAY [0..19] OF CHAR;
			//! <Variable Comment="String Subnet mask" Name="aSubnetMask"/>
		aGateway : ARRAY [0..19] OF CHAR;
			//! <Variable Comment="String Gateway" Name="aGateway"/>
		BSCommand : BSINT
		[
		];

		LastInterface 	: DINT;			//! <Variable Comment="Stores the last used value of Interface" Name="LastInterface"/>
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="Changes the ip informations in the autoexec.lsl" Name="ExchangeNumber"/>
	FUNCTION ExchangeNumber
		VAR_INPUT
			usType 	: USINT;			//! <Variable Comment="0..IP&#13;&#10;1..Subnet&#13;&#10;2..Gateway" Name="ExchangeNumber.usType"/>
			pBuffer 	: ^CHAR;			//! <Variable Comment="pointer to the buffer which contains the text of the autoexec.lsl" Name="ExchangeNumber.pBuffer"/>
			pPosition 	: ^UDINT;			//! <Variable Comment="position in the file" Name="ExchangeNumber.pPosition"/>
			pLength 	: ^DINT;			//! <Variable Comment="file length" Name="ExchangeNumber.pLength"/>
		END_VAR
		VAR_OUTPUT
			pNewBuffer 	: ^CHAR;			//! <Variable Comment="pointer to the new buffer (points behind the last ip setting)" Name="ExchangeNumber.pNewBuffer"/>
		END_VAR;
				//! <Function Comment="read out the file and parses the ip information" Name="GetIPAutoexec"/>
	FUNCTION GetIPAutoexec;
				//! <Function Comment="Check if the given character is a number" Name="IsNumber"/>
	FUNCTION IsNumber
		VAR_INPUT
			usCHAR 	: DINT;			//! <Variable Comment="the character" Name="IsNumber.usCHAR"/>
		END_VAR
		VAR_OUTPUT
			bNumber 	: DINT;			//! <Variable Comment="true = number&#13;&#10;false = other character" Name="IsNumber.bNumber"/>
		END_VAR;
				//! <Function Comment="This method parses the number" Name="ParseNumber"/>
	FUNCTION ParseNumber
		VAR_INPUT
			usType 	: USINT;			//! <Variable Comment="0 = IP&#13;&#10;1 = SUBNET&#13;&#10;2 = GATEWAY" Name="ParseNumber.usType"/>
			pBuffer 	: ^CHAR;			//! <Variable Comment="pointer to the buffer which contains the text of the autoexec.lsl" Name="ParseNumber.pBuffer"/>
			udLength 	: UDINT;			//! <Variable Comment="len of the file" Name="ParseNumber.udLength"/>
		END_VAR
		VAR_OUTPUT
			Length 	: UDINT;			//! <Variable Comment="len of the paresed ip " Name="ParseNumber.Length"/>
		END_VAR;
				//! <Function Comment="make the number valid for the autoexec.lsl" Name="SerializeNumber"/>
	FUNCTION SerializeNumber
		VAR_INPUT
			Byte1 	: USINT;			//! <Variable Comment="first byte of the address" Name="SerializeNumber.Byte1"/>
			Byte2 	: USINT;			//! <Variable Comment="second byte of the address" Name="SerializeNumber.Byte2"/>
			Byte3 	: USINT;			//! <Variable Comment="third byte of the address" Name="SerializeNumber.Byte3"/>
			Byte4 	: USINT;			//! <Variable Comment="fourth byte of the address" Name="SerializeNumber.Byte4"/>
			pBuffer 	: ^CHAR;			//! <Variable Comment="pointer to the buffer which contains the text of the autoexec.lsl" Name="SerializeNumber.pBuffer"/>
			udLength 	: UDINT;			//! <Variable Comment="length of the file" Name="SerializeNumber.udLength"/>
		END_VAR
		VAR_OUTPUT
			udSize 	: UDINT;			//! <Variable Comment="length of the string which contains the address for the autoexec.lsl" Name="SerializeNumber.udSize"/>
		END_VAR;
				//! <Function Comment="writes the address of the servers to the autoexec.lsl" Name="SetIPAutoexec"/>
	FUNCTION SetIPAutoexec;
				//! <Function Comment="reads out the address of the OS " Name="GetIPOS"/>
	FUNCTION GetIPOS;
				//! <Function Comment="sets the address in the OS" Name="SetIPOS"/>
	FUNCTION SetIPOS;
				//! <Function Comment="write the settings to an external file" Name="SetIPEXT"/>
	FUNCTION SetIPEXT;
				//! <Function Comment="get the settings from an external file&#13;&#10;when there is no entry for the given interface,&#13;&#10;all servers representing the config are set to 0" Name="GetIPEXT"/>
	FUNCTION GetIPEXT
		VAR_OUTPUT
			retcode 	: BSINT;			//! <Variable Comment="Return Code = Found bitmask&#13;&#10;Bit 0: IP OK&#13;&#10;Bit 1: Subnet OK&#13;&#10;Bit 2: Gateway OK" Name="GetIPEXT.retcode"/>
		END_VAR;
				//! <Function Comment="build the string for representing one station in the external file and add it to the given string in pFileString&#13;&#10;there has to be enough place in pFileString  (MAX_LENGTH_CONFIG_STRING)" Name="AddIPSettingsString"/>
	FUNCTION AddIPSettingsString
		VAR_INPUT
			pFileString 	: ^CHAR;			//! <Variable Comment="pointer to the string to which the settings string is added &#13;&#10;there has to be enough space in pFileString (MAX_LENGTH_CONFIG_STRING)" Name="AddIPSettingsString.pFileString"/>
			pInterfaceString 	: ^CHAR;			//! <Variable Comment="pointer to the string where the actual interface string, which will be written is stored (e.g. SET IP ord SET IP 2)" Name="AddIPSettingsString.pInterfaceString"/>
		END_VAR;
				//! <Function Comment="method which writes the header for an external file to the place that is handled via the input parameter pFileString&#13;&#10;there has to be enough place in pFileString (MAX_LENGTH_CREATE_EXTFILE - MAX_LENGTH_CONFIG_STRING)" Name="WriteHeader"/>
	FUNCTION WriteHeader
		VAR_INPUT
			pFileString 	: ^CHAR;			//! <Variable Comment="pointer to the beginning of an string in which the header should be written&#13;&#10;there has to be enough place in pFileString (MAX_LENGTH_CREATE_EXTFILE - MAX_LENGTH_CONFIG_STRING)" Name="WriteHeader.pFileString"/>
		END_VAR;
				//! <Function Comment="this method is used to read the command without the number next to the &quot;SET IP&quot;&#13;&#10;for example the IP of interface 1 can be written as &quot;SET IP HOSTADDR XXX&quot; or &quot;SET IP 1 HOSTADDR&quot; " Name="ReadInterface1Paramters"/>
	FUNCTION ReadInterface1Paramters
		VAR_INPUT
			pFile 	: ^CHAR;
			pFileLength 	: ^DINT;
			pReadLength 	: ^UDINT;
		END_VAR
		VAR_OUTPUT
			Commands 	: BSINT;
		END_VAR;
				//! <Function Comment="this method is used to write the command without the number next to the &quot;SET IP&quot;&#13;&#10;for example the IP of interface 1 can be written as &quot;SET IP HOSTADDR XXX&quot; or &quot;SET IP 1 HOSTADDR&quot; " Name="WriteInterface1Parameters"/>
	FUNCTION WriteInterface1Parameters
		VAR_INPUT
			pFile 	: ^CHAR;
			pReadLength 	: ^UDINT;
			pFileLength 	: ^DINT;
		END_VAR
		VAR_OUTPUT
			Commands 	: BSINT;
		END_VAR;
				//! <Function Comment="this method searches for the SET IP commands" Name="SearchIPAddress"/>
	FUNCTION SearchIPAddress
		VAR_INPUT
			pFile 	: ^CHAR;
			pFileLength 	: ^DINT;
			pReadLength 	: ^UDINT;
		END_VAR
		VAR_OUTPUT
			Commands 	: BSINT;
		END_VAR;
				//! <Function Comment="This method looks for SET IP commands and writes the given value for the commands&#13;&#10;" Name="WriteIPAddress"/>
	FUNCTION WriteIPAddress
		VAR_INPUT
			pFile 	: ^CHAR;
			pFileLength 	: ^DINT;
			pReadLength 	: ^UDINT;
		END_VAR
		VAR_OUTPUT
			Commands 	: BSINT;
		END_VAR;
				//! <Function Comment="reads out the MAC Address of the OS" Name="GetMACOS"/>
	FUNCTION GetMACOS;
	
	FUNCTION VIRTUAL GLOBAL SetConfig::Write
		VAR_INPUT
			input (EAX) 	: NetworkConfig::e_SetOptions;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: NetworkConfig::e_SetOptions;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetConfig::Write
		VAR_INPUT
			input (EAX) 	: NetworkConfig::e_GetOptions;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: NetworkConfig::e_GetOptions;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL MACAddress::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL MACAddress::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using String
#pragma usingLtd _FileSys
#pragma usingLtd _IP
#pragma usingLtd _StdLib
#pragma usingLtd SigCLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB NetworkConfig::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_NETWORKCONFIG
1$UINT, 38$UINT, (SIZEOF(::NetworkConfig))$UINT, 
7$UINT, 7$UINT, 0$UINT, 
TO_UDINT(3068426329), "NetworkConfig", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::NetworkConfig.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::NetworkConfig.IPAddress.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1853430993), "IPAddress", 
(::NetworkConfig.SNMask.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3030764618), "SNMask", 
(::NetworkConfig.GWAddress.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2893991514), "GWAddress", 
(::NetworkConfig.SetConfig.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2390827369), "SetConfig", 
(::NetworkConfig.GetConfig.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2142056980), "GetConfig", 
(::NetworkConfig.MACAddress.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(1230141641), "MACAddress", 
//Clients:
(::NetworkConfig.Interface.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1882649138), "Interface", 
(::NetworkConfig.coFileSys.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(940542775), "coFileSys", TO_UDINT(545279513), "_FileSys", 1$UINT, 20$UINT, 
(::NetworkConfig.coStdLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3815072667), "coStdLib", TO_UDINT(3689364044), "_StdLib", 0$UINT, 0$UINT, 
(::NetworkConfig.coSigCLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1750761597), "coSigCLib", TO_UDINT(77440046), "SigCLib", 0$UINT, 37$UINT, 
(::NetworkConfig.coIP.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2582857610), "coIP", TO_UDINT(3530626343), "_IP", 1$UINT, 10$UINT, 
(::NetworkConfig.FileDNPE.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1639300716), "FileDNPE", TO_UDINT(1850111279), "String", 1$UINT, 11$UINT, 
(::NetworkConfig.StringMAC.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2136129866), "StringMAC", TO_UDINT(1850111279), "String", 1$UINT, 11$UINT, 
END_FUNCTION


#define USER_CNT_NetworkConfig 1

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_NetworkConfig] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION NetworkConfig::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_NetworkConfig, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	IPAddress.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF IPAddress.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SNMask.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF SNMask.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	GWAddress.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF GWAddress.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SetConfig.pMeth			:= StoreMethod( #M_RD_DIRECT(), #SetConfig::Write() );
	IF SetConfig.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	GetConfig.pMeth			:= StoreMethod( #M_RD_DIRECT(), #GetConfig::Write() );
	IF GetConfig.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, MACAddress.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Read		:= #MACAddress::Read();
	vmt.CmdTable.Write		:= #MACAddress::Write();
	MACAddress.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF MACAddress.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION

// LeiChr rev 1.31   09.07.2015
// -----------------------------------
FUNCTION VIRTUAL GLOBAL NetworkConfig::Init

  // read ip settings from os if we start the system
  if (_FirstScan) then
    GetIPOS();
    LastInterface :=  Interface; // V1.38; Interface is read by GetIPOS()
    GetMACOS();
  end_if;
  
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL NetworkConfig::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR

  // Set the ip settings in background
  // dependent on the selected server
  // *********************************************
  case (SetConfig) of
    // wait for action
    // -----------------------
    SET_IDLE:
      
    // set the ip settings to autoexec.lsl
    // -----------------------
    SET_AUTOEXEC:
      SetIPAutoexec();
      SetConfig := SET_IDLE;
    
    // set the ip settings to os
    // -----------------------
    SET_OS:
      SetIPOS();
      SetConfig := SET_IDLE;
    
    // set the ip settings to both
    // -----------------------
    SET_BOTH:
      SetIPAutoexec();
      SetIPOS();
      SetConfig := SET_IDLE;
      
    // v1.32 -- FurLuk -- set the ip settings to an external File
    // -----------------------
    SET_EXTFILE:
      SetIPEXT();
      SetConfig := SET_IDLE;
      
  end_case;
  
  
  // MolMat v1.38
  // Only re-read the MAC if the interface has changed!
  if Interface <> LastInterface then
    LastInterface := Interface; // update the marker
    GetMACOS();   
  end_if;
  
  
  // get the ip settings in background
  // dependent on the selected server
  // *********************************************
  case (GetConfig) of
    // wait for action
    // -----------------------
    GET_IDLE:
    
    // get the ip settings from autoexec
    // -----------------------
    GET_AUTOEXEC:
      GetIPAutoexec();
      GetConfig := GET_IDLE;
    
    // get the ip settings from os
    // -----------------------
    GET_OS:
      GetIPOS();
      GetConfig := GET_IDLE;
      
    // v1.32 -- FurLuk -- get the ip settings from an external File
    // -----------------------
    GET_EXTFILE:
      GetIPEXT();
      GetConfig := GET_IDLE;
      
  end_case;


	state := READY;

END_FUNCTION


FUNCTION NetworkConfig::GetIPAutoexec
  VAR
    tmpHandle       : DINT;
    tmpFileLength   : DINT;
    tmpReadLength   : UDINT;
    tmpFile         : ^CHAR;
    tmpSearchString : ARRAY[0..14] OF CHAR;
    szInterface     : ARRAY[0..5] OF CHAR;
    tmpCommands     : BSINT;
    tmpSearchLength : UDINT;
    tmpfound        : DINT;
  END_VAR

  szInterface[0] := 0;
  
  //Initialize Server
  IPAddress := SNMask := GWAddress := 0;
  
  //set the search flag to zero
  BSCommand := 0;

  //Read Client for Interface-number
  Interface := Interface.Read();
  
  // there is no interface 0, if the user enter 0 change it to 1
  if (Interface = 0) then     //VicAug V1.35
    Interface := 1;
    Interface.Write(Interface);
  end_if;                       
  
  //Init Stack-Variables
  tmpCommands        := 0;
  tmpReadLength      := 0;
  tmpSearchString[0] := 'S';
  tmpSearchString[1] := 'E';
  tmpSearchString[2] := 'T';
  tmpSearchString[3] := ' ';
  tmpSearchString[4] := 'I';
  tmpSearchString[5] := 'P';
  
  if ((Interface >= 1) & (Interface < 10)) then   //  VicAug V1.35
    tmpSearchString[6] := ' ';
    tmpSearchString[7] := (48 + Interface)$CHAR;
    tmpSearchString[8] := 0;
  elsif (Interface >= 10) then 
    tmpSearchString[6] := ' ';
    tmpSearchString[7] := 0;
    coSigCLib.IToA(val:= Interface, dst:= #szInterface[0], base:= 10);
    _strcat(dest:= #tmpSearchString[0], src:= #szInterface[0]);
  else
    tmpSearchString[6] := 0;
  end_if;

  tmpSearchLength := _strlen(#tmpSearchString[0]);
  
  // Open autoexec.lsl  
  tmpHandle := coFileSys.FileOpen(filename    := "C:\autoexec.lsl", 
                                  attributes  := ATT_READ_ONLY);
     
  //Check if Handle is valid
  if tmpHandle < 0 then
    return;
  end_if;
  
  //-----------------------------------------------------------------------------------------------  
  // Allocate Memory for Block  
  //-----------------------------------------------------------------------------------------------  
  
  // Get Length of File
  tmpFileLength := coFileSys.FileLength(handle := tmpHandle);

  if tmpFileLength < 0 then
    return;
  end_if;

  // Allocate Memory
  tmpFile:= (coStdLib.Malloc(size := tmpFileLength$UDINT + 1))$^CHAR;

  //Check if Pointer is valid
  if tmpFile = NIL then
    return;
  end_if;
  
  //-----------------------------------------------------------------------------------------------  
  // Read File and search for Configuration
  //-----------------------------------------------------------------------------------------------  
  
  // Get Data from File
  coFileSys.FileRead( handle  := tmpHandle,
                      buffer  := tmpFile, 
                      length  := tmpFileLength$UDINT);
  
  // Close File
  coFileSys.FileClose(handle := tmpHandle);
  
  // ZeroCut of File to avoid problems with _strupr
  (tmpFile + tmpFileLength)^ := 0;
  
  // Change to Capital Letters
  _strupr(str := tmpFile);
       
  //-----------------------------------------------------------------------------------------------  
  // Parsing
  //-----------------------------------------------------------------------------------------------  
  while (tmpReadLength < tmpFileLength$UDINT) do

    tmpfound := 0;
    
    if (Interface = 1) then
    // this method reads on commands without interface number
    tmpCommands := ReadInterface1Paramters(pFile:= tmpFile, 
                                           pFileLength:= #tmpFileLength,
                                           pReadLength:= #tmpReadLength); //VicAug V 1.35
                                           
    end_if;
    
    // Search for REM    
    if (_memcmp(tmpFile + tmpReadLength, "REM", 3) = 0) then
      repeat
        tmpReadLength += 1;
      until ((tmpFile + (tmpReadLength - 1))^ = 10) end_repeat;

    else

      // Search for Configuration of IP2
      if (_memcmp(ptr1 := tmpFile + tmpReadLength, ptr2 := #tmpSearchString[0], cntr := tmpSearchLength) = 0) then

        // Get over "Set IP X"
        if (Interface >= 1) then // VicAug V 1.35
          tmpReadLength += 9;

        else
          tmpReadLength += 6;

          repeat

            if (((tmpFile + tmpReadLength)^ >'0') & ((tmpFile + tmpReadLength)^ < '9')) then

              repeat
                tmpReadLength += 1;

              until ((tmpFile + tmpReadLength)^ = 10) end_repeat;

              tmpfound := 1;

            else
              tmpReadLength += 1;
            end_if;

          until ((tmpFile + (tmpReadLength))^ > '9') end_repeat;

        end_if;

        if (tmpfound = 0) then

           // searches for SET IP commands
           tmpCommands := SearchIPAddress(pFile:= tmpFile,
                                          pFileLength:= #tmpFileLength,
                                          pReadLength:= #tmpReadLength);    //VicAug 1.35

        else
          tmpReadLength -= 1;
        end_if;

        //---------------------------------------------------------------------------------------
        // Everything is done
        //---------------------------------------------------------------------------------------
        if (tmpCommands = 2#111) then
          exit;
        end_if;
        //---------------------------------------------------------------------------------------

      end_if;

      tmpReadLength += 1;   // Get to next Position

    end_if;
  end_while;

  // Free Memory
  coStdLib.Free(mptr := tmpFile);

END_FUNCTION


FUNCTION NetworkConfig::ParseNumber
	VAR_INPUT
		usType 	: USINT;
		pBuffer 	: ^CHAR;
		udLength 	: UDINT;
	END_VAR
	VAR_OUTPUT
		Length 	: UDINT;
	END_VAR
  VAR
  	tmpLength   : UDINT;
    tmpPosition : DINT;
    tmpString   : ARRAY[0..3] OF CHAR;
    tmpValue    : USINT;
    tmpElement  : USINT;
  END_VAR
  
  // Init Locals
  tmpLength   := 0;
  tmpPosition := -1;
  tmpElement  := 0;
  
  // Init Returncode
  Length := 0;
  
  // Parse Address
  while (tmpLength <= udLength) do      // V.1.36 (use <= instead of <)
  
    // Search for end of Number
    if (tmpPosition <> -1) & (IsNumber(usCHAR := (pBuffer + tmpLength)^) = false) then
    
      // Get Number in own String
//      _memset(dest := #tmpString[0], usByte := 0, cntr := sizeof(tmpString));
      _memcpy(ptr1 := #tmpString[0], ptr2 := pBuffer + tmpPosition$UDINT, cntr := tmpLength - tmpPosition$UDINT);
      tmpString[tmpLength - tmpPosition$UDINT] := 0;
      
      // Delete Position
      tmpPosition := -1;
      
      // Convert to IP
      tmpValue := (coSigCLib.AToI(#tmpString[0]))$USINT;
   
      // Write Information to Server
      case usType of
      
        //---------------------------------------------------------------------
        // IP Address
        //---------------------------------------------------------------------
        0:
          case (tmpElement) of
            0: IPAddress := (IPAddress AND 16#FFFFFF00) OR tmpValue;
            1: IPAddress := (IPAddress AND 16#FFFF00FF) OR (tmpValue SHL 8);
            2: IPAddress := (IPAddress AND 16#FF00FFFF) OR (tmpValue SHL 16);
            3: IPAddress := (IPAddress AND 16#00FFFFFF) OR (tmpValue SHL 24);
          end_case;
          
        //---------------------------------------------------------------------
        // Subnet Mask
        //---------------------------------------------------------------------
        1:
          case (tmpElement) of
            0: SNMask := (SNMask AND 16#FFFFFF00) OR tmpValue;
            1: SNMask := (SNMask AND 16#FFFF00FF) OR (tmpValue SHL 8);
            2: SNMask := (SNMask AND 16#FF00FFFF) OR (tmpValue SHL 16);
            3: SNMask := (SNMask AND 16#00FFFFFF) OR (tmpValue SHL 24);
          end_case;
        
        //---------------------------------------------------------------------
        // Gateway
        //---------------------------------------------------------------------
        2:
          case (tmpElement) of
            0: GWAddress := (GWAddress AND 16#FFFFFF00) OR tmpValue;
            1: GWAddress := (GWAddress AND 16#FFFF00FF) OR (tmpValue SHL 8);
            2: GWAddress := (GWAddress AND 16#FF00FFFF) OR (tmpValue SHL 16);
            3: GWAddress := (GWAddress AND 16#00FFFFFF) OR (tmpValue SHL 24);
          end_case;
          
      end_case;
      
      // Everything finished?
      if (tmpElement >= 3) then
      
        // -1 because we are now at the next letter!
        tmpLength -= 1;
        
        // Set Returncode and Exit
        Length := tmpLength;
        exit;
        
      else
        tmpElement += 1;
      end_if;
    
    
    // Search for Numbers
    elsif (tmpPosition = -1) & (IsNumber(usCHAR := (pBuffer + tmpLength)^) = true) then
      tmpPosition := tmpLength$DINT;
      
    // No valid size for address
    elsif ((tmpPosition <> -1) & (tmpLength - tmpPosition$UDINT >= 3)) then
      tmpPosition := -1;
      tmpElement += 1;
    end_if;
  
    // Move to next Position
    tmpLength += 1;
   
  end_while;
  
END_FUNCTION


FUNCTION NetworkConfig::IsNumber
	VAR_INPUT
		usCHAR 	: DINT;
	END_VAR
	VAR_OUTPUT
		bNumber 	: DINT;
	END_VAR

  // Ascii Number
  if ((usCHAR >= '0') & (usCHAR <= '9')) then
    bNumber := true;
    
  // No Ascii Number
  else
    bNumber := false;
  end_if;
  
END_FUNCTION


FUNCTION NetworkConfig::SerializeNumber
	VAR_INPUT
		Byte1 	: USINT;
		Byte2 	: USINT;
		Byte3 	: USINT;
		Byte4 	: USINT;
		pBuffer 	: ^CHAR;
		udLength 	: UDINT;
	END_VAR
	VAR_OUTPUT
		udSize 	: UDINT;
	END_VAR
  VAR
  	tmpString : ARRAY[0..15] OF CHAR;
    tmpByte   : ARRAY[0..3] OF CHAR;
    tmpLength : UDINT;
  END_VAR

  // Init Returncode
  udSize := 0;
  
  //Check Input Parameter
 if ((pBuffer = NIL) | (udLength = 0)) then
    return;
  end_if;
  
  //---------------------------------------------------------------------------
  // First Byte
  //---------------------------------------------------------------------------
  // Reset Byte
  _memset(#tmpByte[0], 0, sizeof(tmpByte));
  
  coSigCLib.IToA(val := Byte1, dst := #tmpByte[0], base := 10);
       
  _strcpy(dest := #tmpString[0], src := #tmpByte[0]);
  _strcat(dest := #tmpString[0], src := ".");

  //---------------------------------------------------------------------------
  // Second Byte
  //---------------------------------------------------------------------------
  // Reset Byte
  _memset(#tmpByte[0], 0, sizeof(tmpByte));
  
  coSigCLib.IToA(val := Byte2, dst := #tmpByte[0], base := 10);
       
  _strcat(dest := #tmpString[0], src := #tmpByte[0]);
  _strcat(dest := #tmpString[0], src := ".");

  //---------------------------------------------------------------------------
  // Third Byte
  //---------------------------------------------------------------------------
  // Reset Byte
  _memset(#tmpByte[0], 0, sizeof(tmpByte));
  
  coSigCLib.IToA(val := Byte3, dst := #tmpByte[0], base := 10);
       
  _strcat(dest := #tmpString[0], src := #tmpByte[0]);
  _strcat(dest := #tmpString[0], src := ".");
 
  //---------------------------------------------------------------------------
  // Fourth Byte
  //---------------------------------------------------------------------------
  // Reset Byte
  _memset(#tmpByte[0], 0, sizeof(tmpByte));
  
  coSigCLib.IToA(val := Byte4, dst := #tmpByte[0], base := 10);
       
  _strcat(dest:= #tmpString[0], src := #tmpByte[0]);
  
  // Get Length of String
  tmpLength := _strlen(src := #tmpString[0]);
  
  //Check if we got enough Space in Buffer
  if (tmpLength > udLength) then
    return;
  end_if;

  // Copy to Buffer
  _memcpy(ptr1 := pBuffer, ptr2 := #tmpString[0], cntr := tmpLength);

  // Return Size of String
  udSize := tmpLength;
  
END_FUNCTION


FUNCTION NetworkConfig::SetIPAutoexec
  VAR
    tmpHandle       : DINT;
    tmpFileLength   : DINT;
    tmpReadLength   : UDINT;
    tmpFile         : ^CHAR;
    tmpSearchString : ARRAY[0..14] OF CHAR;
    szInterface     : ARRAY[0..5] OF CHAR;
    tmpCommands     : BSINT;
    tmpSearchLength : UDINT;
    tmpfound        : DINT;
  END_VAR

  szInterface[0] := 0;
  
  //set the search flag to zero
  BSCommand := 0;

  // Read Client for Interface-number
  Interface := Interface.Read();
  
  if (Interface = 0) then   // Vicaug V 1.35
    Interface := 1;
    Interface.Write(Interface);
  end_if;
  // Init Stack-Variables
  tmpCommands         := 0;
  tmpReadLength       := 0;
  tmpSearchString[0]  := 'S';
  tmpSearchString[1]  := 'E';
  tmpSearchString[2]  := 'T';
  tmpSearchString[3]  := ' ';
  tmpSearchString[4]  := 'I';
  tmpSearchString[5]  := 'P';
  
  if ((Interface >= 1) & (Interface < 10)) then   // VicAug V 1.35 
    tmpSearchString[6] := ' ';
    tmpSearchString[7] := (48 + Interface)$CHAR;
    tmpSearchString[8] := 0;
  elsif (Interface >= 10) then 
    tmpSearchString[6] := ' ';
    tmpSearchString[7] := 0;
    coSigCLib.IToA(val:= Interface, dst:= #szInterface[0], base:= 10);
    _strcat(dest:= #tmpSearchString[0], src:= #szInterface[0]);
  else
    tmpSearchString[6] := 0;
  end_if;

  tmpSearchLength := _strlen(#tmpSearchString[0]);
  
  // Open autoexec.lsl  
  tmpHandle := coFileSys.FileOpen(filename    := "C:\autoexec.lsl", 
                                  attributes  := ATT_READ_ONLY);
     
  // Check if Handle is valid
  if (tmpHandle < 0) then
    return;
  end_if;
  
  //---------------------------------------------------------------------------
  // Allocate Memory for Block  
  //---------------------------------------------------------------------------
  
  // Get Length of File
  tmpFileLength := coFileSys.FileLength(handle := tmpHandle);

  if (tmpFileLength < 0) then
    return;
  end_if;

  // Allocate Memory
  tmpFile:= (coStdLib.Malloc(size := tmpFileLength$UDINT + 1))$^CHAR;

  // Check if Pointer is valid
  if (tmpFile = NIL) then
    return;
  end_if;
  
  //---------------------------------------------------------------------------
  // Read File and search for Configuration
  //---------------------------------------------------------------------------
  
  // Get Data from File
  coFileSys.FileRead( handle  := tmpHandle,
                      buffer  := tmpFile, 
                      length  := tmpFileLength$UDINT);
   
  coFileSys.FileClose(handle := tmpHandle);
  
  // ZeroCut of File to avoid problems with _strupr
  (tmpFile + tmpFileLength)^ := 0;
  
  // Change to Capital Letters
  _strupr(str := tmpFile);
       
  //---------------------------------------------------------------------------
  // Parsing
  //---------------------------------------------------------------------------
  while (tmpReadLength < tmpFileLength$UDINT) do

    tmpfound := 0;
    
    if (Interface = 1) then
      // this method writes on commands without interface number
      tmpCommands:= WriteInterface1Parameters(pFile:=tmpFile,   
                                pReadLength:= #tmpReadLength,
                                pFileLength:= #tmpFileLength); // VicAug V 1.35
    end_if;
     
    // Search for REM
    if (_memcmp(tmpFile + tmpReadLength, "REM", 3) = 0) then
      repeat
        tmpReadLength += 1;
      until ((tmpFile + (tmpReadLength - 1))^ = 10) end_repeat;

    else
      // Search for Configuration of IP2
      if (_memcmp(ptr1 := tmpFile + tmpReadLength, ptr2 := #tmpSearchString[0], cntr := tmpSearchLength) = 0) then
        
        // Get over "Set IP X"
        if (Interface >= 1) then // VicAug V 1.35
          tmpReadLength += 9;

        else
          tmpReadLength += 6;

          repeat

            if (((tmpFile + tmpReadLength)^ >'0') & ((tmpFile + tmpReadLength)^ < '9')) then

              repeat
                tmpReadLength += 1;

              until ((tmpFile + tmpReadLength)^ = 10) end_repeat;

              tmpfound := 1;

            else
              tmpReadLength += 1;

            end_if;

          until ((tmpFile + (tmpReadLength))^ > '9') end_repeat;

        end_if;

        if (tmpfound = 0) then
          // Search for type of Set IP
         tmpCommands := WriteIPAddress(pFile:= tmpFile,
                                       pFileLength:= #tmpFileLength,
                                       pReadLength:= #tmpReadLength);   //VicAug 1.35
        else
          tmpReadLength -= 1;
        end_if;

        // Everything is done
//        if tmpCommands = 2#111 then
//          exit;
//        end_if;

      end_if;
      
      tmpReadLength += 1;   // Get to next Position

    end_if;
  end_while;

  // Open autoexec.lsl  
  tmpHandle := coFileSys.FileOpen(filename    := "C:\autoexec.lsl", 
                                  attributes  := ATT_CREATE_ALWAYS);
     
     
  // Check if Handle is valid
  if (tmpHandle < 0) then
    return;
  end_if;
                      
  // Write Data into File
  coFileSys.FileWrite(handle  := tmpHandle, 
                      buffer  := tmpFile, 
                      length  := tmpFileLength$UDINT);
                
  // Close the File
  coFileSys.FileClose(handle := tmpHandle);
                      
  // Free Memory
  coStdLib.Free(mptr :=tmpFile);
  
END_FUNCTION


FUNCTION NetworkConfig::ExchangeNumber
	VAR_INPUT
		usType 	: USINT;
		pBuffer 	: ^CHAR;
		pPosition 	: ^UDINT;
		pLength 	: ^DINT;
	END_VAR
	VAR_OUTPUT
		pNewBuffer 	: ^CHAR;
	END_VAR
  VAR
    tmpSeperator    : USINT;
    tmpWaitNumber   : BOOL;
    tmpPosition1    : UDINT;
    tmpPosition2    : UDINT;
    tmpString       : ARRAY[0..15] OF CHAR;
    tmpSize         : UDINT;
    tmpNewSize      : UDINT;
  END_VAR
    
  // Search for Address
  while (pPosition^ < pLength^$UDINT) do
    
    // Search for Numbers
    if (IsNumber(usCHAR := (pBuffer + pPosition^)^) = true) then
      
      tmpSeperator  := 0;
      tmpWaitNumber := false;
      tmpPosition1  := pPosition^;
      
      // Search for end of Address
      while (pPosition^ < pLength^$UDINT)  do
      
        // v1.33 - KruAle: Check for end of line
        if ((pBuffer + pPosition^)^ = 10) then
          // abort mission, invalid command
          exit;
      
        elsif ((tmpWaitNumber = false) & (IsNumber(usCHAR := (pBuffer + pPosition^)^) = false) & (tmpSeperator < 3)) then
          //If next Element is number, we got Seperator
          tmpWaitNumber := true;
        
        elsif ((tmpWaitNumber = true) & (IsNumber(usCHAR := (pBuffer + pPosition^)^) = true) & (tmpSeperator < 3)) then
          // Count Seperators
          tmpSeperator  += 1;
          tmpWaitNumber := false;
          
        // End of Address (after 3 Seperator)
        elsif (tmpSeperator >= 3) & (IsNumber(usCHAR := (pBuffer + pPosition^)^) = false) then
        
          tmpPosition2 := pPosition^;
          
          // Depending on Type, serialize Adress
          case usType of
            
            //---------------------------------------------------------------------------------
            // IP-Address
            //---------------------------------------------------------------------------------
            0:  tmpSize := SerializeNumber( Byte1     := (IPAddress AND 16#FF)$USINT, 
                                            Byte2     := ((IPAddress AND 16#FF00) SHR 8)$USINT, 
                                            Byte3     := ((IPAddress AND 16#FF0000) SHR 16)$USINT, 
                                            Byte4     := ((IPAddress AND 16#FF000000) SHR 24)$USINT, 
                                            pBuffer   := #tmpString[0], 
                                            udLength  := sizeof(tmpString));
            
            //---------------------------------------------------------------------------------
            // Subnet-Mask
            //---------------------------------------------------------------------------------
            1:  tmpSize := SerializeNumber( Byte1     := (SNMask AND 16#FF)$USINT, 
                                            Byte2     := ((SNMask AND 16#FF00) SHR 8)$USINT, 
                                            Byte3     := ((SNMask AND 16#FF0000) SHR 16)$USINT, 
                                            Byte4     := ((SNMask AND 16#FF000000) SHR 24)$USINT, 
                                            pBuffer   := #tmpString[0], 
                                            udLength  := sizeof(tmpString));
                                            
            //---------------------------------------------------------------------------------
            // Gateway
            //---------------------------------------------------------------------------------
            2:  tmpSize := SerializeNumber( Byte1     := (GWAddress AND 16#FF)$USINT, 
                                            Byte2     := ((GWAddress AND 16#FF00) SHR 8)$USINT, 
                                            Byte3     := ((GWAddress AND 16#FF0000) SHR 16)$USINT, 
                                            Byte4     := ((GWAddress AND 16#FF000000) SHR 24)$USINT, 
                                            pBuffer   := #tmpString[0], 
                                            udLength  := sizeof(tmpString));
                                            
          end_case;
          
          // Check if Size is equal
          if (tmpSize <> tmpPosition2 - tmpPosition1) then
          
            //---------------------------------------------------------------------------------
            // More Memory is needed
            //---------------------------------------------------------------------------------
            if (tmpSize > (tmpPosition2 - tmpPosition1)) then
            
              tmpNewSize := pLength^$UDINT + (tmpSize - (tmpPosition2 - tmpPosition1));
              pPosition^ += tmpSize - (tmpPosition2 - tmpPosition1);
              
              // Reallocate everytime, to avoid problems with invalid configuration which get corrected by this class
              pBuffer$^void := coStdLib.ReAlloc(mptr := pBuffer$^void, newsize := tmpNewSize);
              
              // Move Memory to get Space for the Address
              _memmove(dest := pBuffer + tmpPosition2 + tmpNewSize - pLength^$UDINT, src := pBuffer + tmpPosition2, anz := pLength^$UDINT - tmpPosition2);
              
            //---------------------------------------------------------------------------------
            // Less Memory is needed
            //---------------------------------------------------------------------------------
            else
            
              tmpNewSize := pLength^$UDINT - ((tmpPosition2 - tmpPosition1) - tmpSize);
              pPosition^ -= (tmpPosition2 - tmpPosition1) - tmpSize;
              
              // Move Memory to get Space for the Address
              _memmove(dest := pBuffer + tmpPosition2 - ((tmpPosition2 - tmpPosition1) - tmpSize), src := pBuffer + tmpPosition2, anz := pLength^$UDINT - tmpPosition2);
              
              // Reallocate everytime, to avoid problems with invalid configuration which get corrected by this class
              pBuffer$^void := coStdLib.ReAlloc(mptr := pBuffer$^void, newsize := tmpNewSize);

            end_if;

            pLength^ := tmpNewSize$DINT;
          
          end_if;
          
          // Copy String into the Memory
          _memcpy(ptr1 := pBuffer + tmpPosition1, ptr2 := #tmpString[0], cntr := tmpSize);

          // Finished
          exit;
          
        end_if;
      
        pPosition^ += 1;    // GoTo next Element
        
      end_while;

      exit;
    
    else
      // GoTo next Element
      pPosition^ += 1;
    end_if;

  end_while;
  
  // Return new Pointer
  pNewBuffer := pBuffer;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL NetworkConfig::SetConfig::Write
	VAR_INPUT
		input (EAX) 	: NetworkConfig::e_SetOptions;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: NetworkConfig::e_SetOptions;
	END_VAR
  
  // LeIChr rev1.31  delete the set options and move to background
	SetConfig := input;
 	result := SetConfig;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL NetworkConfig::GetConfig::Write
	VAR_INPUT
		input (EAX) 	: NetworkConfig::e_GetOptions;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: NetworkConfig::e_GetOptions;
	END_VAR

  // LeiChr rev1.31  delte the get options and move to background
	GetConfig := input;
 	result := GetConfig;

END_FUNCTION


FUNCTION NetworkConfig::GetIPOS
      
  // Get selected Interface
  Interface := Interface.Read();
  
  if (Interface = 0) then     //VicAug V1.35
    Interface := 1;
    Interface.Write(Interface);
  end_if;
  
  // Get IP-Address
  coIP.GetIPInfo( dIface  := Interface, 
                  dOption := IPAPI_OPT_ADDR, 
                  pValue  := #IPAddress, 
                  addOpt  := 0);
                  
  // Get SubnetMask
  coIP.GetIPInfo( dIface  := Interface, 
                  dOption := IPAPI_OPT_SUBNETMASK, 
                  pValue  := #SNMask,   
                  addOpt  := 0);
                                              
  // Get Gateway
  coIP.GetIPInfo( dIface  := Interface, 
                  dOption := IPAPI_OPT_GATEWAY, 
                  pValue  := #GWAddress, 
                  addOpt  := 0);
                                              
END_FUNCTION


FUNCTION NetworkConfig::SetIPOS
  VAR
    tmpIPAddress  : ARRAY[0..15] OF CHAR;
    tmpSNMask     : ARRAY[0..15] OF CHAR;
    tmpGWAddress  : ARRAY[0..15] OF CHAR;
  END_VAR

  // Convert IP-Address to String
  coIP.ConvertBinToStr( strAddress    := #tmpIPAddress[0], 
                        strAddressLen := sizeof(tmpIPAddress), 
                        IPAddress     := IPAddress);

  // Convert SubnetMask to String
  coIP.ConvertBinToStr( strAddress    := #tmpSNMask[0], 
                        strAddressLen := sizeof(tmpSNMask), 
                        IPAddress     := SNMask);


  // Convert Gateway to String
  coIP.ConvertBinToStr( strAddress    := #tmpGWAddress[0], 
                        strAddressLen := sizeof(tmpGWAddress), 
                        IPAddress     := GWAddress);
                                                    
  // Get selected Interface
  Interface := Interface.Read();
  
  if (Interface = 0) then     //VicAug V1.35
    Interface := 1;
    Interface.Write(Interface);
  end_if;
  
  // Set new IP Configuration
  coIP.SetIP( InterfaceNumber := Interface, 
              Address         := #tmpIPAddress[0], 
              SubnetMask      := #tmpSNMask[0], 
              Gateway         := #tmpGWAddress[0]);
              
END_FUNCTION


FUNCTION NetworkConfig::SetIPEXT

  VAR
    tmpHandle       : DINT;
    tmpFileLength   : DINT;
    tmpReadLength   : UDINT;
    tmpFile         : ^CHAR;
    tmpSearchString : ARRAY[0..14]  OF CHAR;
    szInterface     : ARRAY[0..5]   OF CHAR;
    tmpCommands     : BSINT;
    tmpSearchLength : UDINT;
    tmpfound        : DINT;
    tmpFileDPNE     : ARRAY[0..100] OF CHAR;
    tmpPathLength   : UDINT;
    tmpJustCreated  : BOOL;
  END_VAR
  
  // check if config is valid (no 0.0.0.0 entered)
  if ((IPAddress = 0) | (SNMask = 0) | (GWAddress = 0)) then
    return;
  end_if;
  
  //set the search flag to zero
  BSCommand := 0;
  
  // read interface number
  Interface := Interface.Read();
  
  if (Interface = 0) then
    Interface := 1;
    Interface.Write(Interface);
  end_if;
  
  // init stack variables
  tmpJustCreated := FALSE;
  szInterface[0] := 0;
  tmpCommands         := 0;
  tmpReadLength       := 0;
  tmpSearchString[0]  := 'S';
  tmpSearchString[1]  := 'E';
  tmpSearchString[2]  := 'T';
  tmpSearchString[3]  := ' ';
  tmpSearchString[4]  := 'I';
  tmpSearchString[5]  := 'P';
  
  // create string for the interface configuration
  if ((Interface >= 1) & (Interface < 10)) then  //VicAug V 1.35
    tmpSearchString[6] := ' ';
    tmpSearchString[7] := (48 + Interface)$CHAR;
    tmpSearchString[8] := 0;
  elsif (Interface >= 10) then 
    tmpSearchString[6] := ' ';
    tmpSearchString[7] := 0;
    coSigCLib.IToA(val:= Interface, dst:= #szInterface[0], base:= 10);
    _strcat(dest:= #tmpSearchString[0], src:= #szInterface[0]);
  else
    tmpSearchString[6] := 0;
  end_if;

  tmpSearchLength := _strlen(#tmpSearchString[0]);
  
  // return when path of the external file is too long
  tmpPathLength := FileDNPE.GetLength();
  if (tmpPathLength > 100) then
    return;
  else
    FileDNPE.GetDataAt(#tmpFileDPNE[0], tmpPathLength, 0); 
  end_if;
  
  // terminating 0
  tmpFileDPNE[tmpPathLength] := 0;
  
  // open file to write  
  tmpHandle := coFileSys.FileOpen(filename    := #tmpFileDPNE[0], 
                                  attributes  := ATT_READ_ONLY);
     
  // check if handle is valid
  if (tmpHandle < 0) then
    // create file if handle is not valid
    tmpHandle := coFileSys.FileOpen(filename   := #tmpFileDPNE[0],
                                    attributes := ATT_CREATE);
    if (tmpHandle < 0) then
      // folders do not exist
      return;
    end_if;
    // set flag for creation
    tmpJustCreated := TRUE;

  end_if;
  
  // file needs to get created?
  if (tmpJustCreated = TRUE) then
    
    //---------------------------------------------------------------------------------------------
    // create file
    //---------------------------------------------------------------------------------------------

    // allocate memory for the new file
    tmpFile:= (coStdLib.Malloc(MAX_LENGTH_CREATE_EXTFILE))$^CHAR;
    
    // allocation failed
    if (tmpFile = NIL) then
      return;
    end_if;
    
    // create the string to write into the file
    // header
    WriteHeader(tmpFile);
    // interface settings
    AddIPSettingsString(tmpFile, #tmpSearchString[0]);
    
    // set length and write data to file
    tmpFileLength := (coSigCLib.StrLen(tmpFile))$DINT;
    
    coFileSys.FileWrite(handle  := tmpHandle, 
                        buffer  := tmpFile, 
                        length  := tmpFileLength$UDINT);
                  
    // close the file
    coFileSys.FileClose(handle := tmpHandle);
    
    // free memory again
    coStdLib.Free(tmpFile);
    
  else
    //---------------------------------------------------------------------------------------------
    // update file
    //---------------------------------------------------------------------------------------------
    
    // get length of file
    tmpFileLength := coFileSys.FileLength(handle := tmpHandle);

    if (tmpFileLength < 0) then
      return;
    end_if;

    // allocating with space for termination 0
    tmpFile:= (coStdLib.Malloc(size := tmpFileLength$UDINT + 1))$^CHAR;
    
    if (tmpFile = NIL) then
      return;
    end_if;
    
    // read whole data from file
    coFileSys.FileRead( handle  := tmpHandle,
                        buffer  := tmpFile, 
                        length  := tmpFileLength$UDINT);
    
    // close the file
    coFileSys.FileClose(handle := tmpHandle);
    
    // terminating 0 of file to avoid problems with _strupr
    (tmpFile + tmpFileLength)^ := 0;
    
    // change to capital letters if file is written by user in small letters
    _strupr(str := tmpFile);
         
    //-------------------------------------------------------------------------------------------
    // parsing and updating (mainly used from SetIPAutoexec())
    //-------------------------------------------------------------------------------------------
    while (tmpReadLength < tmpFileLength$UDINT) do
      
      tmpfound := 0;  // reset flag
      
      // this method writes on commands without interface number
      tmpCommands := WriteInterface1Parameters(pFile:= tmpFile,
                                               pReadLength:= #tmpReadLength,
                                               pFileLength:=#tmpFileLength); // VicAug V 1.35

      // search for rem and ignore line
      if (_memcmp(tmpFile + tmpReadLength, "REM", 3) = 0) then
        repeat
          tmpReadLength += 1;
          // linefeed was one byte bevore (currently in next line)
        until ((tmpFile + (tmpReadLength - 1))^ = 10) end_repeat;

      else

        // search for configuration of the IP
        if (_memcmp(ptr1 := tmpFile + tmpReadLength, ptr2 := #tmpSearchString[0], cntr := tmpSearchLength) = 0) then
          
          // get over "Set IP X & Set IP XX"
          if (Interface >= 1) then  // VicAug V 1.35
            tmpReadLength += 9;
          else
            
            tmpReadLength += 6;
            
            //---------------------------------------------------------------------------------
            // this is only used for interface 1 
            // -> after "SET IP" there is no number allowed -> would be another interface
            //---------------------------------------------------------------------------------
            repeat // search for a letter
              
              if (((tmpFile + tmpReadLength)^ >'0') & ((tmpFile + tmpReadLength)^ < '9')) then
                
                repeat  // if there is a number it is the setting of another interface -> go to next line and start searching again
                  tmpReadLength += 1;
                until ((tmpFile + tmpReadLength)^ = 10) end_repeat;
                // set flag that it is a wrong interface and search for the next one
                tmpfound := 1;

              else
                tmpReadLength += 1;
              end_if;
              
            until ((tmpFile + (tmpReadLength))^ > '9') end_repeat;
            //---------------------------------------------------------------------------------
            
          end_if;
          
          // right interface is found when tmpfound is 0
          if (tmpfound = 0) then
            // parse for types and exchange values
            tmpCommands := WriteIPAddress(pFile:= tmpFile,
                                          pFileLength:= #tmpFileLength,
                                          pReadLength:= #tmpReadLength);  //VicAug 1.35
            
          else
            // right interface settings not found so far, start searching again
            // decrease pointer because it gets increased below
            tmpReadLength -= 1;
          end_if;
          
          // everything is set
//          if tmpCommands = 2#111 then
//            exit;
//          end_if;

        end_if;
        
        // compare with next position
        tmpReadLength += 1;
      end_if;
      
    end_while;
    
    // create new external file
    tmpHandle := coFileSys.FileOpen(filename    := #tmpFileDPNE[0], 
                                    attributes  := ATT_CREATE_ALWAYS);
    
    if (tmpHandle < 0) then
      return;
    end_if;
    
    // when interface not found, add it to file
    if (tmpCommands <> 2#111) then
    
      // realloc memory and expand with the setting of this interface
      tmpFile := (coStdLib.ReAlloc(tmpFile, (tmpFileLength$UDINT + MAX_LENGTH_CONFIG_STRING + 1)))$^CHAR;
      // termination 0 for string function
      (tmpFile + tmpFileLength)^ := 0; 
      
      // allocation failed
      if (tmpFile = NIL) then
        return;
      end_if;
      
      // create the string to write into the file
      AddIPSettingsString(tmpFile, #tmpSearchString[0]);
      tmpFileLength := (coSigCLib.StrLen(tmpFile))$DINT;
      
    end_if;
    
    // write data to file
    coFileSys.FileWrite(handle  := tmpHandle, 
                        buffer  := tmpFile, 
                        length  := tmpFileLength$UDINT);
    
    // close the file
    coFileSys.FileClose(tmpHandle);
    
    // free memory
    coStdLib.Free(tmpFile);
   
  end_if;

END_FUNCTION


FUNCTION NetworkConfig::GetIPEXT
	VAR_OUTPUT
		retcode 	: BSINT;
	END_VAR

  VAR
    tmpHandle       : DINT;
    tmpFileLength   : DINT;
    tmpReadLength   : UDINT;
    tmpFile         : ^CHAR;
    tmpSearchString : ARRAY[0..14] OF CHAR;
    szInterface     : ARRAY[0..5] OF CHAR;
    tmpCommands     : BSINT;
    tmpSearchLength : UDINT;
    tmpfound        : DINT;
    tmpFileDPNE     : ARRAY[0..100] OF CHAR;
    tmpPathLength   : UDINT;
  END_VAR

  retcode := 0;   // default "Not OK"

  //set the search flag to zero
  BSCommand := 0;
  
  szInterface[0] := 0;
  
  // initialise servers
  IPAddress := SNMask := GWAddress := 0;

  // read interface number
  Interface := Interface.Read();
  
  // initialise stack variables
  tmpCommands        := 0;
  tmpReadLength      := 0;
  tmpSearchString[0] := 'S';
  tmpSearchString[1] := 'E';
  tmpSearchString[2] := 'T';
  tmpSearchString[3] := ' ';
  tmpSearchString[4] := 'I';
  tmpSearchString[5] := 'P';
  
  // create string for searching the interface
  if ((Interface >= 1) & (Interface < 10)) then // VicAug V 1.35
    tmpSearchString[6] := ' ';
    tmpSearchString[7] := (48 + Interface)$CHAR;
    tmpSearchString[8] := 0;
  elsif (Interface >= 10) then 
    tmpSearchString[6] := ' ';
    tmpSearchString[7] := 0;
    coSigCLib.IToA(val:= Interface, dst:= #szInterface[0], base:= 10);
    _strcat(dest:= #tmpSearchString[0], src:= #szInterface[0]);
  else
    tmpSearchString[6] := 0;
  end_if;
  // set search length
  tmpSearchLength := coSigCLib.StrLen(#tmpSearchString[0]);
  
  // return when path of the external file is too long
  tmpPathLength := FileDNPE.GetLength();
  if (tmpPathLength > 100) then
    return;
  else
    FileDNPE.GetDataAt(#tmpFileDPNE[0], tmpPathLength, 0); 
  end_if;
  
  // terminating 0
  tmpFileDPNE[tmpPathLength] := 0;
  
  // open external file  
  tmpHandle := coFileSys.FileOpen(filename    := #tmpFileDPNE[0], 
                                  attributes  := ATT_READ_ONLY);
     
  // return if file is not there or handle is invalid
  if (tmpHandle < 0) then
    return;
  end_if;
  
  // get length of the file
  tmpFileLength := coFileSys.FileLength(handle := tmpHandle);

  if (tmpFileLength < 0) then
    return;
  end_if;

  // allocate memory
  tmpFile:= (coStdLib.Malloc(size := tmpFileLength$UDINT + 1))$^CHAR;

  if (tmpFile = NIL) then
    return;
  end_if;
  
  // read the file
  coFileSys.FileRead( handle  := tmpHandle,
                      buffer  := tmpFile, 
                      length  := tmpFileLength$UDINT);
  
  // close the file
  coFileSys.FileClose(handle := tmpHandle);
  
  // terminating 0 at the end for string functions
  (tmpFile + tmpFileLength)^ := 0;
  
  // change to capital letters if file is written by user in small letters
  _strupr(str := tmpFile);
      
      
  //-----------------------------------------------------------------------------------------------
  // parse and read file
  //-----------------------------------------------------------------------------------------------
  while (tmpReadLength < tmpFileLength$UDINT) do
    
    // reset flag
    tmpfound := 0;
    
    // this method reads on commands without interface number
    tmpCommands := ReadInterface1Paramters(pFile:= tmpFile,
                                           pFileLength:= #tmpFileLength,
                                           pReadLength:= #tmpReadLength);  // VicAug V 1.35

    // search for rem and ignore line
    if (_memcmp(tmpFile + tmpReadLength, "REM", 3) = 0) then
      repeat
        tmpReadLength += 1;
      until ((tmpFile + (tmpReadLength - 1))^ = 10) end_repeat;
      
    else
      
      //-----------------------------------------------------------------------------------------
      // search for configuration of the IP
      //-----------------------------------------------------------------------------------------
      if _memcmp(ptr1 := tmpFile + tmpReadLength, ptr2 := #tmpSearchString[0], cntr := tmpSearchLength) = 0 then
        
        // get over "Set IP X & Set IP XX"
        if (Interface >= 1) then   //VicAug V 1.35
          tmpReadLength += 9;
        else
        
          tmpReadLength += 6;
          
          //-----------------------------------------------------------------------------------
          // this is only used for interface 1 
          // -> after "SET IP" there is no number allowed -> would be another interface
          //-----------------------------------------------------------------------------------
          repeat // search for a letter
            
            if (((tmpFile + tmpReadLength)^ >'0') & ((tmpFile + tmpReadLength)^ < '9')) then
              
              repeat // if there is a number it is the setting of another interface -> go to next line and start searching again
                tmpReadLength += 1;
                
              until ((tmpFile + tmpReadLength)^ = 10) end_repeat;
              
              tmpfound := 1;  // set flag that it is a wrong interface and search for the next one
              
            else
              tmpReadLength += 1;
            end_if;
            
          until ((tmpFile + (tmpReadLength))^ > '9') end_repeat;
          //-----------------------------------------------------------------------------------
          
        end_if;
        
        // right interface is found when tmpfound is 0
        if (tmpfound = 0) then

          tmpCommands := SearchIPAddress(pFile:= tmpFile,
                                         pFileLength:= #tmpFileLength,
                                         pReadLength:= #tmpReadLength); //VicAug 1.35

        else
          tmpReadLength -= 1;
        end_if;

      end_if;

      //-----------------------------------------------------------------------------------------
      // get to next position
      //-----------------------------------------------------------------------------------------
      tmpReadLength += 1;

    end_if;

    retcode := tmpCommands;   // return code bitwise    V.1.36

    // everything is done
    if (tmpCommands = 2#111) then
      exit;
    end_if;

  end_while;
  
  //-----------------------------------------------------------------------------------------------
  // free memory
  //-----------------------------------------------------------------------------------------------
  coStdLib.Free(tmpFile);

  //-----------------------------------------------------------------------------------------------

END_FUNCTION


FUNCTION NetworkConfig::AddIPSettingsString
	VAR_INPUT
		pFileString 	: ^CHAR;
		pInterfaceString 	: ^CHAR;
	END_VAR
  VAR
    tmpNewSettings   : ARRAY[0..MAX_LENGTH_CONFIG_STRING] OF CHAR;
    tmpConvertString : ARRAY[0..16]  OF CHAR;
    tmpConvertLength : UDINT;
  END_VAR
  
  // create the settings string
  
  //-------------------------------------------------------------------------------------------
  // HOSTADDR
  //-------------------------------------------------------------------------------------------
  coSigCLib.StrCpy(#tmpNewSettings[0], pInterfaceString);
  coSigCLib.StrCat(#tmpNewSettings[0], " HOSTADDR ");
  
  tmpConvertLength := SerializeNumber( Byte1     := (IPAddress AND 16#FF)$USINT, 
                                       Byte2     := ((IPAddress AND 16#FF00) SHR 8)$USINT, 
                                       Byte3     := ((IPAddress AND 16#FF0000) SHR 16)$USINT, 
                                       Byte4     := ((IPAddress AND 16#FF000000) SHR 24)$USINT, 
                                       pBuffer   := #tmpConvertString[0], 
                                       udLength  := sizeof(tmpConvertString));
  
  tmpConvertString[tmpConvertLength] := 0;
  coSigCLib.StrCat(#tmpNewSettings[0], #tmpConvertString[0]);
  coSigCLib.StrCat(#tmpNewSettings[0], NEWLINE);
  
  
  //-------------------------------------------------------------------------------------------
  // SUBNET
  //-------------------------------------------------------------------------------------------
  coSigCLib.StrCat(#tmpNewSettings[0], pInterfaceString);
  coSigCLib.StrCat(#tmpNewSettings[0], " SUBNET ");
  
  tmpConvertLength := SerializeNumber( Byte1     := (SNMask AND 16#FF)$USINT, 
                                       Byte2     := ((SNMask AND 16#FF00) SHR 8)$USINT, 
                                       Byte3     := ((SNMask AND 16#FF0000) SHR 16)$USINT, 
                                       Byte4     := ((SNMask AND 16#FF000000) SHR 24)$USINT, 
                                       pBuffer   := #tmpConvertString[0], 
                                       udLength  := sizeof(tmpConvertString));
                                       
  tmpConvertString[tmpConvertLength] := 0;
  coSigCLib.StrCat(#tmpNewSettings[0], #tmpConvertString[0]);
  coSigCLib.StrCat(#tmpNewSettings[0], NEWLINE);
  
  
  //-------------------------------------------------------------------------------------------
  // GATEWAY
  //-------------------------------------------------------------------------------------------
  coSigCLib.StrCat(#tmpNewSettings[0], pInterfaceString);
  coSigCLib.StrCat(#tmpNewSettings[0], " GATEWAY ");
  
  tmpConvertLength := SerializeNumber( Byte1     := (GWAddress AND 16#FF)$USINT, 
                                       Byte2     := ((GWAddress AND 16#FF00) SHR 8)$USINT, 
                                       Byte3     := ((GWAddress AND 16#FF0000) SHR 16)$USINT, 
                                       Byte4     := ((GWAddress AND 16#FF000000) SHR 24)$USINT, 
                                       pBuffer   := #tmpConvertString[0], 
                                       udLength  := sizeof(tmpConvertString));
  
  tmpConvertString[tmpConvertLength] := 0;
  coSigCLib.StrCat(#tmpNewSettings[0], #tmpConvertString[0]);
  coSigCLib.StrCat(#tmpNewSettings[0], NEWLINE);
  coSigCLib.StrCat(#tmpNewSettings[0], NEWLINE);
  //-------------------------------------------------------------------------------------------
  
  // add the settings string to the given string
  coSigCLib.StrCat(pFileString, #tmpNewSettings[0]);
  
END_FUNCTION


FUNCTION NetworkConfig::WriteHeader
	VAR_INPUT
		pFileString 	: ^CHAR;
	END_VAR
  
  //-------------------------------------------------------------------------------------------
  // write header into the given place
  //-------------------------------------------------------------------------------------------
  coSigCLib.StrCpy(pFileString, HEADER_LINE1_EXTFILE);
  coSigCLib.StrCat(pFileString, HEADER_LINE2_EXTFILE);
  coSigCLib.StrCat(pFileString, HEADER_LINE3_EXTFILE);
  coSigCLib.StrCat(pFileString, HEADER_LINE4_EXTFILE);
  coSigCLib.StrCat(pFileString, HEADER_LINE5_EXTFILE);

  //-------------------------------------------------------------------------------------------
  
END_FUNCTION

//VicAug V 1.35
FUNCTION NetworkConfig::ReadInterface1Paramters
	VAR_INPUT
		pFile 	: ^CHAR;
		pFileLength 	: ^DINT;
		pReadLength 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		Commands 	: BSINT;
	END_VAR
  VAR
  	tmpReturncode   : UDINT;
  END_VAR
  
  // set tmp variables to 0
  tmpReturncode := 0;
  
  //check for null
  if ((pFile = nil) | (pFileLength = nil) | (pReadLength = nil)) then
    return;
  end_if;

  //---------------------------------------------------------------------------
  // read for IP address command "SET IP HOSTADDR"
  //---------------------------------------------------------------------------
  if (_memcmp(ptr1:= pFile + pReadLength^, ptr2:= "SET IP HOSTADDR", cntr:= 15) = 0) then 
    
    //Search forAddress
    while pReadLength^ < (pFileLength^)$UDINT do
    
      //Search for Numbers
      if (IsNumber(usCHAR := (pFile + (pReadLength^))^) = true) then
        
        tmpReturncode := ParseNumber( usType    := 0, 
                                      pBuffer   := pFile + pReadLength^, 
                                      udLength  := (pFileLength^)$UDINT - pReadLength^);
                                      
        if tmpReturncode then
          pReadLength^ += tmpReturncode;
          BSCommand.1 := 1;
        end_if;
        
        exit;
      
      else
        //GoTo next Element
        pReadLength^ += 1;
      end_if;
      
    end_while;        
  end_if;
  
  //---------------------------------------------------------------------------
  // read for IP address command " SET IP SUBNET"
  //---------------------------------------------------------------------------
  if (_memcmp(ptr1 := pFile + pReadLength^, ptr2 := "SET IP SUBNET", cntr := 13) = 0) & (BSCommand.2 = 0)  then 
    
   //Search forAddress
   while pReadLength^ < (pFileLength^)$UDINT do
   
     //Search for Numbers
     if (IsNumber(usCHAR := (pFile + (pReadLength^))^) = true) then
       
       tmpReturncode := ParseNumber( usType    := 1, 
                                     pBuffer   := pFile + pReadLength^, 
                                     udLength  := (pFileLength^)$UDINT - pReadLength^);
                                     
       if (tmpReturncode) then
         pReadLength^ += tmpReturncode;
         BSCommand.2 := 1;
       end_if;
       
       exit;
  
     else
       //GoTo next Element
       pReadLength^ += 1;
     end_if;
  
   end_while;
   
  end_if;
  
  //---------------------------------------------------------------------------
  // read for IP address command "SET IP GATEWAY"
  //---------------------------------------------------------------------------
    if (_memcmp(ptr1 := pFile + pReadLength^, ptr2 := "SET IP GATEWAY", cntr := 14) = 0) & (BSCommand.3 = 0)  then  
  
    while pReadLength^ < (pFileLength^)$UDINT do
            
              //Search for Numbers
     if (IsNumber(usCHAR := (pFile + (pReadLength^))^) = true) then
       
       tmpReturncode := ParseNumber( usType    := 2, 
                                     pBuffer   := pFile + pReadLength^, 
                                     udLength  := (pFileLength^)$UDINT - pReadLength^);
                                     
       if (tmpReturncode) then
  //       pReadLength += tmpReturncode;
         BSCommand.3 := 1;
       end_if;
       
       exit;

     else
       //GoTo next Element
       pReadLength^ += 1;
     end_if;
              
   end_while;
  end_if;
  // set the output
  Commands := BSCommand; 
  
END_FUNCTION

//VicAug V 1.35
FUNCTION NetworkConfig::WriteInterface1Parameters
	VAR_INPUT
		pFile 	: ^CHAR;
		pReadLength 	: ^UDINT;
		pFileLength 	: ^DINT;
	END_VAR
	VAR_OUTPUT
		Commands 	: BSINT;
	END_VAR
  
  //check for null
  if (pFile = nil) | (pFileLength = nil) | (pReadLength = nil) then
    return;
  end_if;
  //---------------------------------------------------------------------------
  // write value for IP address command "SET IP HOSTADDR"
  //---------------------------------------------------------------------------
  if (_memcmp(ptr1:= pFile + pReadLength^, ptr2:= "SET IP HOSTADDR", cntr:= 15) = 0 & (IPAddress)) then // VicAug 1.35
    
    //Search forAddress
    while pReadLength^ < (pFileLength^)$UDINT do
    
      //Search for Numbers
      if (IsNumber(usCHAR := (pFile + (pReadLength^))^) = true) then
        
        pFile := ExchangeNumber(usType    := 0, 
                                pBuffer   := pFile, 
                                pPosition := pReadLength, 
                                pLength   := pFileLength);
  
        BSCommand.1 := 1;
        
        exit;
      
      else
        //GoTo next Element
       pReadLength^ += 1;
      end_if;
      
    end_while;        
  end_if; 
  
  //---------------------------------------------------------------------------
  // write value for IP address command " SET IP SUBNET"
  //---------------------------------------------------------------------------
  if (_memcmp(ptr1 := pFile + pReadLength^ , ptr2 := "SET IP SUBNET", cntr := 13) = 0 & (SNMask) )then // Vicaug 1.34
  
        //Search forAddress
    while pReadLength^ < (pFileLength^)$UDINT do
    
      //Search for Numbers
      if (IsNumber(usCHAR := (pFile + (pReadLength^))^) = true) then
        
        pFile := ExchangeNumber(usType    := 1, 
                                pBuffer   := pFile, 
                                pPosition := pReadLength, 
                                pLength   := pFileLength);
  
        BSCommand.2 := 1;
      
        exit;
      
      else
        //GoTo next Element
        pReadLength^ += 1;
      end_if;
      
    end_while;
  
   end_if; 
   
  //---------------------------------------------------------------------------
  // write value for IP address command "SET IP GATEWAY"
  //---------------------------------------------------------------------------
  if (_memcmp(ptr1 := pFile + pReadLength^, ptr2 := "SET IP GATEWAY", cntr := 14) = 0 & (GWAddress)) then // Vicaug 1.34
  
        //Search forAddress
    while pReadLength^ < (pFileLength^)$UDINT do
    
      //Search for Numbers
      if (IsNumber(usCHAR := (pFile + (pReadLength^))^) = true) then
        
        pFile := ExchangeNumber(usType    := 2, 
                                pBuffer   := pFile, 
                                pPosition := pReadLength, 
                                pLength   := pFileLength);
  
        BSCommand.3 := 1;
        
        exit;
      
      else
        //GoTo next Element
        pReadLength^ += 1;
      end_if;
      
    end_while;;
   end_if; 
   
  // set the output  
  Commands := BSCommand;

END_FUNCTION


FUNCTION NetworkConfig::SearchIPAddress
	VAR_INPUT
		pFile 	: ^CHAR;
		pFileLength 	: ^DINT;
		pReadLength 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		Commands 	: BSINT;
	END_VAR
  VAR
    tmpReturncode : UDINT;
  END_VAR
  
  
  // set tmp variables to 0
  tmpReturncode := 0;
  
  //check for null
  if ((pFile = nil) | (pFileLength = nil) | (pReadLength = nil)) then
    return;
  end_if;
  
 // Search for type of Set IP
 while (pReadLength^ < (pFileLength^)$UDINT) do

   //---------------------------------------------------------------------------------
   //Hostaddr
   //---------------------------------------------------------------------------------
   if ((_memcmp(ptr1 := pFile + pReadLength^, ptr2 := "HOSTADDR", cntr := 8) = 0) & (BSCommand.1 = 0)) then
     
     pReadLength^ += 8;   //Get over "HOSTADDR"
   
     // Search forAddress
     while (pReadLength^ < (pFileLength^)$UDINT) do
     
       // Search for Numbers
       if (IsNumber(usCHAR := (pFile + (pReadLength^))^) = true) then
         
         tmpReturncode := ParseNumber( usType    := 0, 
                                       pBuffer   := pFile + pReadLength^, 
                                       udLength  := (pFileLength^)$UDINT - pReadLength^);
                                       
         if (tmpReturncode) then
         //                tmpReadLength += tmpReturncode;
           BSCommand.1 := 1;
         end_if;

         exit;
       
       else
         pReadLength^ += 1;   // GoTo next Element
       end_if;

     end_while;
     exit;
   end_if;

   //---------------------------------------------------------------------------------
   // Subnet
   //---------------------------------------------------------------------------------
   if (_memcmp(ptr1 := pFile + pReadLength^, ptr2 := "SUBNET", cntr := 6) = 0) & (BSCommand.2 = 0) then
     
     pReadLength^ += 6;   // Get over "SUBNET"
     
     // Search forAddress
     while (pReadLength^ < (pFileLength^)$UDINT) do
     
       // Search for Numbers
       if (IsNumber(usCHAR := (pFile + (pReadLength^))^) = true) then
         
         tmpReturncode := ParseNumber( usType    := 1, 
                                       pBuffer   := pFile + pReadLength^, 
                                       udLength  := (pFileLength^)$UDINT - pReadLength^);
                                       
         if (tmpReturncode) then
        //                tmpReadLength += tmpReturncode;
           BSCommand.2 := 1;
         end_if;

         exit;

       else
         pReadLength^ += 1;   //GoTo next Element
       end_if;

     end_while;
     exit;
   end_if;

   //---------------------------------------------------------------------------------
   // Gateway
   //---------------------------------------------------------------------------------
   if ((_memcmp(ptr1 := pFile + pReadLength^, ptr2 := "GATEWAY", cntr := 7) = 0) & (BSCommand.3 = 0)) then
     
     pReadLength^ += 7;   // Get over "GATEWAY"

     // Search forAddress
     while (pReadLength^ < (pFileLength^)$UDINT) do
     
       //Search for Numbers
       if (IsNumber(usCHAR := (pFile + pReadLength^)^) = true) then
         
         tmpReturncode := ParseNumber( usType    := 2, 
                                       pBuffer   := pFile + pReadLength^, 
                                       udLength  := (pFileLength^)$UDINT - pReadLength^);
                                       
         if (tmpReturncode) then
          //                tmpReadLength += tmpReturncode;
           BSCommand.3 := 1;
         end_if;

         exit;

       else
         pReadLength^ += 1;   // GoTo next Element
       end_if;
       
     end_while;
     exit;
   end_if;

   pReadLength^ += 1;   // Get to next Position
   
 end_while;
 
 Commands := BSCommand;
 
END_FUNCTION


FUNCTION NetworkConfig::WriteIPAddress
	VAR_INPUT
		pFile 	: ^CHAR;
		pFileLength 	: ^DINT;
		pReadLength 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		Commands 	: BSINT;
	END_VAR

  
  //check for null
  if (pFile = nil) | (pFileLength = nil) | (pReadLength = nil) then
    return;
  end_if;

          // Search for type of Set IP
  while (pReadLength^ < (pFileLength^)$UDINT) do
  
    //---------------------------------------------------------------------------------
    // Hostaddr
    //---------------------------------------------------------------------------------
    if ((_memcmp(ptr1 := pFile + pReadLength^, ptr2 := "HOSTADDR", cntr := 8) = 0) & (IPAddress)) then   // v1.33 - KruAle: Convert every instance in file
      
      pReadLength^ += 8;   // Get over "HOSTADDR"
      
      // Exchange Number
      pFile := ExchangeNumber(usType    := 0, 
                                pBuffer   := pFile, 
                                pPosition := pReadLength, 
                                pLength   := pFileLength); 
                      
      BSCommand.1 := 1;
      exit;
                                   
    end_if;
    
    //---------------------------------------------------------------------------------
    // Subnet
    //---------------------------------------------------------------------------------
    if ((_memcmp(ptr1 := pFile + pReadLength^, ptr2 := "SUBNET", cntr := 6) = 0) & (SNMask)) then      // v1.33 - KruAle: Convert every instance in file
      
      pReadLength^ += 6;   // Get over "SUBNET"
      
      // Exchange Number
      pFile := ExchangeNumber(usType    := 1, 
                                pBuffer   := pFile, 
                                pPosition := pReadLength, 
                                pLength   := pFileLength); 
      BSCommand.2 := 1;
      exit;
                      
    end_if;

    //---------------------------------------------------------------------------------
    // Gateway
    //---------------------------------------------------------------------------------
    if ((_memcmp(ptr1 := pFile + pReadLength^, ptr2 := "GATEWAY", cntr := 7) = 0) & (GWAddress)) then    // v1.33 - KruAle: Convert every instance in file
      
      pReadLength^ += 7;   // Get over "GATEWAY"
      
      // Exchange Number
      pFile := ExchangeNumber(usType    := 2, 
                                pBuffer   := pFile, 
                                pPosition := pReadLength, 
                                pLength   := pFileLength); 
      BSCommand.3 := 1;
      exit;
                      
    end_if;

    // Get to next Position
    pReadLength^ += 1;
    
  end_while;

  Commands := BSCommand;
  
END_FUNCTION


FUNCTION NetworkConfig::GetMACOS
  VAR
    AddressOfEA : UDINT;
    pEthAddr :^USINT;
    EthernetAddr : ARRAY [0..5] OF USINT;
    MAC : ARRAY [0..18] OF USINT;
    tmp : ARRAY [0..5] of CHAR;
    i : USINT;
  END_VAR
  
  // V1.38: interface will always be read by a preceeding function
  //Interface := Interface.Read(); // Get selected Interface
  
  if (Interface = 0) then
    Interface := 1;
    Interface.Write(Interface);
  end_if;
  
  if coIP.GetIPInfo(Interface, IP_OPT_ETHERNET_ADDR, #AddressOfEA, 0) = 0 then
    pEthAddr := AddressOfEA$^USINT; // Einen Zeiger an diese Adresse casten
    if pEthAddr <> NIL then
      coSigCLib.StrCpy(#MAC[0], ""); //
      for i := 0 to 5 do
        EthernetAddr[i] := pEthAddr^;
        coSigCLib.IToA(pEthAddr^, #tmp[0], 16);
        if coSigCLib.StrLen(#tmp[0]) = 1 then
          coSigCLib.StrCat(#MAC[0], "0");
        end_if;
        coSigCLib.StrCat(#MAC[0], #tmp[0]);
        if i < 5 then
          coSigCLib.StrCat(#MAC[0], "-");
        end_if;
        pEthAddr += 1;
      end_for;
      StringMac.WriteDataOff(coSigCLib.StrLen(#MAC[0]), 0, #MAC[0]);
    end_if;
  else
    
    StringMAC.WriteDataOff(udLen:=15, udOff:=0, pData:="Error"); // KneMar 29.10.2020 Show only valid MACs
    
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL NetworkConfig::MACAddress::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR

	MACAddress := StringMAC.Data.Read();
	output := MACAddress;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL NetworkConfig::MACAddress::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR

	MACAddress := input;
	result := (StringMAC.Data.Write(MACAddress))$UDINT;

END_FUNCTION
