//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION
#include "..\..\Class\DataServiceAPIex\DataServiceAPIex.h"

(*!
<Class
	Name               = "DataServiceAPIex"
	Revision           = "0.2"
	GUID               = "{6F05EC78-0144-4FCC-B5A8-ABDD95808D85}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\DataServiceAPIex\DataServiceAPIex.ico"
	SharedCommandTable = "true"
	Objectsize         = "(374,120)"
	Comment            = "Class Provides Interface to Dataservice">
	<Channels>
		<Server Name="ClassSvr" GUID="{9C61659C-0C3E-4504-A2FF-274270680A75}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ClientNo" GUID="{A18C45B7-3921-401C-88C2-E06933A6647A}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\DataServiceAPIex\cDsApiEx.cpp"/>
			<File Path=".\Class\DataServiceAPIex\DataServiceAPIex.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner/>
		<Dokumentation Revision="0.2" Date="2021-01-14" Author="kolott" Company="sigmatek" Description="Method GetClientUserText() added"/>
		<Dokumentation Revision="0.1" Date="2019-12-20" Author="kolott" Company="sigmatek" Description="Method OnUnRegister(), OnReceiveEx() and SendEx() added"/>
		<Dokumentation Revision="0.0" Date="2019-11-20" Author="kolott" Company="sigmatek" Description="release"/>
	</RevDoku>
</Class>
*)
DataServiceAPIex : CLASS
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
	ClientNo 	: SvrCh_UDINT;
  //Clients:
  //Variables:
  //Functions:
	
	FUNCTION DataServiceAPIex
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment="Method is called every time when recieving data from client.&#13;&#10;Note: This method will not work when OnReceiveEx() is overwritten." Name="OnReceive"/>
	FUNCTION VIRTUAL GLOBAL OnReceive
		VAR_INPUT
			pData 	: ^DsComData;			//! <Variable Comment="Pointer to received data." Name="OnReceive.pData"/>
		END_VAR;
				//! <Function Comment="Method is called every time when recieving data from client.&#13;&#10;Note: Method OnRecieve() will not work when this method is overwritten." Name="OnReceiveEx"/>
	FUNCTION VIRTUAL GLOBAL OnReceiveEx
		VAR_INPUT
			port 	: ^void;			//! <Variable Comment="Pointer to information about client who sent data." Name="OnReceiveEx.port"/>
			pData 	: ^DsComData;			//! <Variable Comment="Pointer to received data." Name="OnReceiveEx.pData"/>
		END_VAR;
				//! <Function Comment="Method to recognize when System is unable to process amount of incomming data from client." Name="OnLevelWatchdog"/>
	FUNCTION VIRTUAL GLOBAL OnLevelWatchdog
		VAR_INPUT
			clientid 	: UDINT;			//! <Variable Comment="Id of client where critical-leveldetection occured" Name="OnLevelWatchdog.clientid"/>
			clevel 	: UDINT;			//! <Variable Comment="Level, a number from 0 to anywhere. User can choose critical threshold (&gt; 0)." Name="OnLevelWatchdog.clevel"/>
		END_VAR;
				//! <Function Comment="Send data to each enclosed client" Name="Send"/>
	FUNCTION GLOBAL Send
		VAR_INPUT
			pData 	: ^DsComData;			//! <Variable Comment="Adress of buffer to send. NOTE: Buffer has to be well initialized." Name="Send.pData"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;			//! <Variable Comment="1 on success&#13;&#10;0 on error" Name="Send.retcode"/>
		END_VAR;
				//! <Function Comment="Send data to single enclosed client" Name="SendEx"/>
	FUNCTION GLOBAL SendEx
		VAR_INPUT
			port 	: ^void;			//! <Variable Comment="Pointer to information about client to receive data." Name="SendEx.port"/>
			pData 	: ^DsComData;			//! <Variable Comment="Adress of buffer to send. NOTE: Buffer has to be well initialized." Name="SendEx.pData"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="1 on success&#13;&#10;0 on error" Name="SendEx.retcode"/>
		END_VAR;
				//! <Function Comment="This method creates a data buffer of the specified size. If dataamount will not fit into given static buffer, databuffer will be allocated. On the other hand the given static buffer will be in use.&#13;&#10;Note: Make sure that return value of Method is &lt;&gt;NIL and do not forget to call ComDataDestroy() after use." Name="ComDataCreate"/>
	FUNCTION GLOBAL ComDataCreate
		VAR_INPUT
			statbuff 	: ^DsComData;			//! <Variable Comment="Pointer to variable of type DsComData." Name="ComDataCreate.statbuff"/>
			expected_size 	: UDINT;			//! <Variable Comment="Bytesize of Data including Header to send." Name="ComDataCreate.expected_size"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: ^DsComData;			//! <Variable Comment="Pointer to databuffer of given size &quot;expected_size&quot; or NIL in case of no memory left." Name="ComDataCreate.retcode"/>
		END_VAR;
				//! <Function Comment="This method will destroy databuffer created by method ComDataCreate()" Name="ComDataDestroy"/>
	FUNCTION GLOBAL ComDataDestroy
		VAR_INPUT
			statbuff 	: ^DsComData;			//! <Variable Comment="Address of static buffer. Has to be same adress which is given to method ComDataCreate()." Name="ComDataDestroy.statbuff"/>
			buffer 	: ^DsComData;			//! <Variable Comment="Address of created buffer by method ComDataCreate() " Name="ComDataDestroy.buffer"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: ^DsComData;			//! <Variable Comment="Always NIL" Name="ComDataDestroy.retcode"/>
		END_VAR;
				//! <Function Comment="This method creates a data buffer of the specified size. If dataamount will not fit into given static buffer, databuffer will be allocated. On the other hand the given static buffer will be in use.&#13;&#10;Note: Make sure that return value of Method is &lt;&gt;NIL and do not forget to call DsComDataDestroy() after use." Name="DsComDataCreate"/>
	FUNCTION GLOBAL DsComDataCreate
		VAR_INPUT
			scratchbuff 	: ^void;			//! <Variable Comment="Address of arbitrary scratch buffer" Name="DsComDataCreate.scratchbuff"/>
			scratchbuffsize 	: UDINT;			//! <Variable Comment="Bytesize of arbitrary scratch buffer" Name="DsComDataCreate.scratchbuffsize"/>
			datasize 	: UDINT;			//! <Variable Comment="Bytesize of Data to send. There is no need to include size of Header to this parameter" Name="DsComDataCreate.datasize"/>
			id_major 	: UINT := 0;			//! <Variable Comment="Major Id to identify message in plc. " Name="DsComDataCreate.id_major"/>
			id_minor 	: UINT := 0;			//! <Variable Comment="Minor Id to identify message in plc." Name="DsComDataCreate.id_minor"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: ^DsComData;			//! <Variable Comment="Pointer to databuffer of given size &quot;datasize + 16&quot;" Name="DsComDataCreate.retcode"/>
		END_VAR;
				//! <Function Comment="This Method will destroy databuffer created by Method DsComDataCreate()" Name="DsComDataDestroy"/>
	FUNCTION GLOBAL DsComDataDestroy
		VAR_INPUT
			scratchbuff 	: ^void;			//! <Variable Comment="Address of arbitrary scratch buffer. Has to be same adress which is given to method DsComDataCreate()." Name="DsComDataDestroy.scratchbuff"/>
			buffer 	: ^DsComData;			//! <Variable Comment="Address of created buffer by method DsComDataCreate() " Name="DsComDataDestroy.buffer"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: ^DsComData;			//! <Variable Comment="always NIL" Name="DsComDataDestroy.retcode"/>
		END_VAR;
				//! <Function Comment="Method is called every time when client will connect or disconnect.&#13;&#10;Note: Parameter &quot;addclt&quot; will give information if client will connect (true) or disconnect (false)" Name="OnUnRegister"/>
	FUNCTION VIRTUAL GLOBAL OnUnRegister
		VAR_INPUT
			port 	: ^void;			//! <Variable Comment="Pointer to information about client who sent data." Name="OnUnRegister.port"/>
			addclt 	: BOOL;			//! <Variable Comment="additional Information if Client will connect or disconnect&#13;&#10;false ... client will disconnect &#13;&#10;true ... client will connect" Name="OnUnRegister.addclt"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="Return &apos;false&apos; when user will denie requested connection, on the other hand &apos;true&apos;.&#13;&#10;NOTE: User can not denie a requested disconnection. Just a try to connect can be denied by user." Name="OnUnRegister.retcode"/>
		END_VAR;
				//! <Function Comment="Methode can be used to get ClientID out of information about client" Name="GetClientId"/>
	FUNCTION GLOBAL GetClientId
		VAR_INPUT
			port 	: ^void;			//! <Variable Comment="Pointer to information about client." Name="GetClientId.port"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;			//! <Variable Comment="ID of Client" Name="GetClientId.retcode"/>
		END_VAR;
				//! <Function Comment="Method is used to get additional textinformation (ascii-0-string) about connected client. If no additional textinformation was given method will return a empty string (&quot;&quot;) and if functionality is not supported by loader you will get &quot;not supported&quot;." Name="GetClientUserText"/>
	FUNCTION GLOBAL GetClientUserText
		VAR_INPUT
			port 	: ^void;			//! <Variable Comment="Pointer to information about client." Name="GetClientUserText.port"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: ^CHAR;			//! <Variable Comment="Pointer to additional textinformation or a empty string (&quot;&quot;) if not available" Name="GetClientUserText.retcode"/>
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB DataServiceAPIex::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_DATASERVICEAPIEX
0$UINT, 2$UINT, (SIZEOF(::DataServiceAPIex))$UINT, 
2$UINT, 0$UINT, 0$UINT, 
TO_UDINT(1322551714), "DataServiceAPIex", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::DataServiceAPIex.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::DataServiceAPIex.ClientNo.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1631067679), "ClientNo", 
//Clients:
END_FUNCTION


#define USER_CNT_DataServiceAPIex 4

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_DataServiceAPIex] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION DataServiceAPIex::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_DataServiceAPIex, pCmd := #vmt.CmdTable);
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #OnReceive();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #OnReceiveEx();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #OnLevelWatchdog();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #OnUnRegister();

#pragma warning (default : 74)
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= DataServiceAPIex();

END_FUNCTION

//{{LSL_IMPLEMENTATION

#ifdef DATASERVICE_LASAL
 #include <loader\class\dataservice\DS_Main.h>
 #ifdef DATASERVICE_VERSION
  #if DATASERVICE_VERSION >= 2
   #define DS_V2
  #endif
  #if DATASERVICE_VERSION >= 3
   #define DS_V3
  #endif
 #endif
#endif

#include "lsl_st_ifssr.h"

type
  pDsApiEx : ^DataServiceAPIex;
end_type

function global __cdecl DsApiGetObjList var_input pno:^udint; end_var var_output retcode:^pDsApiEx; end_var;
function global __cdecl DsApiAdd var_input pthis:^void; end_var var_output retcode:dint; end_var;

FUNCTION GLOBAL __cdecl DataServiceAPIex__OnReceive VAR_INPUT pData:^DsComData; END_VAR
  VAR
    nox : udint;
    ppt : ^pDsApiEx;
  END_VAR

  ppt := DsApiGetObjList(#nox);
  while(nox) do
    nox -= 1;
    ppt^^.OnReceive(pData);
    ppt += 4;
  end_while;
 
END_FUNCTION

FUNCTION GLOBAL __cdecl DataServiceAPIex__OnReceiveEx VAR_INPUT port:^void; pData:^DsComData; END_VAR
  VAR
    nox : udint;
    ppt : ^pDsApiEx;
  END_VAR

  ppt := DsApiGetObjList(#nox);
  while(nox) do
    nox -= 1;
    ppt^^.OnReceiveEx(port, pData);
    ppt += 4;
  end_while;
 
END_FUNCTION

FUNCTION GLOBAL __cdecl DataServiceAPIex__OnUnRegisterClient VAR_INPUT port:^void; addclt:udint; END_VAR var_output retcode:udint; end_var
  VAR
    nox : udint;
    ppt : ^pDsApiEx;
    badd : bool;
  END_VAR
  
  retcode := 1;
  ppt     := DsApiGetObjList(#nox);
  badd    := addclt <> 0;
  while(nox) do
    nox -= 1;
    if(ppt^^.OnUnRegister(port, badd) = false) then
      retcode := 0;
    end_if;
    ppt += 4;
  end_while;
 
END_FUNCTION

FUNCTION GLOBAL __cdecl DataServiceAPIex__OnLevelWatchDog VAR_INPUT clientid:udint; clevel:udint; END_VAR
  VAR
  	nox : udint;
    ppt : ^pDsApiEx;
  END_VAR

  ppt := DsApiGetObjList(#nox);
  while(nox) do
    nox -= 1;
    ppt^^.OnLevelWatchdog(clientid, clevel);
    ppt += 4;
  end_while;

END_FUNCTION

FUNCTION DataServiceAPIex::DataServiceAPIex
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR

	ret_code := C_OK;
  
 #ifdef DATASERVICE_LASAL 
  ClassSvr := DsApiAdd(this);
  
  #ifdef DS_V3
   LDR_DS_Register_pCB_RecieveDataEx(#DataServiceAPIex__OnReceiveEx());
   LDR_DS_Register_pCB_UnRegClient(#DataServiceAPIex__OnUnRegisterClient());
  #else
   LDR_DS_Register_pCB_RecieveData(#DataServiceAPIex__OnReceive());
  #endif

  #ifdef DS_V2
   LDR_DS_Register_pCB_LevelWatchDog(#DataServiceAPIex__OnLevelWatchDog());
  #endif
  
 #endif 
 
END_FUNCTION

#pragma warning(disable:0073)

FUNCTION VIRTUAL GLOBAL DataServiceAPIex::OnUnRegister
	VAR_INPUT
		port 	: ^void;
		addclt 	: bool;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  retcode := true;
  
  if(addclt = true) then
    ClientNo += 1;
  else
    ClientNo -= 1;
  end_if;

END_FUNCTION

FUNCTION GLOBAL VIRTUAL DataServiceAPIex::OnReceive
	VAR_INPUT
		pData 	: ^DsComData;
	END_VAR
END_FUNCTION

FUNCTION VIRTUAL GLOBAL DataServiceAPIex::OnReceiveEx
	VAR_INPUT
		port 	: ^void;
		pData 	: ^DsComData;
	END_VAR
  
  OnReceive(pData); // call is used to keep compatibility to version 0.0
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL DataServiceAPIex::OnLevelWatchdog
	VAR_INPUT
		clientid 	: UDINT;
		clevel 	: UDINT;
	END_VAR
END_FUNCTION

FUNCTION GLOBAL DataServiceAPIex::Send
	VAR_INPUT
		pData 	: ^DsComData;
	END_VAR
	VAR_OUTPUT
		retcode 	: udint;
	END_VAR
  
  #ifdef DATASERVICE_LASAL
   retcode := LDR_DS_Send(pData);
  #else
   retcode := 0; // can't send data
  #endif
  
END_FUNCTION

FUNCTION GLOBAL DataServiceAPIex::SendEx
	VAR_INPUT
		port 	: ^void;
		pData 	: ^DsComData;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  
  #ifdef DATASERVICE_LASAL
   #ifdef DS_V3
    retcode := LDR_DS_SendEx(port, pData) <> 0;
   #else
    retcode := LDR_DS_Send(pData) <> 0;
   #endif
  #else
   retcode := false; // can't send data
  #endif
  
END_FUNCTION

FUNCTION GLOBAL DataServiceAPIex::DsComDataCreate
	VAR_INPUT
		scratchbuff 	: ^void;
		scratchbuffsize 	: UDINT;
		datasize 	: UDINT;
		id_major 	: UINT;(* := 0 *)
		id_minor 	: UINT;(* := 0 *)
	END_VAR
	VAR_OUTPUT
		retcode 	: ^DsComData;
	END_VAR
  
  #ifdef DATASERVICE_LASAL
   #ifdef DS_V2
    datasize += sizeof(DsComDataHdr);
   #else
    datasize += 16;
   #endif
  
    if((scratchbuff <> nil) & (datasize <= scratchbuffsize)) then
      retcode$^void := scratchbuff;
    else
      retcode$^void := OS_SSR_Malloc(datasize);
    end_if;
  
    if(retcode <> nil) then
      retcode^.datalength      := datasize;
      retcode^.id_major        := id_major;
      retcode^.id_minor        := id_minor;
      retcode^.transactionSrc  := 0;
      retcode^.transactionDest := 0;
      retcode^.messageId       := 0;
    end_if;
  #else
    retcode := nil;
  #endif
  
END_FUNCTION

FUNCTION GLOBAL DataServiceAPIex::DsComDataDestroy
	VAR_INPUT
		scratchbuff 	: ^void;
		buffer 	: ^DsComData;
	END_VAR
	VAR_OUTPUT
		retcode 	: ^DsComData;
	END_VAR

  if((buffer <> nil) & (buffer <> scratchbuff)) then
    OS_SSR_Free(buffer);
  end_if;
  
  retcode := nil;

END_FUNCTION

#pragma warning(default:0073)

FUNCTION GLOBAL DataServiceAPIex::ComDataCreate
	VAR_INPUT
		statbuff 	: ^DsComData;
		expected_size 	: udint;
	END_VAR
	VAR_OUTPUT
		retcode 	: ^DsComData;
	END_VAR

  #ifdef DS_V2
    if(expected_size >= sizeof(DsComDataHdr)) then
      expected_size -= sizeof(DsComDataHdr);
    end_if;
  #else
    if(expected_size >= 16) then
      expected_size -= 16;
    end_if;
  #endif
  
  retcode := DsComDataCreate(statbuff, sizeof(DsComData), expected_size);
  
END_FUNCTION

FUNCTION GLOBAL DataServiceAPIex::ComDataDestroy
	VAR_INPUT
		statbuff 	: ^DsComData;
		buffer 	: ^DsComData;
	END_VAR
	VAR_OUTPUT
		retcode 	: ^DsComData;
	END_VAR
  
  retcode := DsComDataDestroy(statbuff, buffer);

END_FUNCTION

FUNCTION GLOBAL DataServiceAPIex::GetClientId
	VAR_INPUT
		port 	: ^void;
	END_VAR
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR

  #ifdef DS_V3
    retcode := LDR_DS_GetClientId(port);
  #else
    retcode := 0;
  #endif

END_FUNCTION

FUNCTION GLOBAL DataServiceAPIex::GetClientUserText
	VAR_INPUT
		port 	: ^void;
	END_VAR
	VAR_OUTPUT
		retcode 	: ^CHAR;
	END_VAR
  VAR
  	lhack :udint;
  END_VAR

  retcode := "not supported";
  lhack   := LDR_DS_Register(999, port);
  if(lhack <> 0) then
    retcode := lhack$^char;
  end_if;

END_FUNCTION
