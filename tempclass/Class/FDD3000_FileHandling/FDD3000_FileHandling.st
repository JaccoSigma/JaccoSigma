//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES

#define _FDD3000_FH_MAX_PARAMETERS 30
#define _FDD3000_FH_SIZE_ONEPARA    (sizeof(ts_OneParameter))

#define _FDD3000_FH_STR_DRIVE    "Drive"
#define _FDD3000_FH_STR_PARAMS   "Params"
#define _FDD3000_FH_STR_PARAM    "Param"
#define _FDD3000_FH_STR_FILENAME "FDD3000_"
#define _FDD3000_FH_STR_FILENAME_GENERAL  "FDD3000_General"

#define _FDD3000_FH_STR_INDEX    "Index"
#define _FDD3000_FH_STR_SUBINDEX "Subindex"
#define _FDD3000_FH_STR_LENGTH   "Length"
#define _FDD3000_FH_STR_RW       "RW"
#define _FDD3000_FH_STR_MODE     "Mode"
#define _FDD3000_FH_STR_DATA     "Data"
//}}LSL_DEFINES

//{{LSL_DECLARATION
#include "..\..\Class\_DriveMngBase\SDDDefinitions.h"

(*!
<Class
	Name               = "FDD3000_FileHandling"
	Revision           = "1.0"
	GUID               = "{DBB3B302-5C7B-4F44-84E9-AFF33F9D053B}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "true"
	DefBackground      = "250 ms"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\_DriveMngBase\Drive.ico"
	SharedCommandTable = "true"
	Objectsize         = "(450,180)"
	Comment            = "save the Drive Parameter in a RAMFILE &#13;&#10;or export the parameter into an excel formated file">
	<Channels>
		<Server Name="ClassSvr" GUID="{E3F30B18-2450-4A3C-A9C3-AAEBED84126D}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="connect this server to the client &apos;FileHandle&apos; at the _DriveAxis class"/>
		<Client Name="_XMLReader1" Required="true" Internal="true"/>
		<Client Name="_XMLWriter1" Required="true" Internal="true"/>
		<Client Name="coFileSys" Required="false" Internal="false" Comment="object channel to the os-class _FileSys"/>
		<Client Name="coLinker" Required="false" Internal="false"/>
		<Client Name="coSigCLib" Required="false" Internal="false" Comment="object channel to the os-class SigCLib"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\_DriveMngBase\SDDDefinitions.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="PieSte"/>
		<Dokumentation Revision="1.0" Date="02.02.2021" Author="ZoePat" Company="Sigmatek" Description="first library version"/>
		<Dokumentation Revision="0.10" Date="18.08.2020" Author="PieSte" Company="Sigmatek" Description="RC Version."/>
		<Dokumentation Revision="0.1" Date="30.07.2020" Author="PieSte" Company="Sigmatek" Description="first version."/>
	</RevDoku>
	<Network Name="FDD3000_FileHandling">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name           = "_XMLReader1"
				GUID           = "{8F2F9F4F-0372-467C-99E6-62D422D97AD0}"
				Class          = "_XMLReader"
				Position       = "(240,630)"
				Visualized     = "true"
				Remotely       = "true"
				BackgroundTime = "100 ms">
				<Channels>
					<Server Name="ClassSvr"/>
					<Server Name="DoConvert"/>
					<Server Name="ErrorLine"/>
					<Server Name="ErrorSign"/>
					<Server Name="ErrorState"/>
					<Server Name="XmlState"/>
					<Client Name="CreateTask" Value="0"/>
					<Client Name="FileSys"/>
					<Client Name="MultiTask"/>
					<Client Name="SigCLib"/>
					<Client Name="StdLib"/>
				</Channels>
			</Object>
			<Object
				Name           = "_XMLWriter1"
				GUID           = "{DD166AF5-8979-4D0C-A286-BC064B55C287}"
				Class          = "_XMLWriter"
				Position       = "(240,1110)"
				Visualized     = "true"
				Remotely       = "true"
				BackgroundTime = "100 ms">
				<Channels>
					<Server Name="ClassSvr"/>
					<Server Name="DoConvert"/>
					<Server Name="XmlError"/>
					<Server Name="XmlState"/>
					<Client Name="CreateTask" Value="0"/>
					<Client Name="FileSys"/>
					<Client Name="MaxFileSize" Value="5000"/>
					<Client Name="MultiTask"/>
					<Client Name="SigCLib"/>
					<Client Name="StdLib"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this._XMLReader1" Destination="_XMLReader1.ClassSvr"/>
			<Connection Source="this._XMLWriter1" Destination="_XMLWriter1.ClassSvr"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
FDD3000_FileHandling : CLASS
	TYPE
	  e_DriveType :  //! <Type Public="true" Name="e_DriveType"/>
	  (
	    _NotFound,
	    _FDD3000_CAN,
	    _FDD3000_EtherCAT,
	    _FDD3000_VARAN
	  )$UDINT;
	  e_SMExportXML :
	  (
	    _Start,
	    _CreatFile,
	    _Wait4File,
	    _WriteData,
	    _WriteGeneralData,
	    _Error
	  )$UDINT;
	  e_SMImportXML :
	  (
	    _Start,
	    _AllocBuffer,
	    _OpenFile,
	    _Wait4File,
	    _OpenFileGeneral,
	    _Wait4FileGeneral,
	    _ReadFile,
	    _CpyParam,
	    _Error
	  )$UDINT;
#pragma pack(push, 1)
	  ts_OneParameter : STRUCT  //! <Type Public="true" Name="ts_OneParameter"/>
	    hiIndex : HINT;
	    usSubIndex : USINT;
	    dData : DINT;
	    usLength : USINT;
	    usRW : USINT;
	    usMode : USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  ts_ParaFileHeader : STRUCT  //! <Type Public="true" Name="ts_ParaFileHeader"/>
	    udCRC32 : UDINT;
	    udLen : UDINT;
	    udVersion : UDINT;
	    DriveType : e_DriveType;
	    AxOffset : UDINT;
	    AxLength : UDINT;
	    AxName : ARRAY [0..20] OF CHAR;
	    bsFileSelect : BSINT
	    [
	      1 FileSerialNbr,
	      2 FileGeneral,
	      3 Bit3,
	      4 Bit4,
	      5 Bit5,
	      6 Bit6,
	      7 Bit7,
	      8 Bit8,
	    ];
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  ts_ParaFile : STRUCT  //! <Type Public="true" Name="ts_ParaFile"/>
	    sHeader : ts_ParaFileHeader;
	    aParaData : ARRAY [0.._FDD3000_FH_MAX_PARAMETERS-1] OF ts_OneParameter;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
  //Clients:
	coFileSys 	: CltChCmd__FileSys;
	coSigCLib 	: CltChCmd_SigCLib;
	coLinker 	: CltChCmd__Linker;
	_XMLReader1 	: CltChCmd__XMLReader;
	_XMLWriter1 	: CltChCmd__XMLWriter;
  //Variables:
		SDDBgSSW 	: _SDDUSERCMD;
		szFileName : ARRAY [0..99] OF CHAR;

		bDefaultName 	: BOOL;
		pSDDData 	: ^ts_ParaFile;
		SMImportXML 	: e_SMImportXML;
		SMExportXML 	: e_SMExportXML;
		pBufferSDDData 	: ^ts_ParaFile;
		DriveType 	: e_DriveType;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="call the function to set a user defined path and file name for the exporting drive parameter&#13;&#10;example :&#13;&#10;pName = &quot;ExportPara.xls&quot;&#13;&#10;pDirectory = &quot;C:\&quot;&#13;&#10;&#13;&#10;if any of the parameters is NIL, the default path and file is used" Name="SetFileName"/>
	FUNCTION GLOBAL SetFileName
		VAR_INPUT
			pName 	: ^CHAR;			//! <Variable Comment="filename for the exporting drive parameter" Name="SetFileName.pName"/>
			pDirectory 	: ^CHAR;			//! <Variable Comment="pointer to the path of the creating filename" Name="SetFileName.pDirectory"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="control the length of the string&#13;&#10;TRUE = new path and filename was accepted (string length is ok)&#13;&#10;FALSE = invalid path or filename was given (string length isn&apos;t ok)&#13;&#10;" Name="SetFileName.retcode"/>
		END_VAR;
				//! <Function Comment=" BIN to ASCII converter" Name="Bin2Ascii"/>
	FUNCTION GLOBAL Bin2Ascii
		VAR_INPUT
			pt 	: ^CHAR;
			value 	: DINT;
			format 	: BINT;
		END_VAR;
	
	FUNCTION VIRTUAL ExportSDDDataXML
		VAR_INPUT
			pData 	: ^ts_ParaFile;
		END_VAR
		VAR_OUTPUT
			retstate 	: iprStates;
		END_VAR;
	
	FUNCTION VIRTUAL ImportSDDDataXML
		VAR_INPUT
			pData 	: ^ts_ParaFile;
		END_VAR
		VAR_OUTPUT
			retstate 	: iprStates;
		END_VAR;
	
	FUNCTION VIRTUAL ConvStr2DINT
		VAR_INPUT
			pStr 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			retval 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GetDriveTypeStr
		VAR_INPUT
			eDriveType 	: e_DriveType;
			pDriveTypeStr 	: ^CHAR;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ClassSvr::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using _XMLReader
#pragma using _XMLWriter
#pragma usingLtd _FileSys
#pragma usingLtd _Linker
#pragma usingLtd SigCLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB FDD3000_FileHandling::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_FDD3000_FILEHANDLING
1$UINT, 0$UINT, (SIZEOF(::FDD3000_FileHandling))$UINT, 
1$UINT, 5$UINT, 0$UINT, 
TO_UDINT(3011908429), "FDD3000_FileHandling", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::FDD3000_FileHandling.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
//Clients:
(::FDD3000_FileHandling.coFileSys.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(940542775), "coFileSys", TO_UDINT(545279513), "_FileSys", 1$UINT, 20$UINT, 
(::FDD3000_FileHandling.coSigCLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1750761597), "coSigCLib", TO_UDINT(77440046), "SigCLib", 0$UINT, 36$UINT, 
(::FDD3000_FileHandling.coLinker.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1382361455), "coLinker", TO_UDINT(1793552568), "_Linker", 0$UINT, 4$UINT, 
(::FDD3000_FileHandling._XMLReader1.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1322631253), "_XMLReader1", TO_UDINT(3727258101), "_XMLReader", 2$UINT, 3$UINT, 
(::FDD3000_FileHandling._XMLWriter1.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1649918351), "_XMLWriter1", TO_UDINT(2243305547), "_XMLWriter", 1$UINT, 4$UINT, 
END_FUNCTION


#define USER_CNT_FDD3000_FileHandling 5

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_FDD3000_FileHandling] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION FDD3000_FileHandling::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_FDD3000_FileHandling, pCmd := #vmt.CmdTable);
	vmt.CmdTable.NewInstr		:= #NewInst();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #ExportSDDDataXML();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #ImportSDDDataXML();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #ConvStr2DINT();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #GetDriveTypeStr();

#pragma warning (default : 74)
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
FUNCTION VIRTUAL GLOBAL FDD3000_FileHandling::ClassSvr::NewInst
  VAR_INPUT
    pPara    : ^CmdStruct;
    pResult  : ^results;
  END_VAR
  VAR_OUTPUT
    ret_code   : iprStates;
  END_VAR
  
  ret_code := ERROR;
  
  CASE pPara^.uiCmd OF
  
  // get the actual length of the data in the ramfile
  0:
    
  // set the new size
  1:
  
  // set the new data into the ramfile
  2:
  
  // get the data of the ramfile
  3:
    
  // Set the new user command
  4 :
    ret_code := READY;
    if ((SDDBgSSW = _SDDIDLE) | 
        (SDDBgSSW = _SDDERROR)) then
      SDDBgSSW := pPara^.aPara[0]$_SDDUSERCMD;
      pSDDData$DINT := pPara^.aPara[1];
      
      case SDDBgSSW of
        _SDDUSERCMD::_SDDIDLE:
        _SDDUSERCMD::_SDDEXDATAXML:
          SMExportXML := e_SMExportXML::_Start;
        _SDDUSERCMD::_SDDIMDATAXML:
          SMImportXML := e_SMImportXML::_Start;
        _SDDUSERCMD::_SDDERROR:
      end_case;

    end_if;
  
  // get the actual user command
  5 :
    ret_code := READY;
    pResult^.aData[0]$_SDDUSERCMD := SDDBgSSW;
  
  // Set Drive Type for xml export
  6 :    
    
  // to check the right class
  199 :
    ret_code := READY;
    pResult^.aData[2] := 16#FE;
        
  END_CASE;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_FileHandling::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
  VAR
    retstate : iprStates;
  END_VAR

  state:= READY;
  
  case SDDBgSSW of
  
    _SDDIDLE :
    
    _SDDEXDATA :
      SDDBgSSW := _SDDIDLE;
      
    _SDDEXDATAXML:
      // export Data of the drive to xml File
      retstate := ExportSDDDataXML(pSDDData);
      if retstate <> BUSY then
        
        SDDBgSSW := _SDDERROR;
        if retstate = READY then
          SDDBgSSW := _SDDIDLE;
        end_if;
        
      end_if;
    
    _SDDIMDATAXML:
      // import Data of the drive from xml File
      retstate := ImportSDDDataXML(pSDDData);
      if retstate <> BUSY then
        
        SDDBgSSW := _SDDERROR;
        if retstate = READY then
          SDDBgSSW := _SDDIDLE;
        end_if;
        
      end_if;
      
    else
      SDDBgSSW := _SDDIDLE;
  end_case;

END_FUNCTION
//[#DEUTSCH]
//Export the drive parameter
//[#DEUTSCH]
//call the function to set a user defined path and file name for the exporting drive parameter
FUNCTION GLOBAL FDD3000_FileHandling::SetFileName
	VAR_INPUT
		pName 	: ^CHAR;
		pDirectory 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
    udLen     : UDINT;
  END_VAR
  
  retcode := FALSE;
  
  // on invalid inputs
  if (pName = NIL) | (pDirectory = NIL) then
    // we reset the filename (is initialized in method ExportSDDData)
    szFileName[0] := 0; 
    return; // Return, _strlen will cause an Access exccpetion if called with nil. (ARM)
  end_if;
  
  udLen := _strlen(pName);
  udLen += _strlen(pDirectory);
  if udLen < 99 then
    _strcpy(#szFileName[0], pDirectory);
    _strcat(#szFileName[0], pName);
    retcode := TRUE;
  end_if;
  
END_FUNCTION

//[#ENGLISH]
// *************************************************************************
//                BIN to ASCII converter
//  The input variables of this function have to be a
//  pointer  on a  Char-String, the value you want to convert(DINT)
//  and a scheme(BINT). In the scheme you must define the number
//  of digits to convert, the position of the decimal point,
//  hasty zeros or not and if the descendant zeros should be
//  deleted or not.
//
//  -------------scheme------------------------------
//
//       xxxx xx00 0000 0000
//       .... .... .... ****    no. of digits
//       .... .... **** ....    pos. of decimal point (from lowest sign.)
//       .... ...* .... ....    reminding digits fill with hasty zeros
//       .... ..*. .... ....    delete descendant zeros
//
//
//       16#0224$BINT
//           |||..........    no. of digits
//           ||...........    pos. of decimal point
//           |............    0 without hasty zeros
//                            1 with hasty zeros
//                            2 delete descendant zeros (the
//                               digits have to be the real number
//                               of digits, without the deleted
//                               zeros! f.e.: 
//                               12.900 => 12.9 that means 3 digits!)
//
//
//  If an error occures during the conversion, the first CHAR in
//  your string will be set to '?' (this f.e. could be the result
//  of a wrong number of digits). The status of all other CHAR in
//  the String is undefined!
//
//
//[>pt]pointer at CHAR-String
//[>value]value to convert
//[>format]scheme for the conversion
//
//[#DEUTSCH]
// *************************************************************************
//                BIN to ASCII Konverter
//  
//  ‹bergeben Sie der Funktion einen Pointer auf ein CHAR-Feld, die
//  Zahl die in ASCII gewandelt werden soll (vom Typ DINT) und das
//  Format nach welchem die Zahl gewandelt wird. Im Format muss
//  folgendes angegeben werden: die Anzahl der Stellen, die 
//  Position des Kommas, ob Vornullen verwendet werden und ob 
//  Nachnullen gelˆscht werden sollen. 
//
//	-------------Format------------------------------
//
//       xxxx xx00 0000 0000
//       .... .... .... ****    Anz. der Stellen
//       .... .... **** ....    pos. des Komma (von hinten)
//       .... ...* .... ....    restlichen Stellen mit Vornullen auff¸llen
//       .... ..*. .... ....    Nachnullen lˆschen
//
//
//        16#0224$BINT
//            |||..........   Anz. der Stellen
//            ||...........   pos. des Komma (von hinten)
//            |............   0 ohne Vornullen
//                            1 mit Vornullen auff¸llen
//                            2 Nachnullen lˆschen (die Anz. der
//                              Stellen muss genau der Anz. der
//                              Gewandelten entsprechen, ohne 
//                              Nachnullen! z.B.:
//                              12.900 => 12.9 d.h. 3 Stellen!)
//
//  Wenn bei der Wandlung ein Fehler aufgetreten ist, wir das 
//  erste Zeichen im CHAR-String auf '?' gesetzt (kˆnnte z.B.
//  durch eine falsche Anzahl Stellen auftreten). Alle Anderen
//  haben einen nicht definierten Zustand!
//
//

// xxxx 0000 0000 0000 format
//      .... .... **** no of digits
//      .... **** .... position decimalpoint
//      ...* .... .... preceding zeros
//      ..*. .... .... descendant zeros
//      .*.. .... .... vorzeichen unmittelbar vor wert (-3 ansonsten -  3)
//      *... .... .... anzahl der stellen automatisch ermitteln

//[>pt]Pointer auf CHAR-String
//[>value]zu konvertierende Zahl
//[>format]das Format
 //GLOBAL SDDSettings::Bin2Ascii
FUNCTION GLOBAL FDD3000_FileHandling::Bin2Ascii
	VAR_INPUT
		pt 	: ^CHAR;
		value 	: DINT;
		format 	: BINT;
	END_VAR
VAR
  tmp       : DINT;
  nk        : UINT;
  dig       : UINT;
  hp        : ^CHAR; 
  pd        : UINT; 
  h         : UINT;
END_VAR

  if((format AND 16#000F) = 0) then
    format := format OR 16#0800;
  end_if;

  if(format AND 16#0800) then
    tmp  := value;
    if tmp = 0 then
      dig := 1;
    else
      dig := 0;
    end_if;

      while(tmp) do
      
      tmp := tmp / 10;
      dig += 1;
      end_while;

      nk := ((format SHR 4) AND 16#0F);
      
    if(nk >= dig) then
        dig := nk + 1;
    end_if;
      
    format := (format AND 16#FFF0) OR (dig AND 16#000F);
  end_if;


  dig := (format and 16#0F);       // Anzahl der Stellen
  hp  := pt + dig;                 // pointer auf String-Ende
  tmp := value;                    // Zahl
  pd  := (format shr 4) and 16#0F; // position des Komma

  
  if(value < 0) then        // kontrolle ob Zahl negativ
  hp    += 1;    
    value := -value;        // Zahl * (-1)
    pt^   := '-';           // Erstes Zeichen auf '-' setzen
  end_if;

  if(format and 16#0200) then   // Nachnullen lˆschen
    h := pd; 
  while(h) do                   // Nur Nullen hinter Komma
    h -= 1; 
    if((value mod 10) = 0) then	// Ist Ziffer Null?
      value := value / 10; 	// wenn ja, Null lˆschen
    pd -= 1; 
      else
      h := 0; 
      end_if; 

  end_while; 
  end_if; 
  
  if(pd <> 0) then      // Komma noch zu setzen?
    hp += 1;
  end_if; 

  hp^ := 0;             // String mit Ascii-0 abschlieﬂen
  hp  -= 1;   

  repeat
    hp^   := '0' + TO_USINT(value mod 10); //akt. Ziffer
  hp    -= 1; 
  pd    -= 1; 
  dig   -= 1; 
  if(pd = 0)then    // Komma setzen?
    hp^ := '.';
    hp -= 1; 
    end_if; 

    value := value / 10;  // n‰chste Ziffer
    
    if((dig = 0) & (value <> 0)) then  // Zahl zu groﬂ 
    pt^   := '?'; 	// Formatfehler
    value := 0; 
  end_if; 
  until(value = 0) end_repeat; 
 
 
  if(dig > 0) then  // mit Vornullen auff¸llen
  repeat            // so lange bis Digits auf Null
      if((format and 16#0100)|(pd$INT >= 0)) then   // Vornullen im 
        hp^ := '0';                                 // Format angegeben?
      else              // formatfehler (digit zu groﬂ und keine Vornullen) 
      pt^   := '?';     // Formatfehler	
      value := 0;
      end_if; 
      pd -= 1;
    hp -= 1;
      if(pd = 0) then	// Komma setzen
      hp^ := '.';
      hp -= 1; 
      end_if; 
    dig -= 1;
  until(dig = 0) end_repeat;   // letzte Ziffer?
  end_if;

END_FUNCTION


FUNCTION VIRTUAL FDD3000_FileHandling::ExportSDDDataXML
	VAR_INPUT
		pData 	: ^ts_ParaFile;
	END_VAR
	VAR_OUTPUT
		retstate 	: iprStates;
	END_VAR
  VAR
    namebuffer  : ARRAY[0..99] of CHAR;
    retcode     : DINT;
    szNr        : ARRAY[0..99] of CHAR;
    i           : UDINT;
    pHlp        : ^ts_OneParameter;
  END_VAR
  
  // Default return values
  retstate := BUSY;

#ifdef _DBGFDD3000_FileHandling
  HWC_LogPrintf(this, "@DBG: ExportSDDDataXML Called in step: %u", #SMExportXML);
#endif
  
  case SMExportXML of
    
    e_SMExportXML::_Start,
    e_SMExportXML::_CreatFile:
    
                  if szFileName[0] = 0 then
                    bDefaultName := TRUE;
                    _strcpy(#namebuffer[0], _FDD3000_FH_STR_FILENAME);
                    _strcpy(#namebuffer[_strlen(#namebuffer$CHAR)], #pData^.sHeader.AxName[0]);
                    _strcpy(#namebuffer[_strlen(#namebuffer$CHAR)], ".xml"); //here the extention will be added
                    SetFileName(#namebuffer[0], "C:\"); // this is for giving the file the name of the axleobject
                  end_if;
                  
                  SMExportXML := e_SMExportXML::_Wait4File;
                  retcode := _XMLWriter1.FileCreate(pName:=#szFileName[0]);
                  if retcode <> 0 then
                    HWC_LogPrintf(this, "@06D2 (FDD3000_FileHandling::ExportSDDDataXML) Failed to create File: '%s', retcode = %d ", #szFileName[0], #retcode);
                    SMExportXML := e_SMExportXML::_Error;
                  end_if;
                  
    e_SMExportXML::_Wait4File:
      
                  if (_XMLWriter1.XmlState = _XMLWriter::_XML_CREATED) then
                    SMExportXML := e_SMExportXML::_WriteData;
                  elsif (_XMLWriter1.xmlstate = _XMLWriter::_XML_ERROR) then
                    HWC_LogPrintf(this, "@06D2 (FDD3000_FileHandling::ExportSDDDataXML) Failed to create File: '%s' ", #szFileName[0]);
                    SMExportXML := e_SMExportXML::_Error;
                  end_if;
                  
    e_SMExportXML::_WriteData:
    
                  // Write xml Header  ***********************************************
                  retcode := _XMLWriter1.WriteStartDocument(pEncoding:= STRING_ISO8859_1);
                  if retcode <> 0 then
                    HWC_LogPrintf(this, "@06D3 (FDD3000_FileHandling::ExportSDDDataXML) Call WriteStartDocument() failed with retcode = %d ", #retcode);
                    SMExportXML := e_SMExportXML::_Error;
                    return;
                  end_if;
                  
                  // Write <Drive DriveType="DiasDrive">  ***********************************************
                  retcode := _XMLWriter1.WriteStartElement(pName:=_FDD3000_FH_STR_DRIVE);
                  if retcode <> 0 then
                    HWC_LogPrintf(this, "@06D3 (FDD3000_FileHandling::ExportSDDDataXML) Call WriteStartElement() failed with retcode = %d ", #retcode);
                    SMExportXML := e_SMExportXML::_Error;
                    return;
                  end_if;
                  
                  GetDriveTypeStr(eDriveType:=pData^.sHeader.DriveType, pDriveTypeStr:=#szNr[0]);
                  retcode := _XMLWriter1.WriteAttributeString(pName:="DriveType", pValue:=#szNr[0]);
                  if retcode <> 0 then
                    HWC_LogPrintf(this, "@06D3 (FDD3000_FileHandling::ExportSDDDataXML) Call WriteAttributeString() failed with retcode = %d ", #retcode);
                    SMExportXML := e_SMExportXML::_Error;
                    return;
                  end_if;
                  
                  // Write <Params>  ***********************************************
                  retcode := _XMLWriter1.WriteStartElement(pName:=_FDD3000_FH_STR_PARAMS);
                  if retcode <> 0 then
                    HWC_LogPrintf(this, "@06D3 (FDD3000_FileHandling::ExportSDDDataXML) Call WriteStartElement() failed with retcode = %d ", #retcode);
                    SMExportXML := e_SMExportXML::_Error;
                    return;
                  end_if;
                  
                  // Loop over all Parameters ***********************************************
                  i := 0;
                  pHlp := (pData + pData^.sHeader.AxOffset)$^ts_OneParameter;
                  while (i < pData^.sHeader.AxLength) do
                  
                    // Write next Param ***********************************************
                    retcode := _XMLWriter1.WriteStartElement(pName:=_FDD3000_FH_STR_PARAM);
                    if retcode <> 0 then
                      HWC_LogPrintf(this, "@06D3 (FDD3000_FileHandling::ExportSDDDataXML) Call WriteStartElement() failed with retcode = %d ", #retcode);
                      SMExportXML := e_SMExportXML::_Error;
                      return;
                    end_if;
                    
                    // Write Index ***********************************************
                    szNr[0] := '0';
                    szNr[1] := 'x';
                    sigclib_itoa(val:=pHlp^.hiIndex, dst:=#szNr[2], base:=16);
                                        
                    retcode := _XMLWriter1.WriteAttributeString(pName:=_FDD3000_FH_STR_INDEX, pValue:=#szNr[0]);
                    if retcode <> 0 then
                      HWC_LogPrintf(this, "@06D3 (FDD3000_FileHandling::ExportSDDDataXML) Call WriteAttributeString() Id failed with retcode = %d ", #retcode);
                      SMExportXML := e_SMExportXML::_Error;
                      return;
                    end_if;
                    
                    // Write Subindex ***********************************************
                    sigclib_itoa(val:=pHlp^.usSubIndex, dst:=#szNr[0], base:=10);
                                        
                    retcode := _XMLWriter1.WriteAttributeString(pName:=_FDD3000_FH_STR_SUBINDEX, pValue:=#szNr[0]);
                    if retcode <> 0 then
                      HWC_LogPrintf(this, "@06D3 (FDD3000_FileHandling::ExportSDDDataXML) Call WriteAttributeString() Id failed with retcode = %d ", #retcode);
                      SMExportXML := e_SMExportXML::_Error;
                      return;
                    end_if;
                                        
                    // Write Length ***********************************************
                    sigclib_itoa(val:=pHlp^.usLength, dst:=#szNr[0], base:=10);
                                        
                    retcode := _XMLWriter1.WriteAttributeString(pName:=_FDD3000_FH_STR_LENGTH, pValue:=#szNr[0]);
                    if retcode <> 0 then
                      HWC_LogPrintf(this, "@06D3 (FDD3000_FileHandling::ExportSDDDataXML) Call WriteAttributeString() Id failed with retcode = %d ", #retcode);
                      SMExportXML := e_SMExportXML::_Error;
                      return;
                    end_if;
                                        
                    // Write RW ***********************************************
                    sigclib_itoa(val:=pHlp^.usRW, dst:=#szNr[0], base:=10);
                                        
                    retcode := _XMLWriter1.WriteAttributeString(pName:=_FDD3000_FH_STR_RW, pValue:=#szNr[0]);
                    if retcode <> 0 then
                      HWC_LogPrintf(this, "@06D3 (FDD3000_FileHandling::ExportSDDDataXML) Call WriteAttributeString() Id failed with retcode = %d ", #retcode);
                      SMExportXML := e_SMExportXML::_Error;
                      return;
                    end_if;
                                                            
                    // Write Mode ***********************************************
                    sigclib_itoa(val:=pHlp^.usMode, dst:=#szNr[0], base:=10);
                                        
                    retcode := _XMLWriter1.WriteAttributeString(pName:=_FDD3000_FH_STR_MODE, pValue:=#szNr[0]);
                    if retcode <> 0 then
                      HWC_LogPrintf(this, "@06D3 (FDD3000_FileHandling::ExportSDDDataXML) Call WriteAttributeString() Id failed with retcode = %d ", #retcode);
                      SMExportXML := e_SMExportXML::_Error;
                      return;
                    end_if;            
                    
                    // Write Data ***********************************************
                    sigclib_itoa(val:=pHlp^.dData, dst:=#szNr[0], base:=10);
                                        
                    retcode := _XMLWriter1.WriteAttributeString(pName:=_FDD3000_FH_STR_DATA, pValue:=#szNr[0]);
                    if retcode <> 0 then
                      HWC_LogPrintf(this, "@06D3 (FDD3000_FileHandling::ExportSDDDataXML) Call WriteAttributeString() Id failed with retcode = %d ", #retcode);
                      SMExportXML := e_SMExportXML::_Error;
                      return;
                    end_if;
                                        
                    // Done Write Param ***********************************************
                    retcode := _XMLWriter1.WriteEndElement(); // _DRIVEFH_STR_PARAM
                    if retcode <> 0 then
                      HWC_LogPrintf(this, "@06D3 (FDD3000_FileHandling::ExportSDDDataXML) Call WriteEndElement() failed with retcode = %d ", #retcode);
                      SMExportXML := e_SMExportXML::_Error;
                      return;
                    end_if;
                    
                    //next parameter
                    pHlp += sizeof(ts_OneParameter);
                    i    += 1;
                    
                  end_while;
                  
                  // Write </Params>  ***********************************************
                  retcode := _XMLWriter1.WriteEndElement(); // _DRIVEFH_STR_PARAMS
                  if retcode <> 0 then
                    HWC_LogPrintf(this, "@06D3 (FDD3000_FileHandling::ExportSDDDataXML) Call WriteEndElement() failed with retcode = %d ", #retcode);
                    SMExportXML := e_SMExportXML::_Error;
                    return;
                  end_if;
                  
                  // Write </Drive>  ***********************************************
                  retcode := _XMLWriter1.WriteEndElement(); // _FDD3000_FH_STR_DRIVE
                  if retcode <> 0 then
                    HWC_LogPrintf(this, "@06D3 (FDD3000_FileHandling::ExportSDDDataXML) Call WriteEndElement() failed with retcode = %d ", #retcode);
                    SMExportXML := e_SMExportXML::_Error;
                    return;
                  end_if;
                  
                  // WriteEndDocument ***********************************************
                  retcode := _XMLWriter1.WriteEndDocument();
                  if retcode <> 0 then
                    HWC_LogPrintf(this, "@06D3 (FDD3000_FileHandling::ExportSDDDataXML) Call WriteEndDocument() failed with retcode = %d ", #retcode);
                    SMExportXML := e_SMExportXML::_Error;
                    return;
                  end_if;
                  
                  // Export data to file ***********************************************
                  retcode := _XMLWriter1.Flush();
                  if retcode <> 0 then
                    HWC_LogPrintf(this, "@06D3 (FDD3000_FileHandling::ExportSDDDataXML) Call Flush() failed with retcode = %d ", #retcode);
                    SMExportXML := e_SMExportXML::_Error;
                    return;
                  end_if;
                  
                  // Close File ***********************************************
                  retcode := _XMLWriter1.FileClose();
                  if retcode <> 0 then
                    HWC_LogPrintf(this, "@06D3 (FDD3000_FileHandling::ExportSDDDataXML) Call FileClose() failed with retcode = %d ", #retcode);
                    SMExportXML := e_SMExportXML::_Error;
                    return;
                  end_if;
                  
                  if pData^.sHeader.bsFileSelect.FileGeneral then
                    SMExportXML := e_SMExportXML::_WriteGeneralData;
                  else
                    //file write is finished
                    retstate := READY;
                  end_if;
                  
    e_SMExportXML::_WriteGeneralData:
    
      
                  if (_XMLWriter1.XmlState = _XMLWriter::_XML_CLOSED)
                  | (_XMLWriter1.XmlState = _XMLWriter::_XML_IDLE) then
                  
                    //copy file to general name if used for more axes
                    _strcpy(#namebuffer[0], "C:\");
                    _strcpy(#namebuffer[_strlen(#namebuffer$CHAR)], _FDD3000_FH_STR_FILENAME_GENERAL);
                    _strcpy(#namebuffer[_strlen(#namebuffer$CHAR)], ".xml"); //here the extention will be added
                                      
                    retcode := coFileSys.FileCopy(pSource:=#szFileName[0], pDest:=#namebuffer[0], udOption:=0);
                    if retcode <> 0 then
                      HWC_LogPrintf(this, "@06D2 (FDD3000_FileHandling::ExportSDDDataXML) Failed to create File: '%s', retcode = %d ", #namebuffer[0], #retcode);
                      SMExportXML := e_SMExportXML::_Error;
                    end_if;
                    
                    bDefaultName := FALSE;
                    szFileName[0] := 0;     // Clear Filename if not set be user to prevent mixing .lda and .xls extensions 
                                     
                    //file write is finished
                    retstate := READY;
                  elsif (_XMLWriter1.xmlstate = _XMLWriter::_XML_ERROR) then
                    HWC_LogPrintf(this, "@06D2 (FDD3000_FileHandling::ExportSDDDataXML) Failed to create File: '%s' ", #szFileName[0]);
                    SMExportXML := e_SMExportXML::_Error;
                  end_if;
    
    e_SMExportXML::_Error:
                  
                  retstate := ERROR;
                  
                  if bDefaultName then
                    bDefaultName := FALSE;
                    szFileName[0] := 0;     // Clear Filename if not set be user to prevent mixing .lda and .xls extensions 
                  end_if;
                  
                  if _XMLWriter1.XmlState = _XMLWriter::_XML_ERROR then
                    _XMLWriter1.Reset();
                    retstate := BUSY;
                  end_if;
  end_case;

END_FUNCTION


FUNCTION VIRTUAL FDD3000_FileHandling::ImportSDDDataXML
	VAR_INPUT
		pData 	: ^ts_ParaFile;
	END_VAR
	VAR_OUTPUT
		retstate 	: iprStates;
	END_VAR
  VAR
    namebuffer      : ARRAY[0..99] of CHAR;
    pElementDrive   : ^_XML_ELEMENT;
    pElementParams  : ^_XML_ELEMENT;
    pElementParam   : ^_XML_ELEMENT;
    i               : DINT;
    dTemp           : DINT;
    pHlp            : ^ts_OneParameter;
    pAttribute      : ^_XML_ATTRIBUTE;
  END_VAR
  
  // Default return values
  retstate := BUSY;

#ifdef _DBGFDD3000_FileHandling
  HWC_LogPrintf(this, "@DBG: ImportSDDDataXML Called in step: %u", #SMImportXML);
#endif

  case SMImportXML of
    e_SMImportXML::_Start,
    e_SMImportXML::_AllocBuffer:
                 
                  pBufferSDDData$^void := sigclib_malloc(size:=sizeof(ts_ParaFile));
                  
                  if pBufferSDDData = nil then
                    HWC_LogPrintf(this, "@06D4 (FDD3000_FileHandling::ImportSDDDataXML) Failed to allocate memory for parameter buffer");
                    SMImportXML := e_SMImportXML::_Error;
                    return;
                  end_if;
                  
                  // See _DriveAxisBase::InitSDDHeader
                  pBufferSDDData^.sHeader.udCRC32   := 0;
                  pBufferSDDData^.sHeader.udLen     := sizeof(ts_ParaFileHeader);
                  pBufferSDDData^.sHeader.udVersion := 1;
                  pBufferSDDData^.sHeader.AxOffset  := sizeof(ts_ParaFileHeader);
                  pBufferSDDData^.sHeader.AxLength  := 0;
                  sigclib_strcpy(dst0 := #pBufferSDDData^.sHeader.AxName[0], src0:=#pSDDData^.sHeader.AxName[0]); // Keep Axname
                  
                  if pData^.sHeader.bsFileSelect.FileGeneral then
                    SMImportXML := e_SMImportXML::_OpenFileGeneral;
                  else
                   SMImportXML := e_SMImportXML::_OpenFile;
                  end_if;
                  
    
    e_SMImportXML::_OpenFile:
                  
                  if szFileName[0] = 0 then
                    bDefaultName := TRUE;
                    _strcpy(#namebuffer[0], _FDD3000_FH_STR_FILENAME);
                    _strcpy(#namebuffer[_strlen(#namebuffer$CHAR)], #pData^.sHeader.AxName[0]);
                    _strcpy(#namebuffer[_strlen(#namebuffer$CHAR)], ".xml"); //here the extention will be added
                    SetFileName(#namebuffer[0], "C:\"); // this is for giving the file the name of the axleobject
                  end_if;
                  
                  SMImportXML := e_SMImportXML::_Wait4File;
                  
                  if (_XMLReader1.ReadFile(FileName:=#szFileName[0]) = FALSE ) then
                    HWC_LogPrintf(this, "@06D5 (FDD3000_FileHandling::ImportSDDDataXML) Failed to open File: '%s' ", #szFileName[0]);
                    SMImportXML := e_SMImportXML::_Error;
                  end_if;
    
    e_SMImportXML::_Wait4File:
    
                  if (_XMLReader1.xmlstate = XML_READ_STATE::_STRUCT_CREATED) then
                    SMImportXML := e_SMImportXML::_ReadFile;
                  elsif (_XMLReader1.xmlstate = XML_READ_STATE::_ERROR) then
                    if _XMLReader1.ErrorState = _PARSE_ERR_NONE then                    
                      HWC_LogPrintf(this, "@06D5 (FDD3000_FileHandling::ImportSDDDataXML) Failed to open File: '%s' ", #szFileName[0]);
                    else
                      HWC_LogPrintf(this, "@06D5 (FDD3000_FileHandling::ImportSDDDataXML) Failed to open File: '%s', ... ", #szFileName[0]);
                      HWC_LogPrintf(this, "... _XMLReader.ErrorState = %u, _XMLReader.ErrorLine = %d ", #_XMLReader1.ErrorState.dData, #_XMLReader1.ErrorLine.dData);

                    end_if;
                    SMImportXML := e_SMImportXML::_Error;
                  end_if;    
    
    e_SMImportXML::_OpenFileGeneral:
                
                  //check for general file
                  _strcpy(#namebuffer[0], "C:\");
                  _strcpy(#namebuffer[_strlen(#namebuffer$CHAR)], _FDD3000_FH_STR_FILENAME_GENERAL);
                  _strcpy(#namebuffer[_strlen(#namebuffer$CHAR)], ".xml"); //here the extention will be added
                      
                
                  SMImportXML := e_SMImportXML::_Wait4FileGeneral;
                  
                  if (_XMLReader1.ReadFile(FileName:=#namebuffer[0]) = FALSE ) then
                    HWC_LogPrintf(this, "@06D5 (FDD3000_FileHandling::ImportSDDDataXML) Failed to open File: '%s' ", #namebuffer[0]);
                    SMImportXML := e_SMImportXML::_Error;
                  end_if;
    
    e_SMImportXML::_Wait4FileGeneral:
    
                  if (_XMLReader1.xmlstate = XML_READ_STATE::_STRUCT_CREATED) then
                    SMImportXML := e_SMImportXML::_ReadFile;
                  elsif (_XMLReader1.xmlstate = XML_READ_STATE::_ERROR) then
                    if _XMLReader1.ErrorState = _PARSE_ERR_NONE then
                      HWC_LogPrintf(this, "@06D5 (FDD3000_FileHandling::ImportSDDDataXML) Failed to open File: '%s' ", #szFileName[0]);
                    else
                      HWC_LogPrintf(this, "@06D5 (FDD3000_FileHandling::ImportSDDDataXML) Failed to open File: '%s', ... ", #szFileName[0]);
                      HWC_LogPrintf(this, "... _XMLReader.ErrorState = %u, _XMLReader.ErrorLine = %d ", #_XMLReader1.ErrorState.dData, #_XMLReader1.ErrorLine.dData);

                    end_if;
                    
                    SMImportXML := e_SMImportXML::_Error;
                  end_if;
                  
    e_SMImportXML::_ReadFile:
                  
                  // Check <Drive>  ***********************************************
                  pElementDrive := _XMLReader1.GetElementByName(_FDD3000_FH_STR_DRIVE);
                  if pElementDrive = nil then
                    HWC_LogPrintf(this, "@06D7 (FDD3000_FileHandling::ImportSDDDataXML) Error parsing '%s', Failed to find element: 'Drive'", #szFileName[0]);
                    SMImportXML := e_SMImportXML::_Error;
                    return;
                  end_if;
    
                  // Check <Params>  ***********************************************
                  pElementParams := _XMLReader1.GetChildByName(pParent:=pElementDrive, pName:=_FDD3000_FH_STR_PARAMS);
                  if pElementParams = nil then
                    HWC_LogPrintf(this, "@06D7 (FDD3000_FileHandling::ImportSDDDataXML) Error parsing '%s', Failed to find element: 'Params'", #szFileName[0]);
                    SMImportXML := e_SMImportXML::_Error;
                    return;
                  end_if;

                  // Check <Param>  ***********************************************
                  pElementParam := _XMLReader1.GetChildByName(pParent:=pElementParams, pName:=_FDD3000_FH_STR_PARAM);
                  if pElementParam = nil then
                    HWC_LogPrintf(this, "@06D7 (FDD3000_FileHandling::ImportSDDDataXML) Error parsing '%s', Failed to find element: 'Param'", #szFileName[0]);
                    SMImportXML := e_SMImportXML::_Error;
                    return;
                  end_if;
                  
                  //get pointer to read entry                  
                  pHlp := (pBufferSDDData + pBufferSDDData^.sHeader.AxOffset)$^ts_OneParameter;
                  i    := 0;
                  
                  while (pElementParam) & 
                        ( (pBufferSDDData^.sHeader.udLen + sizeof(ts_OneParameter)) < sizeof(ts_ParaFile)) do                  
                    
                    // Check no of Attributes ***********************************************
                    if pElementParam^.Attributes.no <> 6 then
                      HWC_LogPrintf(this, "@06D7 (FDD3000_FileHandling::ImportSDDDataXML) Error parsing '%s', Param No: %d, Wrong no of Attributes: %u", #szFileName[0], #i, #pElementParam^.Attributes.no);
                      SMImportXML := e_SMImportXML::_Error;
                      return;
                    end_if;
                    
                    
                    //******************************************************************************************************************
                    //******************************************************************************************************************
                    i += 1;
                    // Check if Attribute _FDD3000_FH_STR_INDEX exists ***********************************************
                    pAttribute := pElementParam^.Attributes.pList;
                    if (sigclib_strcmp(ps1:=_FDD3000_FH_STR_INDEX, ps2:=pAttribute^.Name) <> 0) then
                      HWC_LogPrintf(this, "@06D7 (FDD3000_FileHandling::ImportSDDDataXML) Error parsing '%s', Param No: %d, Attribute 'Id' is missing", #szFileName[0], #i);
                      SMImportXML := e_SMImportXML::_Error;
                      return;
                    end_if;

                    // get Attribute _FDD3000_FH_STR_INDEX  ***********************************************
                    dTemp := ConvStr2DINT(pStr:=pAttribute^.Value);
                    pHlp^.hiIndex := dTemp$HINT;  // Convert ID to 1BYte
                    
                    //******************************************************************************************************************
                    //******************************************************************************************************************
                    i += 1;
                    // Check if Attribute _FDD3000_FH_STR_SUBINDEX exists ***********************************************
                    pAttribute += sizeof(_XML_ATTRIBUTE);
                    if (sigclib_strcmp(ps1:=_FDD3000_FH_STR_SUBINDEX, ps2:=pAttribute^.Name) <> 0) then
                      HWC_LogPrintf(this, "@06D7 (FDD3000_FileHandling::ImportSDDDataXML) Error parsing '%s', Param No: %d, Attribute 'Id' is missing", #szFileName[0], #i);
                      SMImportXML := e_SMImportXML::_Error;
                      return;
                    end_if;

                    // get Attribute _FDD3000_FH_STR_SUBINDEX  ***********************************************
                    dTemp := sigclib_atoi(s:=pAttribute^.Value);
                    pHlp^.usSubIndex := dTemp$USINT;  // Convert ID to 1BYte
                    
                    
                    //******************************************************************************************************************
                    //******************************************************************************************************************
                    i += 1;
                    // Check if Attribute _FDD3000_FH_STR_LENGTH exists ***********************************************
                    pAttribute += sizeof(_XML_ATTRIBUTE);
                    if (sigclib_strcmp(ps1:=_FDD3000_FH_STR_LENGTH, ps2:=pAttribute^.Name) <> 0) then
                      HWC_LogPrintf(this, "@06D7 (FDD3000_FileHandling::ImportSDDDataXML) Error parsing '%s', Param No: %d, Attribute 'Id' is missing", #szFileName[0], #i);
                      SMImportXML := e_SMImportXML::_Error;
                      return;
                    end_if;

                    // get Attribute _FDD3000_FH_STR_LENGTH  ***********************************************
                    dTemp := sigclib_atoi(s:=pAttribute^.Value);
                    pHlp^.usLength := dTemp$USINT;  // Convert ID to 1BYte
                    
                    
                    //******************************************************************************************************************
                    //******************************************************************************************************************
                    i += 1;
                    // Check if Attribute _FDD3000_FH_STR_RW exists ***********************************************
                    pAttribute += sizeof(_XML_ATTRIBUTE);
                    if (sigclib_strcmp(ps1:=_FDD3000_FH_STR_RW, ps2:=pAttribute^.Name) <> 0) then
                      HWC_LogPrintf(this, "@06D7 (FDD3000_FileHandling::ImportSDDDataXML) Error parsing '%s', Param No: %d, Attribute 'Id' is missing", #szFileName[0], #i);
                      SMImportXML := e_SMImportXML::_Error;
                      return;
                    end_if;

                    // get Attribute _FDD3000_FH_STR_RW  ***********************************************
                    dTemp := sigclib_atoi(s:=pAttribute^.Value);
                    pHlp^.usRW := dTemp$USINT;  // Convert ID to 1BYte
                    
                    
                    //******************************************************************************************************************
                    //******************************************************************************************************************
                    i += 1;
                    // Check if Attribute _FDD3000_FH_STR_MODE exists ***********************************************
                    pAttribute += sizeof(_XML_ATTRIBUTE);
                    if (sigclib_strcmp(ps1:=_FDD3000_FH_STR_MODE, ps2:=pAttribute^.Name) <> 0) then
                      HWC_LogPrintf(this, "@06D7 (FDD3000_FileHandling::ImportSDDDataXML) Error parsing '%s', Param No: %d, Attribute 'Id' is missing", #szFileName[0], #i);
                      SMImportXML := e_SMImportXML::_Error;
                      return;
                    end_if;

                    // get Attribute _FDD3000_FH_STR_MODE  ***********************************************
                    dTemp := sigclib_atoi(s:=pAttribute^.Value);
                    pHlp^.usMode := dTemp$USINT;  // Convert ID to 1BYte
                    
                    
                    //******************************************************************************************************************
                    //******************************************************************************************************************
                    i += 1;
                    // Check if Attribute _FDD3000_FH_STR_DATA exists ***********************************************
                    pAttribute += sizeof(_XML_ATTRIBUTE);
                    if (sigclib_strcmp(ps1:=_FDD3000_FH_STR_DATA, ps2:=pAttribute^.Name) <> 0) then
                      HWC_LogPrintf(this, "@06D7 (FDD3000_FileHandling::ImportSDDDataXML) Error parsing '%s', Param No: %d, Attribute 'Id' is missing", #szFileName[0], #i);
                      SMImportXML := e_SMImportXML::_Error;
                      return;
                    end_if;

                    // get Attribute _FDD3000_FH_STR_DATA  ***********************************************
                    dTemp := sigclib_atoi(s:=pAttribute^.Value);
                    pHlp^.dData := dTemp;  // Convert ID to 1BYte
                    
                    
                    //******************************************************************************************************************
                    //******************************************************************************************************************
                    pHlp            += sizeof(ts_OneParameter);                  
                    pElementParam   := pElementParam^.pNext;
                    
                    pBufferSDDData^.sHeader.udLen     += sizeof(ts_OneParameter);
                    pBufferSDDData^.sHeader.AxLength  += 1;
                  end_while;
                  
                  SMImportXML := e_SMImportXML::_CpyParam;
    
    e_SMImportXML::_CpyParam:
    
#ifdef _DBGFDD3000_FileHandling
                  if pBufferSDDData^.AxLength = pSDDData^.AxLength then
                  
                    if sigclib_memcmp(m1:=pBufferSDDData + pBufferSDDData^.AxOffset
                                    , m2:=pSDDData       + pSDDData^.AxOffset, len := pBufferSDDData^.AxLength) = 0 then
                      HWC_LogPrintf(this, "@DBG: ImportSDDDataXML Read data equal existing data");
                    else
                      HWC_LogPrintf(this, "@DBG: ImportSDDDataXML Read data not equal existing data");
                    end_if;

                  else
                    HWC_LogPrintf(this, "@DBG: ImportSDDDataXML Read data length not equal existing data length");
                  end_if;
#endif                  
                  
                  // Copy valid read xml data to passed pointer (crc has to be updated outside
                  sigclib_memcpy(dst0:=pSDDData, src0:=pBufferSDDData, len0:=pBufferSDDData^.sHeader.udLen);

                  // Free mem
                  sigclib_free(ptr:=pBufferSDDData);
                  _XMLReader1.FreeReader();
                  
                  if bDefaultName then
                    bDefaultName := FALSE;
                    szFileName[0] := 0;     // Clear Filename if not set be user to prevent mixing .lda and .xls extensions 
                  end_if;
                  
                  retstate := READY;
    
    e_SMImportXML::_Error:
    
                  retstate := ERROR;
                  
                  if bDefaultName then
                    bDefaultName := FALSE;
                    szFileName[0] := 0;     // Clear Filename if not set be user to prevent mixing .lda and .xls extensions 
                  end_if;
                  
                  if pBufferSDDData then
                    sigclib_free(ptr:=pBufferSDDData);
                  end_if;
                  
                  if _XMLReader1.XmlState <> _XMLReader::_READY then
                    _XMLReader1.FreeReader();
                    retstate := BUSY;
                  end_if;
                  
  end_case;
  
END_FUNCTION


FUNCTION VIRTUAL FDD3000_FileHandling::GetDriveTypeStr
	VAR_INPUT
		eDriveType 	: e_DriveType;
		pDriveTypeStr 	: ^CHAR;
	END_VAR
  
  if pDriveTypeStr then
    case eDriveType of
      e_DriveType::_NotFound:
        sigclib_strcpy(dst0:=pDriveTypeStr, src0:="Unknown");
      e_DriveType::_FDD3000_CAN:
        sigclib_strcpy(dst0:=pDriveTypeStr, src0:="FDD3000_CanOpen");
      e_DriveType::_FDD3000_EtherCAT:
        sigclib_strcpy(dst0:=pDriveTypeStr, src0:="FDD3000_EtherCAT");
      e_DriveType::_FDD3000_VARAN:
        sigclib_strcpy(dst0:=pDriveTypeStr, src0:="FDD3000_VARAN");
    else
      sigclib_strcpy(dst0:=pDriveTypeStr, src0:="Unknown");    
    end_case;  
  end_if;
  
END_FUNCTION  


FUNCTION VIRTUAL FDD3000_FileHandling::ConvStr2DINT
	VAR_INPUT
		pStr 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		retval 	: DINT;
	END_VAR
  VAR
  	pChar1 : ^Char;
    pChar2 : ^Char;
    pChar3 : ^Char;
  END_VAR
  
  retval := 0;

  pChar1 := pStr;
  
  while ((pChar1^ = ' ') | (pChar1^ = 9)) do  // Remove Tab and spaces
    pChar1 += 1;
    
    if pChar1^ = 0 then  // End of string
      return;
    end_if;

  end_while;
  
  pChar2 := pChar1 + 1;
  pChar3 := pChar2 + 1;
  
  // Hex 0x.., , 0X...
  if (pChar1^ = '0' & (pChar2^ = 'x' | pChar2^ = 'X')) then
    retval := sigclib_strtol(nptr:=pChar3, endptr:=nil,16);
    return;
  end_if;
  
  // Hex 16#..,
  if pChar1^ = '1' & pChar2^ = '6' & pChar3^ = '#' then
    pChar3 += 1;
    retval := sigclib_strtol(nptr:=pChar3, endptr:=nil,16);
    return;
  end_if;
  
  // Bin 2#...
  if (pChar1^ = '2' & pChar2^ = '#') then
    retval := sigclib_strtol(nptr:=pChar3, endptr:=nil,2);
    return;
  end_if;
  
  // Bin b... , B...
  if (pChar1^ = 'b' | pChar1^ = 'B') &
     (pChar2^ = '0' | pChar2^ = '1') then
    retval := sigclib_strtol(nptr:=pChar2, endptr:=nil,2);
    return;
  end_if;
  
  // Dez
  retval := sigclib_strtol(nptr:=pChar1, endptr:=nil,10);
  
END_FUNCTION