//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
// maximum number of multiple RW-DOs to manage by one object of this class
#define MAX_MULTIPLE_DO_NUMBER      8
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "Varan_Multiple_ReadWrite"
	Revision           = "1.22"
	GUID               = "{6066CC82-4B9A-4DB0-B565-F413A36002BB}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\Varan_16x16.ico"
	SharedCommandTable = "true"
	Objectsize         = "(546,120)"
	Comment            = "This class is used to get faster access on VARAN modules, which support the multiple read/write command (e.g. VDM085, VDM086)">
	<Channels>
		<Server Name="NewConfig" GUID="{FF243CDC-6CF5-4079-944C-4D6CE84A1A41}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="This server registers when a new configuration is available"/>
		<Server Name="Online" GUID="{E6514D1E-3782-4921-8DC3-09D78FA9D2F6}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="This server is set as soon as the hardware class is operating normally"/>
		<Server Name="Restart" GUID="{38DF799C-C582-4EBD-BA65-A2FDCD4FD4C6}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Writing to this server triggers a reconfiguration. This process is required after a module is connected or disconnected."/>
		<Server Name="RetryCounter" GUID="{EEAFD107-64F2-4203-AA50-CB4364B609A8}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="This server shows all retries of this hardware module."/>
		<Server Name="State" GUID="{F61A2B3B-061B-4A1A-AB1E-C10B5861E3CA}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="This Server shows the state of the Modul"/>
		<Client Name="To_StdLib" Required="false" Internal="false" Comment="This client is automatically connected to the _StdLib OS interface class."/>
		<Client Name="To_VaranManager" Required="true" Internal="false" Comment="This client must be connected directly to the VaranManager_[x]."/>
		<Client Name="UserAction" Required="false" Internal="false" Comment="optional, connect to server to get Varan states via write method.&#13;&#10;possible input values:&#13;&#10; 0..connect&#13;&#10; 1..disconnect&#13;&#10; 2..required data object error&#13;&#10; 3..not required data object error&#13;&#10; 4..fatal error&#13;&#10; 5..time slice error&#13;&#10; 6..watchdog error&#13;&#10; 7..client irq&#13;&#10; 8..device enable&#13;&#10; 9..device disable&#13;&#10;10..irq task interrupt&#13;&#10;&#13;&#10;Possible return values:&#13;&#10; true.. VaranError&#13;&#10;false.. Varan_OK"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="renste"/>
		<Dokumentation Revision="1.22" Date="16.03.2018" Author="EisMic" Company="Sigmatek" Description="Class checks now for a correct varan managernumber in the method AddParticipant."/>
		<Dokumentation Revision="1.21" Date="19.06.2015" Author="RamAnd" Company="Sigmatek" Description="Added watchdog triggering for VARAN clients if the restart functionality is used. Before it hasn&apos;t been possible to reactivate the participants."/>
		<Dokumentation Revision="1.20" Date="04.12.2013" Author="LanSte&#13;&#10;FucHer" Company="Sigmatek" Description="Added payload support&#13;&#10;Changed AWL code to Structured Text."/>
		<Dokumentation Revision="1.10" Date="05.11.2012" Author="RamAnd" Company="Sigmatek" Description="Removed resetting of the FPGA retry counter in method ResetDataObject which could result in a wrong behavior of the RetryCounter server."/>
		<Dokumentation Revision="1.4" Date="03.03.2011" Author="RamAnd" Company="Sigmatek" Description="Added possibility to make more than 1 (up to 8) multiple read write accesses per module."/>
		<Dokumentation Revision="1.3" Date="13.07.2009" Author="armluk" Company="Sigmatek" Description="Added and improved Server/Client comments"/>
		<Dokumentation Revision="1.2" Date="18.06.2009" Author="EbnAnt" Company="Sigmatek" Description="Added the Client UserAction and Insert into the Varan_CallBack() the UserAction-Function.&#13;&#10;And insert IsUserActionConnected() to check if UserACtion is connected"/>
	</RevDoku>
</Class>
*)
Varan_Multiple_ReadWrite : CLASS
	TYPE
	  p_VaranBase : ^Varan_Base;
	  t_CySSW :
	  (
	    __Sort,
	    __Wait4Watchdog,
	    __ConfigDevices,
	    __DetermineResponseTime,
	    __Wait4Response,
	    __StartDO
	  )$UDINT;
#pragma pack(push, 1)
	  t_DOSettings : STRUCT
	    us_Cmd : USINT;
	    us_Filter : USINT;
	    us_Slices : USINT;
	    ud_AddressRead : UDINT;
	    us_ByteCntRead : USINT;
	    ud_AddressWrite : UDINT;
	    us_ByteCntWrite : USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_DO_Structure : STRUCT
	    ud_OffsetRead : UDINT;
	    ud_OffsetWrite : UDINT;
	    ui_LengthRead : UINT;
	    ui_LengthWrite : UINT;
	    ud_DolType : UDINT;
	    sd_IsRequired : DINT;
	    p_Handle : ^LSL_VARANFRAME;
	    p_DOSettings : ^t_DOSettings;
	    p_DataRead : ^UDINT;
	    p_DataWrite : ^UDINT;
	    us_OldRetryCounter : USINT;
	    b_SSWStepFinished : BOOL;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_MultipleData : STRUCT
	    us_Number : USINT;
	    us_State : USINT;
	    p_Node : ^USINT;
	    p_this : p_VaranBase;
	  END_STRUCT;
#pragma pack(pop)
	  t_MultipleDataArray : ARRAY [0..127] OF t_MultipleData;
	  t_VirtualNode : STRUCT
	    us_Length : USINT;
	    us_Byte1 : USINT;
	    us_Byte2 : USINT;
	  END_STRUCT;
	END_TYPE
  //Servers:
	State 	: SvrChCmd_t_e_VaranErrors;
	Online 	: SvrCh_DINT;
	Restart 	: SvrCh_DINT;
	NewConfig 	: SvrCh_DINT;
	RetryCounter 	: SvrCh_UDINT;
  //Clients:
	To_VaranManager 	: CltChCmd_VaranManager;
	To_StdLib 	: CltChCmd__StdLib;
	UserAction 	: CltCh_DINT;
  //Variables:
		us_Firstscan 	: USINT;
		us_MulticastFilter 	: USINT;
		s_VaranPosition 	: t_VirtualNode;
		ui_MaxNumberOfParticipants 	: UINT;
		ui_ActualNumberOfParticipants 	: UINT;
		ui_CalledParticipants 	: UINT;
		p_ParticipantInfo 	: ^t_MultipleDataArray;
		e_CySSW 	: t_CySSW;
		ud_SortTime 	: UDINT;
		ud_CallbackCounter 	: UDINT;
		GeneralIsRequired 	: DINT;
		ud_LastReason 	: UDINT;
		LastData 	: t_CallBackInterrupt;
		b_DistributeError 	: BOOL;
		aDOs : ARRAY [0..MAX_MULTIPLE_DO_NUMBER-1] OF t_DO_Structure;

		ActNumberOfDOs 	: UDINT;
		b_PayloadSupport 	: BOOL;
		ud_HandleModule 	: UDINT;
		pMultiVaran 	: ^LSL_MULTI_VARAN;
		ud_WatchdogTime 	: UDINT;
		ud_ManagerNumber 	: UDINT;
		pVaran 	: ^LSL_VARAN;
		bGotManagerNumber 	: BOOL;
  //Functions:
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Init for Varan class&#13;&#10;=================================================================================================&#13;&#10;[server] State       :W  :state of class&#13;&#10;[members] us_Firstscan     :R/W :variable to count init runs&#13;&#10;   us_MulticastFilter    :W  :multicast filter for multiple read/write command&#13;&#10;   p_VaranPosition     :R/W :node string for virtual callback&#13;&#10;   p_ParticipantInfo    :R  :pointer to participant info data&#13;&#10;   ui_MaxNumberOfParticipants  :R  :maximal listed participants (must not all activated (connected in real))&#13;&#10;   ud_DolType      :R  :DOL type of participants (isochron or asynchron)&#13;&#10;   ui_ActualNumberOfParticipants :R  :actual available participants&#13;&#10;   p_Handle      :W/R :pointer to data object header&#13;&#10;   ud_OffsetRead     :R  :offset of read data in memory area&#13;&#10;   ui_LengthRead     :R  :length of read data&#13;&#10;   p_DataRead      :R  :pointer to read data in dpram&#13;&#10;   ud_OffsetWrite     :R  :offset of write data in memory area&#13;&#10;   ui_LengthWrite     :R  :length of write data&#13;&#10;   p_DataWrite      :R  :pointer to write data in dpram&#13;&#10;   p_DOSettings     :W/R :pointer to command data in dpram&#13;&#10;[locals] sd_retval   :W/R :return value of called functions&#13;&#10;" Name="Init"/>
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="=================================================================================================&#13;&#10;Function to make new config for partisipants&#13;&#10;=================================================================================================&#13;&#10;" Name="CyWork"/>
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT := EAX;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to add a multiple read/write participant&#13;&#10;=================================================================================================&#13;&#10;" Name="AddParticipant"/>
	FUNCTION GLOBAL AddParticipant
		VAR_INPUT
			p_node 	: ^USINT;			//! <Variable Comment="pointer to node information" Name="AddParticipant.p_node"/>
			ud_offset_read 	: UDINT;			//! <Variable Comment="offset of read data" Name="AddParticipant.ud_offset_read"/>
			ui_length_read 	: UINT;			//! <Variable Comment="length of read data" Name="AddParticipant.ui_length_read"/>
			ud_offset_write 	: UDINT;			//! <Variable Comment="offset of write data" Name="AddParticipant.ud_offset_write"/>
			ui_length_write 	: UINT;			//! <Variable Comment="length of write data" Name="AddParticipant.ui_length_write"/>
			p_this 	: DINT;			//! <Variable Comment="thispointer of object" Name="AddParticipant.p_this"/>
			ud_dol_type 	: UDINT;			//! <Variable Comment="dol type of class" Name="AddParticipant.ud_dol_type"/>
			sd_required 	: DINT;			//! <Variable Comment="is class required or not" Name="AddParticipant.sd_required"/>
			pDOIndex 	: ^UDINT := NIL;
			udVaranManagerNumber 	: UDINT := 0;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;			//! <Variable Comment="0=ok, otherwise erorcode" Name="AddParticipant.sd_retval"/>
		END_VAR;
				//! <Function Comment="=================================================================================================&#13;&#10;Function to sort participants&#13;&#10;=================================================================================================&#13;&#10;" Name="SortParticipants"/>
	FUNCTION SortParticipants;
				//! <Function Comment="=================================================================================================&#13;&#10;Function compares two nodes&#13;&#10;=================================================================================================&#13;&#10;" Name="CompareNode"/>
	FUNCTION CompareNode
		VAR_INPUT
			p_first 	: ^USINT;
			p_second 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			b_first 	: BOOL;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to reset settings of a data object&#13;&#10;=================================================================================================&#13;&#10;[client] Required  :R  :is class required for varan or not&#13;&#10;[&gt;p_HandleDO]pointer to data object&#13;&#10;" Name="ResetDataObject"/>
	FUNCTION ResetDataObject
		VAR_INPUT
			p_handleDO 	: ^LSL_VARANFRAME;
			us_state 	: USINT;			//! <Variable Comment="0=not available, 1=available" Name="ResetDataObject.us_state"/>
			ud_bytes 	: UDINT;			//! <Variable Comment="number of bytes in DO" Name="ResetDataObject.ud_bytes"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function to set state of partisipants&#13;&#10;=================================================================================================&#13;&#10;" Name="SetStateOfParticipant"/>
	FUNCTION GLOBAL SetStateOfParticipant
		VAR_INPUT
			us_state 	: USINT;
			p_this 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function for callbacks&#13;&#10;=================================================================================================&#13;&#10;" Name="Varan_CallBack"/>
	FUNCTION GLOBAL Varan_CallBack
		VAR_INPUT
			ud_reason 	: UDINT;			//! <Variable Comment="reason of callback" Name="Varan_CallBack.ud_reason"/>
			ud_data 	: UDINT;			//! <Variable Comment="data of callback function" Name="Varan_CallBack.ud_data"/>
		END_VAR
		VAR_OUTPUT
			sd_retval (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL IsUserActionConnected
		VAR_OUTPUT
			ret_val 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Restart::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _StdLib
#pragma usingLtd VaranManager


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB Varan_Multiple_ReadWrite::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_VARAN_MULTIPLE_READWRITE
1$UINT, 22$UINT, (SIZEOF(::Varan_Multiple_ReadWrite))$UINT, 
5$UINT, 3$UINT, 0$UINT, 
TO_UDINT(2192462048), "Varan_Multiple_ReadWrite", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::Varan_Multiple_ReadWrite.State.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(1422331979), "State", 
(::Varan_Multiple_ReadWrite.Online.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1858763116), "Online", 
(::Varan_Multiple_ReadWrite.Restart.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3636255773), "Restart", 
(::Varan_Multiple_ReadWrite.NewConfig.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3806764754), "NewConfig", 
(::Varan_Multiple_ReadWrite.RetryCounter.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3383993698), "RetryCounter", 
//Clients:
(::Varan_Multiple_ReadWrite.To_VaranManager.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1047760645), "To_VaranManager", TO_UDINT(2940693151), "VaranManager", 3$UINT, 4$UINT, 
(::Varan_Multiple_ReadWrite.To_StdLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2139173287), "To_StdLib", TO_UDINT(3689364044), "_StdLib", 0$UINT, 0$UINT, 
(::Varan_Multiple_ReadWrite.UserAction.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(615089769), "UserAction", 
END_FUNCTION


#define USER_CNT_Varan_Multiple_ReadWrite 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_Varan_Multiple_ReadWrite] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION Varan_Multiple_ReadWrite::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_Varan_Multiple_ReadWrite, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
	State.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF State.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Restart.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Restart::Write() );
	IF Restart.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

#pragma usingLtd Varan_Base

//{{LSL_IMPLEMENTATION
#pragma using Varan_Base

(************************************************************************************
*
*	Class for Multiple Read/Write - access of varan modules
*	Created : Sigmatek	/	SR	/	Jän 2007
*	Changes : 
*
*
*     FOR NEWER CHANGES SEE REVISION DOCUMENTATION IN CLASS PROPERTIES
*
*		1.0 => 1.1	/	11.07.2007
*			- [DB 620]:	Insert function to update module retry counters
*
************************************************************************************)


#define	VARAN_MULTIPLE_DO_HEADER	16#D
#define VM_DO_OFFSET_MULTIPLE_RDWR	13

//[#ENGLISH]
//=================================================================================================
//Init for Varan class
//=================================================================================================
//[server]	State							:W		:state of class
//[members]	us_Firstscan					:R/W	:variable to count init runs
//			us_MulticastFilter				:W		:multicast filter for multiple read/write command
//			p_VaranPosition					:R/W	:node string for virtual callback
//			p_ParticipantInfo				:R		:pointer to participant info data
//			ui_MaxNumberOfParticipants		:R		:maximal listed participants (must not all activated (connected in real))
//			ud_DolType						:R		:DOL type of participants (isochron or asynchron)
//			ui_ActualNumberOfParticipants	:R		:actual available participants
//			p_Handle						:W/R	:pointer to data object header
//			ud_OffsetRead					:R		:offset of read data in memory area
//			ui_LengthRead					:R		:length of read data
//			p_DataRead						:R		:pointer to read data in dpram
//			ud_OffsetWrite					:R		:offset of write data in memory area
//			ui_LengthWrite					:R		:length of write data
//			p_DataWrite						:R		:pointer to write data in dpram
//			p_DOSettings					:W/R	:pointer to command data in dpram
//[locals]	sd_retval			:W/R	:return value of called functions
FUNCTION VIRTUAL GLOBAL Varan_Multiple_ReadWrite::Init
VAR
  DOCount     : UINT;
  ParticipantCount     : UINT;
	sd_retval		: DINT;
	p_handle_da		: ^LSL_VARANFRAME;
	p_data_read		: ^UDINT;
	p_data_write	: ^UDINT;
  
  // For NewInst command 
  _Para 	            : CmdStruct;  
  _Result 	          : Results;    
  paraGetModuleHandel : t_VM_CMD_GetModuleHandle;
  paraAddDO           : t_VM_CMD_AddDO;
  paraGetPointers     : t_VM_CMD_GetDataPointers;
  s_PropertyValuePair : LSL_PROPERTY_VALUE_PAIR;  
END_VAR

	//------------------------------------------------------------------------------------------------
	//only in first init
	if ( us_Firstscan = 0 ) then
		us_Firstscan += 1;

#ifdef HWC_LogInit
    HWC_LogInit();
#endif

    ud_ManagerNumber := To_VaranManager.GetManagerNumber(p_varan:=#pVaran);
    bGotManagerNumber := TRUE;

		//get filter number
		us_MulticastFilter := To_VaranManager.GetFilterNumber();

		//look for invalid filter number
		if ( us_MulticastFilter = 0 ) then

			State := _MultipleError;
			return;
		end_if;

		//get Varan position (virtual node for callback)	
		s_VaranPosition.us_Length := 2;
		s_VaranPosition.us_Byte1 := 255;	
		s_VaranPosition.us_Byte2 := us_MulticastFilter;
    
    //-----------------------------------------------------------------------------------------------
    // Check if Payload is supported by the VM
    _Para.uiCmd := VM_CMD_IS_PAYLOAD_SUPPORTED;
    _Result.aData[0]$BOOL := 0;   // Set to 0 in case the NewInst Method is not Implemented
    To_VaranManager.NewInst(#_Para, #_Result);
    b_PayloadSupport := _Result.aData[0]$BOOL;  

	//------------------------------------------------------------------------------------------------
	//in second init
	elsif ( us_Firstscan = 1 ) then	
		us_Firstscan += 1;		


		//is any class listed and state ok
    if( p_ParticipantInfo <> NIL ) & ( State = _ClassOk )	then

			//free not used memory
			p_ParticipantInfo$pvoid := To_StdLib.ReAlloc( mptr		:= p_ParticipantInfo$pVoid 
														, newsize	:= sizeof( t_MultipleData ) * ui_MaxNumberOfParticipants
														);

			//look if we get space
			if ( p_ParticipantInfo = NIL ) then
				State := _MemoryFault;
				return;
			end_if;

			//sort participants
			if ( ui_ActualNumberOfParticipants <> 0 ) then
				SortParticipants();
			end_if;

      GeneralIsRequired := 0;
      for DOCount := 0 to (ActNumberOfDOs-1) do
        GeneralIsRequired := GeneralIsRequired OR aDOs[DOCount].sd_IsRequired;
      end_for;

			//-----------------------------------------------------------------------------------------------
			//install callback function
      sd_retval := To_VaranManager.SetObjectCallback( p_us_position_info  := ( #s_VaranPosition )$^USINT
															, ud_action_ptr			:= ( #Varan_CallBack() )$UDINT
															, ud_thisp				:= this$UDINT
                                                      , sd_required			    := GeneralIsRequired
															);

			//look if an error occurs
			if ( sd_retval <> VARANMANAGER_OK ) then
				State := _CallBackError;
				return;
			end_if;
      
      if b_PayloadSupport then  
      
        // Get the pointer for the Payload inteface
        if ( OS_CILGet( INTERFACE_MULTIVARANMANAGER, #pMultiVaran ) <> SYS_ERR_NONE) then
          // Should be impossible b_PayloadSupport is only set when this interface was already called succesfully
          TRACE( "Varan_Multiple_ReadWrite::Init No Multi_Varan Interface found" );        
          State 		:= _NoVaranInterface;
          return;
        end_if;
        
        _Para.uiCmd := VM_CMD_GET_MODULE_HANDLE;
        
        paraGetModuleHandel.p_us_position_info := ( #s_VaranPosition )$^USINT;
        paraGetModuleHandel.p_ud_module_handle := #ud_HandleModule;
        
        _Para.aPara[0]  := (#paraGetModuleHandel)$DINT;
        
        To_VaranManager.NewInst(#_Para, #_Result);
        if _result.aData[0] <> VM_CMD_OK then
          State := _RootError;
          return;
        end_if;
      
      end_if;      

      for DOCount := 0 to (ActNumberOfDOs-1) do

        if b_PayloadSupport then
        //add multicast read write DOs
          
          // Add DO Command ------------------------------------------------------------------------------------------
          _Para.uiCmd := VM_CMD_ADD_DO;
          
          paraAddDO.ud_ModuleHandle := ud_HandleModule;
          paraAddDO.p_ud_DoHandle   := ( #aDOs[DOCount].p_Handle )$^UDINT;
          
          paraAddDO.ud_b_DoRequired := GeneralIsRequired$UDINT;
          
          paraAddDO.ud_DolType      := aDOs[DOCount].ud_DolType;
          paraAddDO.ud_OffsetRead   := aDOs[DOCount].ud_OffsetRead;
          paraAddDO.ud_LengthRead   := aDOs[DOCount].ui_LengthRead;
          paraAddDO.ud_OffsetWrite  := aDOs[DOCount].ud_OffsetWrite;
          paraAddDO.ud_LengthWrite  := aDOs[DOCount].ui_LengthWrite;
          
          paraAddDO.ud_PreScalerCounterThreshold   := 0;          
          paraAddDO.ud_PreScalerCounterStartValue  := 0;          
#ifdef HWK_SHOW_PRAGMA_MESSAGES                       
          #pragma message("LanSte 23.05.2013 16:07 \ Check")
#endif
          
          paraAddDO.ud_Priority := VM_PRIORITY_READ_DO;
          
          paraAddDO.ud_Filter   := us_MulticastFilter;
          paraAddDO.ud_Slices   := ui_MaxNumberOfParticipants;    // Create with max number of slices
          
          paraAddDO.ud_WritePayloadType := WR_PLD_TYPE_STANDARD;
          
          paraAddDO.ud_Command  := VARAN_CMD_MULTIPLE_MEMORY_RW;          
          
          _Para.aPara[0]  := (#paraAddDO)$DINT;
          
          To_VaranManager.NewInst(#_Para, #_Result);
          sd_retval := _result.aData[0]$DINT;
          if sd_retval <> VM_CMD_OK then 
            State := _CreateDOFailed;
            return;
          end_if;
          
          // Get Pointers Command ------------------------------------------------------------------------------------------
          _Para.uiCmd := VM_CMD_GET_DATA_POINTERS;  
          
          if ( #aDOs[DOCount].p_Handle )^ then
            paraGetPointers.ud_DoHandle     := ( #aDOs[DOCount].p_Handle )^$UDINT;
          else    
            State := _CreateDOFailed;
            return;
          end_if;  
          
          paraGetPointers.p_ud_ReadData   := ( #aDOs[DOCount].p_DataRead )$^UDINT;
          paraGetPointers.p_ud_WriteData  := ( #aDOs[DOCount].p_DataWrite )$^UDINT;
          
          _Para.aPara[0]  := (#paraGetPointers)$DINT;
          
          To_VaranManager.NewInst(#_Para, #_Result);
          sd_retval := _result.aData[0]$DINT;
        
          if ( sd_retval <> VARANMANAGER_OK ) then
            State := _CreateDOFailed;
            return;
          end_if;
        
        else
          //add multicast read write DOs
			sd_retval := To_VaranManager.AddMultipleRdWr( p_us_position_info		:= ( #s_VaranPosition )$^USINT
                                                    , ud_dol_type				  := aDOs[DOCount].ud_DolType
                                                    , p_ud_handle				  := ( #aDOs[DOCount].p_Handle )$^UDINT
                                                    , ud_address_read			:= aDOs[DOCount].ud_OffsetRead
                                                    , ud_length_read			:= aDOs[DOCount].ui_LengthRead
                                                    , p_ud_data_read			:= ( #aDOs[DOCount].p_DataRead )$^UDINT
                                                    , ud_address_write		:= aDOs[DOCount].ud_OffsetWrite
                                                    , ud_length_write			:= aDOs[DOCount].ui_LengthWrite
                                                    , p_ud_data_write			:= ( #aDOs[DOCount].p_DataWrite )$^UDINT
														, us_filter					:= us_MulticastFilter
                                                      , ui_number_of_slices := ui_MaxNumberOfParticipants   // Create with max number of slices
														);
			//look if an error occurs
			if ( sd_retval <> VARANMANAGER_OK ) then
				State := _CreateDOFailed;
				return;
			end_if;
        end_if;   
        
        if b_PayloadSupport then
			//set actual number of slices
          if ui_ActualNumberOfParticipants < ui_MaxNumberOfParticipants then
            
            s_PropertyValuePair.udPropertyId    := DO_PROP_SLICES;
            s_PropertyValuePair.udPropertyValue := ui_ActualNumberOfParticipants;
            sd_retval := MULTI_VARAN_iSetDoProperties(aDOs[DOCount].p_Handle$UDINT, 1, #s_PropertyValuePair);
            
            if ( sd_retval <> VARANMANAGER_OK ) then
              State := _CreateDOFailed;
              return;
            end_if;
          end_if;
          
        else
        
          //get settings poiner
        aDOs[DOCount].p_DOSettings$^UDINT := aDOs[DOCount].p_DataWrite - VM_DO_OFFSET_MULTIPLE_RDWR;

			//set actual number of slices
        aDOs[DOCount].p_DOSettings^.us_Slices := ui_ActualNumberOfParticipants$USINT;

			//set right length for data write
        aDOs[DOCount].p_Handle^.usSendBufferLength := VARAN_MULTIPLE_DO_HEADER + ( ui_ActualNumberOfParticipants * aDOs[DOCount].ui_LengthWrite );
          
          //set right pointer to read data  (Not dependant on p_DataWrite with payload!)
        aDOs[DOCount].p_DataRead := aDOs[DOCount].p_DataWrite + ( ui_ActualNumberOfParticipants * aDOs[DOCount].ui_LengthWrite );
        end_if;

			//config clients
			if ( ui_ActualNumberOfParticipants <> 0 ) then
				//call all functions
          for ParticipantCount := 0 to ui_MaxNumberOfParticipants - 1 do

					//if client is enabled
            if ( p_ParticipantInfo^[ ParticipantCount ].us_State <> 0 ) then

						//set multicast filter and sequence number
              sd_retval := p_ParticipantInfo^[ ParticipantCount ].p_this^.SetMultipleSettings( us_filter 	 := us_MulticastFilter
                                                                                             , us_sequence := p_ParticipantInfo^[ ParticipantCount ].us_Number
																						);

						//look for an error
						if ( sd_retval <> VARANMANAGER_OK ) then
							State := _MultipleError;
							return;
						end_if;

              if b_PayloadSupport then
						//set data pointer to read data out of dpram
                p_ParticipantInfo^[ ParticipantCount ].p_this^.SetMultipleDataPointers( p_handle      := aDOs[DOCount].p_Handle
                                                                                      , p_data_read   := aDOs[DOCount].p_DataRead  + ( ( p_ParticipantInfo^[ ParticipantCount ].us_Number - 1 ) * aDOs[DOCount].ui_LengthRead)
                                                                                      , p_data_write  := aDOs[DOCount].p_DataWrite + ( ( p_ParticipantInfo^[ ParticipantCount ].us_Number - 1 ) * aDOs[DOCount].ui_LengthWrite )
                                                                                      , DOCount
																				);
              else
                //set data pointer to read data out of dpram
                p_ParticipantInfo^[ ParticipantCount ].p_this^.SetMultipleDataPointers( p_handle      := aDOs[DOCount].p_Handle
                                                                                      , p_data_read   := aDOs[DOCount].p_DataRead  + ( ( p_ParticipantInfo^[ ParticipantCount ].us_Number - 1 ) * ( aDOs[DOCount].ui_LengthRead + 1 ) ) + 1  // +1 from Response 
                                                                                      , p_data_write  := aDOs[DOCount].p_DataWrite + ( ( p_ParticipantInfo^[ ParticipantCount ].us_Number - 1 ) * aDOs[DOCount].ui_LengthWrite )
                                                                                      , DOCount
                                                                                      );
					end_if;
            end_if;
				end_for;
          
          if b_PayloadSupport = false then
				//determine response time
            sd_retval := To_Varanmanager.MultipleRdWrDO(  p_us_position_info  := ( #s_VaranPosition )$^USINT
                                                      , ud_address_read		  := aDOs[DOCount].ud_OffsetRead
                                                      , ud_length_read		  := aDOs[DOCount].ui_LengthRead
															, p_ud_data_read		:= ( #p_data_read )$^UDINT
                                                      , ud_address_write		:= aDOs[DOCount].ud_OffsetWrite
                                                      , ud_length_write		  := aDOs[DOCount].ui_LengthWrite
															, p_ud_data_write		:= ( #p_data_write )$^UDINT
															, us_filter				:= us_MulticastFilter
															, us_slices				:= ui_ActualNumberOfParticipants$USINT
															, p_handle				:= ( #p_handle_da )$^PLSL_VARANFRAME
															);

				//look for an error
				if ( sd_retval <> VARANMANAGER_OK )then
					State := _DirectAccessFailed;
					return;
				end_if;

				//set right retry timeout in data object (+5 because we have preämble + crc bytes to transmit )
          aDOs[DOCount].p_Handle^.uiRetryTimeout := ( p_handle_da^.uiResponseTime * 2 ) + ( ( p_handle_da^.usLengthofExpAnswer + 5 ) * VM_TIMEOUT_ONE_BYTE ) + VM_RETRY_TIMEOUT_STD_OFFSET; 
          end_if;          

          // start DO
          ResetDataObject	( p_handleDO	:= aDOs[DOCount].p_Handle	
								, us_state		:= VARAN_DO_CONT_RUN
								, ud_bytes		:= 100
								);

				//set class ok
				Online := 1;
				NewConfig := 0;
			end_if;
      end_for;
		end_if;
	end_if;

END_FUNCTION
//=================================================================================================
//Function to add a multiple read/write participant
//=================================================================================================
//[>p_node]pointer to node information
//[>ud_offset_read]offset of read data
//[>ui_length_read]length of read data
//[>ud_offset_write]offset of write data
//[>ui_length_write]length of write data
//[>p_this]thispointer of object
//[>ud_dol_type]dol type of class
//[>sd_required]is class required or not
//[<sd_retval]0=ok, otherwise erorcode
FUNCTION GLOBAL Varan_Multiple_ReadWrite::AddParticipant
VAR_INPUT
	p_node				: ^USINT;
	ud_offset_read		: UDINT;
	ui_length_read		: UINT;
	ud_offset_write		: UDINT;
	ui_length_write		: UINT;
	p_this				: DINT;
	ud_dol_type			: UDINT;
	sd_required			: DINT;
		pDOIndex 	: ^UDINT;(* := NIL *)
		udVaranManagerNumber 	: UDINT;(* := 0 *)
END_VAR
VAR_OUTPUT
	sd_retval		: DINT;
END_VAR
  VAR
  	DOCount : UDINT;
    ParticipantCount : UDINT;
    ActDOIndex : DINT;
    ParticipantIndex : DINT;
  END_VAR

	//look for right thispointer
	if ( p_this = NIL ) then
		sd_retval := -1;
		return;
	end_if;

  if bGotManagerNumber = FALSE then
    ud_ManagerNumber := To_VaranManager.GetManagerNumber(p_varan:=#pVaran);
    bGotManagerNumber := TRUE;
  end_if;  
  
  //Check if participant is not on the same varanmanager as MultipleReadWrite class
  if udVaranManagerNumber <> ud_ManagerNumber then
    sd_retval := -3;
#ifdef HWC_LogValue2
    HWC_LogValue2(this,"@01BD (Varan_Multiple_ReadWrite::AddParticipant) Participant (0x{0}) has different managernumber than this class (0x{1}).", udVaranManagerNumber, ud_ManagerNumber);
#endif
    return;
  end_if;

	//get memory for data
	if ( p_ParticipantInfo = NIL ) then
		p_ParticipantInfo$pvoid := To_StdLib.Malloc( size := sizeof( t_MultipleDataArray ) );

		//look if we get space
		if ( p_ParticipantInfo = NIL ) then
			sd_retval := -2;
			return;
		end_if;
	end_if;

  ActDOIndex := -1;

  // check for the next free DO (if there is any)
  if ActNumberOfDOs then
    for DOCount := 0 to (ActNumberOfDOs-1) do
      // if basic access settings are equal
      if (aDOs[DOCount].ud_OffsetRead   = ud_offset_read) & 
         (aDOs[DOCount].ui_LengthRead	  = ui_length_read) &
         (aDOs[DOCount].ud_OffsetWrite	= ud_offset_write) & 
         (aDOs[DOCount].ui_LengthWrite	= ui_length_write) THEN
		
        // check in detail (required and DOL Type also need to be equal)
        if aDOs[DOCount].ud_DolType <> ud_dol_type then
          sd_retval := -7;
			return;
        end_if;
		
        if aDOs[DOCount].sd_IsRequired <> sd_required then
          sd_retval := -8;
			return;
        end_if;

        ActDOIndex := DOCount$DINT;
        exit;
      end_if;
    end_for;
  end_if;

  // no matching DO found
  if (ActDOIndex = -1) then
    // if there is no more free DO => return error
    if ActNumberOfDOs = MAX_MULTIPLE_DO_NUMBER then
      sd_retval := -12;
			return;
    else
      // use the next free DO
      ActDOIndex := ActNumberOfDOs$DINT;
      ActNumberOfDOs += 1;
    end_if;
  end_if;
  
  //set actual parmaters
  aDOs[ActDOIndex].ud_OffsetRead	:= ud_offset_read;
  aDOs[ActDOIndex].ui_LengthRead	:= ui_length_read;
  aDOs[ActDOIndex].ud_OffsetWrite	:= ud_offset_write;
  aDOs[ActDOIndex].ui_LengthWrite	:= ui_length_write;
  aDOs[ActDOIndex].ud_DolType		  := ud_dol_type;
  aDOs[ActDOIndex].sd_IsRequired	:= sd_required;

		
  if ui_MaxNumberOfParticipants then
    // check if we have already added this participant (for other DOs)
    ParticipantIndex := -1;
    
    for ParticipantCount := 0 to (ui_MaxNumberOfParticipants-1) do
      if (p_ParticipantInfo^[ ParticipantCount ].p_Node = p_node) &
         (p_ParticipantInfo^[ ParticipantCount ].p_this = p_this$p_VaranBase) then
        
        ParticipantIndex := ParticipantCount$DINT;
        exit;
      end_if;
    end_for;
    
    // not found in list
    if ParticipantIndex = -1 then
		//look for total length of data object (not bigger then 128 Byte)
      if ( ( ( ui_MaxNumberOfParticipants + 1 ) * ui_length_read ) > 128 ) then
			sd_retval := -9;
			return;
		
      elsif ( ( ( ui_MaxNumberOfParticipants + 1 ) * ui_length_write ) > 128 ) then
			sd_retval := -10;
			return;
		end_if;

	//look if we have max number of participants
	if ( ui_MaxNumberOfParticipants >= 128 ) then
		sd_retval := -11;
		return;
	end_if;
	
      // otherwise it's the next free number
      ParticipantIndex := ui_MaxNumberOfParticipants;
	ui_MaxNumberOfParticipants += 1;
    end_if;
  else
    ParticipantIndex := 0;
    ui_MaxNumberOfParticipants += 1;
  end_if;

	//save thispointer and node pointer
	p_ParticipantInfo^[ ParticipantIndex ].us_Number:= 0;
	p_ParticipantInfo^[ ParticipantIndex ].us_State	:= 0;
	p_ParticipantInfo^[ ParticipantIndex ].p_Node		:= p_node;
	p_ParticipantInfo^[ ParticipantIndex ].p_this		:= p_this$p_VaranBase;

  if pDOIndex <> NIL then
    pDOIndex^ := ActDOIndex$UDINT;
  end_if;

	sd_retval := VARANMANAGER_OK;

END_FUNCTION //GLOBAL Varan_Multiple_ReadWrite::AddParticipant
//=================================================================================================
//Function to sort participants
//=================================================================================================
FUNCTION  Varan_Multiple_ReadWrite::SortParticipants
VAR
	b_sorted				: BOOL;
	us_actual_number		: USINT;
	p_actual_participant	: ^t_MultipleData;
	i						: UINT;
END_VAR

	//do we have data
	if ( p_ParticipantInfo <> NIL ) then

		b_sorted 				:= FALSE;
		p_actual_participant	:= NIL;
		us_actual_number		:= 1;

		//set state of all enabled devices to 1 (unsorted)
		for i := 0 to ui_MaxNumberOfParticipants - 1 do
			if ( p_ParticipantInfo^[ i ].us_State = 2 ) then
				p_ParticipantInfo^[ i ].us_State := 1;
			end_if;
		end_for;

		//while data is sorted
		while ( b_sorted = FALSE ) do

			//we say array is sorted
			b_sorted := TRUE;			

			//look in all data
			for i := 0 to ui_MaxNumberOfParticipants - 1 do
				//if device is enabled and not sorted
				if ( p_ParticipantInfo^[ i ].us_State = 1 ) then
					//look if it is first undorted device in this for loop
					if ( p_actual_participant = NIL ) then
						p_actual_participant := #p_ParticipantInfo^[ i ];
					else
						//look if next device is on a lower position
						if ( CompareNode( p_first := p_actual_participant^.p_Node, p_second := p_ParticipantInfo^[ i ].p_Node ) ) then
							//set pointer of actual lowest device node to new one
							p_actual_participant := #p_ParticipantInfo^[ i ];
						end_if;
						//now we say we must sort again (do not leave while loop)
						b_sorted := FALSE;
					end_if;					
				end_if;
			end_for;

			//set actual data to device data 
			p_actual_participant^.us_Number := us_actual_number;
			p_actual_participant^.us_State := 2;
			//increase sequence number
			us_actual_number += 1;
			//reset pointer to look next time for first device data
			p_actual_participant := NIL;

		end_while;
	end_if;

END_FUNCTION // Varan_Multiple_ReadWrite::SortParticipants
//=================================================================================================
//Function compares two nodes
//=================================================================================================
FUNCTION Varan_Multiple_ReadWrite::CompareNode
VAR_INPUT
	p_first		: ^USINT;
	p_second	: ^USINT;
END_VAR
VAR_OUTPUT
	b_first		: BOOL;
END_VAR
VAR
	len_first   : USINT;
  len_second  : USINT;
END_VAR


	//get length of strings (in first byte)
	len_first  := p_first^;   //edi
	len_second := p_second^;  //ebx

//LABEL_Loop
  while 1 do
  	p_first  += 1;				//increment first pointer to show to next number
	  p_second += 1;				//increment second pointer to show to next number

    if p_first^  > p_second^ then
      //LABEL_Smaller: if number of first string is bigger -> second is smaller
      b_first := TRUE;
      exit;
    elsif p_first^  < p_second^ then
  	  //LABEL_Bigger: if number of first string is smaller -> second is bigger
      b_first := FALSE;
      exit;
    else
      //equal
    	len_first  -= 1;				//decrement length of first string
	    len_second -= 1;				//decrement length of second string

      if len_first = 0 then   //look if end of first string is reached
        b_first := FALSE;     //then second string is bigger
        exit;
      end_if;

      if len_second = 0 then  //look if end of second string is reached
        b_first := TRUE;      //then second string is smaller
        exit;
      end_if;

    end_if;
  end_while;

END_FUNCTION // Varan_Multiple_ReadWrite::FindHigher
//=================================================================================================
//Function compares two nodes
//=================================================================================================
 // Varan_Multiple_ReadWrite::FindHigher
//[#ENGLISH]
//=================================================================================================
//Function to reset settings of a data object
//=================================================================================================
//[client]	Required		:R		:is class required for varan or not
//[>p_HandleDO]pointer to data object
//[>us_state]state of DO (cont run, singl run, stop )
//[>ud_bytes]number of bytes in DO
FUNCTION Varan_Multiple_ReadWrite::ResetDataObject
VAR_INPUT
	p_handleDO		: ^LSL_VARANFRAME;
	us_state		: USINT;
	ud_bytes		: UDINT;
END_VAR

	//look if we have a valid pointer
	if ( p_handleDO <> NIL ) then
  
    if b_PayloadSupport then
      // Just Start/Stop the DO depending on us_state. Other stuff is already handled with the payload interface
      if us_state = VARAN_DO_CONT_RUN then
        MULTI_VARAN_iEnableDo(p_handleDO$UDINT);
      elsif us_state = VARAN_DO_NO_RUN then
        MULTI_VARAN_iDisableDo(p_handleDO$UDINT);
      end_if;
    
    else
		//set state of DO
		if ( GeneralIsRequired ) then
			p_handleDO^.ucCtrlStat 		:= us_state or VARAN_DO_REQUIRED;
		else
			p_handleDO^.ucCtrlStat 		:= us_state;
		end_if;
		
		//reset retry counter
  //		p_handleDO^.ucRetryCounter	:= 0;
		
		//set number of allowed retries
		p_handleDO^.ucRetrys		:= VM_ALLOWED_RETRIES;
	end_if;
		
	end_if;

END_FUNCTION //VIRTUAL GLOBAL Varan_Multiple_ReadWrite::ResetDataObject
//[#ENGLISH]
//=================================================================================================
//Function to set state of partisipants
//=================================================================================================
//[>us_state]0=not available, 1=available
//[>p_this]thispointer of object
FUNCTION GLOBAL Varan_Multiple_ReadWrite::SetStateOfParticipant
VAR_INPUT
	us_state		: USINT;
	p_this			: DINT;
END_VAR
VAR
	i		: UINT;
END_VAR
		
	//look if participant is listed
	for i := 0 to ui_MaxNumberOfParticipants - 1 do

		if ( p_ParticipantInfo^[ i ].p_this = p_this$^Varan_Base ) then
			
			//look if disable or active
			if ( us_state ) then

				p_ParticipantInfo^[ i ].us_State := 1;				//activate participant
				ui_ActualNumberOfParticipants += 1;

			else

        p_ParticipantInfo^[ i ].us_State := 0;				//deactivate participant
				ui_ActualNumberOfParticipants -= 1;
			end_if;

			NewConfig := 1;
      
      // we leave after we found a match => every participant can only be once in the list
      exit;
		end_if;
	end_for;

END_FUNCTION //GLOBAL Varan_Multiple_ReadWrite::SetStateOfParticipant

FUNCTION VIRTUAL GLOBAL Varan_Multiple_ReadWrite::Restart::Write
VAR_INPUT
	input		: DINT;
END_VAR
VAR_OUTPUT
	result		: DINT;
END_VAR
VAR
  DOCount : UDINT;
END_VAR

	//look if last resart finished or we have found devices
	if	(Restart = 0) & (ui_ActualNumberOfParticipants <> 0) & ((State = _HardwareNotrequiredIRQ) | (State = _ClassOk)) then
	
		Restart := input;

    for DOCount := 0 to (ActNumberOfDOs-1) do
      // stop DO
      ResetDataObject	( p_handleDO	:= aDOs[DOCount].p_Handle
						, us_state		:= VARAN_DO_NO_RUN
						, ud_bytes		:= 100
						);
    end_for;

	 	result := Restart := 1;
		e_CySSW := __Sort;
	
	else
		result := -1;
	end_if;

END_FUNCTION //VIRTUAL GLOBAL Varan_Multiple_ReadWrite::Restart::Write
//=================================================================================================
//Function to make new config for partisipants
//=================================================================================================
FUNCTION VIRTUAL GLOBAL Varan_Multiple_ReadWrite::CyWork
VAR_INPUT
	EAX		: UDINT;
END_VAR
VAR_OUTPUT
	state		: UDINT;
END_VAR
VAR
	b_config		: BOOL;
//	i				: UINT;
	ud_timemark		: UDINT;
	ud_timemark2	: UDINT;
	sd_retval		: DINT;
  us_ActRetryCounter : USINT;
  DOCount : UDINT;
  ParticipantCount : UDINT;
  Ready2Proceed : BOOL;
  s_PropertyValuePair : LSL_PROPERTY_VALUE_PAIR;
END_VAR

  if ActNumberOfDOs then
    // check if there was a problem with the DOs
    if b_DistributeError then
      b_DistributeError := FALSE;
      
      for ParticipantCount := 0 to ui_MaxNumberOfParticipants - 1 do
        if p_ParticipantInfo^[ParticipantCount].p_this^.Online then
          p_ParticipantInfo^[ParticipantCount].p_this^.State := this^.State;
        end_if;
      end_for;      
    end_if;
  
  	// check retry counter of DOs
    for DOCount := 0 to (ActNumberOfDOs-1) do
      if ( aDOs[DOCount].p_handle <> NIL ) then
        
        if b_PayloadSupport then
          sd_retval := MULTI_VARAN_iGetDoProperty(( #aDOs[DOCount].p_Handle )^$UDINT, DO_PROP_FAILED_ACCESS_COUNTER, #us_ActRetryCounter$UDINT);
        else
        us_ActRetryCounter := aDOs[DOCount].p_Handle^.ucRetryCounter;
        end_if;
        
        if ( us_ActRetryCounter <> aDOs[DOCount].us_OldRetryCounter ) then
          RetryCounter += TO_USINT( us_ActRetryCounter - aDOs[DOCount].us_OldRetryCounter );
          aDOs[DOCount].us_OldRetryCounter := us_ActRetryCounter;
		end_if;
	end_if;
    end_for;
  end_if;
	
	//look if we must make a reconfig
	if Restart & (ui_ActualNumberOfParticipants <> 0)	then

#ifdef VARAN_iTriggerClientWd
    // trigger watchdog on clients to reactivate them
    VARAN_iTriggerClientWd(ud_ManagerNumber);
#endif

		//steps of initialization
		case ( e_CySSW ) of

			//----------------------------------------------------------------------------------------------
			__Sort:
					ud_timemark := OS_ReadMicroSec();
					
					SortParticipants();

					ud_timemark2 := OS_ReadMicroSec();
					ud_SortTime := ud_timemark2 - ud_timemark;
					ui_CalledParticipants := 0;

          for DOCount := 0 to (ActNumberOfDOs-1) do
					//clear write data in DPRAM
            _memset(dest:=aDOs[DOCount].p_DataWrite, usByte:=0, cntr:= ui_MaxNumberOfParticipants * aDOs[DOCount].ui_LengthWrite);
					end_for;

          ud_WatchdogTime := ops.tAbsolute;

					e_CySSW := __Wait4Watchdog;

			//----------------------------------------------------------------------------------------------
      __Wait4Watchdog:

          if (ops.tAbsolute - ud_WatchdogTime) > 15 then
            e_CySSW := __ConfigDevices;
          end_if;
      
			//----------------------------------------------------------------------------------------------
			__ConfigDevices:
					
					b_config := FALSE;

					while ( b_config = FALSE ) do
				
						//call all functions ( in each cycle one )
						if ( ui_CalledParticipants < ui_MaxNumberOfParticipants ) then
								
							//is device active
							if ( p_ParticipantInfo^[ ui_CalledParticipants ].us_State <> 0 ) then
			
								//config device
								sd_retval := p_ParticipantInfo^[ ui_CalledParticipants ].p_this^.SetMultipleSettings( us_filter 	:= us_MulticastFilter
																													, us_sequence 	:= ( p_ParticipantInfo^[ ui_CalledParticipants ].us_Number )$USINT
																													);

								//look for an error
								if ( sd_retval <> VARANMANAGER_OK ) then
									State := _MultipleError;
									Restart := 0;
									return;
								end_if;
								b_config := TRUE;
							
							end_if;

							//increment called devices
							ui_CalledParticipants += 1;
						
						else
              for DOCount := 0 to (ActNumberOfDOs-1) do
                aDOs[DOCount].b_SSWStepFinished := FALSE;
              end_for;
							b_config := TRUE;
							e_CySSW := __DetermineResponseTime;
							ui_CalledParticipants := 0;
						end_if;
					end_while;
			
			//----------------------------------------------------------------------------------------------
			__DetermineResponseTime:

          Ready2Proceed := TRUE;
          for DOCount := 0 to (ActNumberOfDOs-1) do
          
            if aDOs[DOCount].b_SSWStepFinished = FALSE then
            
              if b_PayloadSupport then
                // set actual number of slices
                // skip the rest and skip to the end of the SM
                s_PropertyValuePair.udPropertyId    := DO_PROP_SLICES;
                s_PropertyValuePair.udPropertyValue := ui_ActualNumberOfParticipants;
                sd_retval := MULTI_VARAN_iSetDoProperties(aDOs[DOCount].p_Handle$UDINT, 1, #s_PropertyValuePair);
                
                if ( sd_retval <> VARANMANAGER_OK ) then
                  State := _CreateDOFailed;
                  return;
                end_if;
                
              else
					//set actual number of slices
              aDOs[DOCount].p_DOSettings^.us_Slices := ui_ActualNumberOfParticipants$USINT;

					//set right length for data write
              aDOs[DOCount].p_Handle^.usSendBufferLength := VARAN_MULTIPLE_DO_HEADER + ( ui_ActualNumberOfParticipants * aDOs[DOCount].ui_LengthWrite );

					//start DO as single call to get max response time
              if ( ( aDOs[DOCount].p_Handle^.ucCtrlStat and 16#F ) = 0 ) then

						//set default retry timeout time
                aDOs[DOCount].p_Handle^.uiRetryTimeout := VM_MAX_RETRY_TIMEOUT_MULTIPLE;						

                //start singleg
                aDOs[DOCount].p_Handle^.ucCtrlStat := VARAN_DO_SINGLE_RUN;

                aDOs[DOCount].b_SSWStepFinished := TRUE;
              else
                Ready2Proceed := FALSE;
              end_if;
              
            end_if;
              
            end_if;
          end_for;
          
          if Ready2Proceed then
            for DOCount := 0 to (ActNumberOfDOs-1) do
              aDOs[DOCount].b_SSWStepFinished := FALSE;
            end_for;            
            
            if b_PayloadSupport then
              // skip to the end of the SM
              // Timeout is determinded by the OS
              e_CySSW := __StartDO;
            else
						e_CySSW := __Wait4Response;
					end_if;
	
					end_if;
	
			//----------------------------------------------------------------------------------------------
			__Wait4Response:

          Ready2Proceed := TRUE;

          for DOCount := 0 to (ActNumberOfDOs-1) do
					//look if do is executed
            if ( ( aDOs[DOCount].p_Handle^.ucCtrlStat and 16#F ) = 0 ) then

						//set right retry timeout in data object (+5 because we have preämble + crc bytes to transmit )
              aDOs[DOCount].p_Handle^.uiRetryTimeout := ( aDOs[DOCount].p_Handle^.uiResponseTime * 2 ) + ( ( aDOs[DOCount].p_Handle^.usLengthofExpAnswer + 5 ) * VM_TIMEOUT_ONE_BYTE ) + VM_RETRY_TIMEOUT_STD_OFFSET; 

              aDOs[DOCount].b_SSWStepFinished := TRUE;
            else
              Ready2Proceed := FALSE;
            end_if;
          end_for;

          if Ready2Proceed then
            for DOCount := 0 to (ActNumberOfDOs-1) do
              aDOs[DOCount].b_SSWStepFinished := FALSE;
            end_for;

						e_CySSW := __StartDO;
					end_if;

			//----------------------------------------------------------------------------------------------
			__StartDO:

					//set ssw back to first step
					e_CySSW := __Sort;
					//set class online
					Online := 1;
					//set state ok
					Varan_Multiple_ReadWrite::State := _ClassOk;
					NewConfig := 0;
					Restart := 0;

          for DOCount := 0 to (ActNumberOfDOs-1) do
					//call all functions ( to set classes online and set new data pointers )
            for ParticipantCount := 0 to ui_MaxNumberOfParticipants - 1 do
								
						//is device active
              if ( p_ParticipantInfo^[ ParticipantCount ].us_State = 2 ) then
			
                if b_PayloadSupport then
							//set pointers for device
                  p_ParticipantInfo^[ ParticipantCount ].p_this^.SetMultipleDataPointers( p_handle      := aDOs[DOCount].p_Handle
                                                                                        , p_data_read   := aDOs[DOCount].p_DataRead  + ( ( p_ParticipantInfo^[ ParticipantCount ].us_Number - 1 ) * aDOs[DOCount].ui_LengthRead ) 
                                                                                        , p_data_write 	:= aDOs[DOCount].p_DataWrite + ( ( p_ParticipantInfo^[ ParticipantCount ].us_Number - 1 ) * aDOs[DOCount].ui_LengthWrite )
                                                                                        , DOCount);
                else
                  //set pointers for device
                  p_ParticipantInfo^[ ParticipantCount ].p_this^.SetMultipleDataPointers( p_handle      := aDOs[DOCount].p_Handle
                                                                                        , p_data_read   := aDOs[DOCount].p_DataWrite + ( ui_ActualNumberOfParticipants * aDOs[DOCount].ui_LengthWrite ) + ( ( p_ParticipantInfo^[ ParticipantCount ].us_Number - 1 ) * ( aDOs[DOCount].ui_LengthRead + 1 ) ) + 1  // +1 From Response
                                                                                        , p_data_write  := aDOs[DOCount].p_DataWrite + ( ( p_ParticipantInfo^[ ParticipantCount ].us_Number - 1 ) * aDOs[DOCount].ui_LengthWrite )
                                                                                        , DOCount);
						end_if;
						  end_if;
					end_for;

            // start DO
            ResetDataObject	( p_handleDO	:= aDOs[DOCount].p_Handle
                            , us_state		:= VARAN_DO_CONT_RUN
                            , ud_bytes		:= 100
                            );
          end_for;

		end_case;
	
	else
		Restart := 0;
		
		//if we have no actual number reset new config server
		if ( ui_ActualNumberOfParticipants = 0 ) then
			NewConfig := 0;
		end_if;
	end_if;

	state:= READY;

END_FUNCTION //VIRTUAL GLOBAL Varan_Multiple_ReadWrite::CyWork
//[#ENGLISH]
//=================================================================================================
//Function for callbacks
//=================================================================================================
//[>ud_reason]reason of callback
//[>ud_data]data of callback function
FUNCTION GLOBAL Varan_Multiple_ReadWrite::Varan_CallBack
	VAR_INPUT
		ud_reason 	: UDINT;
		ud_data 	: UDINT;
	END_VAR
	VAR_OUTPUT
		sd_retval (EAX) 	: DINT;
	END_VAR

	//counter to count number of callback calls
	ud_CallbackCounter += 1;

	//switch case of callback
	case ( ud_reason ) of

		// Interrupt
		VARANMANAGER_CB_REQ_ERROR,
		VARANMANAGER_FATAL_ERROR:		
                    Online	:= 0;
										State	:= _HardwareRequiredIRQ;
                    ud_LastReason := ud_reason;
                    LastData := (ud_data$^t_CallBackInterrupt)^;
                    b_DistributeError := TRUE;

		VARANMANAGER_CB_NOT_REQ_ERROR:	
                    Online := 0;
										State := _HardwareNotRequiredIRQ;
                    ud_LastReason := ud_reason;
                    LastData := (ud_data$^t_CallBackInterrupt)^;
                    b_DistributeError := TRUE;
	end_case;
	
	//------------------------------------------------------------------------------------------------
	//if class is required and state is error (because of first connect (called in Init))
	if GeneralIsRequired & (State <> _ClassOk) then
		
		//give an error back to VaranManager to shut down application
		sd_retval := VARANMANAGER_CALLBACK_NOT_HANDLED;
		//Set state of class
		State := _RequiredError;
		//Set VaranMaster off
		To_VaranManager.SetManagerOff( e_error := State );
	
	else
		//if we have a negative return code but class is not required then we do nothing
		if ( sd_retval <> VARANMANAGER_OK ) then
			sd_retval := VARANMANAGER_OK;
		end_if;
	end_if;
  
  // changed: EBNANT: 18.06.09
	//----------------------------------User has last word -------------------------------------------
	//look if user client is connected
	if ( IsClientConnected( #UserAction ) = TRUE ) then

		//call user call back so that user has chance to change return value to VaranManager
		sd_retval := UserAction.write( ud_reason$DINT );
		
		//look if user want other reaction
		if ( sd_retval ) then
			sd_retval := VARANMANAGER_CALLBACK_NOT_HANDLED;
		else
			sd_retval := VARANMANAGER_OK;
		end_if;
	end_if;

END_FUNCTION // Varan_Multiple_ReadWrite::Varan_CallBack

//[#ENGLISH] --> changed: EBNANT: 18.06.09
//=================================================================================================
// Check if Client UserAction is connected
//=================================================================================================
//[>ret_val] false...Client is not connected
//           true ...Client is connected
FUNCTION GLOBAL Varan_Multiple_ReadWrite::IsUserActionConnected
	VAR_OUTPUT
		ret_val 	: DINT;
	END_VAR
  
  ret_val := IsClientConnected( #UserAction );

END_FUNCTION // Varan_Multiple_ReadWrite::IsUserActionConnected
