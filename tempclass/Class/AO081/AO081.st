//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define DEVICE_ID_AO081 1008

#define AO081_ADDR_CYC_WRITE        16#000
#define AO081_ADDR_CYC_READ         16#080
#define AO081_ADDR_CFG_FIRMWARE     16#100
#define AO081_ADDR_STATE_FIRMWARE   16#180

#define AO081_SDO_RESPONSE_TIMEOUT  SDIAS_SDO_TIMEOUT * 2

#define AO081_NUMBER_OF_OUTPUTS     8
#define AO081_RANGE_FIRMWARE        20000 //(-10000 mV to +10000 mV)
#define AO081_FIRMWARE_MIN          -10000
#define AO081_FIRMWARE_MAX          10000

//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "AO081"
	Revision           = "1.37"
	GUID               = "{F4931417-D1C7-40C4-B677-8E32E0166805}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\s-dias.ico"
	SharedCommandTable = "true"
	Objectsize         = "(502,120)"
	Comment            = "class for AO081 ( 8 x analog outputs (+/-10V ) )">
	<Channels>
		<Server Name="AO1" GUID="{C6E7529D-AA84-4CC2-AA0C-9D146615C3E3}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Analog Output"/>
		<Server Name="AO2" GUID="{154D55A8-2F44-40BA-B5B5-3BA5C4E9CEC6}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Analog Output"/>
		<Server Name="AO3" GUID="{606B8959-1E5D-4835-BE8E-1D28E42689A8}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Analog Output"/>
		<Server Name="AO4" GUID="{2DC968E4-9F79-44BD-B8F0-116B0C27AE79}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Analog Output"/>
		<Server Name="AO5" GUID="{206F489C-2F76-4538-9416-2673374A31DE}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Analog Output"/>
		<Server Name="AO6" GUID="{417FBDCD-A4D3-44DD-A140-86557CA94D37}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Analog Output"/>
		<Server Name="AO7" GUID="{CB637C05-535B-43D5-A5DE-6412E9FBC4E3}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Analog Output"/>
		<Server Name="AO8" GUID="{C7A96EA0-78E9-47B2-8144-A2D9AB82337F}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Analog Output"/>
		<Server Name="ExternVoltageOk" GUID="{AC3A14FC-3BFF-4F53-9268-4F647D0CF832}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Extern Voltage supply is connected&#13;&#10; "/>
		<Server Name="FirmwareVersion" GUID="{D7AB6B90-D52D-4F1A-A082-37F4C1526C6B}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Version of the used firmware&#13;&#10;&#13;&#10;e.g. 16#100 means v1.0"/>
		<Server Name="FWErrorBits" GUID="{869BB65C-DD3F-45B5-9F4F-8E47E5C96F7D}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Firmware Status:&#13;&#10;Bit0...DC not Ok&#13;&#10;Bit1...No Sync&#13;&#10;Bit2...Flash data CRC error&#13;&#10;Bit3...Ram data CRC error&#13;&#10;Bit4...No valid EEPROM Version"/>
		<Client Name="AO1_Max" Required="false" Internal="false" DefValue="10000" Comment="Maximal output value of AO1 (corresponds to +10V)."/>
		<Client Name="AO1_Min" Required="false" Internal="false" DefValue="-10000" Comment="Minimal output value of AO1 (corresponds to -10V)."/>
		<Client Name="AO2_Max" Required="false" Internal="false" DefValue="10000" Comment="Maximal output value of AO2"/>
		<Client Name="AO2_Min" Required="false" Internal="false" DefValue="-10000" Comment="Minimal output value of AO2 (corresponds to -10V)."/>
		<Client Name="AO3_Max" Required="false" Internal="false" DefValue="10000" Comment="Maximal output value of AO3 (corresponds to +10V)."/>
		<Client Name="AO3_Min" Required="false" Internal="false" DefValue="-10000" Comment="Minimal output value of AO3 (corresponds to -10V)."/>
		<Client Name="AO4_Max" Required="false" Internal="false" DefValue="10000" Comment="Maximal output value of AO4  (corresponds to +10V)."/>
		<Client Name="AO4_Min" Required="false" Internal="false" DefValue="-10000" Comment="Minimal output value of AO4 (corresponds to -10V)."/>
		<Client Name="AO5_Max" Required="false" Internal="false" DefValue="10000" Comment="Maximal output value of AO5  (corresponds to +10V)."/>
		<Client Name="AO5_Min" Required="false" Internal="false" DefValue="-10000" Comment="Minimal output value of AO5 (corresponds to -10V)."/>
		<Client Name="AO6_Max" Required="false" Internal="false" DefValue="10000" Comment="Maximal output value of AO6  (corresponds to +10V)."/>
		<Client Name="AO6_Min" Required="false" Internal="false" DefValue="-10000" Comment="Minimal output value of AO6 (corresponds to -10V)."/>
		<Client Name="AO7_Max" Required="false" Internal="false" DefValue="10000" Comment="Maximal output value of AO7  (corresponds to +10V)."/>
		<Client Name="AO7_Min" Required="false" Internal="false" DefValue="-10000" Comment="Minimal output value of AO7 (corresponds to -10V)."/>
		<Client Name="AO8_Max" Required="false" Internal="false" DefValue="10000" Comment="Maximal output value of AO8  (corresponds to +10V)."/>
		<Client Name="AO8_Min" Required="false" Internal="false" DefValue="-10000" Comment="Minimal output value of AO8 (corresponds to -10V)."/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="BeiWol"/>
		<Dokumentation Revision="1.37" Date="12.08.2019" Author="LazJos" Company="Sigmatek" Description="Added support for HWAlarms."/>
		<Dokumentation Revision="1.36" Date="09.01.2019" Author="FurDom" Company="Sigmatek" Description="Added function for Spi Write in SdiasBase class."/>
		<Dokumentation Revision="1.35" Date="08.06.2018" Author="RamAnd" Company="Sigmatek" Description="LASAL Hardware Description (.lhd) file has been updated."/>
		<Dokumentation Revision="1.34" Date="23.01.2018" Author="RamAnd" Company="Sigmatek" Description="Log messages have been standardized for easier maintenance, easier use in any class and to allow spam filtering. Code for the logging functions is now only located in HwControl."/>
		<Dokumentation Revision="1.33" Date="16.05.2017" Author="RamAnd" Company="Sigmatek" Description="When adding an SDO (i.e. via ReadSPIData) from background priority it was possible that the adding process got interrupted by receiving the answer to this SDO which is handled in cyclic priority. In the error case the answer was unexpected and therefore ignored. Then the class signals a timeout while waiting for the answer, which already arrived before waiting for it. Added mutex and changed instruction order to prevent this error."/>
		<Dokumentation Revision="1.32" Date="08.02.2017" Author="EisMic" Company="Sigmatek" Description="Corrected values for current calculation in Lasal hardware description file."/>
		<Dokumentation Revision="1.31" Date="12.07.2016" Author="SeiChr" Company="Sigmatek" Description="Added Values for the total Current calculation. SA 31571"/>
		<Dokumentation Revision="1.30" Date="01.03.2016" Author="EisMic" Company="Sigmatek" Description="Corrected BoundExceed Error in base class at Write method of LEDControl Server when Place = LSL_DEACTIVATED."/>
		<Dokumentation Revision="1.29" Date="23.02.2016" Author="PieSte" Company="Sigmatek" Description="Add support for min range greater max range."/>
		<Dokumentation Revision="1.28" Date="22.06.2015" Author="EisMic" Company="Sigmatek" Description="The servers FPGAVersion, SerialNo, Device ID and status and input servers are now not reset anymore when the module is disconnected."/>
		<Dokumentation Revision="1.27" Date="08.04.2015" Author="RamAnd" Company="Sigmatek" Description="Scaling did not work properly on ARM platforms."/>
		<Dokumentation Revision="1.26" Date="16.04.2015" Author="EisMic&#13;&#10;LanSte" Company="Sigmatek" Description="Added support for visualisation in graphical hardware editor.&#13;&#10;Added support for calculating resources for graphical hardware editor."/>
		<Dokumentation Revision="1.25" Date="17.03.2015" Author="RamAnd" Company="Sigmatek" Description="Added HW Version for sdias clients."/>
		<Dokumentation Revision="1.24" Date="11.02.2015" Author="PieSte" Company="Sigmatek" Description="Corrected read spi data for hardwaretree in methode GetSPIDataFromID from baseclass."/>
		<Dokumentation Revision="1.23" Date="18.11.2014" Author="PieSte" Company="Sigmatek" Description="Added possibility  to read more data from spi flash then one sdo access.&#13;&#10;Set methode GetDeviceID to global.&#13;&#10;Add methode to calculate checksum of spi flash."/>
		<Dokumentation Revision="1.22" Date="04.07.2014" Author="EisMic" Company="Sigmatek" Description="Added support for reading hardware diagnosis and hardwaretree entry."/>
		<Dokumentation Revision="1.21" Date="07.03.2014" Author="EisMic" Company="Sigmatek" Description=" Corrected comment of server Firmwareversion"/>
		<Dokumentation Revision="1.20" Date="20.01.2014" Author="PieSte" Company="Sigmatek" Description="Read Client Required and Place in Init SdiasBase"/>
		<Dokumentation Revision="1.10" Date="05.12.2013" Author="RamAnd" Company="Sigmatek" Description="Changed login mechanism to sdias manager class to be independent of bus accesses."/>
		<Dokumentation Revision="1.0" Date="25.07.2013" Author="BeiWol" Company="Sigmatek" Description="First library version"/>
	</RevDoku>
	<Network Name="AO081">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{D103FB6E-8796-4949-8BDA-3C760DD8462A}"
				Class      = "SdiasBase"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassState"/>
					<Server Name="DeviceID"/>
					<Server Name="FPGAVersion"/>
					<Server Name="HwVersion"/>
					<Server Name="LEDControl" Value="0"/>
					<Server Name="RetryCounter"/>
					<Server Name="SDOState"/>
					<Server Name="SerialNo"/>
					<Client Name="Place" Value="0"/>
					<Client Name="Required" Value="1"/>
					<Client Name="SdiasIn"/>
					<Client Name="ToStdLib"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassState" Destination="_base.ClassState" Vertices="(804,210),(632,210),"/>
			<Connection Source="this.DeviceID" Destination="_base.DeviceID" Vertices="(804,270),(632,270),"/>
			<Connection Source="this.SerialNo" Destination="_base.SerialNo" Vertices="(804,450),(632,450),"/>
			<Connection Source="this.RetryCounter" Destination="_base.RetryCounter" Vertices="(804,510),(632,510),"/>
			<Connection Source="this.LEDControl" Destination="_base.LEDControl" Vertices="(804,570),(632,570),"/>
			<Connection Source="_base.SdiasIn" Destination="this.SdiasIn" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.Place" Destination="this.Place" Vertices="(218,270),(38,270),"/>
			<Connection Source="_base.Required" Destination="this.Required" Vertices="(218,330),(38,330),"/>
			<Connection Source="this.FPGAVersion" Destination="_base.FPGAVersion" Vertices="(804,330),(632,330),"/>
			<Connection Source="this.HwVersion" Destination="_base.HwVersion" Vertices="(804,390),(632,390),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using SdiasBase

AO081 : CLASS
: SdiasBase
	TYPE
	  t_SpecialPurpose : BSINT
	  [
	    1 PmbModus,
	    2 BootloaderUpdateRequ,
	  ];
#pragma pack(push, 1)
	  t_CfgFirmware : STRUCT
	    CRC : UINT;
	    DataLength : UINT;
	    Info : t_SpecialPurpose;
	    Reserved : USINT;
	  END_STRUCT;
#pragma pack(pop)
	  t_InitSSW :
	  (
	    _InitVariables,
	    _ConfigModule,
	    _ReadState,
	    _Finish,
	    _InitError
	  )$UDINT;
#pragma pack(push, 1)
	  t_MinMaxRange : STRUCT
	    MinRangeValue : DINT;
	    MaxRangeValue : DINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_ReadData : STRUCT
	    Status : t_b_SdiasFWState;
	  END_STRUCT;
#pragma pack(pop)
	  t_ResponseState :
	  (
	    _idle,
	    _wait,
	    _valid
	  )$UDINT;
#pragma pack(push, 1)
	  t_StateFirmware : STRUCT
	    CRC : UINT;
	    DataLength : UINT;
	    FirmwareVersion : UINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_TwoOutputs : STRUCT
	    Output1 : INT;
	    Output2 : INT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_WriteData : STRUCT
	    AO1_2 : t_TwoOutputs;
	    AO3_4 : t_TwoOutputs;
	    AO5_6 : t_TwoOutputs;
	    AO7_8 : t_TwoOutputs;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	FirmwareVersion 	: SvrCh_HDINT;
	FWErrorBits 	: SvrCh_t_s_SdiasFWStateStandard_PTofCls_SdiasBase;
	AO1 	: SvrCh_DINT;
	AO2 	: SvrCh_DINT;
	AO3 	: SvrCh_DINT;
	AO4 	: SvrCh_DINT;
	AO5 	: SvrCh_DINT;
	AO6 	: SvrCh_DINT;
	AO7 	: SvrCh_DINT;
	AO8 	: SvrCh_DINT;
	ExternVoltageOk 	: SvrCh_DINT;
  //Clients:
	AO1_Min 	: CltCh_DINT;
	AO1_Max 	: CltCh_DINT;
	AO2_Min 	: CltCh_DINT;
	AO2_Max 	: CltCh_DINT;
	AO3_Min 	: CltCh_DINT;
	AO3_Max 	: CltCh_DINT;
	AO4_Min 	: CltCh_DINT;
	AO4_Max 	: CltCh_DINT;
	AO5_Min 	: CltCh_DINT;
	AO5_Max 	: CltCh_DINT;
	AO6_Min 	: CltCh_DINT;
	AO6_Max 	: CltCh_DINT;
	AO7_Min 	: CltCh_DINT;
	AO7_Max 	: CltCh_DINT;
	AO8_Min 	: CltCh_DINT;
	AO8_Max 	: CltCh_DINT;
  //Variables:
		bsChangeFlag : BSINT
		[
		  1 AO1_2,
		  2 AO3_4,
		  3 AO5_6,
		  4 AO7_8,
		];
			//! <Variable Comment="Bitfield indicates Change of Output-Server." Name="bsChangeFlag"/>
		eInitSSW 	: t_InitSSW;			//! <Variable Comment="Initialisation Statemachine." Name="eInitSSW"/>
		eInitSSWErrorStep 	: t_InitSSW;			//! <Variable Comment="Initialisation Statemachine in case of an Error." Name="eInitSSWErrorStep"/>
		eResponseState 	: t_ResponseState;			//! <Variable Comment="Actual Response State of the SDO Communication." Name="eResponseState"/>
		pReadData 	: ^t_ReadData;			//! <Variable Comment="Read-Data from the Module." Name="pReadData"/>
		pWriteData 	: ^t_WriteData;			//! <Variable Comment="WriteData of the Module." Name="pWriteData"/>
		sCfgFirmware 	: t_CfgFirmware;			//! <Variable Comment="Configuration Data for the Firmware." Name="sCfgFirmware"/>
		sModuleStatus 	: t_ReadData;			//! <Variable Comment="Actual Status of the Module, which gets read from the Hardware." Name="sModuleStatus"/>
		sOutputValues 	: t_WriteData;			//! <Variable Comment="Outputvalues for the Hardware." Name="sOutputValues"/>
		sStateFirmware 	: t_StateFirmware;			//! <Variable Comment="FW Informations of the Module." Name="sStateFirmware"/>
		udSDOTimeout 	: UDINT;			//! <Variable Comment="Timeout for SDO-Communication." Name="udSDOTimeout"/>
		aMul : ARRAY [0..7] OF DINT;

		aDiv : ARRAY [0..7] OF DINT;

		aMinMaxOutput : ARRAY [0..7] OF t_MinMaxRange;

  //Functions:
				//! <Function Comment="Constructor of Class." Name="AO081"/>
	FUNCTION AO081
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment="Realtime Update Methode which runs in PreScan." Name="UpdateRt"/>
	FUNCTION VIRTUAL GLOBAL UpdateRt;
				//! <Function Comment="Realtime Update Methode which runs in PostScan." Name="UpdateRtPostScan"/>
	FUNCTION VIRTUAL GLOBAL UpdateRtPostScan;
				//! <Function Comment="Methode is called if this Module gets connected." Name="ConnectEvent"/>
	FUNCTION VIRTUAL GLOBAL ConnectEvent;
				//! <Function Comment="Methode is called if this Module gets disconnected." Name="DisconnectEvent"/>
	FUNCTION VIRTUAL GLOBAL DisconnectEvent;
				//! <Function Comment="Methode should be used to run a Statemachine to Initialize the Module." Name="InitModule"/>
	FUNCTION VIRTUAL GLOBAL InitModule
		VAR_OUTPUT
			eModuleInitState 	: iprStates;			//! <Variable Comment="Return BUSY until the Initialisation is finished." Name="InitModule.eModuleInitState"/>
		END_VAR;
				//! <Function Comment="This Methode is used, to check the DeviceID of the Module." Name="CheckDeviceID"/>
	FUNCTION VIRTUAL GLOBAL CheckDeviceID
		VAR_INPUT
			udID2Check 	: UDINT;			//! <Variable Comment="Device ID of connected Module." Name="CheckDeviceID.udID2Check"/>
		END_VAR
		VAR_OUTPUT
			bIsOK 	: BOOL;			//! <Variable Comment="FALSE = Wrong DeviceID for Module&#13;&#10;TRUE  = DeviceID of Module is correct" Name="CheckDeviceID.bIsOK"/>
		END_VAR;
				//! <Function Comment="Methode to receive the Response in case of SDO-Communication." Name="ReceiveSDOResponse"/>
	FUNCTION VIRTUAL ReceiveSDOResponse
		VAR_INPUT
			eCommand 	: t_SDIAS_SDO_Cmd;			//! <Variable Comment="Type of SDO-Command" Name="ReceiveSDOResponse.eCommand"/>
			hOffset 	: HINT;			//! <Variable Comment="Address-Offset in Module." Name="ReceiveSDOResponse.hOffset"/>
			usLength 	: USINT;			//! <Variable Comment="Length of Data." Name="ReceiveSDOResponse.usLength"/>
			eResult 	: iprStates;			//! <Variable Comment="State of SDO-Communication." Name="ReceiveSDOResponse.eResult"/>
			pResponseBuffer 	: ^USINT;			//! <Variable Comment="Pointer of ResponseBuffer, where the SDO-Data is located." Name="ReceiveSDOResponse.pResponseBuffer"/>
			ResponseLength 	: USINT;			//! <Variable Comment="Size of the ResponseBuffer." Name="ReceiveSDOResponse.ResponseLength"/>
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;			//! <Variable Comment="Indicates if the Methode was successful." Name="ReceiveSDOResponse.ret_code"/>
		END_VAR;
	
	FUNCTION VIRTUAL GetTaskCfg
		VAR_OUTPUT
			TaskCfg 	: BDINT;			//! <Variable Comment="Select which tasks will be available for this module:&#13;&#10;Bit0..Realtime PreScan&#13;&#10;Bit1..Realtime PostScan&#13;&#10;Bit2..Cyclic&#13;&#10;&#13;&#10;e.g. if only realtime postscan is needed:&#13;&#10;2#010" Name="GetTaskCfg.TaskCfg"/>
		END_VAR;
	
	FUNCTION VIRTUAL GetDeviceID
		VAR_OUTPUT
			output 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GetFWVersion
		VAR_INPUT
			pData 	: ^CHAR;
			Length 	: UDINT;
		END_VAR;
				//! <Function Comment="Methode to calc OutputValue depending on Scaling of the Outputs." Name="CalcScaleInv"/>
	FUNCTION CalcScaleInv
		VAR_INPUT
			ScaleVal 	: DINT;			//! <Variable Comment="Value to Scale into Binary Value." Name="CalcScaleInv.ScaleVal"/>
			MinVal 	: DINT;			//! <Variable Comment="Minimum Value." Name="CalcScaleInv.MinVal"/>
			Index 	: DINT;			//! <Variable Comment="Maximum Value." Name="CalcScaleInv.Index"/>
		END_VAR
		VAR_OUTPUT
			BinVal 	: INT;			//! <Variable Comment="Binary Value as Result." Name="CalcScaleInv.BinVal"/>
		END_VAR;
				//! <Function Comment="Methode reset all Server-Values." Name="ResetServer"/>
	FUNCTION ResetServer;
	
	FUNCTION GetggT
		VAR_INPUT
			Var1 	: DINT;
			Var2 	: DINT;
		END_VAR
		VAR_OUTPUT
			ggT 	: DINT;
		END_VAR;
	
	FUNCTION CalcScale
		VAR_INPUT
			MinScale 	: DINT;
			MaxScale 	: DINT;
			Index 	: DINT;
		END_VAR;
	
	FUNCTION GetMinMaxRange
		VAR_INPUT
			ClientMinRange 	: DINT;
			ClientMaxRange 	: DINT;
			pMinMaxValue 	: ^t_MinMaxRange;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AO1::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AO2::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AO3::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AO4::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AO5::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AO6::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AO7::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AO8::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB AO081::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_AO081
1$UINT, 37$UINT, (SIZEOF(::AO081))$UINT, 
11$UINT, 16$UINT, 0$UINT, 
TO_UDINT(49059806), "AO081", //Class
TO_UDINT(3175101883), "SdiasBase", 1$UINT, 60$UINT, //Baseclass
//Servers:
(::AO081.FirmwareVersion.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(389440282), "FirmwareVersion", 
(::AO081.FWErrorBits.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3888132073), "FWErrorBits", 
(::AO081.AO1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2821090581), "AO1", 
(::AO081.AO2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(825179311), "AO2", 
(::AO081.AO3.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1177029689), "AO3", 
(::AO081.AO4.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3628898714), "AO4", 
(::AO081.AO5.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2940971276), "AO5", 
(::AO081.AO6.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(910358710), "AO6", 
(::AO081.AO7.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1095092256), "AO7", 
(::AO081.AO8.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3522876849), "AO8", 
(::AO081.ExternVoltageOk.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2634085790), "ExternVoltageOk", 
//Clients:
(::AO081.AO1_Min.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1185681792), "AO1_Min", 
(::AO081.AO1_Max.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2057383641), "AO1_Max", 
(::AO081.AO2_Min.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(17591120), "AO2_Min", 
(::AO081.AO2_Max.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1023497225), "AO2_Max", 
(::AO081.AO3_Min.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1013727968), "AO3_Min", 
(::AO081.AO3_Max.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(6389177), "AO3_Max", 
(::AO081.AO4_Min.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2387386096), "AO4_Min", 
(::AO081.AO4_Max.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2990645673), "AO4_Max", 
(::AO081.AO5_Min.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3006052160), "AO5_Min", 
(::AO081.AO5_Max.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2401339417), "AO5_Max", 
(::AO081.AO6_Min.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(4102868368), "AO6_Min", 
(::AO081.AO6_Max.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3363959497), "AO6_Max", 
(::AO081.AO7_Min.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3387745312), "AO7_Min", 
(::AO081.AO7_Max.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(4125219705), "AO7_Max", 
(::AO081.AO8_Min.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1270641649), "AO8_Min", 
(::AO081.AO8_Max.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2008108200), "AO8_Max", 
END_FUNCTION


#define USER_CNT_AO081 25

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_AO081] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION AO081::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= SdiasBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= SdiasBase::ClassState.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, SdiasBase::ClassState.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_AO081;
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #UpdateRt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #UpdateRtPostScan();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #ConnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #DisconnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #InitModule();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #CheckDeviceID();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #ReceiveSDOResponse();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #GetTaskCfg();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #GetDeviceID();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[15]		:= #GetFWVersion();

#pragma warning (default : 74)
	SdiasBase::ClassState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF SdiasBase::ClassState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AO1.pMeth			:= StoreMethod( #M_RD_DIRECT(), #AO1::Write() );
	IF AO1.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AO2.pMeth			:= StoreMethod( #M_RD_DIRECT(), #AO2::Write() );
	IF AO2.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AO3.pMeth			:= StoreMethod( #M_RD_DIRECT(), #AO3::Write() );
	IF AO3.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AO4.pMeth			:= StoreMethod( #M_RD_DIRECT(), #AO4::Write() );
	IF AO4.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AO5.pMeth			:= StoreMethod( #M_RD_DIRECT(), #AO5::Write() );
	IF AO5.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AO6.pMeth			:= StoreMethod( #M_RD_DIRECT(), #AO6::Write() );
	IF AO6.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AO7.pMeth			:= StoreMethod( #M_RD_DIRECT(), #AO7::Write() );
	IF AO7.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AO8.pMeth			:= StoreMethod( #M_RD_DIRECT(), #AO8::Write() );
	IF AO8.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= AO081();

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION VIRTUAL GLOBAL AO081::UpdateRt
  
  sModuleStatus := pReadData^;

  // Set Error bits
  FWErrorBits.ErrorBits := sModuleStatus.Status;

  ExternVoltageOk := sModuleStatus.Status.VoltageNotOk XOR 1;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL AO081::UpdateRtPostScan
  
  if bsChangeFlag then
    if bsChangeFlag.AO1_2 then   
      // on 4 byte access is faster than two 2 byte accesses on PCI
      pWriteData^.AO1_2 := sOutputValues.AO1_2;
    end_if;
   
    if bsChangeFlag.AO3_4 then     
      // on 4 byte access is faster than two 2 byte accesses on PCI
      pWriteData^.AO3_4 := sOutputValues.AO3_4;
    end_if;
    
    
    if bsChangeFlag.AO5_6 then
      // on 4 byte access is faster than two 2 byte accesses on PCI
      pWriteData^.AO5_6 := sOutputValues.AO5_6;
    end_if;
    
    if bsChangeFlag.AO7_8 then    
      // on 4 byte access is faster than two 2 byte accesses on PCI
      pWriteData^.AO7_8 := sOutputValues.AO7_8;
    end_if;
    bsChangeFlag      := 0;
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL AO081::InitModule
	VAR_OUTPUT
		eModuleInitState 	: iprStates;
	END_VAR
  VAR
  	TmpRetcode      :iprStates;
  END_VAR
  
  eModuleInitState := BUSY;

  CASE eInitSSW OF
//**********************************************************************************************************************************************************
    _InitVariables:
    
      AO1_Min := AO1_Min.Read();
      AO1_Max := AO1_Max.Read();
      AO2_Min := AO2_Min.Read();
      AO2_Max := AO2_Max.Read();
      AO3_Min := AO3_Min.Read();
      AO3_Max := AO3_Max.Read();
      AO4_Min := AO4_Min.Read();
      AO4_Max := AO4_Max.Read();
      AO5_Min := AO5_Min.Read();
      AO5_Max := AO5_Max.Read();
      AO6_Min := AO6_Min.Read();
      AO6_Max := AO6_Max.Read();
      AO7_Min := AO7_Min.Read();
      AO7_Max := AO7_Max.Read();
      AO8_Min := AO8_Min.Read();
      AO8_Max := AO8_Max.Read();
      
      GetMinMaxRange(ClientMinRange:=AO1_Min, ClientMaxRange:=AO1_Max, pMinMaxValue:=#aMinMaxOutput[0]);
      GetMinMaxRange(ClientMinRange:=AO2_Min, ClientMaxRange:=AO2_Max, pMinMaxValue:=#aMinMaxOutput[1]);
      GetMinMaxRange(ClientMinRange:=AO3_Min, ClientMaxRange:=AO3_Max, pMinMaxValue:=#aMinMaxOutput[2]);
      GetMinMaxRange(ClientMinRange:=AO4_Min, ClientMaxRange:=AO4_Max, pMinMaxValue:=#aMinMaxOutput[3]);
      GetMinMaxRange(ClientMinRange:=AO5_Min, ClientMaxRange:=AO5_Max, pMinMaxValue:=#aMinMaxOutput[4]);
      GetMinMaxRange(ClientMinRange:=AO6_Min, ClientMaxRange:=AO6_Max, pMinMaxValue:=#aMinMaxOutput[5]);
      GetMinMaxRange(ClientMinRange:=AO7_Min, ClientMaxRange:=AO7_Max, pMinMaxValue:=#aMinMaxOutput[6]);
      GetMinMaxRange(ClientMinRange:=AO8_Min, ClientMaxRange:=AO8_Max, pMinMaxValue:=#aMinMaxOutput[7]);

     
      // Set the MinValue if AO is out of Range
      if (AO1_Max < AO1) | (AO1_Min > AO1) then
        AO1 := AO1_Min;
      end_if;
      if (AO2_Max < AO2) | (AO2_Min > AO2) then
        AO2 := AO2_Min;
      end_if;
      if (AO3_Max < AO3) | (AO3_Min > AO3) then
        AO3 := AO3_Min;
      end_if;
      if (AO4_Max < AO4) | (AO4_Min > AO4) then
        AO4 := AO4_Min;
      end_if;
      if (AO5_Max < AO5) | (AO5_Min > AO5) then
        AO5 := AO5_Min;
      end_if;
      if (AO6_Max < AO6) | (AO6_Min > AO6) then
        AO6 := AO6_Min;
      end_if;
      if (AO7_Max < AO7) | (AO7_Min > AO7) then
        AO7 := AO7_Min;
      end_if;
      if (AO8_Max < AO8) | (AO8_Min > AO8) then
        AO8 := AO8_Min;
      end_if;
      
      // calculate the scales
      CalcScale(MinScale:=AO1_Min, MaxScale:=AO1_Max, Index:=0);
      CalcScale(MinScale:=AO2_Min, MaxScale:=AO2_Max, Index:=1);
      CalcScale(MinScale:=AO3_Min, MaxScale:=AO3_Max, Index:=2);
      CalcScale(MinScale:=AO4_Min, MaxScale:=AO4_Max, Index:=3);
      CalcScale(MinScale:=AO5_Min, MaxScale:=AO5_Max, Index:=4);
      CalcScale(MinScale:=AO6_Min, MaxScale:=AO6_Max, Index:=5);
      CalcScale(MinScale:=AO7_Min, MaxScale:=AO7_Max, Index:=6);
      CalcScale(MinScale:=AO8_Min, MaxScale:=AO8_Max, Index:=7);

      sOutputValues.AO1_2.Output1 := CalcScaleInv(AO1, AO1_Min, 0);
      sOutputValues.AO1_2.Output2 := CalcScaleInv(AO2, AO2_Min, 1);
      sOutputValues.AO3_4.Output1 := CalcScaleInv(AO3, AO3_Min, 2);
      sOutputValues.AO3_4.Output2 := CalcScaleInv(AO4, AO4_Min, 3);
      sOutputValues.AO5_6.Output1 := CalcScaleInv(AO5, AO5_Min, 4);
      sOutputValues.AO5_6.Output2 := CalcScaleInv(AO6, AO6_Min, 5);
      sOutputValues.AO7_8.Output1 := CalcScaleInv(AO7, AO7_Min, 6);
      sOutputValues.AO7_8.Output2 := CalcScaleInv(AO8, AO8_Min, 7);
      
      // for first access
      bsChangeFlag.AO1_2 := 1;
      bsChangeFlag.AO3_4 := 1;
      bsChangeFlag.AO5_6 := 1;
      bsChangeFlag.AO7_8 := 1;
             
      ExternVoltageOk := 0;
      
      sCfgFirmware.Info.PmbModus                      := FALSE;
      sCfgFirmware.Info.BootloaderUpdateRequ          := FALSE;    
      sCfgFirmware.DataLength                         := sizeof(t_CfgFirmware) - sizeof(t_CfgFirmware.CRC) - sizeof(t_CfgFirmware.DataLength);
      sCfgFirmware.CRC                                := CheckSum_16(pData:=(#sCfgFirmware.Info)$^UINT, uiDataLength:= sCfgFirmware.DataLength, uiCrcStart:=16#FFFF);
      
      eInitSSW := _ConfigModule;
      
//**********************************************************************************************************************************************************
    _ConfigModule:
      case eResponseState of
        _idle:
          TmpRetcode  := StartWriteSDO(hOffset:=AO081_ADDR_CFG_FIRMWARE, usLength:=sizeof(t_CfgFirmware), pWriteBuffer:=(#sCfgFirmware)$^USINT, eCommand:=SDIAS_SDO_CMD_MEM_WRITE);
          if TmpRetcode = READY then
            udSDOTimeout  := ops.tAbsolute;
            eResponseState:= _wait; 
          elsif TmpRetcode = ERROR then
            eModuleInitState := ERROR;
            LogError("@ZZZZ (AO081::InitModule) Failed to add write SDO for firmware configuration");
            eInitState := _NoMem;
          end_if;
          //*****************************************************
        _wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > AO081_SDO_RESPONSE_TIMEOUT) then
            LogError("@ZZZZ (AO081::InitModule) SDO Response timeout config module");
            eInitSSWErrorStep := eInitSSW;
            eInitSSW := _InitError;
          end_if;
        //*****************************************************
        _valid:
          eInitSSW        := _ReadState;
          eResponseState  := _idle;
        //*****************************************************
      end_case;
      
//**********************************************************************************************************************************************************
    _ReadState:
      case eResponseState of
        _idle:
          TmpRetcode  := StartReadSDO(hOffset:=AO081_ADDR_STATE_FIRMWARE, usLength:=sizeof(t_StateFirmware), eCommand:=SDIAS_SDO_CMD_MEM_READ);
          if TmpRetcode = READY then
            udSDOTimeout  := ops.tAbsolute;
            eResponseState:= _wait; 
          elsif TmpRetcode = ERROR then
            eModuleInitState := ERROR;
            LogError("@ZZZZ (AO081::InitModule) Failed to add read SDO for firmware info");
            eInitState := _NoMem;
          end_if; 
          //*****************************************************
        _wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > AO081_SDO_RESPONSE_TIMEOUT) then
            LogError("@ZZZZ (AO081::InitModule) SDO Response timeout read state");
            eInitSSWErrorStep := eInitSSW;
            eInitSSW := _InitError;
          end_if;
        //*****************************************************
        _valid:
          if sStateFirmware.DataLength = (sizeof(t_StateFirmware) - sizeof(t_StateFirmware.CRC) - sizeof(t_StateFirmware.DataLength)) then
            if sStateFirmware.CRC = CheckSum_16(pData:=(#sStateFirmware.FirmwareVersion)$^UINT, uiDataLength:=sStateFirmware.DataLength, uiCrcStart:=16#FFFF) then
              FirmwareVersion := (sStateFirmware.FirmwareVersion and 16#0000FFFF)$HDINT;
              eInitSSW         := _Finish;
              eResponseState   := _idle;
            else
              eModuleInitState := ERROR;
              LogError("@ZZZZ (AO081::InitModule) Invalid checksum at firmware info");
              eInitState := _ClientNotready;
            end_if;
          else
            eModuleInitState := ERROR;
            LogError("@ZZZZ (AO081::InitModule) Invalid length at firmware info");
            eInitState := _ClientNotready;
          end_if;
      end_case;
//**********************************************************************************************************************************************************
    _Finish:
      eInitSSW         := _InitVariables;
      eModuleInitState := READY;
      eInitState      := _ClassOk;
      
//**********************************************************************************************************************************************************
    _InitError:
      eModuleInitState := ERROR; 
      if (eInitState <> _InvalidConfguration) then
        eInitState      := _ClientNotready;
      end_if;   
      
//**********************************************************************************************************************************************************

  END_CASE;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AO081::CheckDeviceID
	VAR_INPUT
		udID2Check 	: UDINT;
	END_VAR
	VAR_OUTPUT
		bIsOK 	: BOOL;
	END_VAR
  
	//look if it is right hardware
	if ( udID2Check <> DEVICE_ID_AO081 ) then
		bIsOK := FALSE;
	else
    bIsOK := TRUE;
	end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL AO081::ConnectEvent

  // start the accesses on the SDIAS (initialize the control byte in the DPRAM)
  if DefaultAccesses.ReadAccess.pControlByte then
    pReadData := DefaultAccesses.ReadAccess.pData$^t_ReadData;

    DefaultAccesses.ReadAccess.pControlByte^.EnableDO := TRUE;
  else
    eInitState := _DOHandleInvalid;
    return;
  end_if;
  
  if DefaultAccesses.WriteAccess.pControlByte then
    pWriteData := DefaultAccesses.WriteAccess.pData$^t_WriteData;

    DefaultAccesses.WriteAccess.pControlByte^.EnableDO := TRUE;
  else
    eInitState := _DOHandleInvalid;
    return;
  end_if;
  
  // Reset output memory area
  _memset(pWriteData, 0, sizeof(t_WriteData));

  eInitSSW := _InitVariables;
  eResponseState := _idle;
  eInitState    := _NotInitialized;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AO081::DisconnectEvent

  if pWriteData then
    // Reset output memory area
    _memset(pWriteData, 0, sizeof(t_WriteData));
  end_if;

  //Set invalid Values on Server
  ResetServer();

  SdiasBase::DisconnectEvent();

END_FUNCTION


FUNCTION VIRTUAL AO081::ReceiveSDOResponse
	VAR_INPUT
		eCommand 	: t_SDIAS_SDO_Cmd;
		hOffset 	: HINT;
		usLength 	: USINT;
		eResult 	: iprStates;
		pResponseBuffer 	: ^USINT;
		ResponseLength 	: USINT;
	END_VAR
	VAR_OUTPUT
		ret_code 	: iprStates;
	END_VAR
  
  ret_code := SdiasBase::ReceiveSDOResponse(eCommand, hOffset, usLength, eResult, pResponseBuffer, ResponseLength);

  // spi access from baseclass                                         
  if bSDOResponseHandle = TRUE then
    return;
  end_if;

  if eResult = READY then
    
    case eCommand of
      SDIAS_SDO_CMD_MEM_WRITE:
        case hOffset of
          AO081_ADDR_CFG_FIRMWARE:
            if eResponseState = _wait then
              eResponseState := _valid;
            end_if;           
        end_case;
        
      SDIAS_SDO_CMD_MEM_READ:
        case hOffset of
          AO081_ADDR_STATE_FIRMWARE:
            if eResponseState = _wait then
              eResponseState := _valid;
            end_if;
            
            sStateFirmware := pResponseBuffer^$t_StateFirmware;
        end_case;
    end_case;
    
    if eResponseState <> _valid then
      LogError("@ZZZZ (AO081::ReceiveSDOResponse) Error in response data of SDO");
      eInitSSW := _InitError;      
    end_if;
  else
    case eCommand of
      SDIAS_SDO_CMD_MEM_WRITE:
        LogError("@ZZZZ (AO081::ReceiveSDOResponse) Error while writing the firmware configuration");
      SDIAS_SDO_CMD_MEM_READ:
        LogError("@ZZZZ (AO081::ReceiveSDOResponse) Error while waiting for the firmware state");
    end_case;
    eInitSSW := _InitError;
  end_if;
 
END_FUNCTION


FUNCTION VIRTUAL GLOBAL AO081::AO1::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
  // Only react to changing Values
  if AO1 <> input then  
    // Check input borders
    if input > aMinMaxOutput[0].MaxRangeValue then
      input := aMinMaxOutput[0].MaxRangeValue;
    end_if;
    if input < aMinMaxOutput[0].MinRangeValue then
      input := aMinMaxOutput[0].MinRangeValue;
    end_if;
  
    AO1 := input;    
    
    // Convert Scaled Server Value to corresponding binary value (value sent to the module)
    sOutputValues.AO1_2.Output1 := CalcScaleInv(AO1, AO1_Min, 0);
    
    bsChangeFlag.AO1_2 := 1; 
    result := AO1;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AO081::AO2::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
  // Only react to changing Values
  if AO2 <> input then  
    // Check input borders
    if input > aMinMaxOutput[1].MaxRangeValue then
      input := aMinMaxOutput[1].MaxRangeValue;
    end_if;
    if input < aMinMaxOutput[1].MinRangeValue then
      input := aMinMaxOutput[1].MinRangeValue;
    end_if;
  
    AO2 := input;    
    
    // Convert Scaled Server Value to corresponding binary value (value sent to the module)
    sOutputValues.AO1_2.Output2 := CalcScaleInv(AO2, AO2_Min, 1);
    
    bsChangeFlag.AO1_2 := 1; 
    result := AO2;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AO081::AO3::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  // Only react to changing Values
  if AO3 <> input then  
    // Check input borders
    if input > aMinMaxOutput[2].MaxRangeValue then
      input := aMinMaxOutput[2].MaxRangeValue;
    end_if;
    if input < aMinMaxOutput[2].MinRangeValue then
      input := aMinMaxOutput[2].MinRangeValue;
    end_if;
  
    AO3 := input;    
    
    // Convert Scaled Server Value to corresponding binary value (value sent to the module)
    sOutputValues.AO3_4.Output1 := CalcScaleInv(AO3, AO3_Min, 2);
    
    bsChangeFlag.AO3_4 := 1; 
    result := AO3;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AO081::AO4::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  // Only react to changing Values
  if AO4 <> input then  
    // Check input borders
    if input > aMinMaxOutput[3].MaxRangeValue then
      input := aMinMaxOutput[3].MaxRangeValue;
    end_if;
    if input < aMinMaxOutput[3].MinRangeValue then
      input := aMinMaxOutput[3].MinRangeValue;
    end_if;
  
    AO4 := input;    
    
    // Convert Scaled Server Value to corresponding binary value (value sent to the module)
    sOutputValues.AO3_4.Output2 := CalcScaleInv(AO4, AO4_Min, 3);
    
    bsChangeFlag.AO3_4 := 1; 
    result := AO4;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AO081::AO5::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  // Only react to changing Values
  if AO5 <> input then  
    // Check input borders
    if input > aMinMaxOutput[4].MaxRangeValue then
      input := aMinMaxOutput[4].MaxRangeValue;
    end_if;
    if input < aMinMaxOutput[4].MinRangeValue then
      input := aMinMaxOutput[4].MinRangeValue;
    end_if;
  
    AO5 := input;    
    
    // Convert Scaled Server Value to corresponding binary value (value sent to the module)
    sOutputValues.AO5_6.Output1 := CalcScaleInv(AO5, AO5_Min, 4);
    
    bsChangeFlag.AO5_6 := 1; 
    result := AO5;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AO081::AO6::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  // Only react to changing Values
  if AO6 <> input then  
    // Check input borders
    if input > aMinMaxOutput[5].MaxRangeValue then
      input := aMinMaxOutput[5].MaxRangeValue;
    end_if;
    if input < aMinMaxOutput[5].MinRangeValue then
      input := aMinMaxOutput[5].MinRangeValue;
    end_if;
  
    AO6 := input;    
    
    // Convert Scaled Server Value to corresponding binary value (value sent to the module)
    sOutputValues.AO5_6.Output2 := CalcScaleInv(AO6, AO6_Min, 5);
    
    bsChangeFlag.AO5_6 := 1; 
    result := AO6;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AO081::AO7::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  // Only react to changing Values
  if AO7 <> input then  
    // Check input borders
    if input > aMinMaxOutput[6].MaxRangeValue then
      input := aMinMaxOutput[6].MaxRangeValue;
    end_if;
    if input < aMinMaxOutput[6].MinRangeValue then
      input := aMinMaxOutput[6].MinRangeValue;
    end_if;
  
    AO7 := input;    
    
    // Convert Scaled Server Value to corresponding binary value (value sent to the module)
    sOutputValues.AO7_8.Output1 := CalcScaleInv(AO7, AO7_Min, 6);
    
    bsChangeFlag.AO7_8 := 1; 
    result := AO7;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AO081::AO8::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  // Only react to changing Values
  if AO8 <> input then  
    // Check input borders
    if input > aMinMaxOutput[7].MaxRangeValue then
      input := aMinMaxOutput[7].MaxRangeValue;
    end_if;
    if input < aMinMaxOutput[7].MinRangeValue then
      input := aMinMaxOutput[7].MinRangeValue;
    end_if;
  
    AO8 := input;    
    
    // Convert Scaled Server Value to corresponding binary value (value sent to the module)
    sOutputValues.AO7_8.Output2 := CalcScaleInv(AO8, AO8_Min, 7);
    
    bsChangeFlag.AO7_8 := 1; 
    result := AO8;
  end_if;

END_FUNCTION


FUNCTION AO081::CalcScaleInv
	VAR_INPUT
		ScaleVal 	: DINT;
		MinVal 	: DINT;
		Index 	: DINT;
	END_VAR
	VAR_OUTPUT
		BinVal 	: INT;
	END_VAR

  BinVal := to_int(AO081_FIRMWARE_MIN + (aMul[Index] * (ScaleVal - MinVal)) / aDiv[Index]);
  
END_FUNCTION


FUNCTION AO081::ResetServer
  
  //Reset FWVersion
  FirmwareVersion := 0;
  
  //Reset Stati of Module
  FWErrorBits$DINT  := 0;
  ExternVoltageOk   := 0;

END_FUNCTION


FUNCTION AO081::AO081
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR
  VAR
  	i : DINT;
  END_VAR

  
  // Set invalid Values on Server
  ResetServer();

  // init divisors to prevent crash if someone sets an output in the first init
  for i := 0 to 7 do
    aDiv[i] := 1;
  end_for;
  
	ret_code := C_OK;

END_FUNCTION


FUNCTION VIRTUAL AO081::GetTaskCfg
	VAR_OUTPUT
		TaskCfg 	: BDINT;
	END_VAR

  TaskCfg := SDIAS_TASK_MASK_RT_PRE OR SDIAS_TASK_MASK_RT_POST;

END_FUNCTION


FUNCTION VIRTUAL AO081::GetDeviceID
	VAR_OUTPUT
		output 	: UDINT;
	END_VAR
  
  output := DEVICE_ID_AO081;
  
END_FUNCTION


FUNCTION VIRTUAL AO081::GetFWVersion
	VAR_INPUT
		pData 	: ^CHAR;
		Length 	: UDINT;
	END_VAR
  
  //Check pointer
  if pData then
    //Length of Firmwareversion (HDINT) -> 8Byte +1 byte zero termination
    if Length >= 9 then
      _itoa(udNumber:=FirmwareVersion, pString:=pData);  
    else
      pData^ := 0;
    end_if; 
  end_if;
  
END_FUNCTION


FUNCTION AO081::GetggT
	VAR_INPUT
		Var1 	: DINT;
		Var2 	: DINT;
	END_VAR
	VAR_OUTPUT
		ggT 	: DINT;
	END_VAR

  if Var2 = 0 then
    ggT := Var1;
  else
    ggT := GetggT(Var1:=Var2, Var2:=Var1 MOD Var2);
  end_if;

END_FUNCTION


FUNCTION AO081::CalcScale
	VAR_INPUT
		MinScale 	: DINT;
		MaxScale 	: DINT;
		Index 	: DINT;
	END_VAR
  VAR
  	ggtValue : DINT;
  END_VAR

  ggtValue := GetggT(Var1:=MaxScale-MinScale, Var2:=AO081_FIRMWARE_MAX - AO081_FIRMWARE_MIN);
  
  aMul[Index] := (AO081_FIRMWARE_MAX - AO081_FIRMWARE_MIN) / ggtValue;
  aDiv[Index] := (MaxScale - MinScale) / ggtValue;

END_FUNCTION


FUNCTION AO081::GetMinMaxRange
	VAR_INPUT
		ClientMinRange 	: DINT;
		ClientMaxRange 	: DINT;
		pMinMaxValue 	  : ^t_MinMaxRange;
	END_VAR
  
  if ClientMinRange < ClientMaxRange then
    pMinMaxValue^.MinRangeValue := ClientMinRange;
    pMinMaxValue^.MaxRangeValue := ClientMaxRange;
  else    
    pMinMaxValue^.MinRangeValue := ClientMaxRange;
    pMinMaxValue^.MaxRangeValue := ClientMinRange;
  end_if;

END_FUNCTION