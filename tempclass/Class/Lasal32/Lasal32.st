//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION
#include "..\..\Class\Lasal32\Lasal32Def.h"

(*!
<Class
	Name               = "Lasal32"
	Revision           = "1.4"
	GUID               = "{37AA1DBB-7DAC-4EFA-89EC-17B41149FBF1}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(300,120)"
	Comment            = "Is used to transfer all instructions from the Lasal32 protocol instruction&#13;&#10; ">
	<Channels>
		<Server Name="ClassSvr" GUID="{26365142-90FF-47DD-9AFB-026311E575A5}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="object channel to call the global methods"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\ComTypes.h" Include="false"/>
			<File Path=".\Lsl_st_ifssr.h" Include="false"/>
			<File Path=".\Class\Lasal32\Lasal32c.c"/>
			<File Path=".\Rtos_interfaces.h" Include="false"/>
			<File Path=".\Class\Lasal32\Lasal32Def.h" Include="true"/>
			<File Path=".\lsl_st_onl.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="HoeAnt"/>
		<Dokumentation Revision="1.4" Date="2017-04-07" Author="HubChr" Company="Sigmatek" Description="Type FILE_INFO is now virtual"/>
		<Dokumentation Revision="1.3" Date="2014-10-30" Author="HubChr" Company="Sigmatek" Description="Added functionality to update os of remote station&#13;&#10;Added functionality to get os version of remote station"/>
		<Dokumentation Revision="1.2" Date="2012-03-23" Author="SteAnd" Company="Sigmatek" Description="!!!IMPORTANT: OS version 01.02.155 or higher is required for &quot;ONL_xxx&quot; methods!!!&#13;&#10;Improvement:&#13;&#10;Now the communication is no longer over Loader functions. Instead of Loader functins we use OS functions.&#13;&#10;Please take the &quot;ONL_xxx&quot; and &quot;xxxImproved&quot; functions for communications&#13;&#10;Added and improved methods:&#13;&#10;- All &quot;xxxImproved&quot; methods&#13;&#10;- ONL_REQUEST and ONL_SETSENDINTERVAL&#13;&#10;If you take the old methods, a Cyclic Runtime at the connected CPU can be occur"/>
		<Dokumentation Revision="1.1" Date="2012-03-09" Author="spimar" Company="Sigmatek" Description="Big local variables were set to member variables to save memory on the stack;"/>
		<Dokumentation Revision="1.0" Date="2011-09-27" Author="hötant" Company="Sigmatek" Description="add the online fuctions ; add comment of all functions"/>
	</RevDoku>
</Class>
*)
Lasal32 : CLASS
	TYPE
#pragma pack(push, 1)
	  FILE_INFO : STRUCT  //! <Type Public="true" Name="FILE_INFO"/>
	    fileName : ARRAY [0..7] OF USINT;
	    extension : ARRAY [0..2] OF USINT;
	    attributes : USINT;
	    dateTime : UDINT;  //! <Type Comment="Bit-field of date and time of last modification: sec(div by 2):0..4;min:5..10; hour:11..15;day:16..20; month:21..24;year(since 1980):25..31" Name="FILE_INFO.dateTime"/>
	    fileSize : DINT;
	  END_STRUCT;
#pragma pack(pop)
	  Lasal32Cmd : STRUCT
	    status : iprStates;
	    reason : comlinkReason;
	    pComdef : ^Comdef;
	    cmd : USINT;
	    pWrData : ^USINT;
	    nSend : UDINT;
	    pWrData2 : ^USINT;
	    nSend2 : UDINT;
	    pRdData : ^USINT;
	    nRdSize : UDINT;
	    nRecv : UDINT;
	    nReceived : UDINT;
	    addRdTv_ms : UDINT;
	    dataOfs : UDINT;
	    segNbr : UINT;
	    segNbrResp : UINT;
	    cmdStatus : USINT;
	    cpuStatus : USINT;
	    awlBpStatus : USINT;
	    hdrBuf : ARRAY [0..255] OF USINT;
	    recvBuf : ARRAY [0..255] OF USINT;
	  END_STRUCT;
	  Lasal32Block : STRUCT
	    pComdef : ^Comdef;
	    nbrOfBlocks : UDINT;
	    nextBlkNbr : UDINT;
	    pLslCmd : ^Lasal32Cmd;
	    pData : ^USINT;
	    dataLen : UDINT;
	    dataOfs : UDINT;
	    userData : ARRAY [0..255] OF USINT;
	  END_STRUCT;
	  tLasal32CmdIMPROVED : STRUCT
	    status : iprStates;
	    reason : comlinkReason;
	    OnlHandle : DINT;
	    cmd : USINT;
	    pWrData : ^USINT;
	    nSend : UDINT;
	    pWrData2 : ^USINT;
	    nSend2 : UDINT;
	    pRdData : ^USINT;
	    nRdSize : UDINT;
	    nMinRecv : UDINT;
	    nReceived : UDINT;
	    addRdTv_ms : UDINT;
	    dataOfs : UDINT;
	    segNbr : UINT;
	    segNbrResp : UINT;
	    cmdStatus : USINT;
	    cpuStatus : USINT;
	    awlBpStatus : USINT;
	    hdrBuf : ARRAY [0..255] OF USINT;
	    recvBuf : ARRAY [0..255] OF USINT;
	  END_STRUCT;
#pragma pack(push, 1)
	  tLasal32BlockIMPROVED : STRUCT
	    OnlHandle : DINT;
	    nbrOfBlocks : UDINT;
	    nextBlkNbr : UDINT;
	    pLslCmd : ^tLasal32CmdIMPROVED;
	    pData : ^USINT;
	    dataLen : UDINT;
	    dataOfs : UDINT;
	    userData : ARRAY [0..255] OF USINT;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
  //Clients:
  //Variables:
		CILError 	: DINT;			//! <Variable Comment="0.. Interface found&#13;&#10;1.. Interface not available&#13;&#10;2.. OS version to old. ( &gt;= 01.02.160)" Name="CILError"/>
		pLslOnl 	: ^OS_LSLONL;			//! <Variable Comment="Interface structure of OS to call&#13;&#10;the needed function" Name="pLslOnl"/>
		LastError 	: DINT;
		tmpclsName : ARRAY [0..999] OF CHAR;

		tmpdataBufferFlag : ARRAY [0..999] OF CHAR;

  //Functions:
	
	FUNCTION Lasal32
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment="Supplies the CPU status code for a remote PLC" Name="GetCpuStatus"/>
	FUNCTION GLOBAL GetCpuStatus
		VAR_INPUT
			pComdef 	: ^Comdef;			//! <Variable Comment="pComdef : ^Comdef  Pointer to a Comdef structure&#13;&#10;" Name="GetCpuStatus.pComdef"/>
			pCpuStatus 	: ^USINT;			//! <Variable Comment="pCpuStatus : ^USINT  Pointer to the CPU status variable&#13;&#10;" Name="GetCpuStatus.pCpuStatus"/>
			pReason 	: ^comlinkReason;			//! <Variable Comment="pReason : ^comlink Reason local reason code&#13;&#10;" Name="GetCpuStatus.pReason"/>
		END_VAR
		VAR_OUTPUT
			Status 	: iprStates;			//! <Variable Comment="Status: iprStates  Transfer status " Name="GetCpuStatus.Status"/>
		END_VAR;
				//! <Function Comment="Writes data in a file to a remote PLC. The actual data transfer is made by calling the FileSave_Work-Method." Name="FileSave"/>
	FUNCTION GLOBAL FileSave
		VAR_INPUT
			pComdef 	: ^Comdef;			//! <Variable Comment="pComdef : ^Comdef Pointer to a Comdef structure&#13;&#10;" Name="FileSave.pComdef"/>
			fileName 	: ^CHAR;			//! <Variable Comment="fileName : ^CHAR File name&#13;&#10;" Name="FileSave.fileName"/>
			pData 	: ^USINT;			//! <Variable Comment="pData : ^USINT Data to be sent&#13;&#10;" Name="FileSave.pData"/>
			len 	: UDINT;			//! <Variable Comment="len: UDINT Data size&#13;&#10;" Name="FileSave.len"/>
		END_VAR
		VAR_OUTPUT
			cmdHandle 	: UDINT;			//! <Variable Comment="cmdHandle : UDINT Handle for _work method" Name="FileSave.cmdHandle"/>
		END_VAR;
	
	FUNCTION LslCmd2
		VAR_INPUT
			pComdef 	: ^Comdef;
			cmd 	: USINT;
			pWrData 	: ^USINT;
			nSend 	: UDINT;
			pWrData2 	: ^USINT;
			nSend2 	: UDINT;
			pRdData 	: ^USINT;
			nRdSize 	: UDINT;
			nRecv 	: UDINT;
			pnReceived 	: ^UDINT;
			addRdTv_ms 	: UDINT;
			pCpuStatus 	: ^USINT;
			pAwlBpStatus 	: ^USINT;
			pReason 	: ^comlinkReason;
		END_VAR
		VAR_OUTPUT
			Status 	: iprStates;
		END_VAR;
	
	FUNCTION LslCmd
		VAR_INPUT
			pComdef 	: ^Comdef;
			cmd 	: USINT;
			pWrData 	: ^USINT;
			nSend 	: UDINT;
			pRdData 	: ^USINT;
			nRdSize 	: UDINT;
			nRecv 	: UDINT;
			pnReceived 	: ^UDINT;
			addRdTv_ms 	: UDINT;
			pCpuStatus 	: ^USINT;
			pAwlBpStatus 	: ^USINT;
			pReason 	: ^comlinkReason;
		END_VAR
		VAR_OUTPUT
			Status 	: iprStates;
		END_VAR;
	
	FUNCTION Work
		VAR_INPUT
			pLslCmd 	: ^Lasal32Cmd;
		END_VAR
		VAR_OUTPUT
			status 	: iprStates;
		END_VAR;
	
	FUNCTION NewLasal32Cmd
		VAR_INPUT
			pComdef 	: ^Comdef;
			cmd 	: USINT;
			pWrData 	: ^USINT;
			nSend 	: UDINT;
			pWrData2 	: ^USINT;
			nSend2 	: UDINT;
			pRdData 	: ^USINT;
			nRdSize 	: UDINT;
			nRecv 	: UDINT;
			addRdTv_ms 	: UDINT;
		END_VAR
		VAR_OUTPUT
			pLasal32Cmd 	: ^Lasal32Cmd;
		END_VAR;
	
	FUNCTION DeleteLasal32Cmd
		VAR_INPUT
			pLasal32Cmd 	: ^Lasal32Cmd;
		END_VAR;
				//! <Function Comment="_Work method for FileSave." Name="FileSave_Work"/>
	FUNCTION GLOBAL FileSave_Work
		VAR_INPUT
			cmdHandle 	: UDINT;			//! <Variable Comment="cmdHandle : UDINT Handle&#13;&#10;" Name="FileSave_Work.cmdHandle"/>
			pErrCodeRemote 	: ^DINT;			//! <Variable Comment="pErrCodeRemote : ^DINT  Remote error code &#13;&#10;" Name="FileSave_Work.pErrCodeRemote"/>
			pReason 	: ^comlinkReason;			//! <Variable Comment="pReason : ^comlinkReason  l local reason code&#13;&#10;" Name="FileSave_Work.pReason"/>
		END_VAR
		VAR_OUTPUT
			status 	: iprStates;			//! <Variable Comment="Status: iprStates Transfer status" Name="FileSave_Work.status"/>
		END_VAR;
				//! <Function Comment="Reads data from a file in a remote PLC. The data transfer is made by calling the FileLoad_Work method." Name="FileLoad"/>
	FUNCTION GLOBAL FileLoad
		VAR_INPUT
			pComdef 	: ^Comdef;			//! <Variable Comment="pComdef : ^Comdef  Pointer to a Comdef structure&#13;&#10;" Name="FileLoad.pComdef"/>
			fileName 	: ^CHAR;			//! <Variable Comment="fileName : ^CHAR  File name&#13;&#10;" Name="FileLoad.fileName"/>
			pData 	: ^USINT;			//! <Variable Comment="pData : ^USINT  Buffer for receive data" Name="FileLoad.pData"/>
			len 	: UDINT;			//! <Variable Comment="len: UDINT  Buffer size&#13;&#10;" Name="FileLoad.len"/>
		END_VAR
		VAR_OUTPUT
			cmdHandle 	: UDINT;			//! <Variable Comment="cmdHandle : UDINT  Handle for _work method" Name="FileLoad.cmdHandle"/>
		END_VAR;
	
	FUNCTION NewLasal32Block
		VAR_INPUT
			pComdef 	: ^Comdef;
			nbrOfBlocks 	: UDINT;
			pData 	: ^USINT;
			dataLen 	: UDINT;
		END_VAR
		VAR_OUTPUT
			pLasal32Block 	: ^Lasal32Block;
		END_VAR;
	
	FUNCTION DeleteLasal32Block
		VAR_INPUT
			pLasal32Block 	: ^Lasal32Block;
		END_VAR;
				//! <Function Comment="Provides diverse Information over a file." Name="FileInfo"/>
	FUNCTION GLOBAL FileInfo
		VAR_INPUT
			pComdef 	: ^Comdef;			//! <Variable Comment="pComdef : ^Comdef  Pointer to a Comdef structure&#13;&#10;" Name="FileInfo.pComdef"/>
			fileName 	: ^CHAR;			//! <Variable Comment="fileName : ^CHAR  File name" Name="FileInfo.fileName"/>
			pFileInfo 	: ^FILE_INFO;			//! <Variable Comment="pFileInfo : ^FILE_INFO  Result of the query &#13;&#10;" Name="FileInfo.pFileInfo"/>
			pReason 	: ^comlinkReason;			//! <Variable Comment="pReason : ^comlinkReason local reason code&#13;&#10;" Name="FileInfo.pReason"/>
		END_VAR
		VAR_OUTPUT
			Status 	: iprStates;			//! <Variable Comment="Status: iprStates  Transfer status" Name="FileInfo.Status"/>
		END_VAR;
				//! <Function Comment="Reads the time." Name="ReadTime"/>
	FUNCTION GLOBAL ReadTime
		VAR_INPUT
			pComdef 	: ^Comdef;			//! <Variable Comment="pComdef : ^Comdef  Pointer to a Comdef structure&#13;&#10;" Name="ReadTime.pComdef"/>
			pSystemTime 	: ^LSLDATETIME;			//! <Variable Comment="pSystemTime : ^LSLDATETIME Result of the query&#13;&#10;" Name="ReadTime.pSystemTime"/>
			pReason 	: ^comlinkReason;			//! <Variable Comment="pReason : ^comlinkReason local reason code&#13;&#10;" Name="ReadTime.pReason"/>
		END_VAR
		VAR_OUTPUT
			Status 	: iprStates;			//! <Variable Comment="Status: iprStates  Transfer status" Name="ReadTime.Status"/>
		END_VAR;
				//! <Function Comment="Determines the time difference between local and remote PLCs. If a time difference is returned, it can be used for to call an AdjustTime to calibrate the clock of the remote PLC." Name="GetTimeDiff"/>
	FUNCTION GLOBAL GetTimeDiff
		VAR_INPUT
			pComdef 	: ^Comdef;			//! <Variable Comment="pComdef : ^Comdef  Pointer to a Comdef structure&#13;&#10;" Name="GetTimeDiff.pComdef"/>
			pTimeDiff 	: ^LSLTIMESTAMP;			//! <Variable Comment="pTimeDiff : ^LSLTIMESTAMP Result of the query&#13;&#10;" Name="GetTimeDiff.pTimeDiff"/>
			pReason 	: ^comlinkReason;			//! <Variable Comment="pReason : ^comlinkReason local reason code&#13;&#10;" Name="GetTimeDiff.pReason"/>
		END_VAR
		VAR_OUTPUT
			Status 	: iprStates;			//! <Variable Comment="Status: iprStates  Transfer status" Name="GetTimeDiff.Status"/>
		END_VAR;
				//! <Function Comment="Changes the time of a remote PLC. A time difference must be provided. The format for the time difference consists of 2 UDINT values whereas one gives the split-second value and the 2nd gives the full second value. To calibrate the time of 2 CPUs, the value supplied by the GetTimeDiff function can be used for the time difference." Name="AdjustTime"/>
	FUNCTION GLOBAL AdjustTime
		VAR_INPUT
			pComdef 	: ^Comdef;			//! <Variable Comment="pComdef : ^Comdef  Pointer to a Comdef structure&#13;&#10;" Name="AdjustTime.pComdef"/>
			pTimeDiff 	: ^LSLTIMESTAMP;			//! <Variable Comment="pTimeDiff : ^LSLTIMESTAMP Time difference&#13;&#10;" Name="AdjustTime.pTimeDiff"/>
			pReason 	: ^comlinkReason;			//! <Variable Comment="pReason : ^comlinkReason local reason code&#13;&#10;" Name="AdjustTime.pReason"/>
		END_VAR
		VAR_OUTPUT
			Status 	: iprStates;			//! <Variable Comment="Status: iprStates  Transfer status" Name="AdjustTime.Status"/>
		END_VAR;
				//! <Function Comment="_Work method for FileLoad." Name="FileLoad_Work"/>
	FUNCTION GLOBAL FileLoad_Work
		VAR_INPUT
			cmdHandle 	: UDINT;			//! <Variable Comment="cmdHandle : UDINT  Handle&#13;&#10;" Name="FileLoad_Work.cmdHandle"/>
			pReason 	: ^comlinkReason;			//! <Variable Comment="pReason : ^comlinkReason  local reason code&#13;&#10;" Name="FileLoad_Work.pReason"/>
		END_VAR
		VAR_OUTPUT
			status 	: iprStates;			//! <Variable Comment="Status: iprStates  Transfer status" Name="FileLoad_Work.status"/>
		END_VAR;
	
	FUNCTION GLOBAL GetCpuStatusImproved
		VAR_INPUT
			OnlHandle 	: DINT;
			pCpuStatus 	: ^USINT;
			pReason 	: ^comlinkReason;
		END_VAR
		VAR_OUTPUT
			Status 	: iprStates;
		END_VAR;
	
	FUNCTION GLOBAL FileSaveImproved
		VAR_INPUT
			OnlHandle 	: DINT;
			fileName 	: ^CHAR;
			pData 	: ^USINT;
			len 	: UDINT;
		END_VAR
		VAR_OUTPUT
			cmdHandle 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL FileSave_WorkImproved
		VAR_INPUT
			cmdHandle 	: UDINT;
			pErrCodeRemote 	: ^DINT;
			pReason 	: ^comlinkReason;
		END_VAR
		VAR_OUTPUT
			status 	: iprStates;
		END_VAR;
	
	FUNCTION GLOBAL FileLoadImproved
		VAR_INPUT
			OnlHandle 	: DINT;
			fileName 	: ^CHAR;
			pData 	: ^USINT;
			len 	: UDINT;
		END_VAR
		VAR_OUTPUT
			cmdHandle 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL FileLoad_WorkImproved
		VAR_INPUT
			cmdHandle 	: UDINT;
			pReason 	: ^comlinkReason;
		END_VAR
		VAR_OUTPUT
			status 	: iprStates;
		END_VAR;
	
	FUNCTION GLOBAL FileInfoImproved
		VAR_INPUT
			OnlHandle 	: DINT;
			pfileName 	: ^CHAR;
			pFileInfo 	: ^FILE_INFO;
			pReason 	: ^comlinkReason;
		END_VAR
		VAR_OUTPUT
			Status 	: iprStates;
		END_VAR;
	
	FUNCTION GLOBAL ReadTimeImproved
		VAR_INPUT
			OnlHandle 	: DINT;
			pSystemTime 	: ^LSLDATETIME;
			pReason 	: ^comlinkReason;
		END_VAR
		VAR_OUTPUT
			Status 	: iprStates;
		END_VAR;
	
	FUNCTION GLOBAL GetTimeDiffImproved
		VAR_INPUT
			OnlHandle 	: DINT;
			pTimeDiff 	: ^LSLTIMESTAMP;
			pReason 	: ^comlinkReason;
		END_VAR
		VAR_OUTPUT
			Status 	: iprStates;
		END_VAR;
	
	FUNCTION GLOBAL AdjustTimeImproved
		VAR_INPUT
			OnlHandle 	: DINT;
			pTimeDiff 	: ^LSLTIMESTAMP;
			pReason 	: ^comlinkReason;
		END_VAR
		VAR_OUTPUT
			Status 	: iprStates;
		END_VAR;
				//! <Function Comment="establish a connection via CAN-Bus" Name="ONL_OPEN_CAN"/>
	FUNCTION GLOBAL ONL_OPEN_CAN
		VAR_INPUT
			addr 	: ^OS_LSLONL_ADDR_CAN;			//! <Variable Comment="insert a pointer to your &#13;&#10;address configuration.&#13;&#10;&#13;&#10;( Connection Can-Station 10  :&#13;&#10;&#13;&#10;OnlType := ONLTYPE_CAN;&#13;&#10;CanDestStation := 10;&#13;&#10;&#13;&#10;)&#13;&#10;" Name="ONL_OPEN_CAN.addr"/>
		END_VAR
		VAR_OUTPUT
			descr_num 	: DINT;			//! <Variable Comment="connection handle&#13;&#10;&gt;= 0 .... valid" Name="ONL_OPEN_CAN.descr_num"/>
		END_VAR;
				//! <Function Comment="establish a connection via TCPIP" Name="ONL_OPEN_TCPIP"/>
	FUNCTION GLOBAL ONL_OPEN_TCPIP
		VAR_INPUT
			addr 	: ^OS_LSLONL_ADDR_TCPIP;			//! <Variable Comment="insert a pointer to your &#13;&#10;address configuration.&#13;&#10;&#13;&#10;( Connection TCP Hostaddress  : 10.11.150.1&#13;&#10;&#13;&#10;OnlType := ONLTYPE_TCPIP&#13;&#10;InterfaceNbr :=1;&#13;&#10;IP1 := 10;&#13;&#10;IP2 := 11;&#13;&#10;IP3 := 150;&#13;&#10;IP4 ;= 1;&#13;&#10;&#13;&#10;)" Name="ONL_OPEN_TCPIP.addr"/>
		END_VAR
		VAR_OUTPUT
			descr_num 	: DINT;			//! <Variable Comment="connection handle&#13;&#10;&gt;= 0 .... valid" Name="ONL_OPEN_TCPIP.descr_num"/>
		END_VAR;
				//! <Function Comment="close the connection&#13;&#10;( opend with ONL_OPEN_CAN or ONL_OPEN_TCPIP )" Name="ONL_CLOSE"/>
	FUNCTION GLOBAL ONL_CLOSE
		VAR_INPUT
			descr_num 	: DINT;			//! <Variable Comment="connection handle returned from function&#13;&#10;ONL_OPEN_CAN or ONL_OPEN_TCPIP" Name="ONL_CLOSE.descr_num"/>
		END_VAR
		VAR_OUTPUT
			retval 	: DINT;			//! <Variable Comment="Return - Code of the function.&#13;&#10;( in case of an error you can&#13;&#10;find the errordefinition at file&#13;&#10;Lasal32def.h and lsl_st_onl.h)" Name="ONL_CLOSE.retval"/>
		END_VAR;
				//! <Function Comment="change the state of a remote PLC to RESET ( F8 )&#13;&#10;( connection defined with : ONL_OPEN_CAN or ONL_OPEN_TCPIP )" Name="ONL_RESETSPS"/>
	FUNCTION GLOBAL ONL_RESETSPS
		VAR_INPUT
			descr_num 	: DINT;			//! <Variable Comment="connection handle returned from function&#13;&#10;ONL_OPEN_CAN or ONL_OPEN_TCPIP" Name="ONL_RESETSPS.descr_num"/>
		END_VAR
		VAR_OUTPUT
			retval 	: DINT;			//! <Variable Comment="Return - Code of the function.&#13;&#10;( in case of an error you can&#13;&#10;find the errordefinition at file&#13;&#10;Lasal32def.h and lsl_st_onl.h)" Name="ONL_RESETSPS.retval"/>
		END_VAR;
				//! <Function Comment="change the state of a remote PLC to RUN RAM ( F7 )&#13;&#10;( connection defined with : ONL_OPEN_CAN or ONL_OPEN_TCPIP )" Name="ONL_RUNSPS"/>
	FUNCTION GLOBAL ONL_RUNSPS
		VAR_INPUT
			descr_num 	: DINT;			//! <Variable Comment="connection handle returned from function&#13;&#10;ONL_OPEN_CAN or ONL_OPEN_TCPIP" Name="ONL_RUNSPS.descr_num"/>
		END_VAR
		VAR_OUTPUT
			retval 	: DINT;			//! <Variable Comment="Return - Code of the function.&#13;&#10;( in case of an error you can&#13;&#10;find the errordefinition at file&#13;&#10;Lasal32def.h and lsl_st_onl.h)" Name="ONL_RUNSPS.retval"/>
		END_VAR;
				//! <Function Comment="get the state of a remote PLC&#13;&#10;( connection defined with : ONL_OPEN_CAN or ONL_OPEN_TCPIP )" Name="ONL_GETCPUSTATUS"/>
	FUNCTION GLOBAL ONL_GETCPUSTATUS
		VAR_INPUT
			descr_num 	: DINT;			//! <Variable Comment="connection handle returned from function&#13;&#10;ONL_OPEN_CAN or ONL_OPEN_TCPIP" Name="ONL_GETCPUSTATUS.descr_num"/>
			status 	: ^_LSLONL_STATUS_PLC;			//! <Variable Comment="the state of the configured connection&#13;&#10;will be written to this pointer" Name="ONL_GETCPUSTATUS.status"/>
		END_VAR
		VAR_OUTPUT
			retval 	: DINT;			//! <Variable Comment="Return - Code of the function.&#13;&#10;( in case of an error you can&#13;&#10;find the errordefinition at file&#13;&#10;Lasal32def.h and lsl_st_onl.h)" Name="ONL_GETCPUSTATUS.retval"/>
		END_VAR;
				//! <Function Comment="get the objectaddress from a remote server&#13;&#10;( connection defined with : ONL_OPEN_CAN or ONL_OPEN_TCPIP )" Name="ONL_GETOBJECT"/>
	FUNCTION GLOBAL ONL_GETOBJECT
		VAR_INPUT
			descr_num 	: DINT;			//! <Variable Comment="connection handle returned from function&#13;&#10;ONL_OPEN_CAN or ONL_OPEN_TCPIP" Name="ONL_GETOBJECT.descr_num"/>
			objName 	: ^CHAR;			//! <Variable Comment="Insert the name of Server you want to know&#13;&#10;Objectname.Servername  -&gt; &quot;Objectname.Servername&quot;" Name="ONL_GETOBJECT.objName"/>
			objAddr 	: ^UDINT;			//! <Variable Comment="the Objectaddress of configured &#13;&#10;Server ( objName ) will be written &#13;&#10;to this pointer." Name="ONL_GETOBJECT.objAddr"/>
		END_VAR
		VAR_OUTPUT
			retval 	: DINT;			//! <Variable Comment="Return - Code of the function.&#13;&#10;( in case of an error you can&#13;&#10;find the errordefinition at file&#13;&#10;Lasal32def.h and lsl_st_onl.h)" Name="ONL_GETOBJECT.retval"/>
		END_VAR;
				//! <Function Comment="read a server of a remote station.&#13;&#10;( connection defined with : ONL_OPEN_CAN or ONL_OPEN_TCPIP &#13;&#10;  server defined with : ONL_GETOBJECT )" Name="ONL_READSERVER"/>
	FUNCTION GLOBAL ONL_READSERVER
		VAR_INPUT
			descr_num 	: DINT;			//! <Variable Comment="connection handle returned from function&#13;&#10;ONL_OPEN_CAN or ONL_OPEN_TCPIP" Name="ONL_READSERVER.descr_num"/>
			objAddr 	: UDINT;			//! <Variable Comment="Object address returned from function&#13;&#10;ONL_GETOBJECT" Name="ONL_READSERVER.objAddr"/>
			data 	: ^UDINT;			//! <Variable Comment="the read value of configured &#13;&#10;Server will be written to this &#13;&#10;pointer" Name="ONL_READSERVER.data"/>
		END_VAR
		VAR_OUTPUT
			retval 	: DINT;			//! <Variable Comment="Return - Code of the function.&#13;&#10;( in case of an error you can&#13;&#10;find the errordefinition at file&#13;&#10;Lasal32def.h and lsl_st_onl.h)" Name="ONL_READSERVER.retval"/>
		END_VAR;
				//! <Function Comment="write a server of a remote station.&#13;&#10;( connection defined with : ONL_OPEN_CAN or ONL_OPEN_TCPIP &#13;&#10;  server defined with : ONL_GETOBJECT )" Name="ONL_WRITESERVER"/>
	FUNCTION GLOBAL ONL_WRITESERVER
		VAR_INPUT
			descr_num 	: DINT;			//! <Variable Comment="connection handle returned from function&#13;&#10;ONL_OPEN_CAN or ONL_OPEN_TCPIP" Name="ONL_WRITESERVER.descr_num"/>
			objAddr 	: UDINT;			//! <Variable Comment="Object address returned from function&#13;&#10;ONL_GETOBJECT" Name="ONL_WRITESERVER.objAddr"/>
			data 	: UDINT;			//! <Variable Comment="Value which should be written" Name="ONL_WRITESERVER.data"/>
			result 	: ^UDINT;			//! <Variable Comment="result of IPR Workstate&#13;&#10;&#13;&#10;READY,          interpreter command processed&#13;&#10;ERROR_IP,       i.e. wrong parameters&#13;&#10;ERROR_IP_BUSY,  i.e. stopping movement&#13;&#10;BUSY,           interpreter command processing&#13;&#10;QUIT,           No Interpreter?&#13;&#10;STOP_BP,        interpreter hangs in breakpoint&#13;&#10;SINGLESTEP      interpreter hangs in singlestep" Name="ONL_WRITESERVER.result"/>
		END_VAR
		VAR_OUTPUT
			retval 	: DINT;			//! <Variable Comment="Return - Code of the function.&#13;&#10;( in case of an error you can&#13;&#10;find the errordefinition at file&#13;&#10;Lasal32def.h and lsl_st_onl.h)" Name="ONL_WRITESERVER.retval"/>
		END_VAR;
				//! <Function Comment="Is used for communication over TCP/IP or CAN" Name="ONL_REQUEST"/>
	FUNCTION GLOBAL ONL_REQUEST
		VAR_INPUT
			descr_num 	: DINT;
			Cmd 	: USINT;
			InBuffer1 	: ^USINT;
			InBuffer1Size 	: UDINT;
			InBuffer2 	: ^USINT;
			InBuffer2Size 	: UDINT;
			InBufferSizeAll 	: UDINT;
			OutBuffer 	: ^USINT;
			OutBufferSize 	: UDINT;
			BytesReturned 	: ^UDINT;
			CpuStatus 	: ^USINT;
			fFirstRecPart 	: USINT;
			fLastRecPart 	: USINT;
		END_VAR
		VAR_OUTPUT
			retval 	: DINT;
		END_VAR;
	
	FUNCTION WorkImproved
		VAR_INPUT
			pLslCmd 	: ^tLasal32CmdIMPROVED;
		END_VAR
		VAR_OUTPUT
			status 	: iprStates;
		END_VAR;
	
	FUNCTION Lasal32CmdImproved
		VAR_INPUT
			OnlHandle 	: DINT;
			cmd 	: USINT;
			pWrData 	: ^USINT;
			nSend 	: UDINT;
			pWrData2 	: ^USINT;
			nSend2 	: UDINT;
			pRdData 	: ^USINT;
			nRdSize 	: UDINT;
			nRecv 	: UDINT;
			addRdTv_ms 	: UDINT;
		END_VAR
		VAR_OUTPUT
			pLasal32Cmd 	: ^tLasal32CmdIMPROVED;
		END_VAR;
	
	FUNCTION Lasal32BlockImproved
		VAR_INPUT
			OnlHandle 	: DINT;
			nbrOfBlocks 	: UDINT;
			pData 	: ^USINT;
			dataLen 	: UDINT;
		END_VAR
		VAR_OUTPUT
			pLasal32Block 	: ^tLasal32BlockIMPROVED;
		END_VAR;
	
	FUNCTION DeleteLasal32BlockImproved
		VAR_INPUT
			pLasal32Block 	: ^tLasal32BlockIMPROVED;
		END_VAR;
	
	FUNCTION DeleteLasal32CmdImproved
		VAR_INPUT
			pLasal32Cmd 	: ^tLasal32CmdIMPROVED;
		END_VAR;
	
	FUNCTION LslCmd2Improved
		VAR_INPUT
			OnlHandle 	: DINT;			//! <Variable Comment="connection handle" Name="LslCmd2Improved.OnlHandle"/>
			cmd 	: USINT;			//! <Variable Comment="With this parameter we set the command.&#13;&#10;The command predicates what we want to get" Name="LslCmd2Improved.cmd"/>
			pWrData 	: ^USINT;			//! <Variable Comment="send-buffer 1" Name="LslCmd2Improved.pWrData"/>
			nSend 	: UDINT;			//! <Variable Comment="size of sendbuffer 1" Name="LslCmd2Improved.nSend"/>
			pWrData2 	: ^USINT;			//! <Variable Comment="send-buffer 2" Name="LslCmd2Improved.pWrData2"/>
			nSend2 	: UDINT;			//! <Variable Comment="size of send-buffer 2" Name="LslCmd2Improved.nSend2"/>
			pRdData 	: ^USINT;			//! <Variable Comment="receive-buffer" Name="LslCmd2Improved.pRdData"/>
			nRdSize 	: UDINT;			//! <Variable Comment="size of receive-buffer" Name="LslCmd2Improved.nRdSize"/>
			nMinRecv 	: UDINT;			//! <Variable Comment="minimal size of receive data" Name="LslCmd2Improved.nMinRecv"/>
			pnReceived 	: ^UDINT;			//! <Variable Comment="shows, how many bytes did we receive" Name="LslCmd2Improved.pnReceived"/>
			addRdTv_ms 	: UDINT;			//! <Variable Comment="read timeout in ms" Name="LslCmd2Improved.addRdTv_ms"/>
			pCpuStatus 	: ^USINT;			//! <Variable Comment="shows the cpu-state of the connected cpu" Name="LslCmd2Improved.pCpuStatus"/>
			pAwlBpStatus 	: ^USINT;
			pReason 	: ^comlinkReason;			//! <Variable Comment="if an error occurs, this parameter shows why" Name="LslCmd2Improved.pReason"/>
		END_VAR
		VAR_OUTPUT
			Status 	: iprStates;
		END_VAR;
				//! <Function Comment="We need this for compatibly for older classes, because the type of the returncode of TX-Command (OLD! Loader method) is iprStates.&#13;&#10;Now it is a OS function and we get a DINT back." Name="OSErrorMapping"/>
	FUNCTION OSErrorMapping
		VAR_INPUT
			ActError 	: DINT;
		END_VAR
		VAR_OUTPUT
			Status 	: iprStates;
		END_VAR;
				//! <Function Comment="Set the internal wait time for CAN communication" Name="ONL_SETSENDINTERVAL"/>
	FUNCTION GLOBAL ONL_SETSENDINTERVAL
		VAR_INPUT
			Waittime 	: DINT;
		END_VAR
		VAR_OUTPUT
			retval 	: DINT;
		END_VAR;
				//! <Function Comment="To get the last unmapped occured error" Name="GetLastError"/>
	FUNCTION GLOBAL GetLastError
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
				//! <Function Comment="To achieve os-version from remote station." Name="ONL_GETOSVERSION"/>
	FUNCTION GLOBAL ONL_GETOSVERSION
		VAR_INPUT
			descr_num 	: DINT;			//! <Variable Comment="Communication handle as received by an ONL_OPEN method." Name="ONL_GETOSVERSION.descr_num"/>
			ver_major 	: ^DINT;			//! <Variable Comment="Major revision of the Operating System currently installed on remote station will be written to this address." Name="ONL_GETOSVERSION.ver_major"/>
			ver_minor 	: ^DINT;			//! <Variable Comment="Minor revision the Operating System currently installed on remote station will be written to this address." Name="ONL_GETOSVERSION.ver_minor"/>
		END_VAR
		VAR_OUTPUT
			retval 	: DINT;
		END_VAR;
				//! <Function Comment="Method to boot a previously loaded os-imagefile on remote station. Use method &quot;ONL_LOADOSIMAGE&quot; to load the os-image into the remote-station." Name="ONL_BOOTOSIMAGE"/>
	FUNCTION GLOBAL ONL_BOOTOSIMAGE
		VAR_INPUT
			descr_num 	: DINT;			//! <Variable Comment="communication handle" Name="ONL_BOOTOSIMAGE.descr_num"/>
		END_VAR
		VAR_OUTPUT
			retval 	: DINT;
		END_VAR;
				//! <Function Comment="Method to transfer OS-Image to remote station. File can be transferred either at once or in packets.&#13;&#10;&#13;&#10;When transferring in packets, ffirst has to be TRUE at first request and flast has to be true at last request.&#13;&#10;After transferring method ONL_BOOTOSIMAGE() can be used to update the Operating System." Name="ONL_LOADOSIMAGE"/>
	FUNCTION GLOBAL ONL_LOADOSIMAGE
		VAR_INPUT
			descr_num 	: DINT;			//! <Variable Comment="communication handle" Name="ONL_LOADOSIMAGE.descr_num"/>
			pData 	: ^CHAR;			//! <Variable Comment="points to the data to be transferred" Name="ONL_LOADOSIMAGE.pData"/>
			len 	: UDINT;			//! <Variable Comment="length of the data to transfer. If OS image is transferred in packets, &quot;len&quot; referes to the length of the individual data packet." Name="ONL_LOADOSIMAGE.len"/>
			lenAll 	: UDINT;			//! <Variable Comment="size of the complete OS image" Name="ONL_LOADOSIMAGE.lenAll"/>
			ffirst 	: USINT;			//! <Variable Comment="TRUE at first request" Name="ONL_LOADOSIMAGE.ffirst"/>
			flast 	: USINT;			//! <Variable Comment="TRUE at last request" Name="ONL_LOADOSIMAGE.flast"/>
		END_VAR
		VAR_OUTPUT
			retval 	: DINT;
		END_VAR;
				//! <Function Comment="To execute Command Line Interface commands on remote station." Name="ONL_SERVICEPROVIDER"/>
	FUNCTION GLOBAL ONL_SERVICEPROVIDER
		VAR_INPUT
			descr_num 	: DINT;
			pCmd 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			retval 	: DINT;
		END_VAR;
				//! <Function Comment="Provides information on a given error-code." Name="ONL_ERROR"/>
	FUNCTION GLOBAL ONL_ERROR
		VAR_INPUT
			dError 	: DINT;			//! <Variable Comment="Errorcode as received from other function" Name="ONL_ERROR.dError"/>
			pStrError 	: ^void;			//! <Variable Comment="Pointer to information-string will be written to this address." Name="ONL_ERROR.pStrError"/>
		END_VAR
		VAR_OUTPUT
			retval 	: DINT;			//! <Variable Comment="Since CIL-makro doesn&apos;t provide a return value, retval in this case only checks availability of CIL-interface and given parameters." Name="ONL_ERROR.retval"/>
		END_VAR;
				//! <Function Comment="Cancels running requests" Name="ONL_CANCELREQUEST"/>
	FUNCTION GLOBAL ONL_CANCELREQUEST
		VAR_INPUT
			descr_num 	: DINT;			//! <Variable Comment="Communication handle as received by ONL_OPEN method." Name="ONL_CANCELREQUEST.descr_num"/>
		END_VAR
		VAR_OUTPUT
			retval 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB Lasal32::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_LASAL32
1$UINT, 4$UINT, (SIZEOF(::Lasal32))$UINT, 
1$UINT, 0$UINT, 0$UINT, 
TO_UDINT(3286553581), "Lasal32", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::Lasal32.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
//Clients:
END_FUNCTION


#define USER_CNT_Lasal32 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_Lasal32] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION Lasal32::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_Lasal32, pCmd := #vmt.CmdTable);
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= Lasal32();

END_FUNCTION

//{{LSL_IMPLEMENTATION
(*
  Lasal32.st
  
  Diese Klasse stellt Funktion zur Übertragung von Befehlen aus dem 
  Befehlssatz des Lasal32 Protokolls über einen Comlink Kanal zur Verfügung.
  
  Die Funktionen sind für einen Comlink Kanal nicht thread-safe, da zur 
  Datenübertragung TxCommand verwendet wird und TxCommand pro Comlink Kanal 
  auch nicht thread-safe ist. Falls der Comlink Kanal auch noch von anderen 
  Softwareteilen verwendet wird, dann ist darauf zu achten, daß pro Comlink 
  Kanal die Aufrufe dieser Funktionen und die TxCommand Aufrufe der anderen 
  Softwareteils im selben Task gemacht werden.

  Wenn ein Befehl nicht in einem einzigen Segment Platz hat, dann gibt es 
  dafür 2 Methodenaufrufe:
  1.Lasal32::<Methode>
    - nimmt die Parameter des Befehls entgegen
    - liefert ein Handle zurück, das beim nachfolgenden Aufruf der _Work-
      Methode als Parameter übergeben wird.
  2.Lasal32::<Methode>_Work
    - erwartet sich als Parameter das Handle der vorigen Methode
    - überträgt ein Befehlssegment und gibt über den Returnwert die Info, 
      ob noch weitere Befehlssegmente überrtagen werden müssen (BUSY), ob 
      der Befehl vollständig übertragen wurde (READY) oder ob ein Fehler 
      aufgetreten ist (ERROR).
      
  Wichtig:
  Wenn ein Befehl in mehreren Segmenten übertragen wird, dann müssen Buffer 
  für Sende- und Empfangsdaten für die Dauer der Übertragung gültig sein. 
  Es ist z.B. nicht erlaubt, einen Sendebuffer zu verwenden, der sich am Stack 
  befindet. Wenn ein Buffer am Heap allokiert wird, dann darf er erst freigegeben 
  werden, wenn die Übertragung beendet worden ist !
  
  Die Übertragung eines Befehls oder eines Befehlssegments kann blockieren, da 
  für die Übertragung TXCOMMAND verwendet wird und TXCOMMAND keine asynchrone 
  Übertragung verwendet. Daher sollten diese Befehl nur in Hintergrund-Tasks 
  aufgerufen werden.
*)

//
// I_LSLCMD Befehl:
//	Mit dem I_LSLCMD Befehl wird ein Segment eines Lasal32 Online Befehls und dessen 
//  Antwort übertragen. Ein Befehl und die Antwort wird in Segmente unterteilt, weil 
//  mit dem Befipr Mechanismus pro Request nur max. 255(Tx)/254(Rx) Bytes übertragen 
//  werden können.
//  Jedes Segment wird mit einer segNbr numeriert (0-basierend). Anhand der segNbr 
//	können doppelte oder fehlende Segmente erkannt werden.
//	Zuerst werden die Segmente des Requests übertragen, danach werden die Segmente der 
//	Response angefordert. Das letzte Segment des Requests und das erste Segment der 
//	Response werden in einem einzigen Befipr Befehl übertragen.
//
// Aufbau eines Segments
// 
//   flags   : USINT
//   			Bit 7   : 1 = kennzeichnet letztes Segment
//   			Bit 6   : 1 = Anforderung eines Segments der Lasal32 Response.
//              			  Die angeforderte Segmentnummer steht im Feld seqNbr bzw. 
//                      wenn flags.7 = 1, dann wird Segmentnummer 0 angefordert.
//                      Dieses Bit kann nur im Befipr Code und nicht in der Befipr 
//                      Resu gesetzt sein.
//				Bit 5   : 1 = Single-Segment
//                      Bei einem Single-Segment fehlt segNbr. Die Segmentnummer 
//                      ist in diesem Fall 0.
//   segNbr  : UINT
//				Segmentnummer des Lasal32 Requests bzw. der (angeforderten) Response.
//   data    : ARRAY[0..??] OF USINT;
//				Die Daten des Segments. Die Anzahl der Daten wird aus dem Längenfeld 
//				des Befipr Befehls errechnet.
// 
// Verpackung des Segments im Befipr Befehl
//
// 	Instruct:
// 	a) Single-Segment
//		! uiLng(2B) ! opcode(1B) ! aData(255B)                                                !
//  	!                        ! flags(1B) ! data(254B)                                     !
//  	!                                    ! cmd(1B) ! data(253B)                           !
// 	b) Multi-Segment, 1.Segment
//		! uiLng(2B) ! opcode(1B) ! aData(255B)                                                !
//  	!                        ! flags(1B) ! segNbr(2B) ! reqLen(4B) ! data(248B)           !
//  	!                                                              ! cmd(1B) ! data(247B) !
// 	c) Multi-Segment, 2.+ Segment
//		! uiLng(2B) ! opcode(1B) ! aData(255B)                                                !
//  	!                        ! flags(1B) ! segNbr(2B) ! data(252B)                        !
//
// 	Results:
// 	a) 1.Segment
//		! uiLng(2B) ! aData(254B)                                                             !
//  	!           ! flags(1B) ! data(253B)                                                  !
//  	!                       ! status(1B) | cpuStatus(1B) ! extStatus(1B) ! data(250B)     !
// 	b) 2.+ Segment
//		! uiLng(2B) ! aData(254B)                                                             !
//  	!           ! flags(1B) ! data(253B)                                                  !
//
// Max. mögliche Datenmengen in einer 4-Segment Message:
//	Request:
//		1.Segment:	   1B Cmd, 248B Data
//  	2.-4.Segment:        3*252B Data
//      	           -----------------
//          	       1B Cmd, 1004B Data
//  Response:
//		1.Segment:	   3B Status, 250B Data
//  	2.-4.Segment:           3*253B Data
//                   --------------------
//                   3B Status, 1009B Data
//
//  Der Einfachheit halber und wg. einer Reserve für zukünftige Erweiterungen 
//  wird die max. mögliche Datenmenge auf 1000 Bytes festgelegt.
//


//#include <..\Runtime\Include\LSL\lsl_st_onl.h>

#define DEBUGIP_I_LSLCMD            59

#define DBG_CMD_TEST                0x02
#define DBG_CMD_SYN                 0x16
#define DBG_CMD_SAVE_FILE3          0x40
#define DBG_CMD_LOAD_FILE           0x22
#define DBG_CMD_FILE_INFO           0x23
#define DEB_CMD_FILEUPDATEINFO      0x58
#define DBG_CMD_READDATETIME        0x2B
#define DBG_CMD_ADJUSTDATETIME      0x2D

#define LSLOS_ERROR_GENERAL                     0xA0008013L

#define LASAL32_BLOCKSIZE           1000

//#pragma using _OSKernel

VAR_EXTERNAL
  // Es wird eine Variable benötigt, die mit einem Init-Wert versehen werden kann.
  // Das ist nur in C möglich. Hier ist die extern-Deklaration der Variablen aus dem 
  // C-File.
  // Variable: isInitialized (Initwert 0)
  _g_Lasal32_test : UDINT;
END_VAR

(*
  Diese Funktion dient zum Segmentieren eines Lasal32 Requests.
  Aus dem Befehlsbyte und den Nutzdaten wird eine Befipr Instruktion 
  zusammengestellt, die dann mit dem I_LSLCMD übertragen werden kann.
*)
FUNCTION GLOBAL Lasal32_MakeLslCmdInstruct
VAR_INPUT
  // in:
  cmd : USINT;          // Befehlsbyte. Nur gültig, wenn segNbr = 0
  pData1 : ^USINT;      // Zeiger auf die Segment-Nutzdaten (ohne Cmd). Nur gültig, wenn segNbrResp = 0
  dataLen1 : UDINT;     // Anzahl der Bytes in pData1
  pData2 : ^USINT;      // Zeiger auf die Segment-Nutzdaten (ohne Cmd). Nur gültig, wenn segNbrResp = 0
  dataLen2 : UDINT;     // Anzahl der Bytes in pData2
  dataOfs : UDINT;      // Offset innerhalb pData1 + pData2 (muß 0 sein, wenn seqNbr = 0 ist)
  segNbr : UINT;        // die 0-basierende Segmentnummer 
                        // (16#ffff = keine Requestdaten vorh., es wird nur ein Antwortseg. angefordert)
  segNbrResp : UINT;    // die angeforderte Segmentnummer der Antwort
  // out:
  pCode : ^INSTRUCT;    // die erstellte Befipr Instruktion
  pNewDataOfs : ^UDINT; // neuer pData Offset für den nächsten Aufruf (0=Ende)
END_VAR
VAR_OUTPUT
  retCode : BOOL;
END_VAR
VAR
  available : UDINT;    // verfügbarer Platz im aPara Feld der Instruktion
  isSingle : BOOL;      // TRUE=single segment
  isLast : BOOL;        // TRUE=letztes segment
  reqResp : BOOL;       // TRUE=Anforderung der Antwort
  pDest : ^USINT;
  nCopy : UDINT;
  dataLen : UDINT;      // Anzahl der Bytes in pData1 und pData2
  dataOfs1 : UDINT;     // Offset innerhalb pData1
  dataOfs2 : UDINT;     // Offset innerhalb pData2
END_VAR;

  retCode := TRUE;

  pCode^.uiLng  := 0;
  pCode^.opCode := DEBUGIP_I_LSLCMD$InstrSet;
  pNewDataOfs^ := 0;

  isSingle := FALSE;
  isLast := FALSE;
  reqResp := FALSE;

  available := sizeof(pCode^.aPara) - 1(*flags*);
  pDest := #pCode^.aPara[1];
  nCopy := 0;
  dataLen := dataLen1 + dataLen2;

  IF segNbr = 16#ffff THEN

    // es wird nur die Antwort angefordert
    pDest$^UINT^ := segNbrResp;
    pDest        += sizeof(segNbrResp);

    reqResp := TRUE;

  ELSIF segNbr = 0 & dataLen <= (available - 1) THEN
    // Single-Segment

    pDest^       := cmd;
    available    -= sizeof(cmd);
    pDest        += sizeof(cmd);

    // kopieren aus pData1
    nCopy := dataLen1;
    _memcpy(pDest, pData1, nCopy);
    pDest += nCopy;

    // kopieren aus pData2
    nCopy := dataLen2;
    _memcpy(pDest, pData2, nCopy);
    pDest += nCopy;

    isSingle := TRUE;
    isLast := TRUE;
    reqResp := TRUE;
  
  ELSE
    // Multi-Segment

    IF segNbr = 0 THEN
      // 1.Segment

      pDest$^UINT^ := segNbr;
      available    -= sizeof(segNbr);
      pDest        += sizeof(segNbr);

      pDest$^UDINT^:= dataLen;
      available    -= sizeof(dataLen);
      pDest        += sizeof(dataLen);

      pDest^       := cmd;
      available    -= sizeof(cmd);
      pDest        += sizeof(cmd);

    ELSE
      // 2.+ Segment

      pDest$^UINT^ := segNbr;
      available   -= sizeof(segNbr);
      pDest       += sizeof(segNbr);

    END_IF;

    IF dataOfs >= dataLen1 THEN
      dataOfs1 := 16#FFFFffff;
      dataOfs2 := dataOfs - dataLen1;
    ELSE
      dataOfs1 := dataOfs;
      dataOfs2 := 0;
    END_IF;

    // kopieren aus pData1
    IF dataOfs1 < dataLen1 THEN
      nCopy := available;
      IF nCopy > (dataLen1 - dataOfs1) THEN
        nCopy := dataLen1 - dataOfs1;
      END_IF;
      _memcpy(pDest, pData1 + dataOfs1, nCopy);
      pDest += nCopy;
      available -= nCopy;
      dataOfs += nCopy;
    END_IF;

    // kopieren aus pData2
    nCopy := available;
    IF nCopy > (dataLen2 - dataOfs2) THEN
      nCopy := dataLen2 - dataOfs2;
    END_IF;
    _memcpy(pDest, pData2 + dataOfs2, nCopy);
    pDest += nCopy;
    available -= nCopy;
    dataOfs += nCopy;

    IF dataOfs = dataLen THEN
      isLast := TRUE;
      reqResp := TRUE;
    ELSE
      pNewDataOfs^ := dataOfs;
    END_IF;

  END_IF;

  pCode^.aPara[0] := 0;
  IF isLast THEN
    pCode^.aPara[0] := pCode^.aPara[0] OR 16#80;
  END_IF;
  IF reqResp THEN
    pCode^.aPara[0] := pCode^.aPara[0] OR 16#40;
  END_IF;
  IF isSingle THEN
    pCode^.aPara[0] := pCode^.aPara[0] OR 16#20;
  END_IF;

  pCode^.uiLng := 2 + (pDest$UDINT - (#pCode^.aPara[0])$UDINT)$UINT;

END_FUNCTION


(*
  Schickt einen Lasal32 Befehl an eine Comlink Station.
  Es können 2 getrennte Sendebuffer angegeben werden.
*)
FUNCTION Lasal32::LslCmd2
	VAR_INPUT
		pComdef 	: ^Comdef;
    cmd : USINT;              // Kommando
    pWrData : ^USINT;         // Sendbuffer
    nSend : UDINT;            // Anzahl der zu sendenden Bytes
    pWrData2 : ^USINT;        // Sendbuffer2
    nSend2 : UDINT;           // Anzahl der zu sendenden Bytes im Buffer2
    pRdData : ^USINT;         // Empfangsbuffer
    nRdSize : UDINT;          // Größe des Empfangsbuffers
    nRecv : UDINT;            // minimale Anzahl zu lesender Bytes
    pnReceived : ^UDINT;      // Anzahl empfangener Bytes (NIL = uninteressant)
    addRdTv_ms : UDINT;       // zusätzlicher Read-Timeout in ms
    pCpuStatus : ^USINT;
    pAwlBpStatus : ^USINT;
    pReason : ^comlinkReason;	// reason-code in the case of an error
  END_VAR
  VAR_OUTPUT
    Status   : IPRSTATES;
  END_VAR
  VAR
    dataOfs : UDINT;      // Offset innerhalb pData
    segNbr : UINT;        // die 0-basierende Segmentnummer 
    segNbrResp : UINT;    // die angeforderte Segmentnummer der Antwort
    instr : INSTRUCT;
    newDataOfs : UDINT;   // neuer pData Offset für den nächsten Aufruf (0=Ende)
    resu : RESULTS;       // result buffer
    nReceived : UDINT;
    respLen : UINT;
    pRespData : ^USINT;
    respComplete : BOOL;
    flags : USINT;
    reason		: comlinkReason;
    cmdStatus : USINT;
    cpuStatus : USINT;
    awlBpStatus : USINT;
  END_VAR

  dataOfs := 0;
  segNbr := 0;
  segNbrResp := 0;
  nReceived := 0;
  respComplete := FALSE;

  IF pReason = NIL THEN
    pReason := #reason;
  END_IF;
  IF pCpuStatus = NIL THEN
    pCpuStatus := #cpuStatus;
  END_IF;
  IF pAwlBpStatus = NIL THEN
    pAwlBpStatus := #awlBpStatus;
  END_IF;

  REPEAT

    IF !!Lasal32_MakeLslCmdInstruct(cmd, pWrData, nSend, pWrData2, nSend2, 
                                    dataOfs, segNbr, segNbrResp,
                                    #instr, #newDataOfs) THEN
      Status := ERROR;
      pReason^ := COMLINK_ERR_GENERAL;
      RETURN;
    END_IF;
    
    
   
  	Status := TXCOMMANDEX(DEBUGIP_I_LSLCMD, instr.uiLng - 2, #instr.aPara[0], 
                          pComdef, #resu, sizeof(resu), pReason);
                          
    IF Status <> READY THEN
      RETURN;
    END_IF;

    IF resu.uiLng = 16#ffff THEN
      resu.uiLng := 0;
    END_IF;

    IF newDataOfs = 0 THEN
      // Antwortsegment auswerten
      IF resu.uiLng < 1 THEN
        Status := ERROR;
        pReason^ := COMLINK_ERR_GENERAL;
        RETURN;
      END_IF;
      flags := resu.aData[0];
      respLen := resu.uiLng - 2(*uiLng*) - 1(*flags*);
      pRespData := #resu.aData[1];
      IF segNbrResp = 0 THEN
        IF respLen >= 3 THEN
          // die ersten 3 Bytes der Antwort sind status, cpuStatus und extStatus
          cmdStatus := pRespData^;
          pCpuStatus^ := (pRespData + 1)^;
          pAwlBpStatus^ := (pRespData + 2)^;
          respLen -= 3;
          pRespData += 3;
        ELSE
          Status := ERROR;
          pReason^ := COMLINK_ERR_GENERAL;
          RETURN;
        END_IF;
      END_IF;
      IF pRdData <> NIL THEN
        IF nReceived + respLen > nRdSize THEN
          // der Empfangsbuffer ist zu klein
          Status := ERROR;
          pReason^ := COMLINK_ERR_GENERAL;
          RETURN;
        END_IF;
        _memcpy(pRdData + nReceived, pRespData, respLen);
      END_IF;
      nReceived += respLen;
      segNbr := 16#ffff;
      segNbrResp += 1;
      IF flags AND 16#80 THEN
        respComplete := TRUE;
      END_IF;
    ELSE
      // Befehlssegment wurde gesendet
      dataOfs := newDataOfs;
      segNbr += 1;
    END_IF;

  UNTIL respComplete END_REPEAT;

  IF pnReceived <> NIL THEN
    pnReceived^ := nReceived;
  END_IF;

  IF cmdStatus <> 0 THEN
    Status := ERROR;
    pReason^ := COMLINK_ERR_GENERAL;
    RETURN;
  END_IF;

  IF nReceived < nRecv THEN
    // zuwenig Daten empfangen
    Status := ERROR;
    pReason^ := COMLINK_ERR_GENERAL;
    RETURN;
  END_IF;

END_FUNCTION


FUNCTION Lasal32::LslCmd2Improved
	VAR_INPUT
		OnlHandle 	: DINT;
		cmd 	: USINT;
		pWrData 	: ^USINT;
		nSend 	: UDINT;
		pWrData2 	: ^USINT;
		nSend2 	: UDINT;
		pRdData 	: ^USINT;
		nRdSize 	: UDINT;
		nMinRecv 	: UDINT;
		pnReceived 	: ^UDINT;
		addRdTv_ms 	: UDINT;
		pCpuStatus 	: ^USINT;
		pAwlBpStatus 	: ^USINT;
		pReason 	: ^comlinkReason;
	END_VAR
	VAR_OUTPUT
		Status 	: iprStates;
	END_VAR
   VAR
    reason		    : comlinkReason;
    cpuStatus     : USINT;
    awlBpStatus   : USINT;
    Received      : UDINT;
    retval        : DINT;
  END_VAR

  IF pReason = NIL THEN
    pReason := #reason;
  END_IF;
  IF pCpuStatus = NIL THEN
    pCpuStatus := #cpuStatus;
  END_IF;
  IF pAwlBpStatus = NIL THEN
    pAwlBpStatus := #awlBpStatus;
  END_IF;
  if pnReceived = NIL then
    pnReceived := #Received;
  end_if;

  retval  :=  ONL_REQUEST(descr_num       := OnlHandle, 
                          Cmd             := cmd, 
                          InBuffer1       := pWrData, 
                          InBuffer1Size   := nSend, 
                          InBuffer2       := pWrData2,
                          InBuffer2Size   := nSend2,  
                          InBufferSizeAll := nSend + nSend2, 
                          OutBuffer       := pRdData,
                          OutBufferSize   := nRdSize,  
                          BytesReturned   := pnReceived, 
                          CpuStatus       := pCpuStatus, 
                          fFirstRecPart   := 1, 
                          fLastRecPart    := 1
                          );
    
                          
  IF retval <> 0 THEN  //Error occured
    //We need this for compatibly for older classes, because the type of the returncode of TX-Command is iprStates. Now it is a DINT.
    Status := OSErrorMapping(retval);
    RETURN;
  ELSE
    Status$DINT := retval;
  END_IF;

  
  IF (pnReceived = NIL) | (pnReceived^ < nMinRecv) THEN // zuwenig Daten empfangen
    Status := ERROR;
    pReason^ := COMLINK_ERR_GENERAL;
    RETURN;
  END_IF;

END_FUNCTION

(*
  Schickt einen Lasal32 Befehl an eine Comlink Station
*)
FUNCTION Lasal32::LslCmd
  VAR_INPUT
    pComdef : ^COMDEF; 
    cmd : USINT;              // Kommando
    pWrData : ^USINT;         // Sendbuffer
    nSend : UDINT;            // Anzahl der zu sendenden Bytes
    pRdData : ^USINT;         // Empfangsbuffer
    nRdSize : UDINT;          // Größe des Empfangsbuffers
    nRecv : UDINT;            // minimale Anzahl zu lesender Bytes
    pnReceived : ^UDINT;      // Anzahl empfangener Bytes (NIL = uninteressant)
    addRdTv_ms : UDINT;       // zusätzlicher Read-Timeout in ms
    pCpuStatus : ^USINT;
    pAwlBpStatus : ^USINT;
    pReason : ^comlinkReason;	// reason-code in the case of an error
  END_VAR
  VAR_OUTPUT
    Status   : IPRSTATES;
  END_VAR

  Status := LslCmd2(pComdef, cmd,
                    pWrData, nSend, NIL, 0,
                    pRdData, nRdSize, nRecv, pnReceived, addRdTv_ms,
                    pCpuStatus, pAwlBpStatus,	pReason);

END_FUNCTION


FUNCTION Lasal32::Work
	VAR_INPUT
		pLslCmd 	: ^Lasal32Cmd;
	END_VAR
	VAR_OUTPUT
		status 	: iprStates;
	END_VAR
  VAR
    respComplete : BOOL;
    instr : INSTRUCT;
    resu : RESULTS;       // result buffer
    newDataOfs : UDINT;   // neuer pData Offset für den nächsten Aufruf (0=Ende)
    flags : USINT;
    respLen : UINT;
    pRespData : ^USINT;
  END_VAR

  respComplete := FALSE;

  IF !!Lasal32_MakeLslCmdInstruct(pLslCmd^.cmd, 
                                  pLslCmd^.pWrData, 
                                  pLslCmd^.nSend, 
                                  pLslCmd^.pWrData2, 
                                  pLslCmd^.nSend2, 
                                  pLslCmd^.dataOfs, 
                                  pLslCmd^.segNbr, 
                                  pLslCmd^.segNbrResp,
                                  #instr, 
                                  #newDataOfs) THEN
    pLslCmd^.status := ERROR;
    GOTO End;
  END_IF;

  pLslCmd^.status := TXCOMMANDEX(DEBUGIP_I_LSLCMD, 
                                 instr.uiLng - 2, 
                                 #instr.aPara[0], 
                                 pLslCmd^.pComdef, 
                                 #resu, 
                                 sizeof(resu), 
                                 #pLslCmd^.reason);
  IF pLslCmd^.status <> READY THEN
    GOTO End;
  END_IF;

  IF resu.uiLng = 16#ffff THEN
    resu.uiLng := 0;
  END_IF;

  IF newDataOfs = 0 THEN
    // Antwortsegment auswerten
    IF resu.uiLng < 1 THEN
      pLslCmd^.status := ERROR;
      GOTO End;
    END_IF;
    flags := resu.aData[0];
    respLen := resu.uiLng - 2(*uiLng*) - 1(*flags*);
    pRespData := #resu.aData[1];
    IF pLslCmd^.segNbrResp = 0 THEN
      IF respLen >= 3 THEN
        // die ersten 3 Bytes der Antwort sind status, cpuStatus und extStatus
        pLslCmd^.cmdStatus := pRespData^;
        pLslCmd^.cpuStatus := (pRespData + 1)^;
        pLslCmd^.awlBpStatus := (pRespData + 2)^;
        respLen -= 3;
        pRespData += 3;
      ELSE
        pLslCmd^.status := ERROR;
        GOTO End;
      END_IF;
    END_IF;
    IF pLslCmd^.pRdData <> NIL THEN
      IF pLslCmd^.nReceived + respLen > pLslCmd^.nRdSize THEN
        // der Empfangsbuffer ist zu klein
        pLslCmd^.status := ERROR;
        GOTO End;
      END_IF;
      _memcpy(pLslCmd^.pRdData + pLslCmd^.nReceived, pRespData, respLen);
    END_IF;
    pLslCmd^.nReceived += respLen;
    pLslCmd^.segNbr := 16#ffff;
    pLslCmd^.segNbrResp += 1;
    IF flags AND 16#80 THEN
      respComplete := TRUE;
    END_IF;
  ELSE
    // Befehlssegment wurde gesendet
    pLslCmd^.dataOfs := newDataOfs;
    pLslCmd^.segNbr += 1;
  END_IF;

  IF respComplete THEN
  
    IF pLslCmd^.cmdStatus <> 0 THEN
      pLslCmd^.status := ERROR;
      GOTO End;
    END_IF;
  
    IF pLslCmd^.nReceived < pLslCmd^.nRecv THEN
      // zuwenig Daten empfangen
      pLslCmd^.status := ERROR;
      GOTO End;
    END_IF;
    
  ELSE
  
    pLslCmd^.status := BUSY;
    
  END_IF;

End:
  status := pLslCmd^.status;

END_FUNCTION

FUNCTION Lasal32::WorkImproved
	VAR_INPUT
		pLslCmd 	: ^tLasal32CmdIMPROVED;
	END_VAR
	VAR_OUTPUT
		status 	: iprStates;
	END_VAR
  VAR
  	retval : DINT;
  END_VAR

                                 
  retval := ONL_REQUEST(descr_num      := pLslCmd^.OnlHandle, 
                        Cmd            := pLslCmd^.cmd, 
                        InBuffer1      := pLslCmd^.pWrData, 
                        InBuffer1Size  := pLslCmd^.nSend,
                        InBuffer2      := pLslCmd^.pWrData2,
                        InBuffer2Size  := pLslCmd^.nSend2,
                        InBufferSizeAll:= pLslCmd^.nSend + pLslCmd^.nSend2,
                        OutBuffer      := pLslCmd^.pRdData, 
                        OutBufferSize  := pLslCmd^.nRdSize,
                        BytesReturned  := #pLslCmd^.nReceived, 
                        CpuStatus      := #pLslCmd^.cpuStatus, 
                        fFirstRecPart  := 1, 
                        fLastRecPart   := 1);
  
  IF retval <> 0  THEN
    pLslCmd^.status := OSErrorMapping(retval);
    status := pLslCmd^.status;
    return;
  END_IF;

  IF pLslCmd^.nReceived = 16#ffff THEN
    pLslCmd^.nReceived := 0;
    pLslCmd^.status := OSErrorMapping(retval);
    status := pLslCmd^.status;
    return;
  END_IF;

  
  IF pLslCmd^.cmdStatus <> 0 THEN
    pLslCmd^.status := ERROR;
    status := pLslCmd^.status;
    return;
  END_IF;

  IF pLslCmd^.nReceived < pLslCmd^.nMinRecv THEN
    // zuwenig Daten empfangen
    pLslCmd^.status := ERROR;
    status := pLslCmd^.status;
    return;
  END_IF;
  
  status := pLslCmd^.status;

END_FUNCTION


FUNCTION Lasal32::NewLasal32Cmd
	VAR_INPUT
		pComdef 	: ^Comdef;
		cmd 	: USINT;
		pWrData 	: ^USINT;
		nSend 	: UDINT;
		pWrData2 	: ^USINT;
		nSend2 	: UDINT;
		pRdData 	: ^USINT;
		nRdSize 	: UDINT;
		nRecv 	: UDINT;
		addRdTv_ms 	: UDINT;
	END_VAR
	VAR_OUTPUT
		pLasal32Cmd 	: ^Lasal32Cmd;
	END_VAR
  
  pLasal32Cmd := OS_SSR_Malloc(SIZEOF(Lasal32Cmd))$^Lasal32Cmd;
  IF pLasal32Cmd <> NIL THEN
  
    _memset(pLasal32Cmd, 0, SIZEOF(Lasal32Cmd));
    pLasal32Cmd^.pComdef := pComdef;
    pLasal32Cmd^.cmd := cmd;
    pLasal32Cmd^.pWrData := pWrData;
    pLasal32Cmd^.nSend := nSend;
    pLasal32Cmd^.pWrData2 := pWrData2;
    pLasal32Cmd^.nSend2 := nSend2;
    pLasal32Cmd^.pRdData := pRdData;
    pLasal32Cmd^.nRdSize := nRdSize;
    pLasal32Cmd^.nReceived := 0;
    pLasal32Cmd^.nRecv := nRecv;
    pLasal32Cmd^.addRdTv_ms := addRdTv_ms;

  END_IF;                        

END_FUNCTION

FUNCTION Lasal32::Lasal32CmdImproved
	VAR_INPUT
		OnlHandle 	: DINT;
		cmd 	: USINT;
		pWrData 	: ^USINT;
		nSend 	: UDINT;
		pWrData2 	: ^USINT;
		nSend2 	: UDINT;
		pRdData 	: ^USINT;
		nRdSize 	: UDINT;
		nRecv 	: UDINT;
		addRdTv_ms 	: UDINT;
	END_VAR
	VAR_OUTPUT
		pLasal32Cmd 	: ^tLasal32CmdIMPROVED;
	END_VAR
  
  pLasal32Cmd := OS_SSR_Malloc(SIZEOF(tLasal32CmdIMPROVED))$^tLasal32CmdIMPROVED;
  
  IF pLasal32Cmd <> NIL THEN
  
    _memset(pLasal32Cmd, 0, SIZEOF(Lasal32Cmd));
    pLasal32Cmd^.OnlHandle  := OnlHandle;
    pLasal32Cmd^.cmd        := cmd;
    pLasal32Cmd^.pWrData    := pWrData;
    pLasal32Cmd^.nSend      := nSend;
    pLasal32Cmd^.pWrData2   := pWrData2;
    pLasal32Cmd^.nSend2     := nSend2;
    pLasal32Cmd^.pRdData    := pRdData;
    pLasal32Cmd^.nRdSize    := nRdSize;
    pLasal32Cmd^.nReceived  := 0;
    pLasal32Cmd^.nMinRecv      := nRecv;
    pLasal32Cmd^.addRdTv_ms := addRdTv_ms;

  END_IF;           
  

END_FUNCTION

(*
  Entfernt ein Lasal32CmdPrivate Objekt.
  Es wird ein Zeiger auf den Objektzeiger übergeben, der dann auf NIL 
  gesetzt wird, um sicherzustellen, daß auf das Objekt dann nicht mehr 
  zugegriffen wird.
*)
FUNCTION Lasal32::DeleteLasal32Cmd
  VAR_INPUT
    pLasal32Cmd : ^Lasal32Cmd;
  END_VAR
  
  IF pLasal32Cmd <> NIL THEN
    OS_SSR_Free(pLasal32Cmd);
  END_IF;

END_FUNCTION

FUNCTION Lasal32::DeleteLasal32CmdImproved
	VAR_INPUT
		pLasal32Cmd 	: ^tLasal32CmdIMPROVED;
	END_VAR
  
  IF pLasal32Cmd <> NIL THEN
    OS_SSR_Free(pLasal32Cmd);
  END_IF;

END_FUNCTION


FUNCTION Lasal32::NewLasal32Block
	VAR_INPUT
		pComdef 	: ^Comdef;
		nbrOfBlocks 	: UDINT;
		pData 	: ^USINT;
		dataLen 	: UDINT;
	END_VAR
	VAR_OUTPUT
		pLasal32Block 	: ^Lasal32Block;
	END_VAR

  pLasal32Block := OS_SSR_Malloc(SIZEOF(Lasal32Block))$^Lasal32Block;
  
  IF pLasal32Block <> NIL THEN
  
    _memset(pLasal32Block, 0, SIZEOF(Lasal32Block));
    pLasal32Block^.pComdef      := pComdef;
    pLasal32Block^.nbrOfBlocks  := nbrOfBlocks;
    pLasal32Block^.pData        := pData;
    pLasal32Block^.dataLen      := dataLen;

  END_IF;                        


END_FUNCTION

FUNCTION Lasal32::Lasal32BlockImproved
	VAR_INPUT
		OnlHandle 	: DINT;
		nbrOfBlocks 	: UDINT;
		pData 	: ^USINT;
		dataLen 	: UDINT;
	END_VAR
	VAR_OUTPUT
		pLasal32Block 	: ^tLasal32BlockIMPROVED;
	END_VAR
  
  pLasal32Block := OS_SSR_Malloc(SIZEOF(tLasal32BlockIMPROVED))$^tLasal32BlockIMPROVED;
  IF pLasal32Block <> NIL THEN
  
    _memset(pLasal32Block, 0, SIZEOF(Lasal32Block));
    pLasal32Block^.OnlHandle    := OnlHandle;
    pLasal32Block^.nbrOfBlocks  := nbrOfBlocks;
    pLasal32Block^.pData        := pData;
    pLasal32Block^.dataLen      := dataLen;

  END_IF;          

END_FUNCTION


FUNCTION Lasal32::DeleteLasal32Block
	VAR_INPUT
		pLasal32Block 	: ^Lasal32Block;
	END_VAR

  IF pLasal32Block <> NIL THEN
    OS_SSR_Free(pLasal32Block);
  END_IF;

END_FUNCTION

FUNCTION Lasal32::DeleteLasal32BlockImproved
	VAR_INPUT
		pLasal32Block 	: ^tLasal32BlockIMPROVED;
	END_VAR
  
  
  IF pLasal32Block <> NIL THEN
    OS_SSR_Free(pLasal32Block);
  END_IF;

END_FUNCTION


(*
  Abfrage des CPU Status
*)
FUNCTION GLOBAL Lasal32::GetCpuStatus
	VAR_INPUT
		pComdef 	: ^Comdef;
		pCpuStatus 	: ^USINT;
		pReason 	: ^comlinkReason;
	END_VAR
	VAR_OUTPUT
		Status 	: iprStates;
	END_VAR

  Status := LslCmd(pComdef,
                   DBG_CMD_SYN,  // Kommando
                   NIL,          // Sendbuffer
                   0,            // Anzahl der zu sendenden Bytes
                   NIL,          // Empfangsbuffer
                   0,            // Größe des Empfangsbuffers
                   0,            // minimale Anzahl zu lesender Bytes
                   NIL,          // Anzahl empfangener Bytes (NIL = uninteressant)
                   0,            // zusätzlicher Read-Timeout in ms
                   pCpuStatus,   // CpuStatus
                   NIL,          // AwlBpStatus
                   pReason       // reason-code in the case of an error
                   );

END_FUNCTION

TYPE
#pragma pack(push, 1)
  FILESAVE_HDR : STRUCT 
    hdr_len : UINT;
    version : UINT;
    filename : ARRAY [0..1] OF CHAR;
  END_STRUCT;
#pragma pack(pop)
END_TYPE

FUNCTION GLOBAL Lasal32::GetCpuStatusImproved
	VAR_INPUT
		OnlHandle 	: DINT;
		pCpuStatus 	: ^USINT;
		pReason 	: ^comlinkReason;
	END_VAR
	VAR_OUTPUT
		Status 	: iprStates;
	END_VAR
  
  if pCpuStatus <> NIL then  //otherwise this function is senseless 
                              
    Status := LslCmd2Improved(OnlHandle,           
                              DBG_CMD_SYN,     //Kommando
                              NIL,             //Sendebuffer 1
                              0,               //Anzahl der zu sendenden Bytes im Sendebuffer1
                              NIL,             //Sendebuffer2
                              0,               //Anzahl der zu sendenden Bytes im Sendebuffer2 
                              NIL,             //Empfangsbuffer
                              0,               //Größe des Empfangsbuffers
                              0,               //minimale Anzahl der zu lesenden Bytes
                              NIL,             //Anzahl empfangener Bytes (NIL = uninteressant)
                              0,               //zusätzlicher Read-Timeout in ms
                              pCpuStatus,      //CpuStatus
                              NIL,             //AwlBpStatus
                              pReason          //reason-code in the case of an error
                              );         
  else
  
    Status := ERROR;
    return;
    
  end_if;


END_FUNCTION
  
(*
  Senden eines Files
*)
FUNCTION GLOBAL Lasal32::FileSave
	VAR_INPUT
		pComdef 	: ^Comdef;
		fileName 	: ^CHAR;
		pData 	: ^USINT;
		len 	: UDINT;
	END_VAR
	VAR_OUTPUT
		cmdHandle 	: UDINT;
	END_VAR
  VAR
		pLslCmd	: ^Lasal32Cmd;
    pHdr : ^FILESAVE_HDR;
  END_VAR
  
  cmdHandle := 0;
  
  pLslCmd := NewLasal32Cmd(pComdef, 
                           DBG_CMD_SAVE_FILE3,  // gibts erst ab 5.42
                           NIL,                 // Sendbuffer1
                           0,                   // Anzahl der zu sendenden Bytes aus Buffer1
                           pData,               // Sendbuffer2
                           len,                 // Anzahl der zu sendenden Bytes aus Buffer2
                           NIL,                 // Empfangsbuffer
                           0,                   // Größe des Empfangsbuffers
                           SIZEOF(DINT),        // minimale Anzahl zu lesender Bytes
                           2000);               // zusätzlicher Read-Timeout in ms
  
  IF pLslCmd = NIL THEN
    RETURN;
  END_IF;
  
  // Den Header im Standard-Header-Buffer erstellen
  pHdr := (#pLslCmd^.hdrBuf[0])$^FILESAVE_HDR;
  _strcpy(#pHdr^.filename[0], fileName);
  pHdr^.hdr_len := (FILESAVE_HDR.filename)$UINT + _strlen(fileName)$UINT + 1;
  pHdr^.version := 0;
  
  pLslCmd^.pWrData := pHdr$^USINT;
  pLslCmd^.nSend := pHdr^.hdr_len;
  
  // Die Antwort wird in den Standard-Empfangs-Buffer geschrieben
  pLslCmd^.pRdData := #pLslCmd^.recvBuf[0];
  pLslCmd^.nRdSize := SIZEOF(pLslCmd^.recvBuf);
  
  cmdHandle := pLslCmd$UDINT;
  
END_FUNCTION

FUNCTION GLOBAL Lasal32::FileSaveImproved
	VAR_INPUT
		OnlHandle 	: DINT;
		fileName 	: ^CHAR;
		pData 	: ^USINT;
		len 	: UDINT;
	END_VAR
	VAR_OUTPUT
		cmdHandle 	: UDINT;
	END_VAR
  VAR
		pLslCmd	: ^tLasal32CmdIMPROVED;
    pHdr : ^FILESAVE_HDR;
  END_VAR
  
  cmdHandle := 0;
  
  pLslCmd := Lasal32CmdImproved(OnlHandle   := OnlHandle, 
                                cmd         := DBG_CMD_SAVE_FILE3, 
                                pWrData     := NIL, 
                                nSend       := 0, 
                                pWrData2    := pData, 
                                nSend2      := len, 
                                pRdData     := NIL, 
                                nRdSize     := 0, 
                                nRecv       := sizeof(DINT), 
                                addRdTv_ms  := 0
                                );
  
  
  IF pLslCmd = NIL THEN
    RETURN;
  END_IF;
  
  // Den Header im Standard-Header-Buffer erstellen
  pHdr := (#pLslCmd^.hdrBuf[0])$^FILESAVE_HDR;
  _strcpy(#pHdr^.filename[0], fileName);
  pHdr^.hdr_len := (FILESAVE_HDR.filename)$UINT + _strlen(fileName)$UINT + 1;
  pHdr^.version := 0;
  
  pLslCmd^.pWrData := pHdr$^USINT;
  pLslCmd^.nSend := pHdr^.hdr_len;
  
  // Die Antwort wird in den Standard-Empfangs-Buffer geschrieben
  pLslCmd^.pRdData := #pLslCmd^.recvBuf[0];
  pLslCmd^.nRdSize := SIZEOF(pLslCmd^.recvBuf);
  
  cmdHandle := pLslCmd$UDINT;

END_FUNCTION


FUNCTION GLOBAL Lasal32::FileSave_Work
	VAR_INPUT
		cmdHandle 	: UDINT;
		pErrCodeRemote 	: ^DINT;
		pReason 	: ^comlinkReason;
	END_VAR
	VAR_OUTPUT
		status 	: iprStates;
	END_VAR
  VAR
		pLslCmd 	: ^Lasal32Cmd;
  END_VAR;
  
  pLslCmd := cmdHandle$^Lasal32Cmd;

  IF pLslCmd = NIL THEN
    status := ERROR;
    RETURN;
  END_IF;

  status := Work(pLslCmd);
  CASE status OF
    READY:
      pErrCodeRemote^ := 0;//++todo
      DeleteLasal32Cmd(pLslCmd);
    BUSY:
  ELSE
    pReason^ := pLslCmd^.reason;
    DeleteLasal32Cmd(pLslCmd);
  END_CASE;

END_FUNCTION


TYPE
#pragma pack(push, 1)
  FILELOAD_HDR : STRUCT 
    dllVersion : UDINT;
    packetLen : UDINT;
    pathLen : UDINT;  // Länge von fileName + 0-Terminator
    fileName : ARRAY [0..1] OF CHAR;
  END_STRUCT;
  
  FILELOAD_BLKINFO : STRUCT
    pathLen : UDINT;
    fileName : ARRAY [0..1] OF CHAR;
  END_STRUCT;
#pragma pack(pop)
END_TYPE

(*
  Empfangen eines Files
*)

FUNCTION GLOBAL Lasal32::FileSave_WorkImproved
	VAR_INPUT
		cmdHandle 	: UDINT;
		pErrCodeRemote 	: ^DINT;
		pReason 	: ^comlinkReason;
	END_VAR
	VAR_OUTPUT
		status 	: iprStates;
	END_VAR
  VAR
		pLslCmd 	: ^tLasal32CmdIMPROVED;
  END_VAR;
  
  pLslCmd := cmdHandle$^tLasal32CmdIMPROVED;

  IF pLslCmd = NIL THEN
    status := ERROR;
    RETURN;
  END_IF;

  status := WorkImproved(pLslCmd); 
  CASE status OF
    READY:
      pErrCodeRemote^ := 0;//++todo
    DeleteLasal32CmdImproved(pLslCmd);
    BUSY:
  ELSE
    pReason^ := pLslCmd^.reason;
    DeleteLasal32CmdImproved(pLslCmd);
  END_CASE;

END_FUNCTION
  



FUNCTION GLOBAL Lasal32::FileLoad
	VAR_INPUT
		pComdef 	: ^Comdef;
		fileName 	: ^CHAR;
		pData 	: ^USINT;
		len 	: UDINT;
	END_VAR
	VAR_OUTPUT
		cmdHandle 	: UDINT;
	END_VAR
  VAR
		pLslBlock : ^Lasal32Block;
    nbrOfBlocks : UDINT;
    pBlkInfo : ^FILELOAD_BLKINFO;
  END_VAR

  cmdHandle := 0;
  
  IF len = 0 THEN
    RETURN;
  END_IF;

  nbrOfBlocks := ((len - 1) / LASAL32_BLOCKSIZE) + 1;

  pLslBlock := NewLasal32Block(pComdef, nbrOfBlocks, pData, len); 
  IF pLslBlock = NIL THEN
    RETURN;
  END_IF;
  
  pBlkInfo := (#pLslBlock^.userData[0])$^FILELOAD_BLKINFO;
  pBlkInfo^.pathLen := _strlen(fileName) + 1;
  _strcpy(#pBlkInfo^.fileName[0], fileName);
  
  cmdHandle := pLslBlock$UDINT;

END_FUNCTION

FUNCTION GLOBAL Lasal32::FileLoadImproved
	VAR_INPUT
		OnlHandle 	: DINT;
		fileName 	: ^CHAR;
		pData 	: ^USINT;
		len 	: UDINT;
	END_VAR
	VAR_OUTPUT
		cmdHandle 	: UDINT;
	END_VAR
  VAR
		pLslBlock : ^tLasal32BlockIMPROVED;
    nbrOfBlocks : UDINT;
    pBlkInfo : ^FILELOAD_BLKINFO;
  END_VAR
  
  cmdHandle := 0;
  
  nbrOfBlocks := ((len - 1) / LASAL32_BLOCKSIZE + 1);
  
  pLslBlock := Lasal32BlockImproved(OnlHandle, nbrOfBlocks, pData, len);
  
  if pLslBlock = NIL then
    return;
  end_if;
  
  pBlkInfo := (#pLslBlock^.userData[0])$^FILELOAD_BLKINFO;
  pBlkInfo^.pathLen := _strlen(fileName) + 1;
  _strcpy(#pBlkInfo^.fileName[0], fileName);
  
  cmdHandle := pLslBlock$UDINT;

END_FUNCTION


FUNCTION GLOBAL Lasal32::FileLoad_Work
	VAR_INPUT
		cmdHandle 	: UDINT;
		pReason 	: ^comlinkReason;
	END_VAR
	VAR_OUTPUT
		status 	: iprStates;
	END_VAR
  VAR
		pLslBlock 	: ^Lasal32Block;
    pBlkInfo : ^FILELOAD_BLKINFO;
		pLslCmd	: ^Lasal32Cmd;
    pHdr : ^FILELOAD_HDR;
    packetLen : UDINT;
  END_VAR;

  pLslBlock := cmdHandle$^Lasal32Block;
  
  IF pLslBlock = NIL THEN
    status := ERROR;
    RETURN;
  END_IF;

  pBlkInfo := (#pLslBlock^.userData[0])$^FILELOAD_BLKINFO;

  IF pLslBlock^.pLslCmd = NIL THEN
  
    IF pLslBlock^.nextBlkNbr = pLslBlock^.nbrOfBlocks - 1 THEN
      packetLen := ((pLslBlock^.dataLen - 1) MOD LASAL32_BLOCKSIZE) + 1;
    ELSE
      packetLen := LASAL32_BLOCKSIZE;
    END_IF;
  
    pLslCmd := NewLasal32Cmd(pLslBlock^.pComdef, 
                             DBG_CMD_LOAD_FILE,   // Kommando
                             NIL,                 // Sendbuffer1
                             0,                   // Anzahl der zu sendenden Bytes aus Buffer1
                             NIL,                 // Sendbuffer2
                             0,                   // Anzahl der zu sendenden Bytes aus Buffer2
                             pLslBlock^.pData + pLslBlock^.dataOfs,   // Empfangsbuffer
                             pLslBlock^.dataLen - pLslBlock^.dataOfs, // Größe des Empfangsbuffers
                             packetLen,           // minimale Anzahl zu lesender Bytes
                             2000);               // zusätzlicher Read-Timeout in ms
    
    IF pLslCmd = NIL THEN
      status := ERROR;
      DeleteLasal32Block(pLslBlock);
      RETURN;
    END_IF;
    
    // Den Header im Standard-Header-Buffer erstellen
    pHdr := (#pLslCmd^.hdrBuf[0])$^FILELOAD_HDR;
    pHdr^.dllVersion := 0;
    pHdr^.packetLen := packetLen;
    pHdr^.pathLen := pBlkInfo^.pathLen;
    _strcpy(#pHdr^.fileName[0], #pBlkInfo^.fileName[0]);
    (pHdr + FILELOAD_HDR.fileName + pHdr^.pathLen)$^UDINT^ := pLslBlock^.dataOfs;
    
    pLslCmd^.pWrData := pHdr$^USINT;
    pLslCmd^.nSend := FILELOAD_HDR.fileName + pHdr^.pathLen + SIZEOF(UDINT);
    
    pLslBlock^.pLslCmd := pLslCmd;
    
  ELSE
  
    pLslCmd := pLslBlock^.pLslCmd;
    
  END_IF;

  status := Work(pLslCmd);
  CASE status OF
    READY:
      DeleteLasal32Cmd(pLslCmd);
      pLslBlock^.pLslCmd := NIL;
      pLslBlock^.nextBlkNbr += 1;
      IF pLslBlock^.nextBlkNbr >= pLslBlock^.nbrOfBlocks THEN
        DeleteLasal32Block(pLslBlock);
      ELSE
        pLslBlock^.dataOfs += pLslCmd^.nReceived;
        status := BUSY;
      END_IF;
    BUSY:
  ELSE
    pReason^ := pLslCmd^.reason;
    DeleteLasal32Cmd(pLslCmd);
    DeleteLasal32Block(pLslBlock);
  END_CASE;

END_FUNCTION


FUNCTION GLOBAL Lasal32::FileLoad_WorkImproved
	VAR_INPUT
		cmdHandle 	: UDINT;
		pReason 	: ^comlinkReason;
	END_VAR
	VAR_OUTPUT
		status 	: iprStates;
	END_VAR
  VAR
		pLslBlock 	: ^tLasal32BlockIMPROVED;
    pBlkInfo : ^FILELOAD_BLKINFO;
		pLslCmd	: ^tLasal32CmdIMPROVED;
    pHdr : ^FILELOAD_HDR;
    packetLen : UDINT;
  END_VAR;

  pLslBlock := cmdHandle$^tLasal32BlockIMPROVED;
  
  IF pLslBlock = NIL THEN
    status := ERROR;
    RETURN;
  END_IF;

  pBlkInfo := (#pLslBlock^.userData[0])$^FILELOAD_BLKINFO;

  IF pLslBlock^.pLslCmd = NIL THEN 
  
    IF pLslBlock^.nextBlkNbr = pLslBlock^.nbrOfBlocks - 1 THEN
      packetLen := ((pLslBlock^.dataLen - 1) MOD LASAL32_BLOCKSIZE) + 1;
    ELSE
      packetLen := LASAL32_BLOCKSIZE;
    END_IF;
                             
    pLslCmd := Lasal32CmdImproved(pLslBlock^.OnlHandle, 
                                  DBG_CMD_LOAD_FILE,  //Kommando
                                  NIL, 
                                  0, 
                                  NIL, 
                                  0, 
                                  pLslBlock^.pData + pLslBlock^.dataOfs, 
                                  pLslBlock^.dataLen - pLslBlock^.dataOfs,
                                  packetLen, 
                                  0);

    IF pLslCmd = NIL THEN
      status := ERROR;
      DeleteLasal32BlockImproved(pLslBlock);
      RETURN;
    END_IF;
    
    // Den Header im Standard-Header-Buffer erstellen
    pHdr := (#pLslCmd^.hdrBuf[0])$^FILELOAD_HDR;
    pHdr^.dllVersion := 0;
    pHdr^.packetLen := packetLen;
    pHdr^.pathLen := pBlkInfo^.pathLen;
    _strcpy(#pHdr^.fileName[0], #pBlkInfo^.fileName[0]);
    (pHdr + FILELOAD_HDR.fileName + pHdr^.pathLen)$^UDINT^ := pLslBlock^.dataOfs;
    
    pLslCmd^.pWrData := pHdr$^USINT;
    pLslCmd^.nSend := FILELOAD_HDR.fileName + pHdr^.pathLen + SIZEOF(UDINT);
    
    pLslBlock^.pLslCmd := pLslCmd;
    
  ELSE
  
    pLslCmd := pLslBlock^.pLslCmd;
    
  END_IF;

  status := WorkImproved(pLslCmd);
  CASE status OF
    READY:
      DeleteLasal32CmdImproved(pLslCmd);
      pLslBlock^.pLslCmd := NIL;
      pLslBlock^.nextBlkNbr += 1;
      IF pLslBlock^.nextBlkNbr >= pLslBlock^.nbrOfBlocks THEN
        DeleteLasal32BlockImproved(pLslBlock);
      ELSE
        pLslBlock^.dataOfs += pLslCmd^.nReceived;
        status := BUSY;
      END_IF;
    BUSY:
  ELSE
    pReason^ := pLslCmd^.reason;
    DeleteLasal32CmdImproved(pLslCmd);
    DeleteLasal32BlockImproved(pLslBlock);
  END_CASE;
  

END_FUNCTION

TYPE
#pragma pack(push, 1)
  FILEINFO_HDR : STRUCT 
    dllVersion : UDINT;
    bufSize : UDINT;
  END_STRUCT;
#pragma pack(pop)
END_TYPE

(*
  Abfrage von Fileinformationen
*)


FUNCTION GLOBAL Lasal32::FileInfo
	VAR_INPUT
		pComdef 	: ^Comdef;
		fileName 	: ^CHAR;
		pFileInfo	: ^FILE_INFO;
		pReason 	: ^comlinkReason;
	END_VAR
	VAR_OUTPUT
		Status 	: iprStates;
	END_VAR
  VAR
    hdr : FILEINFO_HDR;
  END_VAR
  
  hdr.dllVersion := 0;
  hdr.bufSize := SIZEOF(FILE_INFO);

  Status := LslCmd2(pComdef,
                    DBG_CMD_FILE_INFO, // Kommando
                    (#hdr)$^USINT,// Sendbuffer1
                    SIZEOF(hdr),  // Anzahl der zu sendenden Bytes im Sendebuffer1
                    fileName,     // Sendbuffer2
                    _strlen(fileName) + 1, // Anzahl der zu sendenden Bytes im Sendebuffer2
                    pFileInfo$^USINT, // Empfangsbuffer
                    SIZEOF(FILE_INFO), // Größe des Empfangsbuffers
                    SIZEOF(FILE_INFO), // minimale Anzahl zu lesender Bytes
                    NIL,          // Anzahl empfangener Bytes (NIL = uninteressant)
                    0,            // zusätzlicher Read-Timeout in ms
                    NIL,          // CpuStatus
                    NIL,          // AwlBpStatus
                    pReason       // reason-code in the case of an error
                    );

END_FUNCTION

FUNCTION GLOBAL Lasal32::FileInfoImproved
	VAR_INPUT
		OnlHandle 	: DINT;
		pfileName 	: ^CHAR;
		pFileInfo 	: ^FILE_INFO;
		pReason 	: ^comlinkReason;
	END_VAR
	VAR_OUTPUT
		Status 	: iprStates;
	END_VAR
  VAR
  	hdr : FILEINFO_HDR;
  END_VAR

  hdr.dllVersion := 0;
  hdr.bufSize := sizeof(FILE_INFO);
  
  Status := LslCmd2Improved(OnlHandle,           
                            DBG_CMD_FILE_INFO,     //Kommando
                            (#hdr)$^USINT,         //Sendebuffer 1
                            sizeof(hdr),           //Anzahl der zu sendenden Bytes im Sendebuffer1
                            pfileName,             //Sendebuffer2
                            _strlen(pfileName) + 1,//Anzahl der zu sendenden Bytes im Sendebuffer2 
                            pFileInfo$^USINT,      //Empfangsbuffer
                            sizeof(FILE_INFO),     //Größe des Empfangsbuffers
                            sizeof(FILE_INFO),     //minimale Anzahl der zu lesenden Bytes
                            NIL,                   //Anzahl empfangener Bytes (NIL = uninteressant)
                            0,                     //zusätzlicher Read-Timeout in ms
                            NIL,                   //CpuStatus
                            NIL,                   //AwlBpStatus
                            pReason                //reason-code in the case of an error
                            );
  
 // pFileInfo^ := tmpFileInfo.FILE_INFO;

END_FUNCTION

(*
  Mit diesem Befehl kann der SPS mitgeteilt werden, daß File-Update Funktionen 
  begonnen, unterbrochen oder beendet werden.
  Diese Information wird von CPUs benötigt, die mit einem Filesystem 
  ausgestattet sind, bei dem Schreibzugriffe sehr lange dauern und daher 
  das gesamte Filesystem zwischengebuffert wird.

  updType:
    0 = Start  : Es wird ein Zwischenbuffer angelegt, in den die nachfolgenden 
                 Files-Updates geschrieben werden
    1 = Abbruch: Der Zwischenbuffer wird verworfen
    2 = Ende   : Die gebufferten Daten werden ins permanente Filesystem übertragen.
*)


(*
  Abfrage der Uhrzeit
*)
FUNCTION GLOBAL Lasal32::ReadTime
	VAR_INPUT
		pComdef 	: ^Comdef;
		pSystemTime	: ^LSLDATETIME;
		pReason 	: ^comlinkReason;
	END_VAR
	VAR_OUTPUT
		Status 	: iprStates;
	END_VAR
  
  Status := LslCmd(pComdef,
                   DBG_CMD_READDATETIME, // Kommando
                   NIL,          // Sendbuffer1
                   0,            // Anzahl der zu sendenden Bytes im Sendebuffer1
                   pSystemTime$^USINT, // Empfangsbuffer
                   SIZEOF(LSLDATETIME), // Größe des Empfangsbuffers
                   SIZEOF(LSLDATETIME), // minimale Anzahl zu lesender Bytes
                   NIL,          // Anzahl empfangener Bytes (NIL = uninteressant)
                   0,            // zusätzlicher Read-Timeout in ms
                   NIL,          // CpuStatus
                   NIL,          // AwlBpStatus
                   pReason       // reason-code in the case of an error
                   );

END_FUNCTION

FUNCTION GLOBAL Lasal32::ReadTimeImproved
	VAR_INPUT
		OnlHandle 	: DINT;
		pSystemTime 	: ^LSLDATETIME;
		pReason 	: ^comlinkReason;
	END_VAR
	VAR_OUTPUT
		Status 	: iprStates;
	END_VAR
  
  Status := LslCmd2Improved(OnlHandle, 
                            DBG_CMD_READDATETIME, 
                            NIL, 
                            0, 
                            NIL, 
                            0, 
                            pSystemTime$^USINT, 
                            sizeof(LSLDATETIME), 
                            sizeof(LSLDATETIME), 
                            NIL, 
                            0, 
                            NIL, 
                            NIL, 
                            pReason
                            );
  

END_FUNCTION

(*
  Abfrage des Uhrzeitunterschieds
*)
FUNCTION GLOBAL Lasal32::GetTimeDiff
	VAR_INPUT
		pComdef 	: ^Comdef;
		pTimeDiff 	: ^LSLTIMESTAMP;
		pReason 	: ^comlinkReason;
	END_VAR
	VAR_OUTPUT
		Status 	: iprStates;
	END_VAR
  VAR
		systemTime_Remote 	: LSLDATETIME;
		systemTime_Local1 	: LSLDATETIME;
		systemTime_Local2 	: LSLDATETIME;
    ts_propDelay : LSLTIMESTAMP;
    ts_propDelayHalbe : LSLTIMESTAMP;
    ts_timeDiff : LSLTIMESTAMP;
	END_VAR
  
  IF _LSL_POS^.piSSR^.sizeofStruct < LSL_SSR.ReadDateTime THEN
    Status := ERROR;
    RETURN;
  END_IF;
  
  // eigene Zeit vor dem Online Befehl abfragen
  OS_SSR_ReadDateTime(#systemTime_Local1);
  
  Status := ReadTime(pComdef, #systemTime_Remote, pReason);
  IF Status = READY THEN
  
    // eigene Zeit nach dem Online Befehl abfragen
    OS_SSR_ReadDateTime(#systemTime_Local2);
  
    // die Übertragungszeit des Online Befehls ausrechnen
    OS_SSR_CompareDateTime(#systemTime_Local2, 
                           #systemTime_Local1, 
                           #ts_propDelay);
    OS_SSR_TimestampDiv(#ts_propDelayHalbe, #ts_propDelay, 2);

    // Unterschied zwischen eigener und entfernter Zeit ausrechnen
    OS_SSR_CompareDateTime(#systemTime_Local1, 
                           #systemTime_Remote, 
                           #ts_timeDiff);
                           
    // die halbe Übertragungszeit dazuzählen
    OS_SSR_TimestampAdd(pTimeDiff, #ts_timeDiff, #ts_propDelayHalbe);

  END_IF;
  
END_FUNCTION

FUNCTION GLOBAL Lasal32::GetTimeDiffImproved
	VAR_INPUT
		OnlHandle 	: DINT;
		pTimeDiff 	: ^LSLTIMESTAMP;
		pReason 	: ^comlinkReason;
	END_VAR
	VAR_OUTPUT
		Status 	: iprStates;
	END_VAR
  VAR
		systemTime_Remote 	: LSLDATETIME;
		systemTime_Local1 	: LSLDATETIME;
		systemTime_Local2 	: LSLDATETIME;
    ts_propDelay : LSLTIMESTAMP;
    ts_propDelayHalbe : LSLTIMESTAMP;
    ts_timeDiff : LSLTIMESTAMP;
	END_VAR
  
  IF _LSL_POS^.piSSR^.sizeofStruct < LSL_SSR.ReadDateTime THEN
    Status := ERROR;
    RETURN;
  END_IF;
  
  // eigene Zeit vor dem Online Befehl abfragen
  OS_SSR_ReadDateTime(#systemTime_Local1);
  
  //Status := ReadTime(pComdef, #systemTime_Remote, pReason);
  Status := ReadTimeImproved(OnlHandle, #systemTime_Remote, pReason); 
  
  IF Status = READY THEN
  
    // eigene Zeit nach dem Online Befehl abfragen
    OS_SSR_ReadDateTime(#systemTime_Local2);
  
    // die Übertragungszeit des Online Befehls ausrechnen
    OS_SSR_CompareDateTime(#systemTime_Local2, 
                           #systemTime_Local1, 
                           #ts_propDelay);
    OS_SSR_TimestampDiv(#ts_propDelayHalbe, #ts_propDelay, 2);

    // Unterschied zwischen eigener und entfernter Zeit ausrechnen
    OS_SSR_CompareDateTime(#systemTime_Local1, 
                           #systemTime_Remote, 
                           #ts_timeDiff);
                           
    // die halbe Übertragungszeit dazuzählen
    OS_SSR_TimestampAdd(pTimeDiff, #ts_timeDiff, #ts_propDelayHalbe);

  END_IF;
  
  
END_FUNCTION



(*
  Uhrzeit korrigieren
*)
FUNCTION GLOBAL Lasal32::AdjustTime
	VAR_INPUT
		pComdef 	: ^Comdef;
		pTimeDiff 	: ^LSLTIMESTAMP;
		pReason 	: ^comlinkReason;
	END_VAR
	VAR_OUTPUT
		Status 	: iprStates;
	END_VAR

  Status := LslCmd(pComdef,
                   DBG_CMD_ADJUSTDATETIME, // Kommando
                   pTimeDiff$^USINT,       // Sendbuffer1
                   SIZEOF(LSLTIMESTAMP),// Anzahl der zu sendenden Bytes im Sendebuffer1
                   NIL,          // Empfangsbuffer
                   0,            // Größe des Empfangsbuffers
                   0,            // minimale Anzahl zu lesender Bytes
                   NIL,          // Anzahl empfangener Bytes (NIL = uninteressant)
                   0,            // zusätzlicher Read-Timeout in ms
                   NIL,          // CpuStatus
                   NIL,          // AwlBpStatus
                   pReason       // reason-code in the case of an error
                   );

END_FUNCTION

FUNCTION GLOBAL Lasal32::AdjustTimeImproved
	VAR_INPUT
		OnlHandle 	: DINT;
		pTimeDiff 	: ^LSLTIMESTAMP;
		pReason 	: ^comlinkReason;
	END_VAR
	VAR_OUTPUT
		Status 	: iprStates;
	END_VAR
  
  
  Status := LslCmd2Improved(OnlHandle,               // Online-Handle
                            DBG_CMD_ADJUSTDATETIME,  // Kommando
                            pTimeDiff$^USINT,        //Sendebuffer 1
                            SIZEOF(LSLTIMESTAMP),    ///Anzahl der zu sendenden Bytes im Sendebuffer 1 
                            NIL,                    
                            0, 
                            NIL, 
                            0, 
                            0, 
                            NIL, 
                            0, 
                            NIL, 
                            NIL, 
                            pReason
                            );
  
  
END_FUNCTION

FUNCTION Lasal32::Lasal32
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR
  
  if _RtOSversion < 16#129B then
    // Error für vorhandenes Interface setzen . Es ist mindestens OS Version 01.02.160 erforderlich
    TRACE("Error: Lasal32 Interface not available with this version/platform! (Needed OS Version >= 01.02.160)");
    CILError:=2;
  else
    // Interface vom OS holen
    if OS_CILGET("LSLONL", #pLslOnl) = SYS_ERR_NONE then
      // Error für vorhandenes Interface zurücksezten
      CILError:=0;
    else
      trace("Lasal32::Lasal32 -> CIL LSLONL not found");
      // Error für vorhandenes Interface sezten
      CILError:=1;
    end_if;
  end_if;
  
	ret_code:= C_OK;

END_FUNCTION

FUNCTION GLOBAL Lasal32::ONL_OPEN_CAN
	VAR_INPUT
		addr 	: ^OS_LSLONL_ADDR_CAN;
	END_VAR
	VAR_OUTPUT
		descr_num 	: DINT;
	END_VAR
  
  // return no valid interface
  descr_num := LSL_ONL_NO_CIL_INTERFACE;
  // check if interface is available
  case CILError of
    
    0:  // no error
        // return no valid address pointer
        descr_num :=  LSL_ONL_NO_VALID_CONNECTION_POINTER;
        // check the address pointer
        if addr <> NIL then
          // call the OS methode to establish the connection and return the state.
          descr_num := OS_ONL_OPEN((addr)$^OS_LSLONL_ADDR);
        end_if;
        
    1:  // return no valid interface
        descr_num := LSL_ONL_NO_CIL_INTERFACE;
        
    2:  // return too old os version ( need OS Version >= 01.02.155 )
        descr_num := LSL_ONL_NEWER_OS_VERSION_REQUIRED;
        TRACE("[ERROR] Lasal32: Too old OS version. OS version 01.02.155 or higher is required!!");
  end_case;
  

END_FUNCTION


FUNCTION GLOBAL Lasal32::ONL_OPEN_TCPIP
	VAR_INPUT
		addr 	: ^OS_LSLONL_ADDR_TCPIP;
	END_VAR
	VAR_OUTPUT
		descr_num 	: DINT;
	END_VAR
  
  // return no valid interface
  descr_num := LSL_ONL_NO_CIL_INTERFACE;
  // check if interface is available
  case CILError of
    
    0:  // no error
        // return no valid address pointer
        descr_num :=  LSL_ONL_NO_VALID_CONNECTION_POINTER;
        // check the address pointer
        if addr <> NIL then
          // call the OS methode to establish the connection and return the state.
          descr_num := OS_ONL_OPEN((addr)$^OS_LSLONL_ADDR);
        end_if;
        
    1:  // return no valid interface
        descr_num := LSL_ONL_NO_CIL_INTERFACE;
        
    2:  // return too old os version ( need OS Version >= 01.02.160 )
        descr_num := LSL_ONL_NEWER_OS_VERSION_REQUIRED;
        TRACE("[ERROR] Lasal32: Too old OS version. OS version 01.02.155 or higher is required!!");
  
  end_case;
  

END_FUNCTION

FUNCTION GLOBAL Lasal32::ONL_RESETSPS
  VAR_INPUT
      descr_num   : DINT;
  END_VAR
  VAR_OUTPUT
      retval      : DINT;
  END_VAR

  // return no valid interface
  retval := LSL_ONL_NO_CIL_INTERFACE;
  // check if interface is available
  if CILError = 0 then
    // check the communication handle
    if descr_num >= 0 then
      // call the OS methode to change the PLC state to RESET and return the state
      retval := OS_ONL_RESETSPS(descr_num);
    else
      // return no valid handle
      retval := LSL_ONL_NO_VALID_CONNECTION_ID;
    end_if;
  end_if;
  
END_FUNCTION

FUNCTION GLOBAL Lasal32::ONL_RUNSPS
  VAR_INPUT
      descr_num   : DINT;
  END_VAR
  VAR_OUTPUT
      retval      : DINT;
  END_VAR

  // return no valid interface
  retval := LSL_ONL_NO_CIL_INTERFACE;
  // check if interface is available
  if CILError = 0 then
    // check the communication handle
    if descr_num >= 0 then
      // call the OS methode to change the PLC state to RUN RAM and return the state
      retval := OS_ONL_RUNSPS(descr_num);
    else
      // return no valid handle
      retval := LSL_ONL_NO_VALID_CONNECTION_ID;
    end_if;
  end_if;

END_FUNCTION

FUNCTION GLOBAL Lasal32::ONL_GETCPUSTATUS
	VAR_INPUT
		descr_num 	: DINT;
		status 	: ^_LSLONL_STATUS_PLC;
	END_VAR
	VAR_OUTPUT
		retval 	: DINT;
	END_VAR
  VAR
  	tmpStatus : usint;
  END_VAR

  tmpStatus := 0;
  status^ := (to_udint(tmpstatus))$_LSLONL_STATUS_PLC;

  // return no valid interface
  retval := LSL_ONL_NO_CIL_INTERFACE;
  // check if interface is available
  if CILError = 0 then
    // check the communication handle
    if descr_num >= 0 then
      // call the OS methode to get the PLC state
      retval := OS_ONL_GETCPUSTATUS(descr_num,#tmpStatus);
      // convert to type _LSLONL_STATUS_PLC
      status^ := (to_udint(tmpstatus))$_LSLONL_STATUS_PLC;
    else
      // return no valid handle
      retval := LSL_ONL_NO_VALID_CONNECTION_ID;
    end_if;
  end_if;



END_FUNCTION

FUNCTION GLOBAL Lasal32::ONL_CLOSE
	VAR_INPUT
		descr_num 	: DINT;
	END_VAR
	VAR_OUTPUT
		retval 	: DINT;
	END_VAR

  // return no valid interface
  retval := LSL_ONL_NO_CIL_INTERFACE;
  // check if interface is available
  if CILError = 0 then
    // check the communication handle only close if valid
    if descr_num >= 0 then
      // call the OS methode to close the connection
      OS_ONL_CLOSE(descr_num);
      // return that the connection is closed.
      retval := LSL_ONL_NO_ERROR;
    else
      // return no valid handle
      retval := LSL_ONL_NO_VALID_CONNECTION_ID;
    end_if;
  end_if;
  
END_FUNCTION

FUNCTION GLOBAL Lasal32::ONL_GETOBJECT
	VAR_INPUT
		descr_num 	: DINT;
		objName 	: ^CHAR;
		objAddr 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		retval 	: DINT;
	END_VAR
  VAR
  	tmpMode           : CHMODE;
  //  tmpclsName        : Array [0..999] of char;
  //  tmpdataBufferFlag : Array [0..999] of char;
  END_VAR
  
  tmpclsName[0]         :=0;
  tmpdataBufferFlag[0]  :=0;

  // return no valid interface
  retval := LSL_ONL_NO_CIL_INTERFACE;
  // check if interface is available
  if CILError = 0 then
    // return no valid Objectname pointer
    retval := LSL_ONL_NO_VALID_OBJECTNAME_POINTER;
    // check pointer of object name
    if objName <> NIL then
      // return no valid address pointer
      retval := LSL_ONL_NO_VALID_ADDRESS_POINTER;
      // check the address pointer
      if objAddr <> 0 then
        // check the communication handle
        if descr_num >= 0 then
          // call the OS methode to get the object address of the server and return the state.
          retval := OS_ONL_GETOBJECT(descr_num, objName, objAddr, #tmpMode, #tmpclsName[0], #tmpdataBufferFlag[0]);
        else
          // return no valid handle
          retval := LSL_ONL_NO_VALID_CONNECTION_ID;
        end_if;
      end_if;
    end_if;
  end_if;


END_FUNCTION

FUNCTION GLOBAL Lasal32::ONL_READSERVER
  VAR_INPUT
      descr_num       : DINT;
      objAddr         : UDINT;
      data            : ^UDINT;
  END_VAR
  VAR_OUTPUT
      retval      : DINT;
  END_VAR

  // return no valid interface
  retval := LSL_ONL_NO_CIL_INTERFACE;
  // check if interface is available
  if CILError = 0 then
    // return no valid address pointer
    retval := LSL_ONL_NO_VALID_ADDRESS;
    // check the address pointer
    if objAddr <> 0 then
      // return no valid data pointer
      retval := LSL_ONL_NO_VALID_DATA_POINTER;
      // check the data pointer
      if data <> NIL then
        // check the communication handle
        if descr_num >= 0 then
          // call the OS methode to read the server and return the state and value.
          retval := OS_ONL_READSERVER(descr_num, objAddr, data, 0);
        else
          // return no valid handle
          retval := LSL_ONL_NO_VALID_CONNECTION_ID;
        end_if;
      end_if;
    end_if;
  end_if;
  


END_FUNCTION



FUNCTION GLOBAL Lasal32::ONL_WRITESERVER
  VAR_INPUT
      descr_num       : DINT;
      objAddr         : UDINT;
      data            : UDINT;
      result          : ^UDINT;
  END_VAR
  VAR_OUTPUT
      retval      : DINT;
  END_VAR
  
  // return no valid interface
  retval := LSL_ONL_NO_CIL_INTERFACE;
  // check if interface is available
  if CILError = 0 then
    // return no valid object address
    retval := LSL_ONL_NO_VALID_ADDRESS;
    // check the object address
    if objAddr <> 0 then
      // return no valid result pointer
      retval := LSL_ONL_NO_VALID_RESULT_POINTER;
      // check the result pointer
      if result <> NIL then
        // check the communication handle
        if descr_num >= 0 then
          // call the OS methode to write the server and return the state.
          retval := OS_ONL_WRITESERVER(descr_num,objAddr,data,result);
        else
          // return no valid handle
          retval := LSL_ONL_NO_VALID_CONNECTION_ID;
        end_if;
      end_if;
    end_if;
  end_if;


END_FUNCTION


FUNCTION GLOBAL Lasal32::ONL_REQUEST
	VAR_INPUT
		descr_num       : DINT;
		Cmd 	          : USINT;   //Command
		InBuffer1       : ^USINT;  //input data buffer 1
		InBuffer1Size   : UDINT;   //size of input data buffer 1
		InBuffer2 	    : ^USINT;  //input data buffer 2
		InBuffer2Size 	: UDINT;   //size of input data buffer 2 
		InBufferSizeAll : UDINT;   //Size of the whole input buffer. If you have to send more than one request, is this the size of every request
		OutBuffer 	    : ^USINT;  //Output data buffer
		OutBufferSize   : UDINT;   //size of the ouput data buffer
		BytesReturned   : ^UDINT;  //Optional
		CpuStatus 	    : ^USINT;  //Optional
		fFirstRecPart 	: USINT;   //Flag must be set, if it is the first part of the request
		fLastRecPart 	  : USINT;   //Flag must be set, if it is the last part of the request
	END_VAR
	VAR_OUTPUT
		retval 	        : DINT;
	END_VAR
  
  // return no valid interface
  retval := LSL_ONL_NO_CIL_INTERFACE;
  
  // check if interface is available
  if CILError = 0 then
     
    // return no valid result pointer
    retval := LSL_ONL_NO_VALID_RESULT_POINTER;
      
    if OutBuffer <> NIL then
      // check the communication handle
      if descr_num >= 0 then
        
        retval := OS_ONL_REQUEST(descr_num,
                                 Cmd,
                                 InBuffer1,
                                 InBuffer1Size,
                                 InBuffer2,
                                 InBuffer2Size,
                                 InBufferSizeAll,
                                 OutBuffer,
                                 OutBufferSize,
                                 BytesReturned,
                                 CpuStatus,
                                 fFirstRecPart,
                                 fLastRecPart
                                 );
      else
        // return no valid handle
        retval := LSL_ONL_NO_VALID_CONNECTION_ID;
      end_if;
    end_if;
  end_if;
  
END_FUNCTION

FUNCTION GLOBAL Lasal32::ONL_SETSENDINTERVAL
	VAR_INPUT
		Waittime 	: DINT;
	END_VAR
	VAR_OUTPUT
		retval 	: DINT;
	END_VAR
  
  if Waittime >= 0 then
    OS_ONL_SETSENDINTERVAL(Waittime);  //The OS-Function itself hasn't a returncode
    retval := 0;
  else
    retval := LSL_ONL_NO_VALID_CONNECTION_ID;
  end_if;
  
END_FUNCTION

FUNCTION Lasal32::OSErrorMapping
	VAR_INPUT
		ActError 	: DINT;
	END_VAR
	VAR_OUTPUT
		Status 	: iprStates;
	END_VAR
  
  //We need this for compatibly for older classes, because the type of the returncode of TX-Command is iprStates.
  //Now it is a OS function and we get a DINT back.
  if ActError < 0 then
    Status := ERROR;
    LastError := ActError;
  else
    Status := READY;
  end_if;

END_FUNCTION

FUNCTION GLOBAL Lasal32::GetLastError
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  
  retcode := LastError;

END_FUNCTION



FUNCTION GLOBAL Lasal32::ONL_GETOSVERSION
	VAR_INPUT
		descr_num 	: DINT;
		ver_major 	: ^DINT;
		ver_minor 	: ^DINT;
	END_VAR
	VAR_OUTPUT
		retval 	: DINT;
	END_VAR

  // return no valid interface
  retval := LSL_ONL_NO_CIL_INTERFACE;
  if CILError = 0 then
    
    // check communication handle
    retval := LSL_ONL_NO_VALID_CONNECTION_ID;
    if descr_num >= 0 then
      
      // check output pointers
      retval := LSL_ONL_NO_VALID_RESULT_POINTER;
      if (ver_major <> NIL) & (ver_minor <> NIL) then
        retval := OS_ONL_GETOSVERSION(descr_num, ver_major, ver_minor);
      end_if;
      
    end_if;
    
  end_if;
      

END_FUNCTION


FUNCTION GLOBAL Lasal32::ONL_BOOTOSIMAGE
	VAR_INPUT
		descr_num 	: DINT;
	END_VAR
	VAR_OUTPUT
		retval 	: DINT;
	END_VAR

  // return no valid interface
  retval := LSL_ONL_NO_CIL_INTERFACE;
  if CILError = 0 then
    
    // check communication handle
    retval := LSL_ONL_NO_VALID_CONNECTION_ID;
    if descr_num >= 0 then
      retval := OS_ONL_BOOTOSIMAGE(descr_num);
    end_if;
    
  end_if;

END_FUNCTION


FUNCTION GLOBAL Lasal32::ONL_LOADOSIMAGE
	VAR_INPUT
		descr_num 	: DINT;
		pData 	: ^CHAR;
		len 	: UDINT;
		lenAll 	: UDINT;
		ffirst 	: USINT;
		flast 	: USINT;
	END_VAR
	VAR_OUTPUT
		retval 	: DINT;
	END_VAR
  
  // return no valid interface
  retval := LSL_ONL_NO_CIL_INTERFACE;
  if CILError = 0 then
  
    // check communication handle
    retval := LSL_ONL_NO_VALID_CONNECTION_ID;
    if descr_num >= 0 then
  
      // check data pointer
      retval := LSL_ONL_NO_VALID_DATA_POINTER;
      if pData <> NIL then     
        retval := OS_ONL_LOADOSIMAGE(descr_num, pData, len, lenAll, ffirst, flast);
      end_if;
      
    end_if;
    
  end_if;
                

END_FUNCTION


FUNCTION GLOBAL Lasal32::ONL_SERVICEPROVIDER
	VAR_INPUT
		descr_num 	: DINT;
		pCmd 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		retval 	: DINT;
	END_VAR

  // return no valid interface
  retval := LSL_ONL_NO_CIL_INTERFACE;
  if CILError = 0 then
  
    // check communication handle
    retval := LSL_ONL_NO_VALID_CONNECTION_ID;
    if descr_num >= 0 then
  
      // check data pointer
      retval := LSL_ONL_NO_VALID_DATA_POINTER;
      if pCmd <> NIL then     
        retval := OS_ONL_SERVICEPROVIDER(descr_num, pCmd);
      end_if;

    end_if;

  end_if;

END_FUNCTION




FUNCTION GLOBAL Lasal32::ONL_ERROR
	VAR_INPUT
		dError 	: DINT;
		pStrError 	: ^void;
	END_VAR
	VAR_OUTPUT
		retval 	: DINT;
	END_VAR
  VAR
  	pTemp   : ^CHAR;
  END_VAR


  // return no valid interface
  retval := LSL_ONL_NO_CIL_INTERFACE;
  if CILError = 0 then
  
    // check data pointer
    retval := LSL_ONL_NO_VALID_DATA_POINTER;
    if pStrError <> NIL then     
      
      pTemp := OS_ONL_ERROR(dError);
      // check returnvalue
      retval := LSL_ONL_NO_VALID_RESULT_POINTER;
      if pTemp <> NIL then
        retval := 0;
        pStrError^$^CHAR := pTemp;
      end_if;
      
    end_if;

  end_if;

END_FUNCTION




FUNCTION GLOBAL Lasal32::ONL_CANCELREQUEST
	VAR_INPUT
		descr_num 	: DINT;
	END_VAR
	VAR_OUTPUT
		retval 	: DINT;
	END_VAR

  // return no valid interface
  retval := LSL_ONL_NO_CIL_INTERFACE;
  if CILError = 0 then

    // check communication handle    
    retval := LSL_ONL_NO_VALID_CONNECTION_ID;
    if descr_num >= 0 then
      retval := 0;
      OS_ONL_CANCELREQUEST(descr_num);
    end_if;
    
  end_if;

END_FUNCTION
