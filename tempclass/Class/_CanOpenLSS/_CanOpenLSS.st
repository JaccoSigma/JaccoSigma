//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
// we set the maximum number of found devices to the maximum possible canopen devices in one network
#define CANOPEN_LSS_MAX_NODE_NR               127

// wait 20ms after commands that do not have a response (like switch state global)
#define CANOPEN_LSS_DEFAULT_WAIT_TIME          20

#define CANOPEN_LSS_OBJ_LSS_TX              0x7E5
#define CANOPEN_LSS_OBJ_LSS_RX              0x7E4

#define CANOPEN_LSS_CMD_SWITCH_ST_GLOB       0x04
#define CANOPEN_LSS_CMD_SWITCH_ST_SEL_VEND   0x40
#define CANOPEN_LSS_CMD_SWITCH_ST_SEL_PROD   0x41
#define CANOPEN_LSS_CMD_SWITCH_ST_SEL_REV    0x42
#define CANOPEN_LSS_CMD_SWITCH_ST_SEL_SER    0x43
#define CANOPEN_LSS_CMD_SWITCH_ST_SEL_RSP    0x44
#define CANOPEN_LSS_CMD_CFG_NODE_ID          0x11
#define CANOPEN_LSS_CMD_CFG_BIT_TIMING       0x13
#define CANOPEN_LSS_CMD_ACTIVATE_BIT_TMG     0x15
#define CANOPEN_LSS_CMD_STORE_CFG            0x17
#define CANOPEN_LSS_CMD_INQUIRE_VEND         0x5A
#define CANOPEN_LSS_CMD_INQUIRE_PROD         0x5B
#define CANOPEN_LSS_CMD_INQUIRE_REV          0x5C
#define CANOPEN_LSS_CMD_INQUIRE_SER          0x5D
#define CANOPEN_LSS_CMD_INQUIRE_NODE_ID      0x5E
#define CANOPEN_LSS_CMD_ID_REMOTE_VEND       0x46
#define CANOPEN_LSS_CMD_ID_REMOTE_PROD       0x47
#define CANOPEN_LSS_CMD_ID_REMOTE_REV_LOW    0x48
#define CANOPEN_LSS_CMD_ID_REMOTE_REV_HIGH   0x49
#define CANOPEN_LSS_CMD_ID_REMOTE_SER_LOW    0x4A
#define CANOPEN_LSS_CMD_ID_REMOTE_SER_HIGH   0x4B
#define CANOPEN_LSS_CMD_ID_REMOTE_RESPONSE   0x4F


// not supported yet
//#define CANOPEN_LSS_CMD_ID_REM_NON_CFG       0x4C
//#define CANOPEN_LSS_CMD_ID_REM_NON_CFG_RSP   0x50
//#define CANOPEN_LSS_CMD_FASTSCAN             0x51
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "_CanOpenLSS"
	Revision           = "1.1"
	GUID               = "{1B5AC99A-9307-430C-9C4D-C156CFFBB038}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	DefCyclictime      = "1 ms"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\CANopen.ico"
	SharedCommandTable = "true"
	Objectsize         = "(548,120)"
	Comment            = "Class for Layer Setting Services of CANopen (CiA DSP 305)&#13;&#10;Only one object of this object is allowed per CAN interface&#13;&#10;&#13;&#10;ATTENTION: Do not use the functionality provided by this class while the machine is running! These services are only for the configuration of the network participants.">
	<Channels>
		<Server Name="ClassState" GUID="{2E50689B-A3AC-488E-B8DD-623C16656011}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the current state of the class.&#13;&#10;_NotInitialized...Class has not been initialized yet&#13;&#10;_Ready...Class is ready for a new task&#13;&#10;_InstallRxFailed...Installation of the receive object failed in the initialisation&#13;&#10;_Busy...Class is already working on a taks&#13;&#10;"/>
		<Client Name="Can" Required="true" Internal="false" Comment="Connect this client to an object channel of class _CanLib or a derivation of it"/>
		<Client Name="ResponseTimeout" Required="true" Internal="false" DefValue="100" Comment="Time to wait for an answer in ms after sending a request (default: 100ms)"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="RamAnd"/>
		<Dokumentation Revision="1.1" Date="25.06.2020" Author="PieSte" Company="Sigmatek" Description="Reset inquired device info if new one is started."/>
		<Dokumentation Revision="1.0" Date="04.02.2019" Author="RamAnd" Company="Sigmatek" Description="First version"/>
	</RevDoku>
</Class>
*)
_CanOpenLSS : CLASS
	TYPE
	  t_CanData : ARRAY [0..7] OF HSINT;
#pragma pack(push, 1)
	  t_CANopenLSS_DeviceDetails : STRUCT  //! <Type Public="true" Name="t_CANopenLSS_DeviceDetails"/>
	    StructItem : DINT;
	  END_STRUCT;
#pragma pack(pop)
	  t_e_LSS_ClassState :  //! <Type Public="true" Name="t_e_LSS_ClassState"/>
	  (
	    _NotInitialized,
	    _Ready,
	    _InstallRxFailed,
	    _Busy
	  )$UDINT;
	  t_e_LSS_ErrorStep :
	  (
	    LSS_NoError,
	    LSS_SwitchStateGlobal_SendError,
	    LSS_SwitchStateSelective_VendSendError,
	    LSS_SwitchStateSelective_ProdSendError,
	    LSS_SwitchStateSelective_RevSendError,
	    LSS_SwitchStateSelective_SerSendError,
	    LSS_SwitchStateSelective_Timeout,
	    LSS_ConfigureNodeID_SendError,
	    LSS_ConfigureNodeID_RspError,
	    LSS_ConfigureNodeID_Timeout,
	    LSS_ConfigureBitTiming_SendError,
	    LSS_ConfigureBitTiming_RspError,
	    LSS_ConfigureBitTiming_Timeout,
	    LSS_ActivateBitTiming_SendError,
	    LSS_StoreConfiguration_SendError,
	    LSS_StoreConfiguration_RspError,
	    LSS_StoreConfiguration_Timeout,
	    LSS_FindDevice_VendSendError,
	    LSS_FindDevice_ProdSendError,
	    LSS_FindDevice_RevLowSendError,
	    LSS_FindDevice_RevHighSendError,
	    LSS_FindDevice_SerLowSendError,
	    LSS_FindDevice_SerHighSendError,
	    LSS_FindDevice_RspError,
	    LSS_FindDevice_Timeout,
	    LSS_InquireDeviceInfos_VendSendError,
	    LSS_InquireDeviceInfos_VendTimeout,
	    LSS_InquireDeviceInfos_ProdSendError,
	    LSS_InquireDeviceInfos_ProdTimeout,
	    LSS_InquireDeviceInfos_RevSendError,
	    LSS_InquireDeviceInfos_RevTimeout,
	    LSS_InquireDeviceInfos_SerSendError,
	    LSS_InquireDeviceInfos_SerTimeout,
	    LSS_InquireDeviceInfos_NodeIDSendError,
	    LSS_InquireDeviceInfos_NodeIDTimeout
	  )$UDINT;
	  t_e_LSS_SSW :
	  (
	    _Idle,
	    _SwitchStateGlobalStart,
	    _SwitchStateGlobalWait,
	    _SwitchStateSelectiveStart,
	    _SwitchStateSelectiveSendProd,
	    _SwitchStateSelectiveSendRev,
	    _SwitchStateSelectiveSendSer,
	    _SwitchStateSelectiveWaitRsp,
	    _ConfigureNodeIdStart,
	    _ConfigureNodeIdWaitForConfirmation,
	    _ConfigureBitTimingStart,
	    _ConfigureBitTimingWaitConfirmation,
	    _ActivateBitTimingStart,
	    _ActivateBitTimingWait,
	    _ActivateBitTimingWait2,
	    _StoreConfigurationStart,
	    _StoreConfigurationWaitConfirmation,
	    _FindDeviceStart,
	    _FindDeviceSendProd,
	    _FindDeviceSendRevLow,
	    _FindDeviceSendRevHigh,
	    _FindDeviceSendSerLow,
	    _FindDeviceSendSerHigh,
	    _FindDeviceWaitRsp,
	    _InquireDeviceInfoVendor,
	    _InquireDeviceInfoWait4Vendor,
	    _InquireDeviceInfoProductCode,
	    _InquireDeviceInfoWait4ProductCode,
	    _InquireDeviceInfoRevision,
	    _InquireDeviceInfoWait4Revision,
	    _InquireDeviceInfoSerialNo,
	    _InquireDeviceInfoWait4SerialNo,
	    _InquireDeviceInfoNodeID,
	    _InquireDeviceInfoWait4NodeID
	  )$UDINT;
#pragma pack(push, 1)
	  t_NodeIdentity : STRUCT
	    VendorID : UDINT;
	    ProductCode : UDINT;
	    RevisionNumber : UDINT;
	    SerialNumber : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_InquiredDeviceInfo : STRUCT
	    IdentityInfo : t_NodeIdentity;
	    NodeID : USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_LSS_ErrorCode : STRUCT  //! <Type Public="true" Name="t_LSS_ErrorCode"/>
	    ErrorStep : t_e_LSS_ErrorStep;
	    ErrorCode : DINT;
	  END_STRUCT;
#pragma pack(pop)
	  t_LSS_InquireOptions : BSINT  //! <Type Public="true" Name="t_LSS_InquireOptions"/>
	  [
	    1 VendorID,
	    2 ProductCode,
	    3 RevisionNumber,
	    4 SerialNumber,
	    5 NodeID,
	  ];
	  t_LSSNumber :
	  (
	    _VendorID:=0,
	    _ProductCode:=1,
	    _RevisionNumber:=2,
	    _SerialNumber:=3
	  )$USINT;
#pragma pack(push, 1)
	  t_ProcessParameter : STRUCT
	    NewGlobalState : USINT;
	    SelectState : t_NodeIdentity;
	    NewNodeID : USINT;
	    NewBaudrate : UINT;
	    AutoStoreConfig : BOOL;
	    BitTimingSwitchDelay : UINT;
	    FindVendorID : UDINT;
	    FindProductCode : UDINT;
	    FindRevNrRangeMin : UDINT;
	    FindRevNrRangeMax : UDINT;
	    FindSerNrRangeMin : UDINT;
	    FindSerNrRangeMax : UDINT;
	    InquireOptions : t_LSS_InquireOptions;
	  END_STRUCT;
#pragma pack(pop)
	  t_SearchOptions : BSINT
	  [
	    1 SelectedVendorID,
	    2 SelectedProductCode,
	    3 SelectedRevisionNumber,
	    4 SelectedSerialNumber,
	  ];
	END_TYPE
  //Servers:
	ClassState 	: SvrChCmd_t_e_LSS_ClassState_PTofCls__CanOpenLSS;
  //Clients:
	Can 	: CltChCmd__CanLib;
	ResponseTimeout 	: CltCh_UDINT;
  //Variables:
		bInitialized 	: BOOL;
		eCurrentStep 	: t_e_LSS_SSW;
		LastProcessStartedByUser 	: t_e_LSS_SSW;
		udSendTimeStamp 	: UDINT;
		udReceiveTimeStamp 	: UDINT;
		MsgResponseTime 	: UDINT;
		MsgResponseTimeMax 	: UDINT;
		LastError 	: t_LSS_ErrorCode;
		usProcessStarting 	: USINT;
		sProcessParameter 	: t_ProcessParameter;
		InquiredDeviceInfos 	: t_InquiredDeviceInfo;
		RxWrongCmdCnt 	: UDINT;
		RxWrongLenCnt 	: UDINT;
		SuccessCount 	: UDINT;
		FailCount 	: UDINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="Switch all LSS slaves to wait or config mode (can be used to switch all to wait mode before picking one to configure with SwitchStateSelective).&#13;&#10;The state of the process as well as it&apos;s result can be checked via GetStatus()." Name="SwitchStateGlobal"/>
	FUNCTION GLOBAL SwitchStateGlobal
		VAR_INPUT
			NewState 	: USINT;			//! <Variable Comment="The State all connected LSS slaves should change to&#13;&#10;0..wait state&#13;&#10;1..config state" Name="SwitchStateGlobal.NewState"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="Returncode to indicate success or errors of the call&#13;&#10;&#13;&#10;0...Successful&#13;&#10;-1...Class not ready&#13;&#10;-2...Invalid parameter&#13;&#10;" Name="SwitchStateGlobal.retcode"/>
		END_VAR;
				//! <Function Comment="Switch a chosen slave to the config mode. The LSS address is used to select the slave.&#13;&#10;The state of the process as well as it&apos;s result can be checked via GetStatus()." Name="SwitchStateSelective"/>
	FUNCTION GLOBAL SwitchStateSelective
		VAR_INPUT
			VendorID 	: UDINT;			//! <Variable Comment="VendorID of the target device" Name="SwitchStateSelective.VendorID"/>
			ProductCode 	: UDINT;			//! <Variable Comment="ProductCode of the target device" Name="SwitchStateSelective.ProductCode"/>
			RevisionNumber 	: UDINT;			//! <Variable Comment="RevisionNumber of the target device" Name="SwitchStateSelective.RevisionNumber"/>
			SerialNumber 	: UDINT;			//! <Variable Comment="SerialNumber of the target device" Name="SwitchStateSelective.SerialNumber"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="Returncode to indicate success or errors of the call&#13;&#10;&#13;&#10;0...Successful&#13;&#10;-1...Class not ready" Name="SwitchStateSelective.retcode"/>
		END_VAR;
				//! <Function Comment="Set a new node ID (LSS slave has to be in config state) with the option to directly store it in the node (StoreConfiguration() does not have to be called separately)&#13;&#10;The state of the process as well as it&apos;s result can be checked via GetStatus()." Name="ConfigureNodeID"/>
	FUNCTION GLOBAL ConfigureNodeID
		VAR_INPUT
			NewNodeID 	: USINT;			//! <Variable Comment="Defines the new node ID between 1 and 127" Name="ConfigureNodeID.NewNodeID"/>
			AutoStoreConfig 	: BOOL := TRUE;			//! <Variable Comment="This value defines if the node id should be automatically stored after setting it. (Default: TRUE)" Name="ConfigureNodeID.AutoStoreConfig"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="Returncode to indicate success or errors of the call&#13;&#10;&#13;&#10;0...Successful&#13;&#10;-1...Class not ready&#13;&#10;-2...Invalid parameter&#13;&#10;" Name="ConfigureNodeID.retcode"/>
		END_VAR;
				//! <Function Comment="Set a new baud rate (LSS slave has to be in config state)&#13;&#10;The state of the process as well as it&apos;s result can be checked via GetStatus()." Name="ConfigureBitTiming"/>
	FUNCTION GLOBAL ConfigureBitTiming
		VAR_INPUT
			NewBaudrate 	: UINT;			//! <Variable Comment="New baudrate in kbps. Valid baudrates are:&#13;&#10;1000&#13;&#10;500&#13;&#10;250&#13;&#10;125&#13;&#10;50&#13;&#10;20" Name="ConfigureBitTiming.NewBaudrate"/>
			SwitchDelay 	: UINT := 0;			//! <Variable Comment="This delay in [ms] has to be waited twice by the network participants after receiving this message.&#13;&#10;Once before and once after switching to the new bit timing.&#13;&#10;&#13;&#10;If this value is set &gt; 0 the new bit timing is automatically stored (StoreConfiguration() is automatically executed) and activated (ActivateBitTiming executed) with this delay.&#13;&#10;If this value is 0, those steps have to be done manually.&#13;&#10;&#13;&#10;ATTENTION: If this is set, the baudrate of the PLC CAN interface will also be changed to the new baudrate!&#13;&#10;" Name="ConfigureBitTiming.SwitchDelay"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="Returncode to indicate success or errors of the call&#13;&#10;&#13;&#10;0...Successful&#13;&#10;-1...Class not ready&#13;&#10;-2...Invalid parameter&#13;&#10;" Name="ConfigureBitTiming.retcode"/>
		END_VAR;
				//! <Function Comment="Activate the bit timing which has been set via ConfigureBitTiming for all LSS slaves (LSS slave has to be in config state)&#13;&#10;After switching the baud rate for the slaves it is recommended also to switch the baud rate for the used CAN interface to be able to store the new configuration via StoreConfiguration()&#13;&#10;The state of the process as well as it&apos;s result can be checked via GetStatus()." Name="ActivateBitTiming"/>
	FUNCTION GLOBAL ActivateBitTiming
		VAR_INPUT
			SwitchDelay 	: UINT;			//! <Variable Comment="This delay in [ms] has to be waited twice by the network participants after receiving this message.&#13;&#10;Once before and once after switching to the new bit timing." Name="ActivateBitTiming.SwitchDelay"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="Returncode to indicate success or errors of the call&#13;&#10;&#13;&#10;0...Successful&#13;&#10;-1...Class not ready" Name="ActivateBitTiming.retcode"/>
		END_VAR;
				//! <Function Comment="Store node ID and baud rate of a LSS slave. You have to make sure that only one LSS slave is in configuration mode and also that you changed the baud rate of the PLC CAN interface to the one of the LSS slave if it changed.&#13;&#10;The state of the process as well as it&apos;s result can be checked via GetStatus()." Name="StoreConfiguration"/>
	FUNCTION GLOBAL StoreConfiguration
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="Returncode to indicate success or errors of the call&#13;&#10;&#13;&#10;0...Successful&#13;&#10;-1...Class not ready&#13;&#10;" Name="StoreConfiguration.retcode"/>
		END_VAR;
				//! <Function Comment="Find a specific device (VendorID/ProductCode) within a certain range of Revisions and Serial Numbers&#13;&#10;The state of the process as well as it&apos;s result can be checked via GetStatus().&#13;&#10;The ErrorStep returned via GetStatus provides the information of the search result:&#13;&#10;LSS_NoError...At least one Device found matching the search criteria&#13;&#10;LSS_FindDevice_Timeout...No Device  found matching the search criteria&#13;&#10;Any other step indicates an error in the search process" Name="FindDevice"/>
	FUNCTION GLOBAL FindDevice
		VAR_INPUT
			VendorID 	: UDINT;			//! <Variable Comment="Define what vendor ID to search for" Name="FindDevice.VendorID"/>
			ProductCode 	: UDINT;			//! <Variable Comment="Define what product code to search for" Name="FindDevice.ProductCode"/>
			RevisionRangeLow 	: UDINT;			//! <Variable Comment="Define the lowest revision number that should be included in the search result" Name="FindDevice.RevisionRangeLow"/>
			RevisionRangeHigh 	: UDINT;			//! <Variable Comment="Define the highest revision number that should be included in the search result" Name="FindDevice.RevisionRangeHigh"/>
			SerialRangeLow 	: UDINT;			//! <Variable Comment="Define the lowest serial number that should be included in the search result" Name="FindDevice.SerialRangeLow"/>
			SerialRangeHigh 	: UDINT;			//! <Variable Comment="Define the highest serial number that should be included in the search result" Name="FindDevice.SerialRangeHigh"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="Returncode to indicate success or errors of the call&#13;&#10;&#13;&#10;0...Successful&#13;&#10;-1...Class not ready&#13;&#10;-2...Invalid parameter&#13;&#10;" Name="FindDevice.retcode"/>
		END_VAR;
				//! <Function Comment="This method provides informations about the state of the last started task as well as details on errors if it failed." Name="GetStatus"/>
	FUNCTION GLOBAL GetStatus
		VAR_INPUT
			pErrorCode 	: ^t_LSS_ErrorCode;			//! <Variable Comment="Provide the address of a variable, so the method can store the error code details on it." Name="GetStatus.pErrorCode"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: iprStates;			//! <Variable Comment="Returncode indicates the current state of the class.&#13;&#10;&#13;&#10;READY...The class is ready for a new task (Never had a task or completed the last task successfully)&#13;&#10;BUSY...The class is busy with a task&#13;&#10;ERROR...The last task resulted in an error&#13;&#10;" Name="GetStatus.retcode"/>
		END_VAR;
				//! <Function Comment="Get device information of a LSS slave (has to be in config state)." Name="InquireDeviceInfos"/>
	FUNCTION GLOBAL InquireDeviceInfos
		VAR_INPUT
			InquireOptions 	: t_LSS_InquireOptions := 2#11111;			//! <Variable Comment="If not all infos needed, with this parameter the needed informations can be chosen" Name="InquireDeviceInfos.InquireOptions"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="Returncode to indicate success or errors of the call&#13;&#10;&#13;&#10;0...Successful&#13;&#10;-1...Class not ready" Name="InquireDeviceInfos.retcode"/>
		END_VAR;
				//! <Function Comment="Get the device infos requested by calling InquireDeviceInfos.&#13;&#10;If the command has been executed successfully on the CAN bus the information of the valid pointers will be filled." Name="GetInquiredDeviceInfos"/>
	FUNCTION GLOBAL GetInquiredDeviceInfos
		VAR_INPUT
			pVendorID 	: ^UDINT := NIL;			//! <Variable Comment="Provide the address of a variable (if the option for the VendorID has been set at the InquireDeviceInfos() call) to get the value of the received VendorID." Name="GetInquiredDeviceInfos.pVendorID"/>
			pProductCode 	: ^UDINT := NIL;			//! <Variable Comment="Provide the address of a variable (if the option for the ProductCode has been set at the InquireDeviceInfos() call) to get the value of the received ProductCode." Name="GetInquiredDeviceInfos.pProductCode"/>
			pRevisionNumber 	: ^UDINT := NIL;			//! <Variable Comment="Provide the address of a variable (if the option for the RevisionNumber has been set at the InquireDeviceInfos() call) to get the value of the received RevisionNumber." Name="GetInquiredDeviceInfos.pRevisionNumber"/>
			pSerialNumber 	: ^UDINT := NIL;			//! <Variable Comment="Provide the address of a variable (if the option for the SerialNumber has been set at the InquireDeviceInfos() call) to get the value of the received SerialNumber." Name="GetInquiredDeviceInfos.pSerialNumber"/>
			pNodeID 	: ^USINT := NIL;			//! <Variable Comment="Provide the address of a variable (if the option for the NodeID has been set at the InquireDeviceInfos() call) to get the value of the received NodeID." Name="GetInquiredDeviceInfos.pNodeID"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="Returncode to indicate success or errors of the call&#13;&#10;&#13;&#10;0...Successful&#13;&#10;-1...Class not ready&#13;&#10;-2...Invalid parameter&#13;&#10;" Name="GetInquiredDeviceInfos.retcode"/>
		END_VAR;
	
	FUNCTION InitMe;
	
	FUNCTION ReceiveCallback
		VAR_INPUT
			PiCanptr 	: ^USINT;
			RxDataptr 	: ^USINT;
			Thisptr 	: DINT;
		END_VAR;
	
	FUNCTION Baudrate2SigmatekIndex
		VAR_INPUT
			Baudrate 	: UINT;
		END_VAR
		VAR_OUTPUT
			Index 	: USINT;			//! <Variable Comment="Index of baud rate (16#FF = invalid)" Name="Baudrate2SigmatekIndex.Index"/>
		END_VAR;
	
	FUNCTION Baudrate2CANopenIndex
		VAR_INPUT
			Baudrate 	: UINT;
		END_VAR
		VAR_OUTPUT
			Index 	: USINT;			//! <Variable Comment="Index of baud rate (16#FF = invalid)" Name="Baudrate2CANopenIndex.Index"/>
		END_VAR;
	
	FUNCTION StartProcess
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION SelectNextInquiry;
	
	FUNCTION CheckResponse
		VAR_INPUT
			ExpectedCommand 	: USINT;
			ReceivedCanObj 	: ^_BasicCanObj;
			CheckErrorCode 	: USINT := 0;			//! <Variable Comment="0..don&apos;t check&#13;&#10;1..Task finished: check, set error, success/fail counter, classstate and current step&#13;&#10;2..Task finished if error: Check and set error, cancel on error but don&apos;t do anything if it&apos;s successful (only return TRUE for further handling in the calling method)" Name="CheckResponse.CheckErrorCode"/>
			ErrorStep 	: t_e_LSS_ErrorStep := LSS_NoError;
		END_VAR
		VAR_OUTPUT
			CorrectResponse 	: BOOL;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _CanLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _CanOpenLSS::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__CANOPENLSS
1$UINT, 1$UINT, (SIZEOF(::_CanOpenLSS))$UINT, 
1$UINT, 2$UINT, 0$UINT, 
TO_UDINT(1339255835), "_CanOpenLSS", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::_CanOpenLSS.ClassState.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(1096059024), "ClassState", 
//Clients:
(::_CanOpenLSS.Can.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(4120639576), "Can", TO_UDINT(529317953), "_CanLib", 1$UINT, 10$UINT, 
(::_CanOpenLSS.ResponseTimeout.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1894052253), "ResponseTimeout", 
END_FUNCTION


#define USER_CNT__CanOpenLSS 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__CanOpenLSS] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _CanOpenLSS::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT__CanOpenLSS, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
	ClassState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION

FUNCTION VIRTUAL GLOBAL _CanOpenLSS::Init

  if _FirstScan then
    // initialize the class (if it hasn't been done already)
    if bInitialized = FALSE then
      InitMe();
    end_if;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _CanOpenLSS::CyWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
  VAR
  	MyTxMsg : t_CanData;
  END_VAR
  
  case eCurrentStep of
//**********************************************************************************************************************************************************
  	t_e_LSS_SSW::_Idle: // wait for commands

//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_SwitchStateGlobalStart:
      _memset(dest:=#MyTxMsg[0], usByte:=0, cntr:=sizeof(MyTxMsg));

      // switch to configuration state
      MyTxMsg[0] := CANOPEN_LSS_CMD_SWITCH_ST_GLOB;       // command: switch state global
      MyTxMsg[1] := sProcessParameter.NewGlobalState;   // switch to desired LSS state
      
      LastError.ErrorCode := Can.CanTxObj(ObjNr:=CANOPEN_LSS_OBJ_LSS_TX, length:=8, data:=#MyTxMsg);

      if LastError.ErrorCode = 0 then
        udSendTimeStamp := ops.tAbsolute;
        eCurrentStep := t_e_LSS_SSW::_SwitchStateGlobalWait;
      else
        LastError.ErrorStep := t_e_LSS_ErrorStep::LSS_SwitchStateGlobal_SendError;
        eCurrentStep := t_e_LSS_SSW::_Idle;  
        ClassState := t_e_LSS_ClassState::_Ready;
        FailCount += 1;
      end_if;     
  
//**********************************************************************************************************************************************************
  t_e_LSS_SSW::_SwitchStateGlobalWait:
      // wait a little before going back to ready
      if (ops.tAbsolute - udSendTimeStamp) > CANOPEN_LSS_DEFAULT_WAIT_TIME then
        // => go back to idle
        eCurrentStep := t_e_LSS_SSW::_Idle;
        ClassState := t_e_LSS_ClassState::_Ready;
        SuccessCount += 1;
      end_if;
    
//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_SwitchStateSelectiveStart:
      _memset(dest:=#MyTxMsg[0], usByte:=0, cntr:=sizeof(MyTxMsg));

      // switch to configuration state
      MyTxMsg[0]        := CANOPEN_LSS_CMD_SWITCH_ST_SEL_VEND;       // command: switch state selective vendor ID
      MyTxMsg[1]$UDINT  := sProcessParameter.SelectState.VendorID;
      
      LastError.ErrorCode := Can.CanTxObj(ObjNr:=CANOPEN_LSS_OBJ_LSS_TX, length:=8, data:=#MyTxMsg);

      if LastError.ErrorCode = 0 then
        eCurrentStep := t_e_LSS_SSW::_SwitchStateSelectiveSendProd;
      else
        LastError.ErrorStep := t_e_LSS_ErrorStep::LSS_SwitchStateSelective_VendSendError;
        eCurrentStep := t_e_LSS_SSW::_Idle;  
        ClassState := t_e_LSS_ClassState::_Ready;
        FailCount += 1;
      end_if;     

//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_SwitchStateSelectiveSendProd:
      _memset(dest:=#MyTxMsg[0], usByte:=0, cntr:=sizeof(MyTxMsg));

      // switch to configuration state
      MyTxMsg[0]        := CANOPEN_LSS_CMD_SWITCH_ST_SEL_PROD;       // command: switch state selective product code
      MyTxMsg[1]$UDINT  := sProcessParameter.SelectState.ProductCode;
      
      LastError.ErrorCode := Can.CanTxObj(ObjNr:=CANOPEN_LSS_OBJ_LSS_TX, length:=8, data:=#MyTxMsg);

      if LastError.ErrorCode = 0 then
        eCurrentStep := t_e_LSS_SSW::_SwitchStateSelectiveSendRev;
      else
        LastError.ErrorStep := t_e_LSS_ErrorStep::LSS_SwitchStateSelective_ProdSendError;
        eCurrentStep := t_e_LSS_SSW::_Idle;  
        ClassState := t_e_LSS_ClassState::_Ready;
        FailCount += 1;
      end_if;    

//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_SwitchStateSelectiveSendRev:
      _memset(dest:=#MyTxMsg[0], usByte:=0, cntr:=sizeof(MyTxMsg));

      // switch to configuration state
      MyTxMsg[0]        := CANOPEN_LSS_CMD_SWITCH_ST_SEL_REV;       // command: switch state selective revision number
      MyTxMsg[1]$UDINT  := sProcessParameter.SelectState.RevisionNumber;
      
      LastError.ErrorCode := Can.CanTxObj(ObjNr:=CANOPEN_LSS_OBJ_LSS_TX, length:=8, data:=#MyTxMsg);

      if LastError.ErrorCode = 0 then
        eCurrentStep := t_e_LSS_SSW::_SwitchStateSelectiveSendSer;
      else
        LastError.ErrorStep := t_e_LSS_ErrorStep::LSS_SwitchStateSelective_RevSendError;
        eCurrentStep := t_e_LSS_SSW::_Idle;  
        ClassState := t_e_LSS_ClassState::_Ready;
        FailCount += 1;
      end_if;    

//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_SwitchStateSelectiveSendSer:
      _memset(dest:=#MyTxMsg[0], usByte:=0, cntr:=sizeof(MyTxMsg));

      // switch to configuration state
      MyTxMsg[0]        := CANOPEN_LSS_CMD_SWITCH_ST_SEL_SER;       // command: switch state selective serial number
      MyTxMsg[1]$UDINT  := sProcessParameter.SelectState.SerialNumber;
      
      LastError.ErrorCode := Can.CanTxObj(ObjNr:=CANOPEN_LSS_OBJ_LSS_TX, length:=8, data:=#MyTxMsg);

      if LastError.ErrorCode = 0 then
        udSendTimeStamp := ops.tAbsolute;
        eCurrentStep := t_e_LSS_SSW::_SwitchStateSelectiveWaitRsp;
      else
        LastError.ErrorStep := t_e_LSS_ErrorStep::LSS_SwitchStateSelective_SerSendError;
        eCurrentStep := t_e_LSS_SSW::_Idle;  
        ClassState := t_e_LSS_ClassState::_Ready;
        FailCount += 1;
      end_if;    

//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_SwitchStateSelectiveWaitRsp:
      // wait until we receive an answer
      if (ops.tAbsolute - udSendTimeStamp) > ResponseTimeout then
        // timed out => go back to idle
        LastError.ErrorStep := t_e_LSS_ErrorStep::LSS_SwitchStateSelective_Timeout;
        eCurrentStep := t_e_LSS_SSW::_Idle;
        ClassState := t_e_LSS_ClassState::_Ready;
        FailCount += 1;
      end_if;

//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_ConfigureNodeIdStart:
      _memset(dest:=#MyTxMsg[0], usByte:=0, cntr:=sizeof(MyTxMsg));

      // send message to set the new nodeid
      MyTxMsg[0] := CANOPEN_LSS_CMD_CFG_NODE_ID;  // command: set nodeid
      MyTxMsg[1] := sProcessParameter.NewNodeID;  // new node ID
      
      LastError.ErrorCode := Can.CanTxObj(ObjNr:=CANOPEN_LSS_OBJ_LSS_TX, length:=8, data:=#MyTxMsg);

      if LastError.ErrorCode = 0 then
        udSendTimeStamp := ops.tAbsolute;
        eCurrentStep := t_e_LSS_SSW::_ConfigureNodeIdWaitForConfirmation;
      else
        LastError.ErrorStep := t_e_LSS_ErrorStep::LSS_ConfigureNodeID_SendError;
        eCurrentStep := t_e_LSS_SSW::_Idle;  
        ClassState := t_e_LSS_ClassState::_Ready;
        FailCount += 1;
      end_if;     

//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_ConfigureNodeIdWaitForConfirmation:
      // wait until we receive an answer
      if (ops.tAbsolute - udSendTimeStamp) > ResponseTimeout then
        // timed out => go back to idle
        LastError.ErrorStep := t_e_LSS_ErrorStep::LSS_ConfigureNodeID_Timeout;
        eCurrentStep := t_e_LSS_SSW::_Idle;
        ClassState := t_e_LSS_ClassState::_Ready;
        FailCount += 1;
      end_if;

//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_ConfigureBitTimingStart:
      _memset(dest:=#MyTxMsg[0], usByte:=0, cntr:=sizeof(MyTxMsg));

      // send message to set the new nodeid
      MyTxMsg[0] := CANOPEN_LSS_CMD_CFG_BIT_TIMING; // command: set bit timing
      MyTxMsg[1] := 0;                              // use CiA 301 table
      MyTxMsg[2] := Baudrate2CANopenIndex(Baudrate:=sProcessParameter.NewBaudrate);
      
      LastError.ErrorCode := Can.CanTxObj(ObjNr:=CANOPEN_LSS_OBJ_LSS_TX, length:=8, data:=#MyTxMsg);

      if LastError.ErrorCode = 0 then
        udSendTimeStamp := ops.tAbsolute;
        eCurrentStep := t_e_LSS_SSW::_ConfigureBitTimingWaitConfirmation;
      else
        LastError.ErrorStep := t_e_LSS_ErrorStep::LSS_ConfigureBitTiming_SendError;
        eCurrentStep := t_e_LSS_SSW::_Idle;  
        ClassState := t_e_LSS_ClassState::_Ready;
        FailCount += 1;
      end_if;     

//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_ConfigureBitTimingWaitConfirmation:
      // wait until we receive an answer
      if (ops.tAbsolute - udSendTimeStamp) > ResponseTimeout then
        // timed out => go back to idle
        LastError.ErrorStep := t_e_LSS_ErrorStep::LSS_ConfigureBitTiming_Timeout;
        eCurrentStep := t_e_LSS_SSW::_Idle;
        ClassState := t_e_LSS_ClassState::_Ready;
        FailCount += 1;
      end_if;
    
//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_ActivateBitTimingStart:
      _memset(dest:=#MyTxMsg[0], usByte:=0, cntr:=sizeof(MyTxMsg));

      // switch to configuration state
      MyTxMsg[0]      := CANOPEN_LSS_CMD_ACTIVATE_BIT_TMG;        // command: activate bit timing
      MyTxMsg[1]$UINT := sProcessParameter.BitTimingSwitchDelay;  // switch to desired LSS state
      
      LastError.ErrorCode := Can.CanTxObj(ObjNr:=CANOPEN_LSS_OBJ_LSS_TX, length:=8, data:=#MyTxMsg);

      if LastError.ErrorCode = 0 then
        udSendTimeStamp := ops.tAbsolute;
        eCurrentStep := t_e_LSS_SSW::_ActivateBitTimingWait;
      else
        LastError.ErrorStep := t_e_LSS_ErrorStep::LSS_ActivateBitTiming_SendError;
        eCurrentStep := t_e_LSS_SSW::_Idle;  
        ClassState := t_e_LSS_ClassState::_Ready;
        FailCount += 1;
      end_if;     

//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_ActivateBitTimingWait:
      // wait the switch delay once
      if (ops.tAbsolute - udSendTimeStamp) > sProcessParameter.BitTimingSwitchDelay then
        // check if we also have to store the setting right away
        if sProcessParameter.AutoStoreConfig then
          Can.SetBaudrate(Baudrate:=Baudrate2SigmatekIndex(Baudrate:=sProcessParameter.NewBaudrate));
        end_if;
        udSendTimeStamp := ops.tAbsolute;
        eCurrentStep := t_e_LSS_SSW::_ActivateBitTimingWait2;
      end_if;

//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_ActivateBitTimingWait2:
      // wait after switching the baudrate of the local CAN
      if (ops.tAbsolute - udSendTimeStamp) > sProcessParameter.BitTimingSwitchDelay then
        // => go back to idle
        eCurrentStep := t_e_LSS_SSW::_Idle;
        ClassState := t_e_LSS_ClassState::_Ready;
        SuccessCount += 1;
      end_if;

//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_StoreConfigurationStart:
      _memset(dest:=#MyTxMsg[0], usByte:=0, cntr:=sizeof(MyTxMsg));

      // send message to store current configuration
      MyTxMsg[0] := CANOPEN_LSS_CMD_STORE_CFG;   // command: store configuration
      
      LastError.ErrorCode := Can.CanTxObj(ObjNr:=CANOPEN_LSS_OBJ_LSS_TX, length:=8, data:=#MyTxMsg);

      if LastError.ErrorCode = 0 then
        udSendTimeStamp := ops.tAbsolute;
        eCurrentStep := t_e_LSS_SSW::_StoreConfigurationWaitConfirmation;
      else
        LastError.ErrorStep := t_e_LSS_ErrorStep::LSS_StoreConfiguration_SendError;
        eCurrentStep := t_e_LSS_SSW::_Idle;  
        ClassState := t_e_LSS_ClassState::_Ready;
        FailCount += 1;
      end_if;     

//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_StoreConfigurationWaitConfirmation:
      // wait until we receive an answer
      if (ops.tAbsolute - udSendTimeStamp) > ResponseTimeout then
        // timed out => go back to idle
        LastError.ErrorStep := t_e_LSS_ErrorStep::LSS_StoreConfiguration_Timeout;
        eCurrentStep := t_e_LSS_SSW::_Idle;
        ClassState := t_e_LSS_ClassState::_Ready;
        FailCount += 1;
      end_if;

//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_FindDeviceStart:
      _memset(dest:=#MyTxMsg[0], usByte:=0, cntr:=sizeof(MyTxMsg));

      // switch to configuration state
      MyTxMsg[0]        := CANOPEN_LSS_CMD_ID_REMOTE_VEND;       
      MyTxMsg[1]$UDINT  := sProcessParameter.FindVendorID;
      
      LastError.ErrorCode := Can.CanTxObj(ObjNr:=CANOPEN_LSS_OBJ_LSS_TX, length:=8, data:=#MyTxMsg);

      if LastError.ErrorCode = 0 then
        eCurrentStep := t_e_LSS_SSW::_FindDeviceSendProd;
      else
        LastError.ErrorStep := t_e_LSS_ErrorStep::LSS_FindDevice_VendSendError;
        eCurrentStep := t_e_LSS_SSW::_Idle;  
        ClassState := t_e_LSS_ClassState::_Ready;
        FailCount += 1;
      end_if;     

//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_FindDeviceSendProd:
      _memset(dest:=#MyTxMsg[0], usByte:=0, cntr:=sizeof(MyTxMsg));

      // switch to configuration state
      MyTxMsg[0]        := CANOPEN_LSS_CMD_ID_REMOTE_PROD;       
      MyTxMsg[1]$UDINT  := sProcessParameter.FindProductCode;
      
      LastError.ErrorCode := Can.CanTxObj(ObjNr:=CANOPEN_LSS_OBJ_LSS_TX, length:=8, data:=#MyTxMsg);

      if LastError.ErrorCode = 0 then
        eCurrentStep := t_e_LSS_SSW::_FindDeviceSendRevLow;
      else
        LastError.ErrorStep := t_e_LSS_ErrorStep::LSS_FindDevice_ProdSendError;
        eCurrentStep := t_e_LSS_SSW::_Idle;  
        ClassState := t_e_LSS_ClassState::_Ready;
        FailCount += 1;
      end_if;     

//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_FindDeviceSendRevLow:
      _memset(dest:=#MyTxMsg[0], usByte:=0, cntr:=sizeof(MyTxMsg));

      // switch to configuration state
      MyTxMsg[0]        := CANOPEN_LSS_CMD_ID_REMOTE_REV_LOW;       
      MyTxMsg[1]$UDINT  := sProcessParameter.FindRevNrRangeMin;
      
      LastError.ErrorCode := Can.CanTxObj(ObjNr:=CANOPEN_LSS_OBJ_LSS_TX, length:=8, data:=#MyTxMsg);

      if LastError.ErrorCode = 0 then
        eCurrentStep := t_e_LSS_SSW::_FindDeviceSendRevHigh;
      else
        LastError.ErrorStep := t_e_LSS_ErrorStep::LSS_FindDevice_RevLowSendError;
        eCurrentStep := t_e_LSS_SSW::_Idle;  
        ClassState := t_e_LSS_ClassState::_Ready;
        FailCount += 1;
      end_if;     

//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_FindDeviceSendRevHigh:
      _memset(dest:=#MyTxMsg[0], usByte:=0, cntr:=sizeof(MyTxMsg));

      // switch to configuration state
      MyTxMsg[0]        := CANOPEN_LSS_CMD_ID_REMOTE_REV_HIGH;       
      MyTxMsg[1]$UDINT  := sProcessParameter.FindRevNrRangeMax;
      
      LastError.ErrorCode := Can.CanTxObj(ObjNr:=CANOPEN_LSS_OBJ_LSS_TX, length:=8, data:=#MyTxMsg);

      if LastError.ErrorCode = 0 then
        eCurrentStep := t_e_LSS_SSW::_FindDeviceSendSerLow;
      else
        LastError.ErrorStep := t_e_LSS_ErrorStep::LSS_FindDevice_RevHighSendError;
        eCurrentStep := t_e_LSS_SSW::_Idle;  
        ClassState := t_e_LSS_ClassState::_Ready;
        FailCount += 1;
      end_if;     

//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_FindDeviceSendSerLow:
      _memset(dest:=#MyTxMsg[0], usByte:=0, cntr:=sizeof(MyTxMsg));

      // switch to configuration state
      MyTxMsg[0]        := CANOPEN_LSS_CMD_ID_REMOTE_SER_LOW;
      MyTxMsg[1]$UDINT  := sProcessParameter.FindSerNrRangeMin;
      
      LastError.ErrorCode := Can.CanTxObj(ObjNr:=CANOPEN_LSS_OBJ_LSS_TX, length:=8, data:=#MyTxMsg);

      if LastError.ErrorCode = 0 then
        eCurrentStep := t_e_LSS_SSW::_FindDeviceSendSerHigh;
      else
        LastError.ErrorStep := t_e_LSS_ErrorStep::LSS_FindDevice_SerLowSendError;
        eCurrentStep := t_e_LSS_SSW::_Idle;  
        ClassState := t_e_LSS_ClassState::_Ready;
        FailCount += 1;
      end_if;     

//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_FindDeviceSendSerHigh:
      _memset(dest:=#MyTxMsg[0], usByte:=0, cntr:=sizeof(MyTxMsg));

      // switch to configuration state
      MyTxMsg[0]        := CANOPEN_LSS_CMD_ID_REMOTE_SER_HIGH;
      MyTxMsg[1]$UDINT  := sProcessParameter.FindSerNrRangeMax;
      
      LastError.ErrorCode := Can.CanTxObj(ObjNr:=CANOPEN_LSS_OBJ_LSS_TX, length:=8, data:=#MyTxMsg);

      if LastError.ErrorCode = 0 then
        udSendTimeStamp := ops.tAbsolute;
        eCurrentStep := t_e_LSS_SSW::_FindDeviceWaitRsp;
      else
        LastError.ErrorStep := t_e_LSS_ErrorStep::LSS_FindDevice_SerHighSendError;
        eCurrentStep := t_e_LSS_SSW::_Idle;  
        ClassState := t_e_LSS_ClassState::_Ready;
        FailCount += 1;
      end_if;     

//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_FindDeviceWaitRsp:
      // wait until we receive an answer
      if (ops.tAbsolute - udSendTimeStamp) > ResponseTimeout then
        // timed out => go back to idle
        LastError.ErrorStep := t_e_LSS_ErrorStep::LSS_FindDevice_Timeout;
        eCurrentStep := t_e_LSS_SSW::_Idle;
        ClassState := t_e_LSS_ClassState::_Ready;
        FailCount += 1;
      end_if;

//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_InquireDeviceInfoVendor:
      _memset(dest:=#MyTxMsg[0], usByte:=0, cntr:=sizeof(MyTxMsg));

      // switch to configuration state
      MyTxMsg[0]        := CANOPEN_LSS_CMD_INQUIRE_VEND;
      
      LastError.ErrorCode := Can.CanTxObj(ObjNr:=CANOPEN_LSS_OBJ_LSS_TX, length:=8, data:=#MyTxMsg);

      if LastError.ErrorCode = 0 then
        udSendTimeStamp := ops.tAbsolute;
        eCurrentStep := t_e_LSS_SSW::_InquireDeviceInfoWait4Vendor;
      else
        LastError.ErrorStep := t_e_LSS_ErrorStep::LSS_InquireDeviceInfos_VendSendError;
        eCurrentStep := t_e_LSS_SSW::_Idle;  
        ClassState := t_e_LSS_ClassState::_Ready;
        FailCount += 1;
      end_if;     

//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_InquireDeviceInfoWait4Vendor:
      // wait until we receive an answer
      if (ops.tAbsolute - udSendTimeStamp) > ResponseTimeout then
        // timed out => go back to idle
        LastError.ErrorStep := t_e_LSS_ErrorStep::LSS_InquireDeviceInfos_VendTimeout;
        eCurrentStep := t_e_LSS_SSW::_Idle;
        ClassState := t_e_LSS_ClassState::_Ready;
        FailCount += 1;
      end_if;

//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_InquireDeviceInfoProductCode:
      _memset(dest:=#MyTxMsg[0], usByte:=0, cntr:=sizeof(MyTxMsg));

      // switch to configuration state
      MyTxMsg[0]        := CANOPEN_LSS_CMD_INQUIRE_PROD;
      
      LastError.ErrorCode := Can.CanTxObj(ObjNr:=CANOPEN_LSS_OBJ_LSS_TX, length:=8, data:=#MyTxMsg);

      if LastError.ErrorCode = 0 then
        udSendTimeStamp := ops.tAbsolute;
        eCurrentStep := t_e_LSS_SSW::_InquireDeviceInfoWait4ProductCode;
      else
        LastError.ErrorStep := t_e_LSS_ErrorStep::LSS_InquireDeviceInfos_ProdSendError;
        eCurrentStep := t_e_LSS_SSW::_Idle;  
        ClassState := t_e_LSS_ClassState::_Ready;
        FailCount += 1;
      end_if;     

//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_InquireDeviceInfoWait4ProductCode:
      // wait until we receive an answer
      if (ops.tAbsolute - udSendTimeStamp) > ResponseTimeout then
        // timed out => go back to idle
        LastError.ErrorStep := t_e_LSS_ErrorStep::LSS_InquireDeviceInfos_ProdTimeout;
        eCurrentStep := t_e_LSS_SSW::_Idle;
        ClassState := t_e_LSS_ClassState::_Ready;
        FailCount += 1;
      end_if;

//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_InquireDeviceInfoRevision:
      _memset(dest:=#MyTxMsg[0], usByte:=0, cntr:=sizeof(MyTxMsg));

      // switch to configuration state
      MyTxMsg[0]        := CANOPEN_LSS_CMD_INQUIRE_REV;
      
      LastError.ErrorCode := Can.CanTxObj(ObjNr:=CANOPEN_LSS_OBJ_LSS_TX, length:=8, data:=#MyTxMsg);

      if LastError.ErrorCode = 0 then
        udSendTimeStamp := ops.tAbsolute;
        eCurrentStep := t_e_LSS_SSW::_InquireDeviceInfoWait4Revision;
      else
        LastError.ErrorStep := t_e_LSS_ErrorStep::LSS_InquireDeviceInfos_RevSendError;
        eCurrentStep := t_e_LSS_SSW::_Idle;  
        ClassState := t_e_LSS_ClassState::_Ready;
        FailCount += 1;
      end_if;     

//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_InquireDeviceInfoWait4Revision:
      // wait until we receive an answer
      if (ops.tAbsolute - udSendTimeStamp) > ResponseTimeout then
        // timed out => go back to idle
        LastError.ErrorStep := t_e_LSS_ErrorStep::LSS_InquireDeviceInfos_RevTimeout;
        eCurrentStep := t_e_LSS_SSW::_Idle;
        ClassState := t_e_LSS_ClassState::_Ready;
        FailCount += 1;
      end_if;

//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_InquireDeviceInfoSerialNo:
      _memset(dest:=#MyTxMsg[0], usByte:=0, cntr:=sizeof(MyTxMsg));

      // switch to configuration state
      MyTxMsg[0]        := CANOPEN_LSS_CMD_INQUIRE_SER;
      
      LastError.ErrorCode := Can.CanTxObj(ObjNr:=CANOPEN_LSS_OBJ_LSS_TX, length:=8, data:=#MyTxMsg);

      if LastError.ErrorCode = 0 then
        udSendTimeStamp := ops.tAbsolute;
        eCurrentStep := t_e_LSS_SSW::_InquireDeviceInfoWait4SerialNo;
      else
        LastError.ErrorStep := t_e_LSS_ErrorStep::LSS_InquireDeviceInfos_SerSendError;
        eCurrentStep := t_e_LSS_SSW::_Idle;  
        ClassState := t_e_LSS_ClassState::_Ready;
        FailCount += 1;
      end_if;     

//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_InquireDeviceInfoWait4SerialNo:
      // wait until we receive an answer
      if (ops.tAbsolute - udSendTimeStamp) > ResponseTimeout then
        // timed out => go back to idle
        LastError.ErrorStep := t_e_LSS_ErrorStep::LSS_InquireDeviceInfos_SerTimeout;
        eCurrentStep := t_e_LSS_SSW::_Idle;
        ClassState := t_e_LSS_ClassState::_Ready;
        FailCount += 1;
      end_if;

//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_InquireDeviceInfoNodeID:
      _memset(dest:=#MyTxMsg[0], usByte:=0, cntr:=sizeof(MyTxMsg));

      // switch to configuration state
      MyTxMsg[0]        := CANOPEN_LSS_CMD_INQUIRE_NODE_ID;
      
      LastError.ErrorCode := Can.CanTxObj(ObjNr:=CANOPEN_LSS_OBJ_LSS_TX, length:=8, data:=#MyTxMsg);

      if LastError.ErrorCode = 0 then
        udSendTimeStamp := ops.tAbsolute;
        eCurrentStep := t_e_LSS_SSW::_InquireDeviceInfoWait4NodeID;
      else
        LastError.ErrorStep := t_e_LSS_ErrorStep::LSS_InquireDeviceInfos_NodeIDSendError;
        eCurrentStep := t_e_LSS_SSW::_Idle;  
        ClassState := t_e_LSS_ClassState::_Ready;
        FailCount += 1;
      end_if;     

//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_InquireDeviceInfoWait4NodeID:
      // wait until we receive an answer
      if (ops.tAbsolute - udSendTimeStamp) > ResponseTimeout then
        // timed out => go back to idle
        LastError.ErrorStep := t_e_LSS_ErrorStep::LSS_InquireDeviceInfos_NodeIDTimeout;
        eCurrentStep := t_e_LSS_SSW::_Idle;
        ClassState := t_e_LSS_ClassState::_Ready;
        FailCount += 1;
      end_if;

//**********************************************************************************************************************************************************
  end_case;  

	state := READY;

END_FUNCTION


FUNCTION _CanOpenLSS::InitMe
  VAR
  	retval : DINT;
  END_VAR

  // initialize stuff here
  ResponseTimeout := ResponseTimeout.Read();

  retval := can.AddCanObj(ObjNr       := CANOPEN_LSS_OBJ_LSS_RX
                        , Length      := 8
                        , Mode        := 1
                        , ActionPtr   := #ReceiveCallback()
                        , ThisPointer := this
                        );
  
  if retval < 0 then
    // error installing the receive object
    ClassState      := t_e_LSS_ClassState::_InstallRxFailed;
  else
    // initialisation successful
    bInitialized    := TRUE;
    ClassState      := t_e_LSS_ClassState::_Ready;
  end_if;

END_FUNCTION


FUNCTION _CanOpenLSS::ReceiveCallback
	VAR_INPUT
		PiCanptr 	: ^USINT;
		RxDataptr 	: ^USINT;
		Thisptr 	: DINT;
	END_VAR
  
  this := Thisptr$^_CanOpenLSS;
  
  udReceiveTimeStamp := ops.tAbsolute;

  // take action depending on the current step
  case eCurrentStep of
//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_SwitchStateSelectiveWaitRsp:
      if CheckResponse(ExpectedCommand:=CANOPEN_LSS_CMD_SWITCH_ST_SEL_RSP, ReceivedCanObj:=RxDataptr$^_BasicCanObj) then
        SuccessCount += 1;

        // ready for the next command
        eCurrentStep  := t_e_LSS_SSW::_Idle;
        ClassState    := t_e_LSS_ClassState::_Ready;
      end_if;

//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_ConfigureNodeIdWaitForConfirmation:
      if CheckResponse(ExpectedCommand:=CANOPEN_LSS_CMD_CFG_NODE_ID, ReceivedCanObj:=RxDataptr$^_BasicCanObj, 2, t_e_LSS_ErrorStep::LSS_ConfigureNodeID_RspError) then
        // check if we have to directly store the new NodeID
        if sProcessParameter.AutoStoreConfig then
          // jump to next step
          eCurrentStep := t_e_LSS_SSW::_StoreConfigurationStart;
        else
          // if not => we're finished here
          SuccessCount += 1;

          // ready for the next command
          eCurrentStep  := t_e_LSS_SSW::_Idle;
          ClassState    := t_e_LSS_ClassState::_Ready;
        end_if;
      end_if;

//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_ConfigureBitTimingWaitConfirmation:
      if CheckResponse(ExpectedCommand:=CANOPEN_LSS_CMD_CFG_BIT_TIMING, ReceivedCanObj:=RxDataptr$^_BasicCanObj, 2, t_e_LSS_ErrorStep::LSS_ConfigureBitTiming_RspError) then
        // check if we have to directly store and activate the new bit timing
        if sProcessParameter.AutoStoreConfig then
          // jump to next step
          eCurrentStep := t_e_LSS_SSW::_StoreConfigurationStart;
        else
          // if not => we're finished here
          SuccessCount += 1;

          // ready for the next command
          eCurrentStep  := t_e_LSS_SSW::_Idle;
          ClassState    := t_e_LSS_ClassState::_Ready;
        end_if;
      end_if;

//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_StoreConfigurationWaitConfirmation:
      if CheckResponse(ExpectedCommand:=CANOPEN_LSS_CMD_STORE_CFG, ReceivedCanObj:=RxDataptr$^_BasicCanObj, 2, t_e_LSS_ErrorStep::LSS_StoreConfiguration_RspError) then
        // here we know it's the correct response command
        
        // if the store config has been called automatically => continue with switching to the new baudrate
        if (sProcessParameter.AutoStoreConfig) & (LastProcessStartedByUser = t_e_LSS_SSW::_ConfigureBitTimingStart) then
          // jump to next step
          eCurrentStep := t_e_LSS_SSW::_ActivateBitTimingStart;
        else
          // if not => we're finished here
          SuccessCount += 1;

          // ready for the next command
          eCurrentStep  := t_e_LSS_SSW::_Idle;
          ClassState    := t_e_LSS_ClassState::_Ready;
        end_if;
      end_if;
    
//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_FindDeviceWaitRsp:
      if CheckResponse(ExpectedCommand:=CANOPEN_LSS_CMD_ID_REMOTE_RESPONSE, ReceivedCanObj:=RxDataptr$^_BasicCanObj, 1, t_e_LSS_ErrorStep::LSS_FindDevice_RspError) then
        // here we know it's the correct response command
      end_if;

//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_InquireDeviceInfoWait4Vendor:
      if CheckResponse(ExpectedCommand:=CANOPEN_LSS_CMD_INQUIRE_VEND, ReceivedCanObj:=RxDataptr$^_BasicCanObj) then
        // save the returned data from canopen
        InquiredDeviceInfos.IdentityInfo.VendorID := RxDataptr^$_BasicCanObj.CanData[1]$UDINT;
                 
        SelectNextInquiry();          
      end_if;

//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_InquireDeviceInfoWait4ProductCode:
      if CheckResponse(ExpectedCommand:=CANOPEN_LSS_CMD_INQUIRE_PROD, ReceivedCanObj:=RxDataptr$^_BasicCanObj) then
        // save the returned data from canopen
        InquiredDeviceInfos.IdentityInfo.ProductCode := RxDataptr^$_BasicCanObj.CanData[1]$UDINT;
                 
        SelectNextInquiry();          
      end_if;

//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_InquireDeviceInfoWait4Revision:
      if CheckResponse(ExpectedCommand:=CANOPEN_LSS_CMD_INQUIRE_REV, ReceivedCanObj:=RxDataptr$^_BasicCanObj) then
        // save the returned data from canopen
        InquiredDeviceInfos.IdentityInfo.RevisionNumber := RxDataptr^$_BasicCanObj.CanData[1]$UDINT;
                 
        SelectNextInquiry();          
      end_if;

//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_InquireDeviceInfoWait4SerialNo:
      if CheckResponse(ExpectedCommand:=CANOPEN_LSS_CMD_INQUIRE_SER, ReceivedCanObj:=RxDataptr$^_BasicCanObj) then
        // save the returned data from canopen
        InquiredDeviceInfos.IdentityInfo.SerialNumber := RxDataptr^$_BasicCanObj.CanData[1]$UDINT;
                 
        SelectNextInquiry();          
      end_if;

//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_InquireDeviceInfoWait4NodeID:
      if CheckResponse(ExpectedCommand:=CANOPEN_LSS_CMD_INQUIRE_NODE_ID, ReceivedCanObj:=RxDataptr$^_BasicCanObj) then
        // save the returned data from canopen
        InquiredDeviceInfos.NodeID := RxDataptr^$_BasicCanObj.CanData[1];
                 
        SelectNextInquiry();          
      end_if;
      
//**********************************************************************************************************************************************************
  end_case;  

END_FUNCTION


FUNCTION _CanOpenLSS::Baudrate2SigmatekIndex
	VAR_INPUT
		Baudrate 	: UINT;
	END_VAR
	VAR_OUTPUT
		Index 	: USINT;
	END_VAR

  case Baudrate of
    1000: Index := 7;
//   615: Index := 0; // not supported by CANopen
     500: Index := 1;
     250: Index := 2;
     125: Index := 3;
//   100: Index := 4; // not officially supported by CANopen
      50: Index := 5;
      20: Index := 6;
  else
    Index := 16#FF;
  end_case;

END_FUNCTION


FUNCTION _CanOpenLSS::Baudrate2CANopenIndex
	VAR_INPUT
		Baudrate 	: UINT;
	END_VAR
	VAR_OUTPUT
		Index 	: USINT;
	END_VAR
  
  case Baudrate of
    1000: Index := 0;
//   800: Index := 1; // not supported by all sigmatek CAN interfaces
     500: Index := 2;
     250: Index := 3;
     125: Index := 4;
//   100: Index := 5; // not officially supported by CANopen
      50: Index := 6;
      20: Index := 7;
//    10: Index := 8; // not supported by all sigmatek CAN interfaces
  else
    Index := 16#FF;   
  end_case;

END_FUNCTION


FUNCTION _CanOpenLSS::StartProcess
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  
  // block re-entrance
  usProcessStarting += 1;
  
  // check for re-entrance
  if usProcessStarting > 1 then
    usProcessStarting -= 1;
    
    retcode := -1;
    return;
  end_if;

  // class is now busy => variables for this step have to be set after the return from this function
  ClassState   := t_e_LSS_ClassState::_Busy;
  
  // clear last error
  LastError.ErrorStep := t_e_LSS_ErrorStep::LSS_NoError;
  LastError.ErrorCode := 0;
  
  // unblock re-entrance
  usProcessStarting -= 1;

  retcode := 0;

END_FUNCTION


FUNCTION GLOBAL _CanOpenLSS::SwitchStateGlobal
	VAR_INPUT
		NewState 	: USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR

  // initialize the class (if it hasn't been done already)
  if bInitialized = FALSE then
    InitMe();
  end_if;

  if ClassState <> t_e_LSS_ClassState::_Ready then
    // class not ready
    retcode := -1;
    return;
  end_if;
  
  if NewState > 1 then
    // invalid parameter value
    retcode := -2;
    return;
  end_if;
  
  // prevents from re-entrance and sets class state to _Busy
  retcode := StartProcess();
  
  // if the start process request was successful
  if retcode = 0 then
    // set variables necessary for the process
    sProcessParameter.NewGlobalState := NewState;
    
    eCurrentStep := t_e_LSS_SSW::_SwitchStateGlobalStart;
    
    // remember the last started process
    LastProcessStartedByUser := eCurrentStep;
  end_if;

END_FUNCTION


FUNCTION GLOBAL _CanOpenLSS::SwitchStateSelective
	VAR_INPUT
		VendorID 	: UDINT;
		ProductCode 	: UDINT;
		RevisionNumber 	: UDINT;
		SerialNumber 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR

  // initialize the class (if it hasn't been done already)
  if bInitialized = FALSE then
    InitMe();
  end_if;

  if ClassState <> t_e_LSS_ClassState::_Ready then
    // class not ready
    retcode := -1;
    return;
  end_if;

  retcode := StartProcess();
  
  // if the start process request was successful
  if retcode = 0 then
    // set variables necessary for the process
    sProcessParameter.SelectState.VendorID       := VendorID;
    sProcessParameter.SelectState.ProductCode    := ProductCode;
    sProcessParameter.SelectState.RevisionNumber := RevisionNumber;
    sProcessParameter.SelectState.SerialNumber   := SerialNumber;
    
    eCurrentStep := t_e_LSS_SSW::_SwitchStateSelectiveStart;

    // remember the last started process
    LastProcessStartedByUser := eCurrentStep;
  end_if;

END_FUNCTION


FUNCTION GLOBAL _CanOpenLSS::ConfigureNodeID
	VAR_INPUT
		NewNodeID 	: USINT;
		AutoStoreConfig 	: BOOL;(* := TRUE *)
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR

  // initialize the class (if it hasn't been done already)
  if bInitialized = FALSE then
    InitMe();
  end_if;

  if ClassState <> t_e_LSS_ClassState::_Ready then
    // class not ready
    retcode := -1;
    return;
  end_if;

  if NewNodeID > CANOPEN_LSS_MAX_NODE_NR then
    // invalid parameter value
    retcode := -2;
    return;
  end_if;

  retcode := StartProcess();
  
  // if the start process request was successful
  if retcode = 0 then
    // set variables necessary for the process
    sProcessParameter.NewNodeID       := NewNodeID;
    sProcessParameter.AutoStoreConfig := AutoStoreConfig;
    
    eCurrentStep := t_e_LSS_SSW::_ConfigureNodeIdStart;

    // remember the last started process
    LastProcessStartedByUser := eCurrentStep;
  end_if;

END_FUNCTION


FUNCTION GLOBAL _CanOpenLSS::ConfigureBitTiming
	VAR_INPUT
		NewBaudrate 	: UINT;
		SwitchDelay 	: UINT;(* := 0 *)
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR

  // initialize the class (if it hasn't been done already)
  if bInitialized = FALSE then
    InitMe();
  end_if;

  if ClassState <> t_e_LSS_ClassState::_Ready then
    // class not ready
    retcode := -1;
    return;
  end_if;

  if Baudrate2CANopenIndex(Baudrate:=NewBaudrate) = 16#FF then
    // invalid parameter value
    retcode := -2;
    return;
  end_if;

  retcode := StartProcess();
  
  // if the start process request was successful
  if retcode = 0 then
    // set variables necessary for the process
    sProcessParameter.NewBaudrate := NewBaudrate;
    
    if SwitchDelay then
      sProcessParameter.BitTimingSwitchDelay := SwitchDelay;
      sProcessParameter.AutoStoreConfig := TRUE;
    else
      sProcessParameter.AutoStoreConfig := FALSE;
    end_if;   
    
    eCurrentStep := t_e_LSS_SSW::_ConfigureBitTimingStart;

    // remember the last started process
    LastProcessStartedByUser := eCurrentStep;
  end_if;

END_FUNCTION


FUNCTION GLOBAL _CanOpenLSS::ActivateBitTiming
	VAR_INPUT
		SwitchDelay 	: UINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR

  // initialize the class (if it hasn't been done already)
  if bInitialized = FALSE then
    InitMe();
  end_if;

  if ClassState <> t_e_LSS_ClassState::_Ready then
    // class not ready
    retcode := -1;
    return;
  end_if;

  retcode := StartProcess();
  
  // if the start process request was successful
  if retcode = 0 then
    // set variables necessary for the process
    sProcessParameter.BitTimingSwitchDelay := SwitchDelay;
    
    // make sure it's not automatically storing the settings after the activation (might be set from a previous call of ConfigureNodeID or ConfigureBitTiming)
    sProcessParameter.AutoStoreConfig := FALSE;

    eCurrentStep := t_e_LSS_SSW::_ActivateBitTimingStart;

    // remember the last started process
    LastProcessStartedByUser := eCurrentStep;
  end_if;

END_FUNCTION


FUNCTION GLOBAL _CanOpenLSS::StoreConfiguration
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR

  // initialize the class (if it hasn't been done already)
  if bInitialized = FALSE then
    InitMe();
  end_if;

  if ClassState <> t_e_LSS_ClassState::_Ready then
    // class not ready
    retcode := -1;
    return;
  end_if;
  
  retcode := StartProcess();
  
  // if the start process request was successful
  if retcode = 0 then
    // set variables necessary for the process
    eCurrentStep := t_e_LSS_SSW::_StoreConfigurationStart;

    // remember the last started process
    LastProcessStartedByUser := eCurrentStep;
  end_if;

END_FUNCTION


FUNCTION GLOBAL _CanOpenLSS::FindDevice
	VAR_INPUT
		VendorID 	: UDINT;
		ProductCode 	: UDINT;
		RevisionRangeLow 	: UDINT;
		RevisionRangeHigh 	: UDINT;
		SerialRangeLow 	: UDINT;
		SerialRangeHigh 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR

  // initialize the class (if it hasn't been done already)
  if bInitialized = FALSE then
    InitMe();
  end_if;

  if ClassState <> t_e_LSS_ClassState::_Ready then
    // class not ready
    retcode := -1;
    return;
  end_if;
  
  // check if range values are valid
  if (RevisionRangeLow > RevisionRangeHigh) | (SerialRangeLow > SerialRangeHigh) then
    // invalid parameter value
    retcode := -2;
    return;
  end_if;

  
  retcode := StartProcess();
  
  // if the start process request was successful
  if retcode = 0 then
    // set variables necessary for the process
    sProcessParameter.FindVendorID      := VendorID;
    sProcessParameter.FindProductCode   := ProductCode;
    sProcessParameter.FindRevNrRangeMin := RevisionRangeLow;
    sProcessParameter.FindRevNrRangeMax := RevisionRangeHigh;
    sProcessParameter.FindSerNrRangeMin := SerialRangeLow;
    sProcessParameter.FindSerNrRangeMax := SerialRangeHigh;
    
    eCurrentStep := t_e_LSS_SSW::_FindDeviceStart;

    // remember the last started process
    LastProcessStartedByUser := eCurrentStep;
  end_if;

END_FUNCTION


FUNCTION GLOBAL _CanOpenLSS::GetStatus
	VAR_INPUT
		pErrorCode 	: ^t_LSS_ErrorCode;
	END_VAR
	VAR_OUTPUT
		retcode 	: iprStates;
	END_VAR

  case ClassState of
//*****************************************************************************
    _CanOpenLSS::t_e_LSS_ClassState::_NotInitialized:
  	_CanOpenLSS::t_e_LSS_ClassState::_InstallRxFailed:
      retcode := ::iprStates::ERROR;

//*****************************************************************************
  	_CanOpenLSS::t_e_LSS_ClassState::_Ready:
      retcode := ::iprStates::READY;

//*****************************************************************************
  	_CanOpenLSS::t_e_LSS_ClassState::_Busy:
      retcode := ::iprStates::BUSY;

//*****************************************************************************
  end_case;

  if pErrorCode then
    pErrorCode^ := LastError;
  end_if;

END_FUNCTION


FUNCTION GLOBAL _CanOpenLSS::InquireDeviceInfos
	VAR_INPUT
		InquireOptions 	: t_LSS_InquireOptions;(* := 2#11111 *)
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR

  // initialize the class (if it hasn't been done already)
  if bInitialized = FALSE then
    InitMe();
  end_if;

  if ClassState <> t_e_LSS_ClassState::_Ready then
    // class not ready
    retcode := -1;
    return;
  end_if;
  
  retcode := StartProcess();
  
  // if the start process request was successful
  if retcode = 0 then
    // set variables necessary for the process
    sProcessParameter.InquireOptions := InquireOptions;
    
    //reset inquired infos
    _memset(dest:=#InquiredDeviceInfos, usByte:=0x00, cntr:=sizeof(InquiredDeviceInfos));
    
    // chose start step depending on options
    SelectNextInquiry();

    // remember the last started process
    LastProcessStartedByUser := eCurrentStep;
  end_if;

END_FUNCTION


FUNCTION GLOBAL _CanOpenLSS::GetInquiredDeviceInfos
	VAR_INPUT
		pVendorID 	: ^UDINT;(* := NIL *)
		pProductCode 	: ^UDINT;(* := NIL *)
		pRevisionNumber 	: ^UDINT;(* := NIL *)
		pSerialNumber 	: ^UDINT;(* := NIL *)
		pNodeID 	: ^USINT;(* := NIL *)
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR

  // initialize the class (if it hasn't been done already)
  if bInitialized = FALSE then
    InitMe();
  end_if;

  if ClassState <> t_e_LSS_ClassState::_Ready then
    // class not ready
    retcode := -1;
    return;
  end_if;
  
  // check if there is a valid pointer
  if (pVendorID = NIL) & (pProductCode = NIL) & (pRevisionNumber = NIL) & (pSerialNumber = NIL) & (pNodeID = NIL) then
    // invalid parameter value
    retcode := -2;
    return;
  end_if;

  // check if pointer is valid
  if pVendorID then
    // check if value has been requested
    if sProcessParameter.InquireOptions.VendorID then
      // return the value
      pVendorID^ := InquiredDeviceInfos.IdentityInfo.VendorID;
    else
      // invalid parameter value
      retcode := -2;
      return;
    end_if;
  end_if;

  // check if pointer is valid
  if pProductCode then
    // check if value has been requested
    if sProcessParameter.InquireOptions.ProductCode then
      // return the value
      pProductCode^ := InquiredDeviceInfos.IdentityInfo.ProductCode;
    else
      // invalid parameter value
      retcode := -2;
      return;
    end_if;
  end_if;

  // check if pointer is valid
  if pRevisionNumber then
    // check if value has been requested
    if sProcessParameter.InquireOptions.RevisionNumber then
      // return the value
      pRevisionNumber^ := InquiredDeviceInfos.IdentityInfo.RevisionNumber;
    else
      // invalid parameter value
      retcode := -2;
      return;
    end_if;
  end_if;

  // check if pointer is valid
  if pSerialNumber then
    // check if value has been requested
    if sProcessParameter.InquireOptions.SerialNumber then
      // return the value
      pSerialNumber^ := InquiredDeviceInfos.IdentityInfo.SerialNumber;
    else
      // invalid parameter value
      retcode := -2;
      return;
    end_if;
  end_if;

  // check if pointer is valid
  if pNodeID then
    // check if value has been requested
    if sProcessParameter.InquireOptions.NodeID then
      // return the value
      pNodeID^ := InquiredDeviceInfos.NodeID;
    else
      // invalid parameter value
      retcode := -2;
      return;
    end_if;
  end_if;

  // we returned all the requested values => success
  retcode := 0; 

END_FUNCTION


FUNCTION _CanOpenLSS::SelectNextInquiry
  VAR
    FirstBitToCheck : USINT;
    i               : USINT;
  END_VAR

  // depending on where we are right now, we decide how to continue
  case eCurrentStep of
//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_InquireDeviceInfoWait4Vendor:
      FirstBitToCheck := 1;
      
//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_InquireDeviceInfoWait4ProductCode:
      FirstBitToCheck := 2;
      
//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_InquireDeviceInfoWait4Revision:
      FirstBitToCheck := 3;
      
//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_InquireDeviceInfoWait4SerialNo:
      FirstBitToCheck := 4;
      
//**********************************************************************************************************************************************************
    t_e_LSS_SSW::_InquireDeviceInfoWait4NodeID:
      // this is already the highest possible bit => we're done here
      // ready for the next command
      eCurrentStep  := t_e_LSS_SSW::_Idle;
      ClassState    := t_e_LSS_ClassState::_Ready;
      SuccessCount += 1;
      return;
      
//**********************************************************************************************************************************************************
  else
    FirstBitToCheck := 0;
  end_case;
  
  // start with the bit according to our current step
  i := FirstBitToCheck;
  // search for the next set bit
  while i < 5 do
    if sProcessParameter.InquireOptions AND (1 SHL i) then
      case i of
      //****************************************************************************
        0: 
            eCurrentStep := t_e_LSS_SSW::_InquireDeviceInfoVendor;
            return;
      //****************************************************************************
        1:  
            eCurrentStep := t_e_LSS_SSW::_InquireDeviceInfoProductCode;
            return;
      //****************************************************************************
        2:  
            eCurrentStep := t_e_LSS_SSW::_InquireDeviceInfoRevision;
            return;
      //****************************************************************************
        3: 
            eCurrentStep := t_e_LSS_SSW::_InquireDeviceInfoSerialNo;
            return;
      //****************************************************************************
        4: 
            eCurrentStep := t_e_LSS_SSW::_InquireDeviceInfoNodeID;
            return;
      //****************************************************************************
      end_case;
    end_if;
  
    // check the next bit
    i += 1;
  end_while;

  // no more set bits found => we're finished with the inquiry
  // ready for the next command
  eCurrentStep  := t_e_LSS_SSW::_Idle;
  ClassState    := t_e_LSS_ClassState::_Ready;
  SuccessCount += 1;

END_FUNCTION


FUNCTION _CanOpenLSS::CheckResponse
	VAR_INPUT
		ExpectedCommand 	: USINT;
		ReceivedCanObj 	: ^_BasicCanObj;
		CheckErrorCode 	: USINT;(* := 0 *)
		ErrorStep 	: t_e_LSS_ErrorStep;(* := LSS_NoError *)
	END_VAR
	VAR_OUTPUT
		CorrectResponse 	: BOOL;
	END_VAR

  CorrectResponse := FALSE;

  // LSS message detected. check length of data
  if ReceivedCanObj^.length = 8 then
    // check the command
    if ReceivedCanObj^.CanData[0] = ExpectedCommand then

      // remember max response time
      MsgResponseTime := udReceiveTimeStamp - udSendTimeStamp;
      if MsgResponseTime > MsgResponseTimeMax then
        MsgResponseTimeMax := MsgResponseTime;
      end_if;

      if CheckErrorCode = 1 then
        // save the returncode from canopen
        LastError.ErrorCode := ReceivedCanObj^.CanData[1];
        
        if LastError.ErrorCode = 0 then
          SuccessCount += 1;
        else
          LastError.ErrorStep := ErrorStep;
          FailCount += 1;
        end_if;
        
        // ready for the next command
        eCurrentStep  := t_e_LSS_SSW::_Idle;
        ClassState    := t_e_LSS_ClassState::_Ready;
      elsif CheckErrorCode = 2 then
        // save the returncode from canopen
        LastError.ErrorCode := ReceivedCanObj^.CanData[1];
        
        // only act on error
        if LastError.ErrorCode <> 0 then
          LastError.ErrorStep := ErrorStep;
          FailCount += 1;

          // ready for the next command
          eCurrentStep  := t_e_LSS_SSW::_Idle;
          ClassState    := t_e_LSS_ClassState::_Ready;
          
          // fake wrong response, because the calling method doesn't have to do anything else
          CorrectResponse := FALSE;          
          return;
        end_if;       
      end_if;
      
      CorrectResponse := TRUE;
    else
      // other message => ignore here
      RxWrongCmdCnt += 1;
    end_if;
  else
    // invalid length => ignore here (should not be possible to have an object with this ID but not with 8 Byte length)
    RxWrongLenCnt += 1;
  end_if;

END_FUNCTION
