//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
//FPGA Components
#define CP731_IOS_DEVICE_ID_XADC           16#0A60
#define CP731_IOS_DEVICE_ID_CPU_REG        16#0F02

//XADC Register
#define CP731_IOS_OFFSET_TEMPERATURE       16#00
#define CP731_IOS_OFFSET_VOLTAGE_VP_VN     16#06
#define CP731_IOS_OFFSET_TEMPERATURE_MAX   16#40
#define CP731_IOS_OFFSET_TEMPERATURE_MIN   16#48

//CPU Register
#define CP731_IOS_OFFSET_DIGITAL_INPUT_REGISTER           16#00
#define CP731_IOS_OFFSET_DIGITAL_OUTPUT_CLEAR_REGISTER    16#01
#define CP731_IOS_OFFSET_DIGITAL_OUTPUT_READ_SET_REGISTER 16#02

#define CP731_IOS_REGISTER_NOT_FOUND       16#FFFF

#define CP731_IOS_OFFSET_TEMPSENSOR1       16#08
#define CP731_IOS_OFFSET_TEMPSENSOR2       16#0A



//Constants and calculation from xilinx datasheet
//https://www.xilinx.com/support/documentation/user_guides/ug480_7Series_XADC.pdf
//Equation 2-6 (Temperature) and Equation 2-7 (Voltage)
#define CP731_TEMP_MULTIPLIER    503.975
#define CP731_TEMP_DIVISIOR      4096
#define CP731_TEMP_OFFSET        273.15

#define CP731_IOS_TEMP_CONSTANT_KELVIN  273

#define CP731_VOLTAGE_MULTIPLIER 31      

#define CP731_CONVERT_V_TO_MV    1000    //Convert V to mV
#define CP731_CONVERT_TO_1_10_C  10      //Convert °C to 1/10 °C

#define CP731_SUPPLY_VOLTAGE_OFFSET 430  //0,43 V offset (Info from CPU department)
//}}LSL_DEFINES

//{{LSL_DECLARATION
#include "..\..\Source\interfaces\lsl_st_pci.h"
#include "..\..\Source\interfaces\lsl_st_xadc.h"
#include "..\..\Class\PLC_Info\XRegs.h"
#include "..\..\Source\interfaces\lsl_st_gpio.h"

(*!
<Class
	Name               = "CP731_IOs"
	Revision           = "1.3"
	GUID               = "{F26B8902-CDCA-4254-9F13-FB87D0695A39}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\DigInOut.ICO"
	SharedCommandTable = "true"
	Objectsize         = "(688,120)"
	Comment            = "Hardwareclass to access the IOs on the CP731.">
	<Channels>
		<Server Name="BatteryOk" GUID="{F1C8D773-BF26-454F-B5F3-C10A2AA031ED}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the state of the battery.&#13;&#10;0 .. Not OK&#13;&#10;1 .. OK"/>
		<Server Name="Can1_Termination" GUID="{C40CD437-0B21-44F3-805E-A3E125E1C212}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="Write to this server to set the CAN termination.&#13;&#10;0 ... CAN termination is off&#13;&#10;1 ... CAN termination is on&#13;&#10;-1 ... not available/failed to set register in FPGA"/>
		<Server Name="CAN_1_Connect" GUID="{07D2F4D3-079A-435E-841B-B2ED8765FA86}" Class="_CanLib" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ClassState" GUID="{C366970B-A808-4FC8-A9BB-80E6AD602B0A}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the initialisation state of the class.&#13;&#10; 0 ... Initialisation ok&#13;&#10;-1 ... PCI Interface not found&#13;&#10;-2 ... &quot;XADC&quot; interface not found&#13;&#10;-3 ... &quot;IXREGS&quot; interface not found&#13;&#10;-4 ... GPIO Interface not found&#13;&#10;-5 ... CPU Register not found&#13;&#10;-6 ... Login to HwControl failed&#13;&#10;"/>
		<Server Name="ErrorLED" GUID="{4E32AA19-2FCF-40D7-B8B5-CA7A791738BC}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="The &quot;Error&quot;-LED of the CPU can be controlled with this server.&#13;&#10;&#13;&#10;0 ... HW - Status of LED is active&#13;&#10;1 ... LED is off&#13;&#10;2 ... LED is flashes&#13;&#10;3 ... LED is on&#13;&#10;&#13;&#10;-1 ... Class not ok"/>
		<Server Name="Ethernet_1_Connect" GUID="{4F006F0F-D3C6-477E-87A7-C1797D101CA5}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Connection servers for Hardware-Editor."/>
		<Server Name="Ethernet_2_Connect" GUID="{43288535-0ADE-4A08-86D2-470CEE74FE3E}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Connection servers for Hardware-Editor."/>
		<Server Name="RunLED" GUID="{2FE10D9D-3524-40FD-8141-096243A7E079}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="The &quot;Run&quot;-LED of the CPU can be controlled with this server.&#13;&#10;&#13;&#10;0 ... HW - Status of LED is active&#13;&#10;1 ... LED is off&#13;&#10;2 ... LED is flashes&#13;&#10;3 ... LED is on&#13;&#10;&#13;&#10;-1 ... Class not ok"/>
		<Server Name="StatusLED" GUID="{B17FE5D4-0250-4AA4-8971-5A4DE28E1016}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="The &quot;Status&quot;-LED of the CPU can be controlled with this server.&#13;&#10;&#13;&#10;0 ... HW - Status of LED is active&#13;&#10;1 ... LED is off&#13;&#10;2 ... LED is flashes&#13;&#10;3 ... LED is on&#13;&#10;&#13;&#10;-1 ... Class not ok"/>
		<Server Name="SupplyVoltage" GUID="{33E30385-8B11-4C59-A721-590D1763D9D8}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the supply voltage in mV."/>
		<Server Name="TemperatureConnectors" GUID="{904E4AB2-6421-4ED4-9E99-AA0264D9553E}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the measured ambient temperature of the connectors in [1°C/10]."/>
		<Server Name="TemperatureCPU" GUID="{C72E7D50-48C9-46DE-A9A9-BB63823280E3}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the measured ambient temperature of the CPU in [1°C/10]."/>
		<Server Name="USB_1_Connect" GUID="{0F360075-9AA9-4FB1-B8E9-B56F254EECEC}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Client Name="To_HwControl" Required="true" Internal="false" Comment="Connect this client to the class &quot;HwControl&quot;."/>
		<Client Name="XXXBase_IOs6" Required="true" Internal="true"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Source\interfaces\lsl_st_pci.h" Include="true"/>
			<File Path=".\Source\interfaces\lsl_st_xadc.h" Include="true"/>
			<File Path=".\Class\PLC_Info\XRegs.h" Include="true"/>
			<File Path=".\Source\interfaces\lsl_st_gpio.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="EisMic"/>
		<Dokumentation Revision="1.3" Date="16.05.2019" Author="EisMic" Company="Sigmatek" Description="Fixed compiler warning (Mixing UINT with REAL constant...)."/>
		<Dokumentation Revision="1.2" Date="28.01.2019" Author="HaeTho&#13;&#10;EisMic" Company="Sigmatek" Description="Index of sub classes for CAN- and seriell connection is now &gt;= 1.&#13;&#10;Corrected an error that the CAN1_Termination won&apos;t work with FPGA version 1.2 or higher (only 1.0 and 1.1 was working)."/>
		<Dokumentation Revision="1.1" Date="02.08.2018" Author="HaeTho" Company="Sigmatek" Description="Hardware-Editor Bus-Connectors"/>
		<Dokumentation Revision="1.0" Date="23.04.2018" Author="EisMic" Company="Sigmatek" Description="Initial version."/>
	</RevDoku>
	<Network Name="CP731_IOs">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "XXXBase_IOs6"
				GUID       = "{4020E3B8-1946-4099-940A-50516C20427C}"
				Class      = "XXXBase_IOs"
				Position   = "(150,120)"
				Visualized = "false">
				<Channels>
					<Server Name="CAN_1_Connect"/>
					<Server Name="CAN_2_Connect"/>
					<Server Name="ClassState"/>
					<Server Name="COM_1_Connect"/>
					<Server Name="COM_2_Connect"/>
					<Server Name="COM_3_Connect"/>
					<Server Name="Ethernet_1_Connect"/>
					<Server Name="Ethernet_2_Connect"/>
					<Server Name="Ethernet_3_Connect"/>
					<Server Name="Ethernet_4_Connect"/>
					<Server Name="USB_1_Connect"/>
					<Client Name="To_HwControl"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.XXXBase_IOs6" Destination="XXXBase_IOs6.ClassState"/>
			<Connection Source="XXXBase_IOs6.To_HwControl" Destination="this.To_HwControl" Vertices="(150,210),(38,210),"/>
			<Connection Source="this.USB_1_Connect" Destination="XXXBase_IOs6.USB_1_Connect" Vertices="(908,750),(736,270),"/>
			<Connection Source="this.CAN_1_Connect" Destination="XXXBase_IOs6.CAN_1_Connect" Vertices="(908,930),(736,570),"/>
			<Connection Source="this.Ethernet_1_Connect" Destination="XXXBase_IOs6.Ethernet_1_Connect" Vertices="(908,810),(736,330),"/>
			<Connection Source="this.Ethernet_2_Connect" Destination="XXXBase_IOs6.Ethernet_2_Connect" Vertices="(908,870),(736,390),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
CP731_IOs : CLASS
  //Servers:
	ClassState 	: SvrChCmd_DINT;
	BatteryOk 	: SvrCh_DINT;
	SupplyVoltage 	: SvrCh_DINT;
	TemperatureConnectors 	: SvrCh_DINT;
	TemperatureCPU 	: SvrCh_DINT;
	RunLED 	: SvrCh_DINT;
	ErrorLED 	: SvrCh_DINT;
	StatusLED 	: SvrCh_DINT;
	Can1_Termination 	: SvrCh_DINT;
	USB_1_Connect 	: SvrChCmd_DINT;
	Ethernet_1_Connect 	: SvrChCmd_DINT;
	Ethernet_2_Connect 	: SvrChCmd_DINT;
	CAN_1_Connect 	: SvrChCmd_DINT;
  //Clients:
	To_HwControl 	: CltChCmd_HwControl;
	XXXBase_IOs6 	: CltChCmd_XXXBase_IOs;
  //Variables:
		us_FirstScan 	: USINT;
		p_XADC 	: ^void;
		p_CPUReg 	: ^void;
		pXADC 	: ^LSLAPI_IXADC;
		p_XREGS 	: ^T_XREGS;
		bsLedValue : BSINT
		[
		];

		pGPIO 	: ^LSL_GPIO_TYPE;
		sDigitalOutputReadSetRegisterInfo 	: LSL_LOCALIO_IDINFO;
		sDigitalOutputClearRegisterInfo 	: LSL_LOCALIO_IDINFO;
		udFoundRegisterIndex 	: UDINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION ConvertVoltage
		VAR_INPUT
			uiVoltage 	: UINT;
			Offset 	: DINT;
		END_VAR
		VAR_OUTPUT
			Voltage 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL RunLED::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ErrorLED::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL StatusLED::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Can1_Termination::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL USB_1_Connect::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Ethernet_1_Connect::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Ethernet_2_Connect::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL CAN_1_Connect::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using XXXBase_IOs
#pragma usingLtd HwControl


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB CP731_IOs::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_CP731_IOS
1$UINT, 3$UINT, (SIZEOF(::CP731_IOs))$UINT, 
13$UINT, 2$UINT, 0$UINT, 
TO_UDINT(1325227388), "CP731_IOs", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::CP731_IOs.ClassState.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(1096059024), "ClassState", 
(::CP731_IOs.BatteryOk.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3075126500), "BatteryOk", 
(::CP731_IOs.SupplyVoltage.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(54046992), "SupplyVoltage", 
(::CP731_IOs.TemperatureConnectors.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2379133219), "TemperatureConnectors", 
(::CP731_IOs.TemperatureCPU.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3999971414), "TemperatureCPU", 
(::CP731_IOs.RunLED.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4270009735), "RunLED", 
(::CP731_IOs.ErrorLED.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3486187614), "ErrorLED", 
(::CP731_IOs.StatusLED.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2779581079), "StatusLED", 
(::CP731_IOs.Can1_Termination.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2215910728), "Can1_Termination", 
(::CP731_IOs.USB_1_Connect.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(4121287287), "USB_1_Connect", 
(::CP731_IOs.Ethernet_1_Connect.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(1853777383), "Ethernet_1_Connect", 
(::CP731_IOs.Ethernet_2_Connect.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(1475565858), "Ethernet_2_Connect", 
(::CP731_IOs.CAN_1_Connect.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(192824020), "CAN_1_Connect", 
//Clients:
(::CP731_IOs.To_HwControl.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000110$UINT, TO_UDINT(1012711711), "To_HwControl", TO_UDINT(2471641665), "HwControl", 5$UINT, 15$UINT, 
(::CP731_IOs.XXXBase_IOs6.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(139628313), "XXXBase_IOs6", TO_UDINT(819479645), "XXXBase_IOs", 1$UINT, 1$UINT, 
END_FUNCTION


#define USER_CNT_CP731_IOs 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_CP731_IOs] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION CP731_IOs::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_CP731_IOs, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
	ClassState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	RunLED.pMeth			:= StoreMethod( #M_RD_DIRECT(), #RunLED::Write() );
	IF RunLED.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ErrorLED.pMeth			:= StoreMethod( #M_RD_DIRECT(), #ErrorLED::Write() );
	IF ErrorLED.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	StatusLED.pMeth			:= StoreMethod( #M_RD_DIRECT(), #StatusLED::Write() );
	IF StatusLED.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Can1_Termination.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Can1_Termination::Write() );
	IF Can1_Termination.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, USB_1_Connect.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Read		:= #USB_1_Connect::Read();
	USB_1_Connect.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF USB_1_Connect.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, Ethernet_1_Connect.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Read		:= #Ethernet_1_Connect::Read();
	Ethernet_1_Connect.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF Ethernet_1_Connect.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, Ethernet_2_Connect.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Read		:= #Ethernet_2_Connect::Read();
	Ethernet_2_Connect.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF Ethernet_2_Connect.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, CAN_1_Connect.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Read		:= #CAN_1_Connect::Read();
	CAN_1_Connect.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF CAN_1_Connect.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION VIRTUAL GLOBAL CP731_IOs::Init
  VAR
    SigmaTekDevInfo     : ^PCICONFDATA;
    pSPCIInfo           : ^LSL_SPCIINFO;
    Settings            : t_HwObjListSettings;    
    result              : DINT;
    tmpLocalIOInfo      : LSL_LOCALIO_IDINFO;
    udAmountLocalIOs    : UDINT;
    i                   : UDINT;
  END_VAR

  us_FirstScan += 1; //Init-counter
  
  if us_FirstScan = 10 then 
  
    if OS_CILGET("PCICONFIG", #pSPCIInfo) <> SYS_ERR_NONE then
      ClassState := -1; //PCICONFIG not found
      return;
    end_if;
    
    if OS_CILGET(INTERFACE_XADC, #pXADC) <> SYS_ERR_NONE then
      ClassState := -2; //XADC Device not found
      return;
    end_if;

    if OS_CILGET("IXREGS", #p_XREGS) <> SYS_ERR_NONE then
      ClassState := -3; //XREGS Device not found
      return;
    end_if;

    if OS_CILGET(INTERFACE_GPIO, #pGPIO) <> SYS_ERR_NONE then
      ClassState := -4; //GPIO Device not found
      return;
    end_if;
    
    SigmaTekDevInfo := SPCIINFO_FINDDEVICE(CP731_IOS_DEVICE_ID_CPU_REG,0);

    //Check pointer to be valid
    if SigmaTekDevInfo then
          
      p_CPUReg$pVoid := SPCIINFO_GETADDRESS(SigmaTekDevInfo);

      //Check pointer to be valid
      if p_CPUReg = NIL then
        ClassState := 5;
        return;
      end_if;      
    else
      ClassState := -5;
      return;
    end_if;
    
    //Get necessary infos for Can termination handling
    //*********************************************************************************************************************
    
    //Get amount of local IOs from OS
    udAmountLocalIOs      := OS_LOCALIO_GETCOUNT(pGPIO);
    udFoundRegisterIndex  := CP731_IOS_REGISTER_NOT_FOUND; //Register not found
    
    //Check if we found local IOs on the hardware
    if udAmountLocalIOs then
      
      //Now search all local IOs to find the correct registers of the "wb_cpu_reg" component
      for i:= 0 to udAmountLocalIOs-1 do
        result := OS_LOCALIO_GETINFO(pGPIO,i,#tmpLocalIOInfo);
        
        //Check if we found the correct component
        if (tmpLocalIOInfo.typeinfo AND 16#FFFF) = CP731_IOS_DEVICE_ID_CPU_REG then
        
          //We found it, save number and exit
          udFoundRegisterIndex := i;
          exit;              
        end_if;
      end_for;

      //Check if we found the correct component
      if udFoundRegisterIndex <> CP731_IOS_REGISTER_NOT_FOUND then

        //Now we have to get the correct ID of both the "Clear" and the "Read/Set" Register
        //First local io we found is the Digital Input Reg because it is the first one in the adress mapping
        
        //Reg 0 ... Digital Input               ... udFoundRegisterIndex 
        //Reg 1 ... Digtal Output Clear         ... udFoundRegisterIndex + 1
        //Reg 2 ... Digital Output Read / Set   ... udFoundRegisterIndex + 2
        
        result := OS_LOCALIO_GETINFO(pGPIO,udFoundRegisterIndex + CP731_IOS_OFFSET_DIGITAL_OUTPUT_CLEAR_REGISTER,#sDigitalOutputClearRegisterInfo);
        
        //Check for errors
        if result <> 0 then
          udFoundRegisterIndex  := CP731_IOS_REGISTER_NOT_FOUND; //Register not found
        end_if;

        result := OS_LOCALIO_GETINFO(pGPIO,udFoundRegisterIndex + CP731_IOS_OFFSET_DIGITAL_OUTPUT_READ_SET_REGISTER,#sDigitalOutputReadSetRegisterInfo);

        //Check for errors
        if result <> 0 then
          udFoundRegisterIndex  := CP731_IOS_REGISTER_NOT_FOUND; //Register not found      
        end_if;
      end_if;    
    end_if;

    
    //Write first time in init
    Can1_Termination.Write(input:=Can1_Termination);
    
    //*********************************************************************************************************************

    // initialisiation OK => we login to HwControl
    Settings            := 0;
    Settings.Cyclic     := TRUE;
    
    if To_HwControl.AddHwObject(pThis:=THIS$pVirtualBase, Settings:=Settings) then
      ClassState := -6;
    end_if; 
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL CP731_IOs::CyWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
  VAR
  	udTmpValue : UDINT;
  END_VAR


  //Check if initialisation was successfull -> so pointers must be valid and we don't need to check them
  if ClassState = 0 then   
        
    OS_XADC_GETVPVN(pXADC,#udTmpValue);
    SupplyVoltage           := ConvertVoltage(udTmpValue$UINT,CP731_SUPPLY_VOLTAGE_OFFSET);
    
    TemperatureConnectors   := ((p_CPUReg + 16#8)^$UINT - CP731_IOS_TEMP_CONSTANT_KELVIN) * CP731_CONVERT_TO_1_10_C;
    TemperatureCPU          := ((p_CPUReg + 16#A)^$UINT - CP731_IOS_TEMP_CONSTANT_KELVIN) * CP731_CONVERT_TO_1_10_C;

    BatteryOk := p_XREGS^.Batt_funct$funct_XREGS_BattGood();

  else
    //Show on server that the information is not valid
    SupplyVoltage           := ACCESS_DENIED;
    TemperatureConnectors   := ACCESS_DENIED;
    TemperatureCPU          := ACCESS_DENIED;
    RunLED                  := -1;
    ErrorLED                := -1;
    StatusLED               := -1;
  end_if;
  
	state := READY;

END_FUNCTION


FUNCTION CP731_IOs::ConvertVoltage
	VAR_INPUT
		uiVoltage 	: UINT;
		Offset 	: DINT;
	END_VAR
	VAR_OUTPUT
		Voltage 	: DINT;
	END_VAR
  
  //12 Bit Value is stored in the MSB bits in the 16bit register -> shift right 4  
  Voltage := TO_DINT( TO_REAL(((uiVoltage SHR 4) * CP731_VOLTAGE_MULTIPLIER * CP731_CONVERT_V_TO_MV) / CP731_TEMP_DIVISIOR));
  Voltage += Offset;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL CP731_IOs::RunLED::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if p_XREGS then
    if input >= 0 & input <= 3 then
      RunLED := input;
      bsLedValue := (RunLED$USINT AND 0x3) OR ((StatusLED$USINT AND 0x3) SHL 2) OR ((ErrorLED$USINT AND 0x3) SHL 4);
      p_XREGS^.LED_funct$funct_XREGS_SETLeds(val:= bsLedValue);
    end_if;
  end_if;

	result := RunLED;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL CP731_IOs::ErrorLED::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if p_XREGS then
    if input >= 0 & input <= 3 then
      ErrorLED := input;
      bsLedValue := (RunLED$USINT AND 0x3) OR ((StatusLED$USINT AND 0x3) SHL 2) OR ((ErrorLED$USINT AND 0x3) SHL 4);
      p_XREGS^.LED_funct$funct_XREGS_SETLeds(val:= bsLedValue);
    end_if;
  end_if;
  
	result := ErrorLED;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL CP731_IOs::StatusLED::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if p_XREGS then
    if input >= 0 & input <= 3 then
      StatusLED := input;
      bsLedValue := (RunLED$USINT AND 0x3) OR ((StatusLED$USINT AND 0x3) SHL 2) OR ((ErrorLED$USINT AND 0x3) SHL 4);
      p_XREGS^.LED_funct$funct_XREGS_SETLeds(val:= bsLedValue);
    end_if;
  end_if;
  
	result := StatusLED;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL CP731_IOs::Can1_Termination::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  VAR
    TmpRegValue : UDINT;
  END_VAR

  //Digitale Ausgänge
  //Bit 0: USB 0 einschalten (wird noch nicht verwendet)
  //Bit 1: USB 3.0 einschalten(wird noch nicht verwendet)
  //Bit 2: USB 2 einschalten(wird noch nicht verwendet)
  //Bit 3: USB 3 einschalten(wird noch nicht verwendet)
  //Bit 4: CPU Power BTN
  //Bit 5: Can TERM einschalten
  //Bit 6: SDIAS 24V einschalten
  //Bit 7: SDIAS 5V einschalten
  //Bit 15..8: Reserviert
  
  //Check if function is available
  if pGPIO & udFoundRegisterIndex <> CP731_IOS_REGISTER_NOT_FOUND then
        
    //Get current register value
    result$DINT := OS_GPIO_GETREG(pGPIO, sDigitalOutputReadSetRegisterInfo.id, CP731_IOS_OFFSET_DIGITAL_OUTPUT_READ_SET_REGISTER, #TmpRegValue);
    
    //Check for errors
    if result = 0 then
      
      //Register in FPGA is inverted
      //*****************************************************************************
      if input = 1 then
      
        TmpRegValue := 0x20;  //Only clear Bit 5
        
        result$DINT := OS_GPIO_SETREG(pGPIO, sDigitalOutputClearRegisterInfo.id, CP731_IOS_OFFSET_DIGITAL_OUTPUT_CLEAR_REGISTER, TmpRegValue);
        
        if result = 0 then
          Can1_Termination := 1;
        else
          Can1_Termination := -1; //Failed to set register
        end_if;

      //*****************************************************************************
      elsif input = 0 then
      
        TmpRegValue := TmpRegValue OR 0x20;  //Set current Bits and Bit 5
        
        result$DINT := OS_GPIO_SETREG(pGPIO, sDigitalOutputReadSetRegisterInfo.id, CP731_IOS_OFFSET_DIGITAL_OUTPUT_READ_SET_REGISTER, TmpRegValue);

        if result = 0 then
          Can1_Termination := 0;
        else
          Can1_Termination := -1; //Failed to set register
        end_if;
      end_if;
      //*****************************************************************************      
    else
      Can1_Termination := -1;
    end_if;
  else
    Can1_Termination := -1;
  end_if;
  
	result := Can1_Termination;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL CP731_IOs::USB_1_Connect::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	USB_1_Connect := XXXBase_IOs6.USB_1_Connect.Read();
	output := USB_1_Connect;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL CP731_IOs::CAN_1_Connect::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	CAN_1_Connect := XXXBase_IOs6.CAN_1_Connect.Read();
	output := CAN_1_Connect;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL CP731_IOs::Ethernet_1_Connect::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	Ethernet_1_Connect := XXXBase_IOs6.Ethernet_1_Connect.Read();
	output := Ethernet_1_Connect;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL CP731_IOs::Ethernet_2_Connect::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	Ethernet_2_Connect := XXXBase_IOs6.Ethernet_2_Connect.Read();
	output := Ethernet_2_Connect;

END_FUNCTION
