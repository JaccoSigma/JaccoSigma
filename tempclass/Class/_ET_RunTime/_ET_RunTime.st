//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION
#include "..\..\Class\_ET_RunTime\Version.h"

(*!
<Class
	Name               = "_ET_RunTime"
	Revision           = "1.23"
	GUID               = "{D92BF8A0-12D1-11D5-B924-00106092053B}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "true"
	DefBackground      = "always"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\_ET_RunTime\toolbox.ICO"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)"
	Comment            = "Kern Version 1.20&#13;&#10;">
	<Channels>
		<Server Name="PicNo" GUID="{89001252-E41F-11D5-B924-00106092053B}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Actual picture number"/>
		<Server Name="Terminal" GUID="{D92BF8A1-12D1-11D5-B924-00106092053B}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Connection to the terminal class"/>
		<Client Name="Application" Required="false" Internal="false" Comment="Connection to Virtual_User "/>
		<Client Name="Cursortime" Required="false" Internal="false" DefValue="500" Comment="cursor flashing time in [ms] as initvalue"/>
		<Client Name="Language" Required="false" Internal="false" Comment="Actual language number"/>
		<Client Name="Not4_User" Required="false" Internal="false" Comment="Only for ET_Init Class"/>
		<Client Name="StartPic" Required="false" Internal="false" Comment="Start Picture"/>
		<Client Name="User" Required="true" Internal="false" Comment="Connect with ET_User"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Source\ET_glob.h" Include="false"/>
			<File Path=".\Class\_ET_RunTime\ET_RunTimeTypes.h" Include="false"/>
			<File Path=".\Class\_ET_RunTime\Version.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="hötant"/>
		<Dokumentation Revision="1.23" Date="2019-05-23" Author="HubChr" Company="Sigmatek" Description="Disable compiler warning 172 for functions that do not use members"/>
		<Dokumentation Revision="1.22" Date="2014-06-03" Author="FesGue" Company="Sigmatek" Description="It was not possible to delete the refreshlist of station 0 "/>
		<Dokumentation Revision="1.21" Date="2013-06-28" Author="spimar" Company="Sigmatek" Description="ARM ready"/>
		<Dokumentation Revision="1.20" Date="18.05.2010" Author="FesGue" Company="Sigmatek" Description="Refresh Problem in the Method OutXy"/>
		<Dokumentation Revision="1.19" Date="06.10.09" Author="ortalo" Company="Sigmatek" Description="the function SET now consider the upper limit and the low limit"/>
	</RevDoku>
</Class>
*)
_ET_RunTime : CLASS
	TYPE
	  _WORKSTATE :
	  (
	    WS_START,
	    WS_START_RDY,
	    WS_READY,
	    WS_RUN,
	    WS_END,
	    WS_ERROR
	  )$UDINT;
	  CallBack : STRUCT
	    ptr : ^USINT;
	    pComdata : ^comData;
	    pThis : ^UINT;
	  END_STRUCT;
	  temp_INTERPRETER : ET_INTERPRETER;
	  temp_INTERZLE : ET_INTERZLE;
	  temp_PVOIDL : _PVOIDL;
	  temp_typ_lslcommregdata : typ_lslcommregdata;
	END_TYPE
  //Servers:
	Terminal 	: SvrChCmd_DINT;
	PicNo 	: SvrCh_DINT;
  //Clients:
	User 	: CltChCmd_ET_User;
	Not4_User 	: CltChCmd_ET_Init;
	Language 	: CltCh_DINT;
	StartPic 	: CltCh_DINT;
	Application 	: CltChCmd_Virtual_User;
	Cursortime 	: CltCh_DINT;
  //Variables:
		PtDisplay 	: ^_DISPLAYDUMMY;
		PtTerminalInfo 	: ^_TERMINAL_INFO;
		PtKeys 	: ^_KEYS_DATA;
		PtLeds 	: ^_LEDS_DATA;
		Workstate 	: _WORKSTATE;
		StxList 	: ET_SPRACHE;
		MtxList 	: ET_SPRACHE;
		AtxList 	: ET_SPRACHE;
		Picture 	: ET_PICTURE;
		Key 	: ET_PREFKEY;
		Oldkey 	: DINT;
		Picmemo 	: ET_PICMEMO;
		Scancode 	: UINT;
		PlcIsReady 	: BOOL;
		CursorSlur 	: BOOL;
		Len 	: UINT;
		AppliState 	: UINT;
		Cursor 	: ET_CURSOR;
		Timecursor 	: UDINT;
		ABCIndex 	: ET_ABCDATA;
		ABCEdit 	: BOOL;
		oldtabno 	: UINT;
		Varlist 	: ET_VARLIST;
		Symboltable 	: ET_SYMBOLTABLE;
		Onlinestation : ARRAY [0..32] OF ET_COMDEF;

		reflistitem : ARRAY [0..32] OF UINT;

		OldScan 	: DINT;
		FirstSelect 	: BOOL;
		CursorNext 	: BOOL;
		EditMem 	: BOOL;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION LoadProject
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION Out_BTX
		VAR_INPUT
			pt 	: ^ET_BTX;
			pl 	: ^ET_SPRACHE;
		END_VAR;
	
	FUNCTION Out_REFTXT
		VAR_INPUT
			pt 	: ^ET_REFTXT;
			pl 	: ^ET_SPRACHE;
		END_VAR;
	
	FUNCTION Out_PICTURE
		VAR_INPUT
			pt 	: ^ET_PICTURE;
		END_VAR;
	
	FUNCTION GLOBAL setpoiofET
		VAR_INPUT
			p_display 	: ^_DISPLAYDUMMY;
			p_leds 	: ^_LEDS_DATA;
			p_keys 	: ^_KEYS_DATA;
			p_terminalinfo 	: ^_TERMINAL_INFO;
		END_VAR;
	
	FUNCTION ClrScr;
	
	FUNCTION Out_IO
		VAR_INPUT
			pio 	: ^ET_IO;
		END_VAR;
	
	FUNCTION Out_REFOUTPUT
		VAR_INPUT
			pout 	: ^ET_REFOUTPUT;
		END_VAR;
	
	FUNCTION Out_REFINPUT
		VAR_INPUT
			pin 	: ^ET_REFINPUT;
		END_VAR;
	
	FUNCTION ET_Start
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION ET_Ready
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION ET_Run
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL AddPicmemo
		VAR_INPUT
			no 	: UINT;
		END_VAR;
	
	FUNCTION GLOBAL GetPicmemo
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
	
	FUNCTION GLOBAL CloseEditor;
	
	FUNCTION GLOBAL OpenEditor
		VAR_INPUT
			no 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL OutXY
		VAR_INPUT
			x 	: UINT;
			y 	: UINT;
			width 	: UINT;
			txt 	: ^CHAR;
		END_VAR;
	
	FUNCTION GLOBAL GetXY
		VAR_INPUT
			dst 	: ^CHAR;
			x 	: UINT;
			y 	: UINT;
			width 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION RunEditor
		VAR_INPUT
			pe 	: ^ET_EDITOR;
		END_VAR;
	
	FUNCTION Out_IO_Intern
		VAR_INPUT
			pio 	: ^ET_IO;
			pr 	: ^ET_RESULT;
			pv 	: ^ET_VARIABLE;
		END_VAR;
	
	FUNCTION SaveEditor
		VAR_INPUT
			pe 	: ^ET_EDITOR;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION OutDate
		VAR_INPUT
			x 	: UINT;
			y 	: UINT;
			pd 	: ^SYSDATE;
			io_format 	: ET_IO_FORMAT;
		END_VAR;
	
	FUNCTION OutTime
		VAR_INPUT
			x 	: UINT;
			y 	: UINT;
			pt 	: ^SYSTIME;
			io_format 	: ET_IO_FORMAT;
		END_VAR;
	
	FUNCTION GetDay
		VAR_INPUT
			txt 	: ^CHAR;
			dow 	: UINT;
		END_VAR;
	
	FUNCTION GetDayWeek
		VAR_INPUT
			day 	: UINT;
			month 	: UINT;
			year 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
	
	FUNCTION GetDayOfMonth
		VAR_INPUT
			month 	: UINT;
			year 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
	
	FUNCTION schoitjoa
		VAR_INPUT
			year 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL LoadGlobal
		VAR_INPUT
			lan 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment=" ******************************************************************&#13;&#10; *****************      Set cursor to position          ***********&#13;&#10; ******************************************************************&#13;&#10; *****                                                        *****&#13;&#10; *****                                                        *****&#13;&#10; *****  Input Parameter :   x = X position of display         *****&#13;&#10; *****                      y = Y position of display         *****&#13;&#10; *****                      width = size of Cursor            *****&#13;&#10;" Name="CursorOn"/>
	FUNCTION GLOBAL CursorOn
		VAR_INPUT
			x 	: UINT;
			y 	: UINT;
			width 	: UINT;
		END_VAR;
				//! <Function Comment=" ******************************************************************&#13;&#10; *****************      Set cursor hide and off         ***********&#13;&#10; ******************************************************************&#13;&#10; *****                                                        *****&#13;&#10; *****                                                        *****&#13;&#10; *****                                                        *****&#13;&#10;" Name="CursorOff"/>
	FUNCTION GLOBAL CursorOff;
				//! <Function Comment="[#ENGLISH]&#13;&#10; ******************************************************************&#13;&#10; *****************      Set cursor hide       *********************&#13;&#10; ******************************************************************&#13;&#10; *****                                                        *****&#13;&#10; *****                                                        *****&#13;&#10; *****                                                        *****&#13;&#10;" Name="CursorHide"/>
	FUNCTION GLOBAL CursorHide;
				//! <Function Comment=" ******************************************************************&#13;&#10; ******************    Put cursor on screen     *******************&#13;&#10; ******************************************************************&#13;&#10; ******                                                      ******&#13;&#10; ******  Input parameter : state = false = Cursor hide       ******&#13;&#10; ******                            true  = Cursor fisible    ******&#13;&#10;" Name="CursorShow"/>
	FUNCTION CursorShow
		VAR_INPUT
			state 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL DoInterzle
		VAR_INPUT
			pe 	: ^ET_INTERZLE;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL DoInterpreter
		VAR_INPUT
			pip 	: ^ET_INTERPRETER;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL GetKeyInterpreter
		VAR_INPUT
			no 	: UINT;
			src 	: ET_PREFKEY;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^ET_INTERPRETER;
		END_VAR;
	
	FUNCTION LoadPicture
		VAR_INPUT
			no 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION DestroyCursorSlur;
	
	FUNCTION CmdKeyCode
		VAR_INPUT
			op 	: ^ET_VARLABEL;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION CmdString
		VAR_INPUT
			op1 	: ^ET_VARLABEL;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GetABCIndex
		VAR_INPUT
			tab 	: ^UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
	
	FUNCTION RunABCIndex;
	
	FUNCTION GLOBAL SetABCEdit
		VAR_INPUT
			state 	: BOOL;
		END_VAR;
	
	FUNCTION GetLimit
		VAR_INPUT
			pr 	: ^ET_RESULT;
			pv 	: ^ET_VARINFO;
		END_VAR;
	
	FUNCTION GLOBAL GetSystemdata
		VAR_INPUT
			pr 	: ^ET_RESULT;
			pv 	: ^ET_VARIABLE;
			pvl 	: ^ET_VARLABEL;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL GetValue
		VAR_INPUT
			pr 	: ^ET_RESULT;
			pv 	: ^ET_VARIABLE;
			no 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL GetVariable
		VAR_INPUT
			no 	: UINT;
			ptr 	: ^ET_VARIABLE;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL LoadVarlist
		VAR_INPUT
			src 	: ^void;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL SetSystemdata
		VAR_INPUT
			pv 	: ^ET_VARLABEL;
			pr 	: ^ET_RESULT;
			pvari 	: ^ET_VARIABLE;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL MakeSymbolTable
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL GetSize
		VAR_INPUT
			pi 	: ^ET_VARINFO;
		END_VAR
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
	
	FUNCTION GLOBAL GetPointerToData
		VAR_INPUT
			pv 	: ^ET_VARIABLE;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^USINT;
		END_VAR;
	
	FUNCTION GetLabelIntern
		VAR_INPUT
			txt 	: ^CHAR;
			varobj 	: ^USINT;
			no 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GetLabelPart
		VAR_INPUT
			no 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^CHAR;
		END_VAR;
	
	FUNCTION GLOBAL InitOnline;
	
	FUNCTION GetCOMDEF
		VAR_INPUT
			station 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^ET_COMDEF;
		END_VAR;
	
	FUNCTION PLC_LogIn
		VAR_INPUT
			station 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION AddReflist
		VAR_INPUT
			varno 	: UINT;
			station 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION DeletReflist;
	
	FUNCTION GLOBAL RefreshIRQ
		VAR_INPUT
			refno 	: UDINT;
			pt 	: ^USINT;
		END_VAR;
	
	FUNCTION GetAdressOBJ
		VAR_INPUT
			pt 	: ^CHAR;
			pid 	: ^UDINT;
			pch 	: ^ET_COMDEF;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION DelReflistItem
		VAR_INPUT
			station 	: UINT;
		END_VAR;
	
	FUNCTION GetReflistItem
		VAR_INPUT
			station 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
	
	FUNCTION IncReflistItem
		VAR_INPUT
			station 	: UINT;
		END_VAR;
	
	FUNCTION GLOBAL KeyNew
		VAR_INPUT
			d_key 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL KeyGone
		VAR_INPUT
			d_key 	: DINT;
		END_VAR;
	
	FUNCTION CmdLed
		VAR_INPUT
			op1 	: ^ET_VARLABEL;
			op2 	: ^ET_VARLABEL;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION CmdChaPic
		VAR_INPUT
			op 	: ^ET_VARLABEL;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION CmdLan
		VAR_INPUT
			op 	: ^ET_VARLABEL;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10; ***************************************************************************&#13;&#10; ***************            User Interface LED Control      ****************&#13;&#10; ***************************************************************************&#13;&#10; *******                                                              ******&#13;&#10; *******   Variable input LED number = LED number                     ******&#13;&#10; *******                  LED Mode   = 0 = Off                        ******&#13;&#10; *******                               1 = ON                         ******&#13;&#10; *******                               2 = blinking                   ******&#13;&#10;" Name="Control_Led"/>
	FUNCTION GLOBAL Control_Led
		VAR_INPUT
			LED_Number 	: DINT;
			LED_Mode 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10; ***************************************************************************&#13;&#10; ***************       User Interface Picture Control       ****************&#13;&#10; ***************************************************************************&#13;&#10; *******                                                              ******&#13;&#10; *******   Variable input Pic_number = Picture number                 ******&#13;&#10; *******                           0 = Global Picture !!!             ******&#13;&#10; *******                                                              ******&#13;&#10; *******                                                              ******&#13;&#10;" Name="Control_Pic"/>
	FUNCTION GLOBAL Control_Pic
		VAR_INPUT
			Pic_Number 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10; ***************************************************************************&#13;&#10; ***************       User Interface Language Control      ****************&#13;&#10; ***************************************************************************&#13;&#10; *******                                                              ******&#13;&#10; *******   Variable input Lan_Number = Language number                ******&#13;&#10; *******                                                              ******&#13;&#10; *******                                                              ******&#13;&#10; *******                                                              ******&#13;&#10;" Name="Control_Lan"/>
	FUNCTION GLOBAL Control_Lan
		VAR_INPUT
			Lan_Number 	: DINT;
		END_VAR;
	
	FUNCTION CmdInc
		VAR_INPUT
			op 	: ^ET_VARLABEL;
			inc 	: DINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION CmdDec
		VAR_INPUT
			op 	: ^ET_VARLABEL;
			dec 	: DINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION CmdRetPic
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION CmdSet
		VAR_INPUT
			op1 	: ^ET_VARLABEL;
			op2 	: ^ET_VARLABEL;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION CmdAdd
		VAR_INPUT
			op1 	: ^ET_VARLABEL;
			op2 	: ^ET_VARLABEL;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION CmdSub
		VAR_INPUT
			op1 	: ^ET_VARLABEL;
			op2 	: ^ET_VARLABEL;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION CmdToggle
		VAR_INPUT
			op 	: ^ET_VARLABEL;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION CmdFCAWL
		VAR_INPUT
			op1 	: ^ET_VARLABEL;
			op2 	: ^ET_VARLABEL;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION CmdNextIO
		VAR_INPUT
			state 	: INT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10; ***************************************************************************&#13;&#10; ***************      User Interface Increment Variable     ****************&#13;&#10; ***************************************************************************&#13;&#10; *******                                                              ******&#13;&#10; *******   Variable input Var_Number = Variable number                ******&#13;&#10; *******                                                              ******&#13;&#10; *******                                                              ******&#13;&#10; *******                                                              ******&#13;&#10;" Name="Control_Inc"/>
	FUNCTION GLOBAL Control_Inc
		VAR_INPUT
			Var_Number 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10; ***************************************************************************&#13;&#10; ***************      User Interface Decrement Variable     ****************&#13;&#10; ***************************************************************************&#13;&#10; *******                                                              ******&#13;&#10; *******   Variable input Var_Number = Variable number                ******&#13;&#10; *******                       Value = Value of decrement             ******&#13;&#10; *******                                                              ******&#13;&#10; *******&#13;&#10;" Name="Control_Dec"/>
	FUNCTION GLOBAL Control_Dec
		VAR_INPUT
			Var_Number 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10; ***************************************************************************&#13;&#10; *****************      User Interface Return Picture     ******************&#13;&#10; ***************************************************************************&#13;&#10; *******                                                              ******&#13;&#10; *******                                                              ******&#13;&#10; *******                                                              ******&#13;&#10; *******                                                              ******&#13;&#10; *******&#13;&#10;" Name="Control_RetPic"/>
	FUNCTION GLOBAL Control_RetPic;
				//! <Function Comment="[#ENGLISH]&#13;&#10; ***************************************************************************&#13;&#10; ************      User Interface set variable to a value      *************&#13;&#10; ***************************************************************************&#13;&#10; *******                                                              ******&#13;&#10; *******   Variable input Var_Number = Variable number                ******&#13;&#10; *******                       Value = Value to set variable          ******&#13;&#10; *******                                                              ******&#13;&#10; *******                                                              ******&#13;&#10;" Name="Control_Set"/>
	FUNCTION GLOBAL Control_Set
		VAR_INPUT
			Var_Number 	: DINT;
			Value 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10; ***************************************************************************&#13;&#10; *************      User Interface add value to Variable     ***************&#13;&#10; ***************************************************************************&#13;&#10; *******                                                              ******&#13;&#10; *******   Variable input Var_Number = Variable number                ******&#13;&#10; *******                       Value = Value of add                   ******&#13;&#10; *******                                                              ******&#13;&#10; *******                                                              ******&#13;&#10;" Name="Control_Add"/>
	FUNCTION GLOBAL Control_Add
		VAR_INPUT
			Var_Number 	: DINT;
			Value 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10; ***************************************************************************&#13;&#10; **********      User Interface subtract value of Variable     *************&#13;&#10; ***************************************************************************&#13;&#10; *******                                                              ******&#13;&#10; *******   Variable input Var_Number = Variable number                ******&#13;&#10; *******                       Value = Value of subtract              ******&#13;&#10; *******                                                              ******&#13;&#10; *******                                                              ******&#13;&#10;" Name="Control_Sub"/>
	FUNCTION GLOBAL Control_Sub
		VAR_INPUT
			Var_Number 	: DINT;
			Value 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10; ***************************************************************************&#13;&#10; *************      User Interface for toggle a variable       *************&#13;&#10; ***************************************************************************&#13;&#10; *******                                                              ******&#13;&#10; *******   Variable input Var_Number = Variable number                ******&#13;&#10; *******                       Value = Value to set variable          ******&#13;&#10; *******                                                              ******&#13;&#10; *******                                                              ******&#13;&#10;" Name="Control_Toggle"/>
	FUNCTION GLOBAL Control_Toggle
		VAR_INPUT
			Var_Number 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10; ***************************************************************************&#13;&#10; **************      User Interface for edit a variable       **************&#13;&#10; ***************************************************************************&#13;&#10; *******                                                              ******&#13;&#10; *******   Variable input Var_Number = Variable number                ******&#13;&#10; *******                           0 = the first variable             ******&#13;&#10; *******                               of the picture                 ******&#13;&#10; *******                                                              ******&#13;&#10;" Name="Control_EditIO"/>
	FUNCTION GLOBAL Control_EditIO
		VAR_INPUT
			Var_Number 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment=" ******************************************************************&#13;&#10; ***********     User Interface to set negativ sign    ************&#13;&#10; ******************************************************************&#13;&#10; *****                                                        *****&#13;&#10; *****                                                        *****&#13;&#10; *****                                                        *****&#13;&#10;" Name="Control_VarNeg"/>
	FUNCTION GLOBAL Control_VarNeg;
				//! <Function Comment=" ******************************************************************&#13;&#10; ***********     User Interface to set positiv sign     ***********&#13;&#10; ******************************************************************&#13;&#10; *****                                                        *****&#13;&#10; *****                                                        *****&#13;&#10; *****                                                        *****&#13;&#10;" Name="Control_VarPos"/>
	FUNCTION GLOBAL Control_VarPos;
	
	FUNCTION get_TXTBUF
		VAR_INPUT
			src 	: ^ET_TXTBUF;
			no 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^CHAR;
		END_VAR;
	
	FUNCTION load_TXTBUF
		VAR_INPUT
			dest 	: ^ET_TXTBUF;
			src 	: ^void;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION jump_TXTBUF
		VAR_INPUT
			src 	: ^void;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION load_SPRACHE
		VAR_INPUT
			dest 	: ^ET_SPRACHE;
			src 	: ^void;
			sprache 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION get_SPRACHE
		VAR_INPUT
			src 	: ^ET_SPRACHE;
			no 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^CHAR;
		END_VAR;
	
	FUNCTION load_REFTXT
		VAR_INPUT
			dst 	: ^ET_REFTXT;
			src 	: ^void;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION load_PICTURE
		VAR_INPUT
			dst 	: ^ET_PICTURE;
			no 	: UINT;
			lan 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION load_REFOUTPUT
		VAR_INPUT
			dst 	: ^ET_REFOUTPUT;
			src 	: ^void;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION load_REFINPUT
		VAR_INPUT
			dst 	: ^ET_REFINPUT;
			src 	: ^void;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION load_REFKEY
		VAR_INPUT
			pdst 	: ^ET_PREFKEY;
			src 	: ^void;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION dtoa
		VAR_INPUT
			pt 	: ^CHAR;
			value 	: DINT;
			format 	: HINT;
		END_VAR;
	
	FUNCTION __CDECL irq_PLC
		VAR_INPUT
			cd 	: ^ET_COMDEF;
			pd 	: ^UDINT;
		END_VAR;
	
	FUNCTION MyMemory
		VAR_INPUT
			dest 	: ^_PVOIDL;
			size 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION Lasal_To_SYSTIME
		VAR_INPUT
			ptr 	: ^SYSTIME;
			src 	: DINT;
		END_VAR;
	
	FUNCTION Lasal_To_SYSDATE
		VAR_INPUT
			ptr 	: ^SYSDATE;
			src 	: DINT;
		END_VAR;
	
	FUNCTION SYSTIME_To_Lasal
		VAR_INPUT
			src 	: ^DINT;
			ptr 	: ^SYSTIME;
		END_VAR;
	
	FUNCTION SYSDATE_To_Lasal
		VAR_INPUT
			src 	: ^DINT;
			ptr 	: ^SYSDATE;
		END_VAR;
	
	FUNCTION GLOBAL Get_String
		VAR_INPUT
			pv 	: ^ET_VARIABLE;
			dest 	: ^void;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL GetLasalId
		VAR_INPUT
			varno 	: DINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL LenLabelPart
		VAR_INPUT
			label 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
	
	FUNCTION GLOBAL GetIDVarNo
		VAR_INPUT
			ID 	: UDINT;
		END_VAR
		VAR_OUTPUT
			VarNo 	: UINT;
		END_VAR;
	
	FUNCTION GLOBAL GetLabel
		VAR_INPUT
			txt 	: ^CHAR;
			varobj 	: ^USINT;
			no 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL Get_ANYTHING
		VAR_INPUT
			pa 	: ^ET_ANYTHING;
			pl 	: ^ET_SPRACHE;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^CHAR;
		END_VAR;
	
	FUNCTION GetCHARTAB
		VAR_INPUT
			tabno 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^UINT;
		END_VAR;
				//! <Function Comment="[#DEUTSCH]&#13;&#10;Neu Funktion weil this pointer breits von Callback übergeben wird.&#13;&#10;" Name="irq_PLC2"/>
	FUNCTION __CDECL irq_PLC2
		VAR_INPUT
			cd 	: ^ET_COMDEF;
			pd 	: ^UDINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10; The &apos;NewInst&apos;-method is used to implement class-specific&#13;&#10; commands.&#13;&#10; This method can provide a class interface besides the&#13;&#10; implemented class-methods. This interface will be used, when&#13;&#10; working with interpreter code, or for remote calls to an&#13;&#10; object.&#13;&#10; Define the commands in the method editor, LASAL will create&#13;&#10; a private data type with the command-enums. &apos;NewInst&apos; will&#13;&#10; typically contain a CASE-statement to evaluate each of these&#13;&#10; commands. It has to return either READY, BUSY, ERROR or&#13;&#10; ERROR_BUSY to indicate, if the command was processed or if&#13;&#10; it is still processed (i.e. a movement) or if an error occured.&#13;&#10; However, &apos;NewInst&apos; is just called once (per command) to&#13;&#10; initialize an operation. Eventually &apos;GetState&apos; or &apos;Kill&apos; are&#13;&#10; called later on.&#13;&#10; The default implementation of &apos;NewInst&apos; simply does nothing.&#13;&#10; So &apos;NewInst&apos; can be called for each server.&#13;&#10;" Name="Terminal.NewInst"/>
	FUNCTION VIRTUAL GLOBAL Terminal::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd ET_Init
#pragma usingLtd ET_User
#pragma usingLtd Virtual_User


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _ET_RunTime::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__ET_RUNTIME
1$UINT, 23$UINT, (SIZEOF(::_ET_RunTime))$UINT, 
2$UINT, 6$UINT, 0$UINT, 
TO_UDINT(744851685), "_ET_RunTime", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::_ET_RunTime.Terminal.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(1229490445), "Terminal", 
(::_ET_RunTime.PicNo.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3798475378), "PicNo", 
//Clients:
(::_ET_RunTime.User.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3137747965), "User", TO_UDINT(1010922426), "ET_User", 1$UINT, 0$UINT, 
(::_ET_RunTime.Not4_User.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1754540190), "Not4_User", TO_UDINT(2007384455), "ET_Init", 1$UINT, 1$UINT, 
(::_ET_RunTime.Language.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(317255161), "Language", 
(::_ET_RunTime.StartPic.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(159117737), "StartPic", 
(::_ET_RunTime.Application.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(693653289), "Application", TO_UDINT(820555109), "Virtual_User", 1$UINT, 0$UINT, 
(::_ET_RunTime.Cursortime.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1868847490), "Cursortime", 
END_FUNCTION


#define USER_CNT__ET_RunTime 1

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__ET_RunTime] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _ET_RunTime::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT__ET_RunTime, pCmd := #vmt.CmdTable);
	vmt.CmdTable.NewInstr		:= #NewInst();
	vmt.CmdTable.Write		:= #M_WR_DIRECT();
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
	Terminal.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF Terminal.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


//*********************Inserted from .\_ET_RunTime\_ET_RunTime_00_00.st*********************



 


#include "..\..\Class\_ET_RunTime\Version.h"      

VAR_GLOBAL
	pVarList		 : ^_ET_RunTime;    //  ET_Variable;
END_VAR


#include <ComTypes.h>
#include <RTOS_IprIntern.h>
#include <Comlink.h>
#include <Rtos_interpreter.h>

#pragma warning(disable:172); // HubChr v1.23
FUNCTION VIRTUAL GLOBAL _ET_RunTime::Init

  
  Workstate := WS_START; 

  ET_Init::init_SPRACHE(#AtxList); 
  ET_Init::init_SPRACHE(#MtxList); 
  ET_Init::init_SPRACHE(#StxList); 
  ET_Init::init_PICTURE(#Picture);
  ET_Init::init_PICMEMO(#Picmemo);
  PtDisplay      := NIL;
  PtTerminalInfo := NIL;  
  PtKeys		 := NIL;
  PtLeds		 := NIL;
  Scancode       := 0;
  PlcIsReady     := FALSE; 
  CursorSlur     := FALSE;
  Firstselect    := TRUE;  // true wenn cursor neu gesetzt
  CursorNext     := FALSE;
  
  Oldkey := 0; 
  AppliState := 0;

  // Cursor init  
  ET_Init::init_CURSOR(#Cursor);
  timecursor := ops.tAbsolute;

  // Interpreter init 
  ET_Init::Init_ABCDATA(#ABCIndex); 
  ABCEdit := FALSE; 

  // init Variablen
  ET_INIT::init_VARLIST(#Varlist);
  ET_INIT::init_SYMBOLTABLE(#Symboltable);
  pVarList := this; 	


END_FUNCTION //VIRTUAL GLOBAL _ET_RunTime::Init
#pragma warning(default:172); // HubChr v1.23

FUNCTION VIRTUAL GLOBAL _ET_RunTime::Background
VAR_INPUT
	EAX		: UDINT;
END_VAR
VAR_OUTPUT
	state		: UDINT;
END_VAR


  if (OPS.sysstate = c_runram | (OPS.sysstate = c_runrom)) THEN;

	  case Workstate of
	    WS_START : if(LoadProject() = TRUE) then
		             Workstate := WS_START_RDY;        
			       else  
					 Workstate := WS_ERROR; 
		           end_if;
	
		WS_START_RDY :             
		           // warten bis Rainer fertig
				   if (PlcIsReady = TRUE) then
				     AppliState := TO_UINT(IsClientConnected(#Application));
		               if(ET_Start() = TRUE) then 
		                 Picture.picstate := PS_DRAW; 		 
					     If AppliState then
					       Application.AppliStart();
	                     end_if;
					     Workstate := WS_READY; 
	                   else
					     Workstate := WS_ERROR; 
	                   end_if; 
	               else
					 Workstate := WS_ERROR; 
	               end_if;
	
		WS_READY : if(ET_Ready() = TRUE) then
					 If AppliState then
					   Application.AppliReady();
	                 end_if;
	                 Workstate := WS_RUN; 
	               else
				     Workstate := WS_ERROR; 
				   end_if; 

		WS_RUN   : if(ET_Run() = FALSE) then
	                 Workstate := WS_ERROR;
	               end_if; 
				   If AppliState then
				     Application.AppliRun();
	               end_if;
			   
				   Scancode := ET_NOKEY;
                         
		WS_END   : If AppliState then
				     Application.AppliEnd();
	               end_if;
  
		WS_ERROR : 
	  end_case; 


    if(Cursor.active = TRUE) then
      if (ops.tAbsolute - timecursor) >= TO_UDINT(Cursortime) then
      if(Cursor.status = TRUE) then
        CursorShow(FALSE);
      else 
        CursorShow(TRUE);
      end_if; 
    end_if;
    else 
      timecursor := ops.tAbsolute;
    end_if;   

  end_if;


  state:= READY;

END_FUNCTION //VIRTUAL GLOBAL _ET_RunTime::Background

FUNCTION  _ET_RunTime::LoadProject
VAR_OUTPUT
	retcode		: BOOL;
END_VAR
VAR
  lan       : UINT;
  pic       : UINT;
END_VAR   

  Language := Language.Read();
  lan      := TO_UINT(Language);
  StartPic := StartPic.Read();
  pic      := TO_UINT(StartPic);
    
  LoadGlobal(lan);                 // alle Textlisten laden 
  load_PICTURE(#Picture, pic, lan);              // tab_PIC00
  AddPicmemo(0); 

  LoadVarlist((#tab_VAR())+4);            //tab_VAR 
  load_REFKEY(#Key, (#tab_KEY())+4);              //tab_KEY

  //warten bis rainer fertig
  //while(PlcIsReady = FALSE) do
  //end_while; 
   
  //grafik.SetExternFunction(#irq_PLC(), #shut_down());  // oldcom

  if OPS.uiLoaderVersion$UINT >= 16#0202 then	  
	INSTALLCALLBACK(#irq_PLC());
  end_if;

  //if(PlcIsReady = TRUE) then
    MakeSymbolTable(); 
  //end_if; 

  retcode := TRUE; 

END_FUNCTION // _ET_RunTime::LoadProject
FUNCTION  GLOBAL _ET_RunTime::Get_ANYTHING
VAR_INPUT
	pa		: ^ET_ANYTHING;
	pl		: ^ET_SPRACHE;
END_VAR
VAR_OUTPUT
	retcode		: ^CHAR;
END_VAR
VAR
	list        : ET_LIST; 
END_VAR

  list := pa^.list; 
  if((pl = NIL)&(list = ET_LTX)) then
    list := ET_STX; 
  end_if;
   
  case list of
    ET_STX: retcode := get_SPRACHE(#StxList, pa^.no);
	ET_ATX: retcode := get_SPRACHE(#AtxList, pa^.no);
    ET_MTX: retcode := get_SPRACHE(#MtxList, pa^.no);
	ET_ET1:
	ET_LTX: retcode := get_SPRACHE(pl,pa^.no);
    else  retcode := get_SPRACHE(#AtxList, 16#FFFF);
  end_case;

END_FUNCTION // _ET_RunTime::Get_ANYTHING
FUNCTION  _ET_RunTime::Out_BTX
VAR_INPUT
	pt		: ^ET_BTX;
	pl		: ^ET_SPRACHE;
END_VAR
VAR
  txt		: ^CHAR;
END_VAR

  txt := Get_ANYTHING(#pt^.anything,pl);
  OutXY(pt^.xpos, pt^.ypos, pt^.width, txt);

END_FUNCTION
FUNCTION  _ET_RunTime::Out_REFTXT
VAR_INPUT		
    pt		: ^ET_REFTXT;	
	pl		: ^ET_SPRACHE;

END_VAR
VAR
   ptr		: ^ET_BTX;
   no		: UINT;
END_VAR

  ptr := pt^.ptr; 
  no  := pt^.no;

  while no do
    Out_BTX(ptr,pl);
	ptr += sizeof(ET_BTX);
	no -= 1;
  end_while;

END_FUNCTION // _ET_RunTime::Out_REFTXT
FUNCTION  _ET_RunTime::Out_PICTURE
VAR_INPUT
	pt		: ^ET_PICTURE;
END_VAR
VAR
   // cd      : ^_COMDEF;
END_VAR

  DeletReflist();
  ClrScr();
  Out_REFTXT(#pt^.reftxt,#pt^.sprache);
  Out_REFOUTPUT(#pt^.refoutput);  
  Out_REFINPUT(#pt^.refinput);

END_FUNCTION // _ET_RunTime::Out_PICTURE
FUNCTION GLOBAL _ET_RunTime::GetXY
VAR_INPUT
	dst		: ^char;
	x		: uint;
	y		: uint;
	width	: uint;
END_VAR
VAR_OUTPUT
	retcode		: bool;
END_VAR
VAR
  pos		: UINT;
  t_width   : UINT; 
end_var
  
  retcode := FALSE; 

  if(PtDisplay <> NIL) & (PtTerminalInfo <> NIL) then
    if(y < PtTerminalInfo^.ud_lines) then
      t_width := TO_UINT(PtTerminalInfo^.ud_charperline); 
	  pos := (y * t_width + x);  
      _memmove(dst, PtDisplay + pos, width); 
	  dst  += width; 
	  dst^ := 0; 
	  retcode := TRUE; 
    end_if;
  end_if;

END_FUNCTION //GLOBAL _ET_RunTime::GetXY
FUNCTION GLOBAL _ET_RunTime::OutXY
VAR_INPUT
	x		: UINT;
	y		: UINT;
	width	: UINT;
	txt		: ^CHAR;
END_VAR
var
  pos		: UINT;
  len       : UINT; 
  t_width   : UINT; 
end_var
  
 if(PtDisplay <> NIL) & (PtTerminalInfo <> NIL) then
    if(y < PtTerminalInfo^.ud_lines) then
      t_width := TO_UINT(PtTerminalInfo^.ud_charperline); 
      pos := (y * t_width + x);  
      len := TO_UINT(_strlen(txt)); 

      if (width = 0) then
        width := len;
      end_if; 

      if(x < t_width) then
        if((x + width) >= t_width) then
          width := t_width - x;  // correction display width
        end_if; 
        if(width > len) then
          //_memset(PtDisplay+pos, ' ', width);//FesGue
          _memset(PtDisplay+pos+len, ' ', width-len); //FesGue Refresh Problem
          width := len;  
        end_if; 
        _memcpy(PtDisplay + pos, txt, width);
      end_if;
    end_if;
  end_if;

END_FUNCTION // _ET_RunTime::OutXY
FUNCTION  _ET_RunTime::ClrScr
VAR
  size		:UINT;
END_VAR

  if(PtDisplay <> NIL) & (PtTerminalInfo <> NIL) then
     size := TO_UINT(PtTerminalInfo^.ud_lines * PtTerminalInfo^.ud_charperline);
     _memset(PtDisplay, ' ', size);
  end_if;

END_FUNCTION // _ET_RunTime::ClrScr
FUNCTION  _ET_RunTime::Out_IO
VAR_INPUT
	pio		: ^ET_IO;
END_VAR
VAR
    result   : ET_RESULT; 
	variable : ET_VARIABLE;
END_VAR
   
  if(GetValue(#result, #variable, pio^.varno) = TRUE) then
    Out_IO_Intern(pio, #result, #variable); 
  end_if; 

END_FUNCTION // _ET_RunTime::Out_IO
FUNCTION  _ET_RunTime::Out_REFOUTPUT
VAR_INPUT
	pout		: ^ET_REFOUTPUT;

END_VAR
VAR
   pt		: ^ET_IO;
   no		: UINT; 
END_VAR
  
  pt  := pout^.ptr;
  no  := pout^.no;  
    
  while no do
    Out_IO(pt);
	pt += sizeof(ET_IO);
	no -= 1;
  end_while;  

END_FUNCTION // _ET_RunTime::Out_REFOUTPUT
FUNCTION  _ET_RunTime::Out_REFINPUT
VAR_INPUT
	pin		: ^ET_REFINPUT;
END_VAR
VAR
   pt		: ^ET_IO;
   no		: UINT;
END_VAR

  pt  := pin^.ptr;
  no  := pin^.no;  
    
  while no do
    Out_IO(pt);
	pt += sizeof(ET_IO);
	no -= 1;
  end_while;  

END_FUNCTION // _ET_RunTime::Out_REFINPUT
FUNCTION  _ET_RunTime::ET_Start
VAR_OUTPUT
  retcode		: BOOL;
END_VAR

  retcode := TRUE;

END_FUNCTION // _ET_RunTime::ET_Start
FUNCTION  _ET_RunTime::ET_Ready
VAR_OUTPUT
  retcode		: BOOL;
END_VAR

  retcode := TRUE;

END_FUNCTION // _ET_RunTime::ET_Ready
FUNCTION  _ET_RunTime::ET_Run
VAR_OUTPUT
	retcode		: BOOL;
END_VAR
VAR
    pio     : ^ET_IO; 
	pi		: ^ET_INTERPRETER;
	taste   : UINT; 
END_VAR

  retcode := true;
    
  case Picture.picstate of
   
    PS_ERROR : 

    PS_DRAW :
	  
      Out_PICTURE(#Picture); 
      Picture.picstate := PS_REFRESH;

    PS_REFRESH : 
	  RunABCIndex(); 
      if(Picture.actual.input < Picture.refinput.no) then    
        // *************** input refresh ***************
		if(Picture.actual.input <> Picture.editor.no) then
          pio := Picture.refinput.ptr + Picture.actual.input * sizeof(ET_IO); 
	      Out_IO(pio); 
        end_if; 
        Picture.actual.input += 1; 
      elsif(Picture.actual.output < Picture.refoutput.no) then
	    // *************** output refresh ***************
        pio := Picture.refoutput.ptr + Picture.actual.output * sizeof(ET_IO); 
	    Out_IO(pio); 
        Picture.actual.output += 1; 
      else 
        Picture.actual.input  := 0;
	    Picture.actual.output := 0;
      end_if;

      // keypress

//(*
      if(PtKeys^.keybuffer_pressed[0] <> Oldkey) then
        taste := to_UINT(PtKeys^.keybuffer_pressed[0]); 
        if(taste <> 0) then
	      pi := GetKeyInterpreter(taste, Picture.prefkey); 
	      if(pi <> NIL) then    // if local function ?
            DoInterpreter(pi); 
          else 
	        pi := GetKeyInterpreter(taste, Key); 
	        if(pi <> NIL) then  // else global function
              DoInterpreter(pi); 
            end_if; 
          end_if;
	    end_if;   
	    Oldkey := taste;  
      end_if; 
//*)

      Picno := Picture.picno;            

	  if (Picture.editor.no < Picture.refinput.no) then
	 // editor is activ
		RunEditor(#Picture.editor);
	  end_if;
  end_case;   
	
	      

END_FUNCTION //_ET_RunTime::ET_Run

FUNCTION GLOBAL _ET_RunTime::KeyNew
#pragma warning (disable : 73)

VAR_INPUT
	d_key		: DINT;
END_VAR

#pragma warning (default : 73)

END_FUNCTION //GLOBAL _ET_RunTime::KeyNew


FUNCTION GLOBAL _ET_RunTime::KeyGone
#pragma warning (disable : 73)

VAR_INPUT
	d_key		: DINT;
END_VAR

#pragma warning (default : 73)

END_FUNCTION //GLOBAL _ET_RunTime::KeyGone
FUNCTION GLOBAL _ET_RunTime::AddPicmemo
VAR_INPUT
	no		: UINT;
END_VAR
VAR
    i : UINT; 
END_VAR

  if(Picmemo.no > 0) then
    if(Picmemo.memo[Picmemo.no - 1] = no) then
	  return; 
    end_if; 
  end_if; 

  if(Picmemo.no < 10) then
    Picmemo.memo[Picmemo.no] := no; 
	Picmemo.no += 1;   
  else
    for i:=0 to 7 do
      Picmemo.memo[i] := Picmemo.memo[i+1];
    end_for;
    Picmemo.memo[9] := no;
  end_if; 
  

END_FUNCTION //GLOBAL _ET_RunTime::AddPicmemo
FUNCTION GLOBAL _ET_RunTime::GetPicmemo
VAR_OUTPUT
	retcode		: UINT;
END_VAR

  if(Picmemo.no < 2) then
    retcode    := Picmemo.memo[0];
	Picmemo.no := 0; 
  else
    Picmemo.no -= 2; 
    retcode := Picmemo.memo[Picmemo.no];
  end_if;  

END_FUNCTION //GLOBAL _ET_RunTime::GetPicmemo
FUNCTION GLOBAL _ET_RunTime::CloseEditor
VAR
  pio    :^ET_IO; 
END_VAR 

  if(Picture.editor.no < Picture.refinput.no) then
    pio := Picture.refinput.ptr + Picture.editor.no * sizeof(ET_IO);
	CursorOff(); 
    Out_IO(pio); 
#pragma warning(disable:172); // HubChr v1.23
	ET_Init::Init_EDITOR(#Picture.editor);
#pragma warning(default:172); // HubChr v1.23
    // schließen
  end_if;

END_FUNCTION //GLOBAL _ET_RunTime::CloseEditor

FUNCTION GLOBAL _ET_RunTime::OpenEditor
VAR_INPUT
	no		: UINT;
END_VAR
VAR_OUTPUT
    retcode : BOOL;  
END_VAR
VAR
    pio      : ^ET_IO;
	tmp      : ET_EDITOR;
	width    : UINT; 
	abcstate : BOOL; 
END_VAR

  abcstate := FALSE; 
  retcode := FALSE;
  Firstselect := TRUE; // true wenn cursor neu gesetzt

  if(no < Picture.refinput.no) then
    // Editor neu aufmachen
#pragma warning(disable:172); // HubChr v1.23
	ET_Init::init_EDITOR(#tmp);
#pragma warning(default:172); // HubChr v1.23
	pio    := Picture.refinput.ptr + no * sizeof(ET_IO);
 	tmp.io := pio^;
	tmp.no := no; 

    if(GetValue(#tmp.result, #tmp.variable, tmp.io.varno) = TRUE) then   
	  CloseEditor(); 
	  Picture.editor := tmp; 
	  Picture.editor.newres := tmp.result;
	  Picture.editor.change := FALSE;
	  retcode        := TRUE; 
      
	  case(pio^.io_format) of
		IF_CODE       :
          width := (tmp.variable.info.format and 16#000F);
	    IF_NONE       :  
	    IF_NUMERIC    :
          width := (tmp.variable.info.format and 16#000F);
	      if(tmp.variable.info.format and 16#00F0) then
	        width += 1; 
          end_if;
	      if(tmp.variable.info.format and 16#0400) then
	        tmp.io.xpos +=1;
          end_if;
          
		
		IF_HHMM       : width := 5;
		IF_HHMMSS     : width := 8; 
		IF_TTMM       : width := 5;
        IF_TTMMYY     : width := 8;
        IF_TTMMYYYY   : width := 10;
        IF_WOTTMM     : width := 8;
        IF_WOTTMMYY   : width := 11;
        IF_WOTTMMYYYY : width := 13;
        IF_STRING     : width := GetSize(#tmp.variable.info);
		                _memset(#Picture.editor.memo[0], ' ', width); 
		                _memcpy(#Picture.editor.memo[0], tmp.result.my_string, _strlen(tmp.result.my_string));
                        tmp.memo[width] := 0; 
		                width := 1; 
		                abcstate := TRUE;
      end_case;

      SetABCEdit(abcstate); 
      
	  CursorOn(tmp.io.xpos, tmp.io.ypos, width);  
	  // ready initialize editor
    end_if; 
  end_if;


  DestroyCursorSlur();             // zeitbasis für cursor nach rechts zerstören

END_FUNCTION //GLOBAL _ET_RunTime::OpenEditor
FUNCTION  _ET_RunTime::RunEditor
VAR_INPUT
	pe		: ^ET_EDITOR;
END_VAR
VAR
    state   : BOOL;
    format  : ET_IO_FORMAT;
	width   : UINT; 
	pos     : UINT;
	newpos  : UINT;
	value   : DINT;  
END_VAR

  if (Scancode <> 0) then
    state  := FALSE;
	format := pe^.io.io_format;

//*********************** Numerical edit ***************************

    if(format = IF_NUMERIC) then
      case Scancode of
         16#30..16#39:
   	       if (pe^.change = FALSE) then
		     pe^.newres.value := 0;
           end_if;
           pe^.newres.value := (pe^.newres.value * 10) + Scancode - 16#30;
		   pe^.change := TRUE;
		   state := TRUE;
         ET_MINUS :
           pe^.newres.value := -pe^.newres.value;
		   pe^.change := TRUE;
		   state := TRUE;
         ET_PLUS :
           if (pe^.newres.value < 0)  then
		     pe^.newres.value := pe^.newres.value * -1 ;
		   end_if;
		   pe^.change := TRUE;
		   state := TRUE;
		 ET_ENTER : 
	       EditMem := TRUE;
		   SaveEditor(pe); //Werte übernehmen
		   CloseEditor(); 
	     ET_CLEAR :
	       _memcpy(#pe^.newres, #pe^.result, sizeof(ET_RESULT)); 	       
		   //pe^.newres := pe^.result; 
		   pe^.change := FALSE;  
	       CloseEditor();    
	  end_case;
	elsif(format = IF_CODE) then
      case Scancode of
         16#30..16#39:
   	       if (pe^.change = FALSE) then
		     pe^.newres.value := 0;
           end_if;
           value := (pe^.newres.value * 10) + Scancode - 16#30;
		   if(value < pe^.newres.hi_limit) then
		     pe^.newres.value := value; 
		     pe^.change := TRUE;
		   end_if; 
		   state := TRUE;
         ET_ENTER : 
//         EditMem := TRUE;
		   SaveEditor(pe); //Werte übernehmen
		   CloseEditor(); 
	     ET_CLEAR :
	       _memcpy(#pe^.newres, #pe^.result, sizeof(ET_RESULT)); 	       
		   //pe^.newres := pe^.result; 
		   pe^.change := FALSE;  
	       CloseEditor();    
	  end_case;

//*********************** Time edit *********************************

    elsif((format = IF_HHMM) | (format = IF_HHMMSS)) then    
	         case Scancode of
          16#30..16#39:
   	        if (pe^.change = FALSE) then
#pragma warning(disable:172); // HubChr v1.23
	          ET_Init::init_SYSTIME(#pe^.newres.my_time);
#pragma warning(default:172); // HubChr v1.23
            end_if;
		    if(pe^.cntr < 2) then
		      pe^.newres.my_time.wHour := (pe^.newres.my_time.wHour * 10) + Scancode - 16#30;
			elsif(pe^.cntr < 4) then
		      pe^.newres.my_time.wMinute := (pe^.newres.my_time.wMinute * 10) + Scancode - 16#30;
            elsif(format = IF_HHMMSS) then
		      pe^.newres.my_time.wSecond := (pe^.newres.my_time.wSecond * 10) + Scancode - 16#30;
            end_if;	 
            pe^.cntr   += 1; 
            pe^.change := TRUE;
		    state      := TRUE;
          ET_ENTER : 
	        SaveEditor(pe); //Werte übernehmen
		    CloseEditor(); 
	      ET_CLEAR :
	        _memcpy(#pe^.newres, #pe^.result, sizeof(ET_RESULT)); 	       
	        //pe^.newres := pe^.result; 
		    pe^.change := FALSE;  
	        CloseEditor();    
	   end_case;

//************************** Date edit *******************************2
       
    elsif((format = IF_TTMM)|(format = IF_TTMMYY)|(format = IF_TTMMYYYY)|
          (format = IF_WOTTMM)|(format =  IF_WOTTMMYY)|(format = IF_WOTTMMYYYY)) then
      case Scancode of
         16#30..16#39:
   	       if (pe^.change = FALSE) then
#pragma warning(disable:172); // HubChr v1.23
			 ET_Init::init_SYSDATE(#pe^.newres.my_date);
#pragma warning(default:172); // HubChr v1.23
           end_if;
		   if (pe^.cntr < 2) then
		     pe^.newres.my_date.wDay := (pe^.newres.my_date.wDay * 10) + Scancode - 16#30;
		   elsif (pe^.cntr < 4) then
		     pe^.newres.my_date.wMonth := (pe^.newres.my_date.wMonth * 10) + Scancode - 16#30;
           elsif (format = IF_TTMMYY) | (format = IF_WOTTMMYY) then
		     if(pe^.cntr < 6) then			     
               pe^.newres.my_date.wYear := (pe^.newres.my_date.wYear * 10) + Scancode - 16#30;
			 end_if;    
		   elsif(format = IF_TTMMYYYY) | (format = IF_WOTTMMYYYY) then
		   	 if (pe^.cntr < 8) then
               pe^.newres.my_date.wYear := (pe^.newres.my_date.wYear * 10) + Scancode - 16#30;		     
		     end_if;
		   end_if; 
           pe^.cntr   += 1; 
           pe^.change := TRUE;
		   state      := TRUE;
         ET_ENTER : 
	       SaveEditor(pe); //Werte übernehmen
		   CloseEditor(); 
	     ET_CLEAR :
	       _memcpy(#pe^.newres, #pe^.result, sizeof(ET_RESULT)); 	       
	       //pe^.newres := pe^.result; 
		   pe^.change := FALSE;  
	       CloseEditor();    
	  end_case;

//************************** String edit ***************************

    elsif(format = IF_STRING) then
      pos := pe^.actpos;

	  case(Scancode)of
	    ET_LEFT :  if (pos > 0) then 
		           pos -= 1; 
			     end_if; 
				 Firstselect := TRUE; 
                
        ET_RIGHT : pos += 1;
				 Firstselect := TRUE; 
                 
		ET_CLEAR : 
				 Firstselect := TRUE; 
                  
		ET_BCKSPC: width := GetSize(#pe^.variable.info);
		         newpos := width - pos -1;
				 _memmove(#pe^.memo[pos], #pe^.memo[pos+1], newpos);
		         pe^.memo[width -1] := ' '; 
                 pe^.change := TRUE;		
                 pe^.newres.my_string := #pe^.memo[0]; 
				 state := TRUE;
   				 Firstselect := TRUE; 
        ET_ENTER :
        else     if(CursorNext = TRUE) then  
	               pos += 1;
	             end_if;
     		     pe^.memo[pos]   := TO_USINT(Scancode);
//	    	     pe^.memo[pos+1] := 0;     
		    	 pe^.change := TRUE; 
			     pe^.newres.my_string := #pe^.memo[0]; 
		         state := TRUE; 
	         
      end_case; 
                     
//******************************************************************

      width := GetSize(#pe^.variable.info); 
      if(pos >= width) then
	    pos := width - 1; 
	  end_if; 

	  CursorOn(pe^.io.xpos + pos, pe^.io.ypos, 1);  
      pe^.actpos := pos; 

      if(Scancode = ET_CLEAR) then
	    _memcpy(#pe^.newres, #pe^.result, sizeof(ET_RESULT)); 	       
		pe^.change := FALSE;  
	    CloseEditor();    
      end_if; 

      if (Scancode = ET_ENTER) then 				
	    SaveEditor(pe); //String übernehmen		
		CloseEditor(); 							
	  end_if;

	end_if;

    if (state = TRUE) then
	  EditMem := FALSE;
      CursorHide();
	  Out_IO_Intern(#pe^.io, #pe^.newres, #pe^.variable);
	end_if;
    
    Scancode := 0;

  end_if;

END_FUNCTION // _ET_RunTime::RunEditor
(*

FUNCTION  _ET_RunTime::FormatGraphic
VAR_INPUT
    txt     : ^CHAR; 
	pr		: ^_RESULT;
	pv		: ^_VARIABLE;
END_VAR

  bereich := pr^.hi_limit - pr^.lo_limit;
   
  offset  := pr^.lo_limit;  


END_FUNCTION
*)


FUNCTION  _ET_RunTime::Out_IO_Intern
VAR_INPUT
	pio		: ^ET_IO;
	pr		: ^ET_RESULT;
	pv		: ^ET_VARIABLE;
END_VAR
VAR
	txt      : ARRAY[0..40] of CHAR;
	ptxt     : ^CHAR; 
	width    : UINT; 
	anyt     : ET_ANYTHING;
	anz      : UINT;
	area     : DINT;
	value    : DINT;
	anz2     : UINT;
	offset   : DINT;
	txtlen   : UINT;
	offsetval: DINT;
END_VAR
  
 
  case(pio^.io_format) of
    IF_NONE:
	IF_CODE:        value := pr^.value/10;
	                width := 1; 
					while(value) do
					  width += 1; 
					  value := value / 10; 
                    end_while; 
//					if(width) then
					  _memset(#txt[0], '*', width); 
                      txt[width] := 0; 
					  width := (pv^.info.format and 16#000F);
                      OutXY(pio^.xpos, pio^.ypos, width, #txt[0]);
//					end_if; 

    IF_NUMERIC:     width := (pv^.info.format and 16#000F);
	                if(pv^.info.format and 16#00F0) then
                      width += 1; 
                    end_if;
					if(pv^.info.format and 16#0F00) then  //and 16#0F00
					  if pv^.info.vartyp=ET_BYTE | pv^.info.vartyp=ET_WORD | pv^.info.vartyp=ET_DWORD then
					    width += 1;
                      end_if;
					end_if;
					
					if(pr^.value > pr^.hi_limit) & (EditMem = TRUE) then
					  anz := 0;
                      while anz < width do
             		    txt[anz] := '>'; 
					    anz += 1;   
					  end_while;
					  txt[anz] := '0';
					elsif(pr^.value < pr^.lo_limit) & (EditMem = TRUE) then
                      anz := 0;
					  while anz < width do
					    txt[anz] := '<';
					    anz += 1;
                      end_while;
					  txt[anz] := '0';
					else  
                      dtoa(#txt[0], pr^.value, pv^.info.format);
					end_if; 
                    OutXY(pio^.xpos, pio^.ypos, width, #txt[0]);

    IF_HHMM :       OutTIME(pio^.xpos, pio^.ypos, #pr^.my_time, pio^.io_format);
    IF_HHMMSS :     OutTIME(pio^.xpos, pio^.ypos, #pr^.my_time, pio^.io_format);

    IF_TTMM :       OutDATE(pio^.xpos, pio^.ypos, #pr^.my_date, pio^.io_format);
    IF_TTMMYY :     OutDATE(pio^.xpos, pio^.ypos, #pr^.my_date, pio^.io_format);
    IF_TTMMYYYY :   OutDATE(pio^.xpos, pio^.ypos, #pr^.my_date, pio^.io_format);
    IF_WOTTMM :     OutDATE(pio^.xpos, pio^.ypos, #pr^.my_date, pio^.io_format);
    IF_WOTTMMYY :   OutDATE(pio^.xpos, pio^.ypos, #pr^.my_date, pio^.io_format);
    IF_WOTTMMYYYY : OutDATE(pio^.xpos, pio^.ypos, #pr^.my_date, pio^.io_format);
    
	IF_STRING :     width := GetSize(#pv^.info);
   	                OutXY(pio^.xpos, pio^.ypos, width, pr^.my_string);  
  
    IF_TEXT :       anyt    := pio^.anything;
					anyt.no += to_UINT(pr^.value);
                    ptxt    := Get_ANYTHING(#anyt, NIL); //Sprache);  // Sprache is a client
                    txtlen  := TO_UINT(_strlen(ptxt));
     				
					//if pio^.txtlen < txtlen then   
                    //   pio^.txtlen := txtlen;     
                    //end_if;                         
         
					OutXY(pio^.xpos, pio^.ypos, pio^.txtlen, ptxt);  //OutXY(pio^.xpos, pio^.ypos, txtlen, ptxt);
              
			                                         
    IF_GRAPHIC:     // Balkenbreite mit Zeichen füllen
	                width :=  pio^.anything.no;
					anz := 0;
					while anz < width do
             		  txt[anz] := 16#A5; 
					  anz += 1;   
				    end_while;
					txt[anz] := '0';

// *********** Balken von links nach rechts ausgeben ***************
					if (pv^.info.limit_lo.value >= 0) 
					   & (pv^.info.limit_hi.value >= 0) then					 
					  area := pv^.info.limit_hi.value 
					          - pv^.info.limit_lo.value;                                        					  
					  value := (pr^.value * width) / area;					  
 					  if pv^.info.limit_lo.value >= 0 then
                        offsetval := (pv^.info.limit_lo.value * width) / area;
	                    value := value - offsetval;				  
					  end_if;
					  anz2 := 0;			  
					  if pr^.value > pv^.info.limit_hi.value then
					    value := width;
					    while anz2 < value do
             		      txt[anz2] := '>';  
					      anz2 += 1;   
				        end_while;                      
					  elsif pr^.value < pv^.info.limit_lo.value then // o then
					    value := width;
					    while anz2 < value do
             		      txt[anz2] := '<';  
					      anz2 += 1;   
				        end_while;                      
                      end_if;
					  while anz2 < value do
             		    txt[anz2] := 255;  
					    anz2 += 1;   
				      end_while;

// ************* Balken von rechts nach links ausgeben **************
					elsif (pv^.info.limit_lo.value < 0) 
					       & (pv^.info.limit_hi.value <= 0) then
					  area := pv^.info.limit_lo.value 
					          - pv^.info.limit_hi.value;
					  value := (pr^.value * width) / area;
        			  if pv^.info.limit_hi.value <= 0 then
                        offsetval := (pv^.info.limit_hi.value * width) / area;
	                    value := value - offsetval;				  
					  end_if;
					  if pr^.value < pv^.info.limit_lo.value then
					    value := width;
					    offset := width - value$UINT; 
					    anz2 := width-1;
					    while anz2 > offset do
             		      txt[anz2] := '<';  
						  anz2 -= 1;
					      if anz2 = offset then
						    txt[anz2] := '<';
						  end_if;     
				        end_while;
					  elsif pr^.value > pv^.info.limit_hi.value then
					    value := width;				                          
					    offset := width - value$UINT; 
					    anz2 := width-1;
					    while anz2 > offset do
             		      txt[anz2] := '>';  
						  anz2 -= 1;
						  if anz2 = offset then
						    txt[anz2] := '>';
						  end_if;     
				        end_while;
					  else
					    offset := width - value$UINT; 
					    anz2 := width-1;
					  
					    while anz2 > offset do
             		      txt[anz2] := 255;  
						  anz2 -= 1;
						  if anz2 = offset then
						    txt[anz2] := 255;
						  end_if;     
				        end_while;
					  end_if;    

// *************** Balken nach beide Seiten ausgeben ***************
					elsif (pv^.info.limit_lo.value <= 0) 
					      & (pv^.info.limit_hi.value > 0) then
					  area := pv^.info.limit_hi.value 
					          - pv^.info.limit_lo.value;                                        					  
					  value := (pr^.value * width) / area;					                        
   					  // Werte größer Null
					  if value >= 0 then		  
                        offsetval := (pv^.info.limit_hi.value * width) / area;
                        value += offsetval;
					    anz2 := offsetval$UINT; 
					    if pr^.value > pv^.info.limit_hi.value then
					      value := width;
					      while anz2 < value do
             		        txt[anz2] := '>';  
					        anz2 += 1;   
				          end_while;                      
                        end_if;
						while anz2 < value do
             		      txt[anz2] := 255;  
					      anz2 += 1;   
				        end_while;
                      // Wert kleiner Null
					  elsif value <= 0 then
                        offsetval := (pv^.info.limit_hi.value * width) / area;
                        value += offsetval;
					    anz2 := offsetval$UINT; 
					    if pr^.value < pv^.info.limit_lo.value then
					      value := offsetval;
					      offset := offsetval - value$UINT; 
					      anz2 := offsetval$UINT-1;
					      while anz2 > offset do 
             		        txt[anz2] := '<';  
						    anz2 -= 1;
					        if anz2 = offset then 
						      txt[anz2] := '<';
						    end_if;     
				          end_while;
					    else
						  anz2 := offsetval$UINT-1;   
					      while anz2 > value do   
             		        txt[anz2] := 255;  
						    anz2 -= 1;
				          end_while;
                          if anz2 = value then
						    txt[anz2] := 255;
						  end_if;     
					    end_if;
				      end_if;
                    end_if;
				    OutXY(pio^.xpos, pio^.ypos, width, #txt[0]);

  end_case; 
  
	END_FUNCTION // _ET_RunTime::Out_IO_Intern

FUNCTION  _ET_RunTime::SaveEditor
VAR_INPUT
	pe		: ^ET_EDITOR;
END_VAR
VAR_OUTPUT
    retcode : UDINT;
END_VAR
VAR
  va        : ET_VARIABLE;
  vl        : ET_VARLABEL;
  dom       : UINT; 
END_VAR
 
  if(pe^.change = TRUE) then;
    pe^.result.value := pe^.newres.value; 
	vl.state := VLS_VARIABLE; 
	vl.value := pe^.io.varno;


    if(pe^.variable.info.vartyp = ET_DATE) then
      // check date
      dom := GetDayOfMonth(pe^.newres.my_date.wMonth, pe^.newres.my_date.wYear);
	  if(pe^.newres.my_date.wDay > dom) then
	    pe^.newres.my_date.wDay := dom; 
	  elsif(pe^.newres.my_date.wDay < 1) then
	    pe^.newres.my_date.wDay := 1; 
      end_if; 

	  if(pe^.newres.my_date.wMonth > 12) then
        pe^.newres.my_date.wMonth := 12; 
      elsif(pe^.newres.my_date.wMonth < 1) then
        pe^.newres.my_date.wMonth := 1; 
      end_if; 

      if(pe^.newres.my_date.wYear < 90) then
	    pe^.newres.my_date.wYear += 2000; 
      elsif(pe^.newres.my_date.wYear < 100) then
	    pe^.newres.my_date.wYear := pe^.newres.my_date.wYear + 1900; 		     
      end_if; 

      pe^.newres.my_date.wDayOfWeek := GetDayWeek(pe^.newres.my_date.wDay, pe^.newres.my_date.wMonth, pe^.newres.my_date.wYear); 

    elsif(pe^.variable.info.vartyp = ET_TIME) then
	  // check time
      pe^.newres.my_time.wHour   := pe^.newres.my_time.wHour mod 24; 
      pe^.newres.my_time.wMinute := pe^.newres.my_time.wMinute mod 60; 
      pe^.newres.my_time.wSecond := pe^.newres.my_time.wSecond mod 60; 
	end_if; 
      

    retcode  := SetSystemdata(#vl, #pe^.newres, #va);
  end_if;

END_FUNCTION // _ET_RunTime::SaveEditor


FUNCTION  _ET_RunTime::OutDate
VAR_INPUT
	x	    	: UINT;
	y	    	: UINT;
	pd	    	: ^SYSDATE;
	io_format	: ET_IO_FORMAT;
END_VAR
VAR
  txt       : ARRAY[0..14] of CHAR;
  i         : UINT; 
END_VAR

//  pd^ := SysDate;

  i := 0; 
  if((io_format = IF_WOTTMMYYYY)|
     (io_format = IF_WOTTMMYY)|
     (io_format = IF_WOTTMM)) THEN
     
    GetDay(#txt[0], pd^.wDayOfWeek);
	txt[2] := ':';
    i := 3;
  end_if; 

  dtoa(#txt[i], pd^.wDay, 16#0102); i += 2;
  txt[i] := '.'; i += 1; 
  dtoa(#txt[i], pd^.wMonth, 16#0102); i += 2; 
  
  if((io_format = IF_TTMMYYYY) |
     (io_format = IF_WOTTMMYYYY)) THEN
	 txt[i] := '.'; i += 1;           
     dtoa(#txt[i], pd^.wYear, 16#0104); i += 4; 
  elsif((io_format = IF_WOTTMMYY)|
        (io_format = IF_TTMMYY)) THEN
		txt[i] := '.'; i += 1;         
	dtoa(#txt[i], pd^.wYear mod 100, 16#0102); i += 2; 
  end_if;

  txt[i] := 0; 

  OutXY(x, y, 0, #txt[0]);

 
END_FUNCTION // _ET_RunTime::OutDate

FUNCTION  _ET_RunTime::OutTime
VAR_INPUT
	x		: UINT;
	y		: UINT;
	pt		: ^SYSTIME;
	io_format		: ET_IO_FORMAT;
END_VAR
VAR
  txt       : ARRAY[0..9] of CHAR;
END_VAR

//  pt^ := SysTime; 
  dtoa(#txt[0], pt^.wHour, 16#0102);
  txt[2] := ':';
  dtoa(#txt[3], pt^.wMinute, 16#0102);   //  #txt[3]
  if(io_format = IF_HHMMSS) then
    txt[5] := ':';
	dtoa(#txt[6], pt^.wSecond, 16#0102);
	txt[8] := 0;
  else
    txt[5] := 0;
  end_if;
  OutXY(x, y, 0, #txt[0]);


END_FUNCTION // _ET_RunTime::OutTime

FUNCTION  _ET_RunTime::GetDay
VAR_INPUT
    txt     : ^CHAR;
	dow		: UINT;
END_VAR

  dow := dow mod 7;      // dow = Day of week
  _memcpy(txt, get_SPRACHE(#StxList, 0) + 2 * dow, 2);
 
END_FUNCTION // _ET_RunTime::GetDay

FUNCTION  _ET_RunTime::GetDayWeek
VAR_INPUT
  day       : UINT;
  month     : UINT;
  year      : UINT;
END_VAR
VAR_OUTPUT
  retcode   : UINT;
END_VAR
VAR
  days : UDINT; 
  maxs : UINT; 
END_VAR

  year  -= 1; 
  maxs  := year / 4; 
  maxs  -= year / 100; 
  maxs  += year / 400; 
  days  := ((TO_UDINT(year)) * 365) + maxs; 

  while(month > 1) do
    month -= 1; 
    days  += GetDayOfMonth(month+1, year+1);   
  end_while; 

  days += day;

  retcode := to_UINT(days mod 7);  
  

END_FUNCTION // _ET_RunTime::GetDayWeek

FUNCTION  _ET_RunTime::GetDayOfMonth
VAR_INPUT
	month		: UINT;
	year		: UINT;
END_VAR
VAR_OUTPUT
	retcode		: UINT;
END_VAR

  retcode := 30; 
  case month of
    1,3,5,7,8,10,12: retcode := 31;
	              2: if (schoitjoa(year) = true) then
	                   retcode := 29;
		             else
		               retcode := 28;
		             end_if;             
  end_case;


END_FUNCTION // _ET_RunTime::GetDayOfMonth

FUNCTION  _ET_RunTime::schoitjoa
VAR_INPUT
	year		: UINT;
END_VAR
VAR_OUTPUT
	retcode		: BOOL;
END_VAR

  retcode := FALSE;

  if((year mod 4) = 0)then
    retcode := TRUE; 
    if((year mod 100) = 0) then
	  retcode := FALSE; 
	  if((year mod 400) = 0) then
	    retcode := TRUE; 
      end_if; 
    end_if; 
  end_if; 

END_FUNCTION // _ET_RunTime::schoitjoa

FUNCTION GLOBAL _ET_RunTime::LoadGlobal
VAR_INPUT
	lan		: UINT;
END_VAR
VAR_OUTPUT
	retcode		: BOOL;
END_VAR

  load_SPRACHE(#StxList, (#tab_STX())+4, lan);  //tab_STX
  load_SPRACHE(#MtxList, (#tab_MTX())+4, lan);  //tab_MTX
  load_SPRACHE(#AtxList, (#tab_ATX())+4, lan);  //tab_ATX

  retcode := TRUE;

END_FUNCTION //GLOBAL _ET_RunTime::LoadGlobal
// ******************************************************************
// *****************      Set cursor to position          ***********
// ******************************************************************
// *****                                                        *****
// *****                                                        *****
// *****  Input Parameter :   x = X position of display         *****
// *****                      y = Y position of display         *****
// *****                      width = size of Cursor            *****
FUNCTION GLOBAL _ET_RunTime::CursorOn
VAR_INPUT
	x		: uint;
	y		: uint;
	width	: uint;
END_VAR

 CursorOff(); 
  _memset(#Cursor.slurry[0], 255, width);  
  Cursor.width  := width; 
  Cursor.x      := x; 
  Cursor.y      := y; 
  Cursor.active := TRUE; 
  CursorShow(TRUE); 
  

END_FUNCTION //GLOBAL _ET_RunTime::CursorOn
// ******************************************************************
// *****************      Set cursor hide and off         ***********
// ******************************************************************
// *****                                                        *****
// *****                                                        *****
// *****                                                        *****
FUNCTION GLOBAL _ET_RunTime::CursorOff

  if(Cursor.active = TRUE) then 
    CursorShow(FALSE);
	Cursor.active := FALSE;  
  end_if;  


END_FUNCTION //GLOBAL _ET_RunTime::CursorOff
//[#ENGLISH]
// ******************************************************************
// *****************      Set cursor hide       *********************
// ******************************************************************
// *****                                                        *****
// *****                                                        *****
// *****                                                        *****
FUNCTION GLOBAL _ET_RunTime::CursorHide

  if(Cursor.active = TRUE) then
    CursorShow(FALSE); 
  end_if; 

END_FUNCTION //GLOBAL _ET_RunTime::CursorHide
// ******************************************************************
// ******************    Put cursor on screen     *******************
// ******************************************************************
// ******                                                      ******
// ******  Input parameter : state = false = Cursor hide       ******
// ******                            true  = Cursor fisible    ******
FUNCTION  _ET_RunTime::CursorShow
VAR_INPUT
	state		: bool;
END_VAR


  if(Cursor.active = TRUE) then

    if(state = TRUE) then
	  if(Cursor.status = FALSE) then
	    GetXY(#Cursor.memo[0], Cursor.x, Cursor.y, Cursor.width); 
	    OutXY(Cursor.x, Cursor.y, Cursor.width, #Cursor.slurry[0]);
		Cursor.status := TRUE; 
      end_if; 
    elsif(Cursor.status = TRUE) then 
	  OutXY(Cursor.x, Cursor.y, Cursor.width, #Cursor.memo[0]);
      Cursor.status := FALSE; 
    end_if;
  end_if;

  timecursor := ops.tAbsolute;   

END_FUNCTION // _ET_RunTime::CursorShow
FUNCTION GLOBAL _ET_RunTime::DoInterzle
VAR_INPUT
	pe		: ^ET_INTERZLE;
END_VAR
VAR_OUTPUT
	retcode		: BOOL;
END_VAR

  retcode := FALSE;  

  case pe^.bef of

    _ET_CHAPIC:  retcode := CmdChaPic(#pe^.op1);		    // Change picture
	          			                
    _ET_RETPIC:  retcode := CmdRetPic();				    // Return picture

    _ET_LAN:     retcode := CmdLan(#pe^.op1);			    // Change Sprache

    _ET_FCAWL:   retcode := CmdFCAWL(#pe^.op1, #pe^.op2); // Function call

    _ET_INC:     retcode := CmdInc(#pe^.op1, 1);          // Increment variable

    _ET_DEC:     retcode := CmdDec(#pe^.op1, 1);         // Decrement variable

    _ET_ADD:     retcode := CmdAdd(#pe^.op1, #pe^.op2);   // Add value to variable

    _ET_SUB:     retcode := CmdSub(#pe^.op1, #pe^.op2);   // Sub value from variable

    _ET_SET:	   retcode := CmdSet(#pe^.op1, #pe^.op2);   // Set variable 

    _ET_BEEP:    //retcode := CmdBeep(#pe^.op1);             

    _ET_TOGGLE:  retcode := CmdToggle(#pe^.op1);          // Toggle between

    _ET_LED:     retcode := CmdLed(#pe^.op1, #pe^.op2);  // Led (1-on, 0-off, 2-blink)

    _ET_KEY:     //retcode := CmdKey(#pe^.op1);

    _ET_NEXT:    retcode := CmdNextIO(1);         // Cursor to right

	_ET_BEFOR:   retcode := CmdNextIO(-1);        // Cursor to left

    _ET_KEYCOD:  retcode := CmdKeyCode(#pe^.op1); // Key (1 to 9, Clear, 0, Enter)
	
    _ET_STRING:  retcode := CmdString(#pe^.op1);  // String input

	_ET_NOP:     // Tu mal nichts !!!

  end_case;

END_FUNCTION //GLOBAL _ET_RunTime::DoInterzle
FUNCTION GLOBAL _ET_RunTime::DoInterpreter
VAR_INPUT
	pip		: ^ET_INTERPRETER;
END_VAR
VAR_OUTPUT
	retcode		: BOOL;
END_VAR
VAR
  i			: UINT;
  no		: UINT;
END_VAR

  retcode := FALSE;

  if(pip^.no > 0) then
    no := pip^.no -1;
    for i:=0 to no do
	  DoInterzle(#pip^.zle[i]);
    end_for;
	retcode := TRUE;
  end_if;

END_FUNCTION //GLOBAL _ET_RunTime::DoInterpreter
FUNCTION GLOBAL _ET_RunTime::GetKeyInterpreter
VAR_INPUT
	no		: UINT;
	src		: ET_PREFKEY;
END_VAR
VAR_OUTPUT
	retcode		: ^ET_INTERPRETER;
END_VAR
VAR
  offset	: UINT;
END_VAR

  retcode := NIL;

  if(src <> NIL) then
    if (no < src^.no) then
      offset := src^.offset[no];
    	if (offset <> 16#FFFF) then
	    retcode := src + offset;
	  end_if; 
    end_if;
  end_if; 

END_FUNCTION //GLOBAL _ET_RunTime::GetKeyInterpreter
FUNCTION  _ET_RunTime::CmdLed
VAR_INPUT
	op1		: ^ET_VARLABEL;
	op2		: ^ET_VARLABEL;
END_VAR
VAR_OUTPUT
	retcode		: BOOL;
END_VAR
VAR
  variable : ET_VARIABLE; 
  result   : ET_RESULT; 
  no       : UINT; 
  state    : UINT;
  dsepp    : UDINT; 
END_VAR

  retcode := FALSE; 

  if(GetSystemdata(#result, #variable, op1) = TRUE) then
    no := TO_UINT(result.value); 
    if(GetSystemdata(#result, #variable, op2) = TRUE) then
      state   := TO_UINT(result.value); 
      retcode := TRUE; 


      dsepp := (TO_UDINT(1) shl no) xor 16#FFFFFFFF; 
	  
	  // led off
	  PtLeds^.bd_ledson := PtLeds^.bd_ledson and dsepp; 
	  PtLeds^.bd_ledsblinking := PtLeds^.bd_ledsblinking and dsepp; 

      dsepp := dsepp xor 16#FFFFFFFF; 

      if(state = 1) then
	    PtLeds^.bd_ledson := PtLeds^.bd_ledson or dsepp; 
      elsif(state = 2) then
	    PtLeds^.bd_ledsblinking := PtLeds^.bd_ledsblinking or dsepp; 
	  end_if;         
    end_if; 
  end_if; 

END_FUNCTION // _ET_RunTime::CmdLed
(*      

FUNCTION  _ET_RunTime::CmdBeep
VAR_INPUT
  op		: ^_VARLABEL;
END_VAR
VAR_OUTPUT
  retcode   : BOOL;
END_VAR

  retcode := FALSE; 
  
END_FUNCTION // _ET_RunTime::CmdBeep  

*)    

FUNCTION _ET_RunTime::CmdChaPic
VAR_INPUT
	op		: ^ET_VARLABEL;
END_VAR
VAR_OUTPUT
  retcode : BOOL; 
END_VAR
VAR
  variable : ET_VARIABLE; 
  result   : ET_RESULT;  
END_VAR

  retcode := FALSE;
   
  if(GetSystemdata(#result, #variable, op) = TRUE) then
    retcode := LoadPicture(to_uint(result.value));
  end_if;

END_FUNCTION // _ET_RunTime::CmdPic
FUNCTION  _ET_RunTime::CmdInc
VAR_INPUT
	op		: ^ET_VARLABEL;
	inc		: DINT;
END_VAR
VAR_OUTPUT
	retcode		: BOOL;
END_VAR
VAR
    variable : ET_VARIABLE; 
	result   : ET_RESULT; 
END_VAR

  retcode := FALSE; 

  if(GetSystemdata(#result, #variable, op) = TRUE) then
    result.value += inc;
	
	// *** Begrenzung für Hi_Limit und Lo_Limit ***
	if result.value > result.hi_limit then       //variable.info.limit_hi.value 
	  result.value := result.hi_limit;           //variable.info.limit_hi.value;      
    end_if;

	retcode := SetSystemdata(op, #result, #variable); 
  end_if; 

(*
  retcode := FALSE; 

  if(GetSystemdata(#result, #variable, op) = TRUE) then
    result.value += inc;
	retcode := SetSystemdata(op, #result, #variable); 
  end_if; 
*)
END_FUNCTION // _ET_RunTime::CmdIncDec
FUNCTION  _ET_RunTime::CmdDec
VAR_INPUT
	op		: ^ET_VARLABEL;
	dec		: DINT;
END_VAR
VAR_OUTPUT
	retcode		: BOOL;
END_VAR
VAR
    variable : ET_VARIABLE; 
	result   : ET_RESULT; 
END_VAR

  retcode := FALSE; 

  if(GetSystemdata(#result, #variable, op) = TRUE) then
    result.value -= dec;
	
	// *** Begrenzung für Hi_Limit und Lo_Limit ***
	if result.value < result.lo_limit then  
	  result.value := result.lo_limit;      
    end_if;

	retcode := SetSystemdata(op, #result, #variable); 
  end_if; 

END_FUNCTION // _ET_RunTime::CmdIncDec


FUNCTION  _ET_RunTime::CmdSet
VAR_INPUT
	op1		: ^ET_VARLABEL;
	op2		: ^ET_VARLABEL;
END_VAR
VAR_OUTPUT
	retcode		: BOOL;
END_VAR
VAR
  result1   : ET_RESULT; 
  result2   : ET_RESULT; 
  varLo      : DINT;
  varHi      : DINT;
    variable : ET_VARIABLE; 
END_VAR

  retcode := FALSE; 

  (*
        original code
        
  if(GetSystemdata(#result, #variable, op2) = TRUE) then
	retcode := SetSystemdata(op1, #result, #variable); 
  end_if;   

        Ende original code 
  *)
   
   
  if(GetSystemdata(#result1, #variable, op1) = TRUE) then
    varLo := result1.lo_limit; 
    varHi := result1.hi_limit;                                
   
      if(GetSystemdata(#result2, #variable, op2) = TRUE) then
      
         if result2.value <= varHi & result2.value >= varLo then
            result1.value := result2.value;
          
         end_if;   
         
         retcode := SetSystemdata(op1, #result1, #variable);
         
      end_if;
  end_if;
 
  
END_FUNCTION // _ET_RunTime::CmdSet
FUNCTION  _ET_RunTime::CmdAdd
VAR_INPUT
	op1		: ^ET_VARLABEL;
	op2		: ^ET_VARLABEL;
END_VAR
VAR_OUTPUT
	retcode		: BOOL;
END_VAR
VAR
    variable : ET_VARIABLE; 
	result1   : ET_RESULT; 
	result2   : ET_RESULT; 
    vari      : DINT;
END_VAR

  retcode := FALSE;

  if(GetSystemdata(#result1, #variable, op1) = TRUE) then
    vari := result1.hi_limit;                                
	if(GetSystemdata(#result2, #variable, op2) = TRUE) then
	  result1.value := result1.value + result2.value;
      
	  // *** Begrenzung Hi_Limit ***
	  if result1.value > vari then
	    result1.value -= result2.value;
	  end_if; 
	  
	  retcode := SetSystemdata(op1, #result1, #variable);
    end_if;
  end_if;

(*
  retcode := FALSE;

  if(Varlist.GetSystemdata(#result1, #variable, op1) = TRUE) then
    if(Varlist.GetSystemdata(#result2, #variable, op2) = TRUE) then
	  result1.value := result1.value + result2.value;
      retcode := Varlist.SetSystemdata(op1, #result1, #variable);
    end_if;
  end_if;
*)
END_FUNCTION // _ET_RunTime::CmdAdd
FUNCTION  _ET_RunTime::CmdSub
VAR_INPUT
	op1		: ^ET_VARLABEL;
	op2		: ^ET_VARLABEL;
END_VAR
VAR_OUTPUT
	retcode		: BOOL;
END_VAR
VAR
    variable  : ET_VARIABLE; 
	result1   : ET_RESULT;
	result2   : ET_RESULT; 
	vari      : DINT;
END_VAR

  retcode := FALSE;

  if(GetSystemdata(#result1, #variable, op1) = TRUE) then
	vari := result1.lo_limit;                                   
	if(GetSystemdata(#result2, #variable, op2) = TRUE) then
	  result1.value := result1.value - result2.value;
      
	  // *** Begrenzung Lo_Limit ***
	  if result1.value < vari then
	    result1.value += result2.value;
	  end_if; 
	  	  
	  retcode := SetSystemdata(op1, #result1, #variable);
    end_if;
  end_if;
(*
  retcode := FALSE;

  if(Varlist.GetSystemdata(#result1, #variable, op1) = TRUE) then
    if(Varlist.GetSystemdata(#result2, #variable, op2) = TRUE) then
      result1.value := result1.value - result2.value;
      retcode := Varlist.SetSystemdata(op1, #result1, #variable);
    end_if;
  end_if;
*)
END_FUNCTION // _ET_RunTime::CmdSub
FUNCTION  _ET_RunTime::CmdRetPic
VAR_OUTPUT
	retcode		: BOOL;
END_VAR

  retcode := LoadPicture(GetPicmemo());

END_FUNCTION // _ET_RunTime::CmdRetpic
FUNCTION  _ET_RunTime::LoadPicture
VAR_INPUT
	no		    : UINT;
END_VAR
VAR_OUTPUT
	retcode		: BOOL;
END_VAR
VAR
  tmp           : ET_PICTURE;
END_VAR

  retcode := FALSE;
  
  CloseEditor(); 
  Language := Language.Read();
  //pic := tmp.;  

#pragma warning(disable:172); // HubChr v1.23
  ET_Init::init_PICTURE(#tmp); 
#pragma warning(default:172); // HubChr v1.23
  if(load_PICTURE(#tmp, no, Language$UINT) = TRUE) then
    // free_PICTURE(#RunTime.Picture); 
    AddPicmemo(no); 
    tmp.picstate    := PS_DRAW;
    Picture := tmp; 
    retcode := TRUE; 
  //else
  	// free_PICTURE(#tmp); 
  end_if; 

END_FUNCTION // _ET_RunTime::LoadPicture
FUNCTION  _ET_RunTime::CmdToggle
VAR_INPUT
	op		: ^ET_VARLABEL;
END_VAR
VAR_OUTPUT
	retcode		: BOOL;
END_VAR
VAR
    variable : ET_VARIABLE; 
	result   : ET_RESULT; 
END_VAR

  retcode := FALSE; 

  if(GetSystemdata(#result, #variable, op) = TRUE) then
    if(result.value <> 0) then
	  result.value := 0;
    else
	  result.value := 1;
    end_if;
    retcode := SetSystemdata(op, #result, #variable);
  end_if;

END_FUNCTION // _ET_RunTime::CmdToggle
FUNCTION  _ET_RunTime::CmdFCAWL
VAR_INPUT
	op1		: ^ET_VARLABEL;
	op2		: ^ET_VARLABEL;
END_VAR
VAR_OUTPUT
	retcode		: BOOL;
END_VAR
VAR
    variable  : ET_VARIABLE; 
	result1   : ET_RESULT; 
	result2   : ET_RESULT; 
END_VAR

  retcode := FALSE;

  if(GetSystemdata(#result1, #variable, op1) = TRUE) then
    if(GetSystemdata(#result2, #variable, op2) = TRUE) then
       
       User.FC_User(result1.value, result2.value);
     
	  retcode := TRUE;	 
    end_if;
  end_if;

END_FUNCTION // _ET_RunTime::CmdFCAWL
FUNCTION  _ET_RunTime::CmdNextIO
VAR_INPUT
    state       : INT; 
END_VAR
VAR_OUTPUT
	retcode		: BOOL;
END_VAR
VAR
  no          : UINT;
END_VAR

  if(Picture.refinput.no > 0) then
    if(Picture.editor.no > Picture.refinput.no) then
	  no := 0;
	  if(state < 0) then
  	    no := Picture.refinput.no - 1;
      end_if; 
    else
	  if(state < 0) then  // back
	    if(Picture.editor.no > 0) then
		  no := Picture.editor.no - 1; 
        else
		  no := Picture.refinput.no - 1; 
        end_if; 
	  else  // forward
	    if(Picture.editor.no >= (Picture.refinput.no -1)) then
          no := 0; 
        else
		  no := Picture.editor.no + 1;
		end_if;
      end_if; 
    end_if; 
  end_if; 

  if(no < Picture.refinput.no) then
    OpenEditor(no);   // open new editor
  end_if;
   
  retcode := TRUE; 

END_FUNCTION // _ET_RunTime::CmdNextIO


FUNCTION  _ET_RunTime::DestroyCursorSlur

  CursorSlur := FALSE; 
#pragma warning(disable:172); // HubChr v1.23
  ET_Init::init_ABCDATA(#ABCIndex); 
#pragma warning(default:172); // HubChr v1.23

END_FUNCTION 

FUNCTION  _ET_RunTime::CmdKeyCode
VAR_INPUT
  op          : ^ET_VARLABEL;
END_VAR
VAR_OUTPUT
	retcode		: BOOL;
END_VAR
VAR
    variable  : ET_VARIABLE; 
	result1   : ET_RESULT; 
END_VAR

  DestroyCursorSlur();     // zeitbasis für cursor nach rechts zerstören

  retcode := FALSE;

  if(GetSystemdata(#result1, #variable, op) = TRUE) then
    retcode := TRUE;
	Scancode := TO_UINT(result1.value);
  end_if;  


END_FUNCTION // _ET_RunTime::CmdKeyCode

FUNCTION  _ET_RunTime::CmdLan
VAR_INPUT
	op		: ^ET_VARLABEL;
END_VAR
VAR_OUTPUT
	retcode		: BOOL;
END_VAR
VAR
  variable : ET_VARIABLE; 
  result   : ET_RESULT;  
END_VAR

  retcode := FALSE; 

  if(GetSystemdata(#result, #variable, op) = TRUE) then
    //Language.Write(result.value);
	retcode := LoadGlobal(TO_UINT(result.value)); 
    LoadPicture(Picture.picno);
  end_if;

END_FUNCTION // _ET_RunTime::CmdLan


FUNCTION  _ET_RunTime::CmdString
VAR_INPUT
  op1          : ^ET_VARLABEL;
END_VAR
VAR_OUTPUT
  retcode     : BOOL;
END_VAR
VAR
  variable : ET_VARIABLE; 
  result1   : ET_RESULT;    
  tab      : ^UINT; 
  tmp      : ET_VARLABEL; 
  c        : char; 
  ptc      : ^char; 
  no       : UINT; 
END_VAR

  CursorSlur := FALSE; 
  CursorNext := FALSE; 
  retcode    := FALSE; 

  if(GetSystemdata(#result1, #variable, op1) = TRUE) then
    
	tab := GetCHARTAB(TO_UINT(result1.value));                      
	if(tab <> NIL) then  

      if(ABCEdit = TRUE) then
		CursorSlur := TRUE; 
        if(result1.value <> ABCIndex.tabno) then
		  if(FirstSelect = FALSE) then
            CursorNext := TRUE;	  // cursor um eins nach rechts weil neue taste gedrückt
			DestroyCursorSlur();  // zeitbasis für cursor nach rechts zerstören
		  end_if; 
		  FirstSelect := FALSE; 
		  ABCIndex.tabno := TO_USINT(result1.value); 
          ABCIndex.delaytime := 10000;  
		end_if; 
    	retcode  := TRUE;
		Scancode := GetABCIndex(tab);      
	  else
   	    no := tab^;
        if(no <> 0) then
	      ptc := tab + 2; 
		  
		  while no do
		    no -= 1; 
		    c  := ptc^; 
            if((c >= '0') & (c <= '9')) then
	          //  no := 0; 
	          tmp.state := VLS_CONSTANT; 
              tmp.value := c; //result1.value + '0'; 
              CMDKeyCode(#tmp); 
			  retcode := TRUE;
	          EXIT;		
			end_if; 
		    ptc += 1; 
		  end_while;
        
		end_if; 
      end_if; 
    end_if;      	
  end_if;

  
(*
  CursorSlur := FALSE; 
  retcode := FALSE; 

  if(GetSystemdata(#result1, #variable, op1) = TRUE) then

    if(ABCEdit = TRUE) then
      if(GetSystemdata(#result2, #variable, op2) = TRUE) then
        if(result2.value <> ABCIndex.tabno) then
	      ABCIndex.tabno := TO_USINT(result2.value); 
          ABCIndex.delaytime := 10000; 
        end_if; 
   
	    tab := GetCHARTAB(ABCIndex.tabno);                      
	    if (tab <> NIL) then
	      retcode := TRUE;
	      Scancode := GetABCIndex(tab);      
	      CursorSlur := TRUE; 
	    end_if;
      end_if; 
    else
	  tmp.state := VLS_CONSTANT; 
      tmp.value := result1.value + '0'; 
      CMDKeyCode(#tmp); 
    end_if; 
  end_if;      	

*)

END_FUNCTION

FUNCTION  _ET_RunTime::GetCHARTAB
VAR_INPUT
  tabno          : UINT;
END_VAR
VAR_OUTPUT
  retcode      : ^UINT;
END_VAR
VAR
  tab         :^UINT; 
END_VAR

  retcode := NIL;
  tab := #tab_CHAR()$^uint; //#GR
  tab +=4;
  if (tabno < tab^) then
    retcode := tab + 2;
	while tabno do
      tabno -= 1;
	  retcode += retcode^ + 3;
	end_while;
  end_if; 

END_FUNCTION

FUNCTION  _ET_RunTime::GetABCIndex
VAR_INPUT
  tab          : ^UINT;
END_VAR
VAR_OUTPUT
  retcode      : UINT;
END_VAR
VAR 
  pchr : ^CHAR;
END_VAR
 
  if (ABCIndex.delaytime < 1000) then       
    ABCIndex.index += 1;			
	if (ABCIndex.index >= (tab^)) then
      ABCIndex.index := 0;
    end_if;
    
  else
	ABCIndex.index := 0;
  end_if;
  ABCIndex.delaytime := 0; 
     
  pchr    := tab + sizeof(UINT) + ABCIndex.index;
  retcode := pchr^; 
  

END_FUNCTION 
FUNCTION  _ET_RunTime::RunABCIndex

  //if (_imp10ms) then 

	if (ABCIndex.delaytime < 1000) then 
	  ABCIndex.delaytime += 1; 
	  CursorSlur := TRUE;
    elsif(CursorSlur = TRUE) then
	  CursorSlur  := FALSE; 
      FirstSelect := TRUE; // true wenn cursor neu gesetzt
	  Scancode    := ET_RIGHT; 
  	end_if; 

  //end_if;   



END_FUNCTION



FUNCTION GLOBAL _ET_RunTime::SetABCEdit
VAR_INPUT
	state		: BOOL;
END_VAR

  ABCEdit := state; 

END_FUNCTION //GLOBAL _ET_RunTime::SetABCEdit

FUNCTION _ET_RunTime::GetLimit
VAR_INPUT
	pr  	: ^ET_RESULT;
	pv      : ^ET_VARINFO;
END_VAR
VAR
    variable : ET_VARIABLE;
	result   : ET_RESULT; 
	hi_limit : DINT; 
	lo_limit : DINT;  
END_VAR

  case pv^.vartyp of
  
    ET_UBYTE : hi_limit := 16#FF;
	         lo_limit := 16#00;  
                      
    ET_UWORD : hi_limit := 16#FFFF;  
	         lo_limit := 16#00;  
                      
	ET_UDWORD: hi_limit := 16#7FFFFFFF;  
	         lo_limit := 16#00;  
                      
    ET_BYTE  : hi_limit := 16#7F;  
	         lo_limit := -128;  
                      
    ET_WORD  : hi_limit := 16#7FFF;   
	         lo_limit := -32768;  
                      
    else     hi_limit := 16#7FFFFFFF;  
	         lo_limit := -2147483648;  
  end_case; 

  if(GetSystemdata(#result, #variable, #pv^.limit_hi) = TRUE) then
    if(result.value < hi_limit) then  
      hi_limit := result.value;
	end_if;    
  end_if; 

  if(GetSystemdata(#result, #variable, #pv^.limit_lo) = TRUE) then
    if(result.value > lo_limit) then  
      lo_limit := result.value;
	end_if;    
  end_if; 
  
  pr^.hi_limit := hi_limit; 
  pr^.lo_limit := lo_limit; 

END_FUNCTION//_ET_RunTime::GetLimit
FUNCTION GLOBAL _ET_RunTime::Get_String
VAR_INPUT 
  pv   : ^ET_VARIABLE; 
  dest : ^void; 
END_VAR
VAR_OUTPUT
  retcode  : BOOL; 
END_VAR
VAR
  tmp    : ARRAY[0..50] of USINT; 
  result : ^USINT; 
  psym   : ^ET_SYMBOL; 
  size   : UINT; 
  length : UINT; 
END_VAR

  retcode := FALSE; 
  size := pv^.info.format; 
  _memset(dest, ' ', size); 

  if(pv^.no < Symboltable.no) then
    psym := Symboltable.ptr + TO_UINT(pv^.no) * sizeof(ET_SYMBOL); 
    tmp[0]$UDINT := psym^.id.id;  
    tmp[4]$UINT  := 1; 
    tmp[6]$USINT := P_EOL;

//#GR
    if(TXCOMMAND(TO_UDINT(I_CMD), 9, #tmp[0], (GetCOMDEF(pv^.info.station))$^::Comdef, (#result)$^UDINT) = READY) then
      result += 2; 
	  length := TO_UINT(result$^UDINT^); 
	  result += 4; 
      // result zeigt nun auf string, vorsicht string ohne final zero
      if(length > size) then
	    length := size; 
      end_if; 
	  _memcpy(dest, result, length); 
	  retcode := TRUE; 
    end_if; 
  end_if; 



END_FUNCTION
FUNCTION GLOBAL _ET_RunTime::GetSystemdata
VAR_INPUT
	pr  	: ^ET_RESULT;
	pv      : ^ET_VARIABLE;
	pvl		: ^ET_VARLABEL;
END_VAR
VAR_OUTPUT
	retcode		: BOOL;
END_VAR
VAR
  size        : UINT; 
  src         : ^USINT;
  varno       : UINT; 
  ps          : ^ET_SYMBOL;
END_VAR

  retcode   := FALSE; 
  
  case pvl^.state of

#pragma warning(disable:172); // HubChr v1.23
   VLS_NONE:     ET_Init::init_RESULT(pr);
#pragma warning(default:172); // HubChr v1.23

   VLS_CONSTANT: pr^.value    := pvl^.value;
   				 pr^.hi_limit := pvl^.value;
				 pr^.lo_limit := pvl^.value;
#pragma warning(disable:172); // HubChr v1.23
				 ET_Init::init_VARIABLE(pv);
#pragma warning(default:172); // HubChr v1.23
				 retcode      := TRUE;
 
   VLS_VARIABLE: varno := to_uint(pvl^.value); 
   
                 if(GetVariable(varno, pv) = TRUE) then
                   
                   ps := Symboltable.ptr + varno * sizeof(ET_SYMBOL); 
				  // if(pv^.info.station <= 31) then
                     if(ps^.sent = FALSE) then
				       AddReflist(varno, pv^.info.station); 
				     end_if; 
                  // end_if; 

                   src := GetPointerToData(pv);
                       
				   if(src <> NIL) then
				     size := GetSize(#pv^.info); 

                     case pv^.info.vartyp of
                         
				       ET_UBYTE : pr^.value := src$^USINT^; 
					              GetLimit(pr, #pv^.info);
                                          
					   ET_UWORD : pr^.value := src$^UINT^;  
					              GetLimit(pr, #pv^.info);
                                          
					   ET_UDWORD: pr^.value := src$^DINT^;  
					              GetLimit(pr, #pv^.info);
                       ET_BYTE  : pr^.value := src$^SINT^;  
					              GetLimit(pr, #pv^.info);
                       ET_WORD  : pr^.value := src$^INT^;   
					              GetLimit(pr, #pv^.info);
                       ET_DWORD : pr^.value := src$^DINT^;  
					              GetLimit(pr, #pv^.info);

					   ET_BOOL  : if(src^ = 0) then
					                pr^.value := 0; 
                                  else
					  		        pr^.value := 1; 
                                  end_if; 
								  pr^.hi_limit := 1; 
								  pr^.lo_limit := 0; 

					   ET_TIME  : pr^.value := src$^DINT^;
					              Lasal_To_SYSTIME(#pr^.my_time, pr^.value); 

					   ET_DATE  : pr^.value := src$^DINT^;
					              Lasal_To_SYSDATE(#pr^.my_date, pr^.value); 

					   ET_STRING: Get_String(pv, src); 
					              pr^.my_string := src; 

					   //_TEXT wird nicht editiert.

				     end_case; 

				     retcode := TRUE;
                   end_if; 
                 end_if; 
                 
  end_case;



END_FUNCTION //GLOBAL _ET_RunTime::GetSystemdata
FUNCTION GLOBAL _ET_RunTime::GetValue
VAR_INPUT
    pr          : ^ET_RESULT; 
	pv          : ^ET_VARIABLE;
	no		    : UINT;
END_VAR
VAR_OUTPUT
	retcode		: BOOL;
END_VAR
VAR
    vl		   : ET_VARLABEL; 
END_VAR
  
#pragma warning(disable:172); // HubChr v1.23
  ET_Init::init_VARLABEL(#vl); 
#pragma warning(default:172); // HubChr v1.23
  vl.state := VLS_VARIABLE; 
  vl.value := no; 
  retcode  := GetSystemdata(pr, pv, #vl); 

END_FUNCTION //GLOBAL _ET_RunTime::GetValue

FUNCTION GLOBAL _ET_RunTime::GetVariable
VAR_INPUT
	no			: UINT;
	ptr	     	: ^ET_VARIABLE;
END_VAR
VAR_OUTPUT
	retcode		: BOOL;
END_VAR
VAR
  pti		: ^ET_VARINFO; 
END_VAR
  
  retcode := false;
  
  if (no < varlist.no) then
    retcode := true;
    pti := Varlist.ptr + sizeof(ET_VARINFO) * no;
	ptr^.info := pti^;
	ptr^.no   := no;

//    Für Vorzeichenbehaftete Variablen !!! wird nicht verwendet
//    if((ptr^.info.vartyp = _BYTE)|(ptr^.info.vartyp = _WORD)|(ptr^.info.vartyp = _DWORD)) then
//      ptr^.info.format := ptr^.info.format or 16#0400; 
//    end_if; 

  end_if;


END_FUNCTION //GLOBAL _ET_RunTime::GetVariable



FUNCTION GLOBAL _ET_RunTime::LoadVarlist
VAR_INPUT
	src			:^VOID;
END_VAR
VAR_OUTPUT
	retcode		: UDINT;
END_VAR

  // [2] ... Anzahl der Variablen
  // [ ..... Variablen

#pragma warning(disable:172); // HubChr v1.23
  ET_Init::init_VARLIST(#Varlist); 
#pragma warning(default:172); // HubChr v1.23
  
  Varlist.no := src$^UINT^;
  Varlist.ptr := src + 2;

  retcode := 2 + Varlist.no * sizeof(ET_VARINFO);
  retcode += load_TXTBUF(#Varlist.txtbuf, src + retcode);


END_FUNCTION //GLOBAL _ET_RunTime::LoadVarlist

FUNCTION GLOBAL _ET_RunTime::SetSystemdata
VAR_INPUT
	pv		: ^ET_VARLABEL;
	pr		: ^ET_RESULT;
	pvari	: ^ET_VARIABLE;
END_VAR
VAR_OUTPUT
	retcode		: BOOL;
END_VAR
VAR
	dest        : ^USINT; 
	dat         : ARRAY[0..100] OF USINT;  
	presult     : ^UINT; 
	st          : BOOL;
	value       : DINT; 
	psym        : ^ET_SYMBOL; 
	id          : UDINT; 
	len         : UINT;
END_VAR

  retcode := FALSE; 
  st      := FALSE; 

  if(pv^.state = VLS_VARIABLE) then
    if(GetVariable(to_uint(pv^.value), pvari) = TRUE) then

      if (pr^.value > pr^.hi_limit) then
        pr^.value := pr^.hi_limit;  // Set variable to upper limit
	  elsif (pr^.value < pr^.lo_limit) then
        pr^.value := pr^.lo_limit;  // Set variable to lower limit
	  end_if;
 
      case pvari^.info.vartyp of
        ET_UBYTE : value := pr^.value; st := TRUE; 
	    ET_UWORD : value := pr^.value; st := TRUE;
	    ET_UDWORD: value := pr^.value; st := TRUE;
        ET_BYTE  : value := pr^.value; st := TRUE;
        ET_WORD  : value := pr^.value; st := TRUE;
        ET_DWORD : value := pr^.value; st := TRUE;
        ET_BOOL  : if(pr^.value = 0) then
	  		         value := 0; 
                   else
		  	         value := 1; 
                   end_if; 
			       st := TRUE; 

  	    ET_TIME  : SYSTIME_To_Lasal(#pr^.value, #pr^.my_time);                 
		           value := pr^.value; st := TRUE;
				   retcode := TRUE; 

		ET_DATE  : SYSDATE_To_Lasal(#pr^.value, #pr^.my_date);
		           value := pr^.value; st := TRUE;
		           retcode := TRUE; 

		ET_STRING: //dest := pr^.my_string;
				 	        
//                 len  := TO_UINT(_strlen(pr^.my_string));
                 len  := TO_UINT(pvari^.info.format);
	             psym := Symboltable.ptr + TO_UINT(pv^.value) * sizeof(ET_SYMBOL); 
                 dat[0]$UDINT := psym^.id.id;  
                 dat[4]$UINT  := 2;  
                 dat[6]       := P_USER_STREAM;
                 dat[7]$UDINT := len + 1; 
				 
				 _memcpy(#dat[11], pr^.my_string, len);
				 dat[11 + len] := 0;  
				 retcode := FALSE; 
				 
                 if(TXCOMMAND(TO_UDINT(I_CMD),(dat[7])$UDINT+11,
				 #dat[0], (GetCOMDEF(pvari^.info.station))$^Comdef, #presult$UDINT) = READY) then
                 retcode := TRUE; 
                 end_if;
				 return;  // es tut mir in der seele weh !!!

				// Text wird nicht editiert.

	  end_case; 
      
      //[4]..... [0]lasalid der variable
      //[1]..... [4]prefix (P_IMMED)
	  //[4]..... [5]value 
      //[1]..... [9]prefix (P_EOL)
	  psym := Symboltable.ptr + TO_UINT(pv^.value) * sizeof(ET_SYMBOL); 
	  id   := psym^.id.id;  
      dat[0]$UDINT := id;  
      dat[4]       := P_IMMED; 
      dat[5]$DINT  := value;
      dat[9]       := P_EOL; 

      if((st = TRUE)&(id <> 0)) then
        if(TXCOMMAND(TO_UDINT(I_WRITE), 10, #dat[0], (GetCOMDEF(pvari^.info.station))$^Comdef, #presult$UDINT) = READY) then
          retcode := TRUE; 

          dest := GetPointerToData(pvari); 
          if(dest <> NIL) then
            _memcpy(dest, #value$USINT, GetSize(#pvari^.info));
		  end_if; 
	    end_if; 
	  end_if; 
    end_if; 
  end_if; 

END_FUNCTION //GLOBAL _ET_RunTime::SetSystemdata

FUNCTION GLOBAL _ET_RunTime::MakeSymbolTable
VAR_OUTPUT
	retcode		: BOOL;
END_VAR
VAR 
    size     : UDINT; 
	hp       : ^_PVOIDL;    
	ps       : ^ET_SYMBOL; 
	no       : UINT;
	variable : ET_VARIABLE;  
	offset   : UINT; 
	label    : ARRAY [0..120] of CHAR;
	varobj   : USINT;
	cd       : ^ET_COMDEF;
  //	txt      : ^CHAR;
END_VAR  

  InitOnline(); 
  retcode := FALSE; 
  size    := Varlist.no * sizeof(ET_SYMBOL);
  hp      := #Symboltable.ptr$^_VOIDL;
 
//  System::Free(NIL); 

  if(MyMemory(hp, size) <> 0) then  //(SYSMAE_Memory(hp, size) <> 0)

    retcode          := TRUE; 
	Symboltable.no   := Varlist.no; 
	ps               := Symboltable.ptr; 
    no               := 0; 
	offset           := 0; 

	while(no < Symboltable.no) do
#pragma warning(disable:172); // HubChr v1.23
      ET_Init::init_SYMBOL(ps); 
#pragma warning(default:172); // HubChr v1.23
      ps^.offset := 16#FFFF;
      if(GetVariable(no, #variable) = TRUE) then
        
        cd := GetCOMDEF(variable.info.station); 
		
//        if(variable.info.station <> 16#FF) then  // externe Variable
		  if((variable.info.vartyp <> ET_OBJECT) & (variable.info.vartyp <> ET_STRUCT)) then
		    if(PLC_LogIn(variable.info.station) = TRUE) then
              ps^.offset := offset;


              if(GetLabel(#label[0], #varobj, no) = TRUE) then
			    if(varobj = 0) then
				  ps^.varobj := FALSE; 
  				  // SYSMAE_GetAddressVar(#label[0]$_BYTE, (#ps^.id)$PVOID, (cd)$PVOID); // oldcom
                     	 		    
				else
				  ps^.varobj := TRUE; 
                  // SYSMAE_GetAddressObj(#label[0]$_BYTE, (#ps^.id)$PVOID, (cd)$PVOID); // oldcom			    
				  GetAdressOBJ(#label[0], #ps^.id$UDINT, cd);
				end_if;
              end_if;
              offset += GetSize(#variable.info);
			end_if;    
          end_if;
//		else // locale Variable

             // Funktionsaufruf für locale Lasalid  
             

		      
//        end_if; 
	  end_if; 

	  ps += sizeof(ET_SYMBOL); 
	  no  += 1; 
	end_while; 

    hp := #Symboltable.pdata$^_VOIDL;                
    if(MyMemory(hp, offset) <> 0) then  //(SYSMAE_Memory(hp, offset) <> 0)
	  _memset(Symboltable.pdata, 0, offset); 
    else
	  retcode := FALSE; 
    end_if; 

  end_if; 


END_FUNCTION //GLOBAL _ET_RunTime::MakeSymbolTable

FUNCTION GLOBAL _ET_RunTime::GetSize
VAR_INPUT
	pi		: ^ET_VARINFO;
END_VAR
VAR_OUTPUT
	retcode		: UINT;
END_VAR

  retcode := 0; 

  case pi^.vartyp of

    ET_UBYTE   :  retcode := 1;
	ET_BYTE    :  retcode := 1; 
	ET_UWORD   :  retcode := 2;
	ET_WORD    :  retcode := 2;
	ET_UDWORD  :  retcode := 4;
	ET_DWORD   :  retcode := 4;
	ET_BOOL    :  retcode := 1;
	ET_TIME    :  retcode := 4; //sizeof(SYSTIME);
	ET_DATE    :  retcode := 4; //sizeof(SYSDATE);
	ET_STRING  :  retcode := pi^.format;
	ET_OBJECT  :  retcode := pi^.format; 
	ET_STRUCT  :  retcode := pi^.format; 
   // _TEXT    :  retcode := pi^.format;
  
  end_case; 

END_FUNCTION //GLOBAL _ET_RunTime::GetSize

FUNCTION GLOBAL _ET_RunTime::GetPointerToData
VAR_INPUT
	pv      : ^ET_VARIABLE;
END_VAR
VAR_OUTPUT
	retcode : ^USINT;
END_VAR
VAR
    no : UINT;  
	ps : ^ET_SYMBOL;
END_VAR; 

  retcode := NIL; 
  no      := pv^.no;  

  if(no < Symboltable.no) then

    //if(pv^.info.station <> 16#FF) then  
	  // extern data
      ps := Symboltable.ptr + no * sizeof(ET_SYMBOL);
	  if(ps^.valid = TRUE) then
	    retcode := SymbolTable.pdata + ps^.offset; 
      end_if; 
    //else
	  // local data    
	    //if (ps^.valid = TRUE) then
		//  retcode := #NurTest$USINT; 
        //end_if;
	//end_if; 
  end_if; 

END_FUNCTION //_ET_RunTime::GetPointerToData


FUNCTION GLOBAL _ET_RunTime::GetLabel
VAR_INPUT
  txt     : ^CHAR;
  varobj  : ^USINT;
  no		  :  UINT;
END_VAR
VAR_OUTPUT
    retcode : BOOL;
END_VAR

  txt^    := 0;
  varobj^ := 1; 
  retcode := GetLabelIntern(txt, varobj, no);


END_FUNCTION // _ET_RunTime::GetLabel

FUNCTION  _ET_RunTime::GetLabelIntern
VAR_INPUT
	txt		: ^CHAR;
	varobj	: ^USINT;
	no		: UINT;
END_VAR
VAR_OUTPUT
	retcode		: BOOL;
END_VAR
VAR
	ptr      : ^ET_VARINFO;
    tmp      : ^CHAR;
	scope    : UINT;
END_VAR
  
  retcode := FALSE;
  
  if(no < Varlist.no) then
    retcode := TRUE;
	ptr := Varlist.ptr + no * sizeof(ET_VARINFO);
    if(ptr^.vartyp = ET_OBJECT) then               
	  varobj^ := 1;
    end_if; 

    scope := ptr^.scope;                        
    if(scope <> 16#FFFF) then                  
      retcode := GetLabelIntern(txt, varobj, scope);  
      if(retcode = TRUE) then
	    if(ptr^.vartyp = ET_OBJECT) then                          
		  _strcat(txt, "\");
		else 
		  _strcat(txt, ".");
        end_if;
	  end_if;      
    end_if; 

	if(retcode = TRUE) then
      tmp := GetLabelPart(no);
	  if(tmp <> NIL) then
        _strcat(txt, tmp);
	  end_if;
	end_if;
  end_if;

END_FUNCTION // _ET_RunTime::GetLabelIntern

FUNCTION  _ET_RunTime::GetLabelPart
VAR_INPUT
	no		: UINT;
END_VAR
VAR_OUTPUT
	retcode		: ^CHAR;
END_VAR

  retcode := NIL;

  if(no < Varlist.no) then
    retcode := get_TXTBUF(#Varlist.txtbuf, no);
  end_if;   

END_FUNCTION // _ET_RunTime::GetLabelPart

FUNCTION GLOBAL _ET_RunTime::InitOnline
VAR
  i       : UINT;
END_VAR

  for i := 0 to 32 do
#pragma warning(disable:172); // HubChr v1.23
    ET_Init::init_COMDEF(#OnlineStation[i]);
#pragma warning(default:172); // HubChr v1.23
  end_for; 

END_FUNCTION //GLOBAL _ET_RunTime::InitOnline

FUNCTION  _ET_RunTime::GetCOMDEF
VAR_INPUT
	station		: UINT;
END_VAR
VAR_OUTPUT
	retcode		: ^ET_COMDEF;
END_VAR

  if (station > 32) then
    station := 32;
  end_if;	  

  retcode := #OnlineStation[station];

// ****************************************************************** 
// ********  For Can Communication with more Cpu's ****************** 
// ****************************************************************** 

  if(station = 1) then               // Stationnumber of Lasal Text
    retcode^.typ     := ET_COM_CAN1;    
    retcode^.adress  := 1;           // Stationnumber of CPU    
  elsif(station = 2) then            
    retcode^.typ     := ET_COM_CAN1;    
    retcode^.adress  := 2;            
  elsif(station = 3) then            
    retcode^.typ     := ET_COM_CAN1;    
    retcode^.adress  := 3;            
  elsif(station = 4) then            
    retcode^.typ     := ET_COM_CAN1;    
    retcode^.adress  := 4;            
  elsif(station = 5) then            
    retcode^.typ     := ET_COM_CAN1;    
    retcode^.adress  := 5;            
  end_if;

// ****************************************************************** 
// ****************************************************************** 
// ****************************************************************** 

END_FUNCTION // _ET_RunTime::GetCOMDEF
FUNCTION  _ET_RunTime::PLC_LogIn
VAR_INPUT
	station		: UINT;
END_VAR
VAR_OUTPUT
	retcode		: BOOL;
END_VAR
VAR
    cd          : ^ET_COMDEF;
    state       : UINT;
	CallBack    : CallBack;
END_VAR

  cd := GetCOMDEF(station);
  if(cd^.login = ET_LOGIN_INIT) then
    cd^.login := ET_LOGIN_FALSE; 
    state := LOGIN(cd$^Comdef);
    if state = 0 then
	  if OPS.uiLoaderVersion$UINT >= 16#0202 then	  
        CallBack.ptr      := #irq_PLC2()$^USINT;
		CallBack.pComdata := cd^.handle$^Comdata;	  
		CallBack.pThis    := this$^UINT;  
		INSTALLCALLBACK(#CallBack);
	  end_if;
	  cd^.login := ET_LOGIN_TRUE;
    end_if; 
  end_if;

  retcode := FALSE; 
  if(cd^.login = ET_LOGIN_TRUE) then
    retcode := TRUE; 
  end_if; 

END_FUNCTION // _ET_RunTime::PLC_LogIn
FUNCTION  _ET_RunTime::AddReflist
VAR_INPUT
	varno       : UINT;
	station     : UINT; 
END_VAR
VAR_OUTPUT
	retcode		: BOOL;
END_VAR
VAR
  st            : UDINT;
  reg           : typ_lslcommregdata;
  ps            : ^ET_SYMBOL;
  pv            : ^ET_VARINFO;  
  cd            : ^ET_COMDEF; 
END_VAR

  retcode := FALSE;

  if(varno < Symboltable.no) then    
    ps := Symboltable.ptr + varno * sizeof(ET_SYMBOL);

    if(ps^.id.id <> 0) then
      pv := VarList.ptr + varno * sizeof(ET_VARINFO);  
      if(ps^.sent = FALSE) then
        cd := GetCOMDEF(station); 
        if(cd^.login = ET_LOGIN_TRUE) then
      
          reg.id        := ps^.id.id;
          reg.channel   := 1;
          reg.ftime     := pv^.refreshtime; 
          reg.varpos    := GetReflistItem(station) + 1000; 
          reg.varlistid := varno;
		    
          if(ps^.varobj = FALSE) then
          //  st := SYSMAE_RegisterVar(#reg$USINT, cd);  // oldcom
            st := 1;        
		  else
          //  st := SYSMAE_RegisterObj(#reg$USINT, cd);   // oldcom
            st := 0;
		    TXUPD(#reg$LsLcommregdata, cd$^COMDEF);  // newcom
		  end_if;	
	
          if(st = 0) then
            ps^.sent           := TRUE; 
			ps^.reflistentryno := reg.varpos;  
            retcode            := TRUE;
		    IncReflistItem(station); 
            StartStopRefresh(cd$^Comdef, GetReflistItem(station), 1);  // newcom
		  end_if;
        end_if;
      end_if;  
    end_if; 
  end_if; 

END_FUNCTION // _ET_RunTime::AddReflist

FUNCTION  _ET_RunTime::DeletReflist
VAR
  no       : UINT;
  ps       : ^ET_SYMBOL;
  cd       : ^ET_COMDEF; 
END_VAR


  no := 33; 
  while no do
    no -= 1;
    cd := GetCOMDEF(no); 
    if(cd^.login = ET_LOGIN_TRUE) then
       //SYSMAE_DeleteQueue(0, cd); //oldcom
       StartStopRefresh(cd$^Comdef, 0, 1);  
	end_if; 
	DelReflistItem(no);  // Anzahl der Reflisteinträge rücksetzen 
	//no -= 1; 
  end_while; 

  no := Symboltable.no;
  ps := Symboltable.ptr; 
  while no do
    ps^.valid := FALSE;
    ps^.sent  := FALSE;
	ps += sizeof(ET_SYMBOL);
	no -= 1;
  end_while;

END_FUNCTION // _ET_RunTime::DeletReflist
FUNCTION GLOBAL _ET_RunTime::setpoiofET
VAR_INPUT
	p_display		: ^_DISPLAYDUMMY;
	p_leds		: ^_LEDS_DATA;
	p_keys		: ^_KEYS_DATA;
	p_terminalinfo		: ^_TERMINAL_INFO;
END_VAR

  PtDisplay      := p_display;
  PtTerminalInfo := p_terminalinfo;
  PtKeys		 := p_keys;
  PtLeds		 := p_leds;

  PlcIsReady     := TRUE; 

END_FUNCTION //GLOBAL _ET_RunTime::setpoiofET
//[#ENGLISH]
// The 'NewInst'-method is used to implement class-specific
// commands.
// This method can provide a class interface besides the
// implemented class-methods. This interface will be used, when
// working with interpreter code, or for remote calls to an
// object.
// Define the commands in the method editor, LASAL will create
// a private data type with the command-enums. 'NewInst' will
// typically contain a CASE-statement to evaluate each of these
// commands. It has to return either READY, BUSY, ERROR or
// ERROR_BUSY to indicate, if the command was processed or if
// it is still processed (i.e. a movement) or if an error occured.
// However, 'NewInst' is just called once (per command) to
// initialize an operation. Eventually 'GetState' or 'Kill' are
// called later on.
// The default implementation of 'NewInst' simply does nothing.
// So 'NewInst' can be called for each server.
//[>pPara]2 byte command enum, up to 80 bytes of parameter data
//[>pResult]result data, length is buffer length+sizeof(UINT)
//[<ret_code]indicates if operation is successfully completed
FUNCTION VIRTUAL GLOBAL _ET_RunTime::Terminal::NewInst
VAR_INPUT
	pPara		: ^CmdStruct;
	pResult		: ^results;
END_VAR
VAR_OUTPUT
	ret_code		: iprStates;
END_VAR
VAR
    inPara : ^_ET_HW;
END_VAR

  inPara := PPara$^_ET_HW;

  CASE (inPara^.cmd) OF
  TERMINAL_PTR:
                setpoiofET(inPara^.para[0]$^_DISPLAYDUMMY
				          ,inPara^.para[1]$^_LEDS_DATA
						  ,inPara^.para[2]$^_KEYS_DATA
						  ,inPara^.para[3]$^_TERMINAL_INFO);
//                setpoiofET(p_display, p_leds, p_keys, p_terminalinfo);
  KEY_NEW:
                keynew(inPara^.para[0]);
  KEY_GONE:
                keygone(inPara^.para[0]);
  ELSE
     ret_code := ERROR;
  END_CASE;

END_FUNCTION //VIRTUAL GLOBAL _ET_RunTime::Terminal::NewInst
FUNCTION GLOBAL _ET_RunTime::RefreshIRQ
VAR_INPUT
	refno	: UDINT;
	pt		: ^USINT;
END_VAR
VAR
  pv        : ^ET_VARINFO;
  ps        : ^ET_SYMBOL;
  pdest     : ^USINT;
  size      : UINT;
  varno     : UINT;
END_VAR


  // refno ... varno = symboltableindex (wenn nicht gibt's totenköpfe) 
  // pt ...... --> to data
  
  // ********* Vorsicht Interupt *********
  
  varno := TO_UINT(refno); // spezialtrick otto  

(* soog
  varno := 0; 
  size  := Symboltable.no; 
  ps    := Symboltable.ptr; 
  while size do
    size -= 1;
	varno += 1;  
    if(ps^.reflistentryno = refno) then
	  size := 0;
	  varno -= 1; 
    end_if; 
    ps += sizeof(_SYMBOL); 
  end_while; 
soog *)

  if(varno < Varlist.no) then
    ps := Symboltable.ptr + varno * sizeof(ET_SYMBOL);    
    if(ps^.offset <> 16#FFFF) then
      pdest := Symboltable.pdata + ps^.offset; 
      pv    := Varlist.ptr + varno * sizeof(ET_VARINFO);    
	  size  := GetSize(pv);
      _memcpy(pdest, pt, size);
	  ps^.valid := TRUE;
	end_if;
  end_if; 
  

END_FUNCTION //GLOBAL _ET_RunTime::RefreshIRQ

FUNCTION _ET_RunTime::GetAdressOBJ
VAR_INPUT
  pt 	: ^CHAR;
  pid 	: ^UDINT;
  pch 	: ^ET_COMDEF;
END_VAR
VAR_OUTPUT
  retcode 	: BOOL;
END_VAR
VAR
    result      : ^USINT;
    len         : UINT;
END_VAR
  
  retcode := FALSE;

  if(pch^.handle <> 0) then

    len := TO_UINT(_strlen(pt)+1);
    if (TXCOMMAND(TO_UDINT(I_GET_OBJ), len, pt, pch$^Comdef, #result$UDINT) = READY) then
      retcode := TRUE;
      result += 2;
      pid^ := result$^UDINT^;  
    end_if;
  end_if;

END_FUNCTION // _ET_RunTime::GetAdressOBJ

FUNCTION  _ET_RunTime::DelReflistItem
VAR_INPUT
	station		: UINT;
END_VAR

  if(station > 32) then
    station := 32; 
  end_if; 

  RefListItem[station] := 0;   

END_FUNCTION // _ET_RunTime::DelReflistItem

FUNCTION  _ET_RunTime::GetReflistItem
VAR_INPUT
	station		: UINT;
END_VAR
VAR_OUTPUT
    retcode     : UINT;
END_VAR

  if(station > 32) then
    station := 32; 
  end_if; 

  retcode := RefListItem[station]; 

END_FUNCTION // _ET_RunTime::GetReflistItem

FUNCTION  _ET_RunTime::IncReflistItem
VAR_INPUT
	station		: UINT;
END_VAR

  if(station > 32) then
    station := 32; 
  end_if; 

  RefListItem[station] += 1; 

END_FUNCTION // _ET_RunTime::IncReflistItem
//[#ENGLISH]
// ***************************************************************************
// ***************            User Interface LED Control      ****************
// ***************************************************************************
// *******                                                              ******
// *******   Variable input LED number = LED number                     ******
// *******                  LED Mode   = 0 = Off                        ******
// *******                               1 = ON                         ******
// *******                               2 = blinking                   ******
FUNCTION GLOBAL _ET_RunTime::Control_Led
VAR_INPUT
	Led_Number		: DINT;
	Led_Mode		: DINT;
END_VAR
VAR
	OP1X : ET_VARLABEL;
	OP2X : ET_VARLABEL;
END_VAR

  OP1X.state := VLS_CONSTANT;
  OP1X.value := Led_Number;
  OP2X.state := VLS_CONSTANT;
  OP2X.Value := Led_Mode; 

  CmdLed(op1 := #OP1X, op2 := #OP2X);

END_FUNCTION //GLOBAL _ET_RunTime::Control_Led
//[#ENGLISH]
// ***************************************************************************
// ***************       User Interface Picture Control       ****************
// ***************************************************************************
// *******                                                              ******
// *******   Variable input Pic_number = Picture number                 ******
// *******                           0 = Global Picture !!!             ******
// *******                                                              ******
// *******                                                              ******
FUNCTION GLOBAL _ET_RunTime::Control_Pic
VAR_INPUT
    Pic_Number       : DINT;
END_VAR
VAR
	OP1X : ET_VARLABEL;
END_VAR

  OP1X.state := VLS_CONSTANT;
  OP1X.value := Pic_Number;

  CmdChaPic(op := #OP1X);

END_FUNCTION //GLOBAL _ET_RunTime::Control_Pic
//[#ENGLISH]
// ***************************************************************************
// ***************       User Interface Language Control      ****************
// ***************************************************************************
// *******                                                              ******
// *******   Variable input Lan_Number = Language number                ******
// *******                                                              ******
// *******                                                              ******
// *******                                                              ******
FUNCTION GLOBAL _ET_RunTime::Control_Lan
VAR_INPUT
    Lan_Number       : DINT;
END_VAR
VAR
	OP1X : ET_Varlabel;
END_VAR

  OP1X.state := VLS_CONSTANT;
  OP1X.value := Lan_Number;

  CmdLan(op := #OP1X);

END_FUNCTION //GLOBAL _ET_RunTime::Control_Lan
//[#ENGLISH]
// ***************************************************************************
// ***************      User Interface Increment Variable     ****************
// ***************************************************************************
// *******                                                              ******
// *******   Variable input Var_Number = Variable number                ******
// *******                                                              ******
// *******                                                              ******
// *******                                                              ******
FUNCTION GLOBAL _ET_RunTime::Control_Inc
VAR_INPUT
    Var_Number       : DINT;
END_VAR
VAR
	OP1X : ET_Varlabel;
END_VAR

  OP1X.state := VLS_VARIABLE;
  OP1X.value := Var_Number;

  CmdInc(op := #OP1X, 1);

END_FUNCTION //GLOBAL _ET_RunTime::Control_Inc
//[#ENGLISH]
// ***************************************************************************
// ***************      User Interface Decrement Variable     ****************
// ***************************************************************************
// *******                                                              ******
// *******   Variable input Var_Number = Variable number                ******
// *******                       Value = Value of decrement             ******
// *******                                                              ******
// *******
FUNCTION GLOBAL _ET_RunTime::Control_Dec
VAR_INPUT
    Var_Number       : DINT;
END_VAR
VAR
	OP1X : ET_Varlabel;
END_VAR

  OP1X.state := VLS_VARIABLE;
  OP1X.value := Var_Number;

  CmdDec(op := #OP1X, 1);

END_FUNCTION //GLOBAL _ET_RunTime::Control_Dec
//[#ENGLISH]
// ***************************************************************************
// *****************      User Interface Return Picture     ******************
// ***************************************************************************
// *******                                                              ******
// *******                                                              ******
// *******                                                              ******
// *******                                                              ******
// *******
FUNCTION GLOBAL _ET_RunTime::Control_RetPic

  CmdRetPic();

END_FUNCTION //GLOBAL _ET_RunTime::Control_RetPic
//[#ENGLISH]
// ***************************************************************************
// *************      User Interface add value to Variable     ***************
// ***************************************************************************
// *******                                                              ******
// *******   Variable input Var_Number = Variable number                ******
// *******                       Value = Value of add                   ******
// *******                                                              ******
// *******                                                              ******
FUNCTION GLOBAL _ET_RunTime::Control_Add
VAR_INPUT
	Var_Number		: DINT;
	Value    		: DINT;
END_VAR
VAR
	OP1X : ET_Varlabel;
	OP2X : ET_Varlabel;
END_VAR

  OP1X.state := VLS_VARIABLE;
  OP1X.value := Var_Number;
  OP2X.state := VLS_CONSTANT;
  OP2X.Value := Value; 

  CmdAdd(op1 := #OP1X, op2 := #OP2X);

END_FUNCTION //GLOBAL _ET_RunTime::Control_Add
//[#ENGLISH]
// ***************************************************************************
// **********      User Interface subtract value of Variable     *************
// ***************************************************************************
// *******                                                              ******
// *******   Variable input Var_Number = Variable number                ******
// *******                       Value = Value of subtract              ******
// *******                                                              ******
// *******                                                              ******
FUNCTION GLOBAL _ET_RunTime::Control_Sub
VAR_INPUT
	Var_Number		: DINT;
	Value    		: DINT;
END_VAR
VAR
	OP1X : ET_Varlabel;
	OP2X : ET_Varlabel;
END_VAR

  OP1X.state := VLS_VARIABLE;
  OP1X.value := Var_Number;
  OP2X.state := VLS_CONSTANT;
  OP2X.Value := Value; 

  CmdSub(op1 := #OP1X, op2 := #OP2X);

END_FUNCTION //GLOBAL _ET_RunTime::Control_Sub
//[#ENGLISH]
// ***************************************************************************
// ************      User Interface set variable to a value      *************
// ***************************************************************************
// *******                                                              ******
// *******   Variable input Var_Number = Variable number                ******
// *******                       Value = Value to set variable          ******
// *******                                                              ******
// *******                                                              ******
FUNCTION GLOBAL _ET_RunTime::Control_Set
VAR_INPUT
	Var_Number		: DINT;
	Value    		: DINT;
END_VAR
VAR
	OP1X : ET_Varlabel;
	OP2X : ET_Varlabel;
END_VAR

  OP1X.state := VLS_VARIABLE;
  OP1X.value := Var_Number;
  OP2X.state := VLS_CONSTANT;
  OP2X.Value := Value; 

  CmdSet(op1 := #OP1X, op2 := #OP2X);

END_FUNCTION //GLOBAL _ET_RunTime::Control_Set
//[#ENGLISH]
// ***************************************************************************
// *************      User Interface for toggle a variable       *************
// ***************************************************************************
// *******                                                              ******
// *******   Variable input Var_Number = Variable number                ******
// *******                       Value = Value to set variable          ******
// *******                                                              ******
// *******                                                              ******
FUNCTION GLOBAL _ET_RunTime::Control_Toggle
VAR_INPUT
    Var_Number       : DINT;
END_VAR
VAR
	OP1X : ET_Varlabel;
END_VAR


  OP1X.state := VLS_VARIABLE;
  OP1X.value := Var_Number;

  CmdToggle(op := #OP1X);

END_FUNCTION //GLOBAL _ET_RunTime::Control_Toggle
//[#ENGLISH]
// ***************************************************************************
// **************      User Interface for edit a variable       **************
// ***************************************************************************
// *******                                                              ******
// *******   Variable input Var_Number = Variable number                ******
// *******                           0 = the first variable             ******
// *******                               of the picture                 ******
// *******                                                              ******
FUNCTION GLOBAL _ET_RunTime::Control_EditIO
VAR_INPUT
    Var_Number       : UINT; 
END_VAR
VAR_OUTPUT
	retcode		: BOOL;
END_VAR

  if(Var_Number < Picture.refinput.no) then
    OpenEditor(Var_Number);   // open new editor
  end_if;

  retcode := TRUE; 

END_FUNCTION //GLOBAL _ET_RunTime::EditIO

// ******************************************************************
// ***********     User Interface to set negativ sign    ************
// ******************************************************************
// *****                                                        *****
// *****                                                        *****
// *****                                                        *****
FUNCTION GLOBAL _ET_RunTime::Control_VarNeg

  if(Cursor.active = TRUE) then
    if (Picture.editor.variable.info.vartyp = ET_WORD) |
	   (Picture.editor.variable.info.vartyp = ET_DWORD) |
	   (Picture.editor.variable.info.vartyp = ET_BYTE) then
      Picture.editor.io.io_format := IF_NUMERIC;
      Scancode := ET_MINUS;
      RunEditor(#Picture.editor);
    end_if;
  end_if;

END_FUNCTION // _ET_RunTime::Control_VarNeg
// ******************************************************************
// ***********     User Interface to set positiv sign     ***********
// ******************************************************************
// *****                                                        *****
// *****                                                        *****
// *****                                                        *****
FUNCTION GLOBAL _ET_RunTime::Control_VarPos

  if(Cursor.active = TRUE) then
    if (Picture.editor.variable.info.vartyp = ET_WORD) |
	   (Picture.editor.variable.info.vartyp = ET_DWORD) |
	   (Picture.editor.variable.info.vartyp = ET_BYTE) then
      Picture.editor.io.io_format := IF_NUMERIC;
      Scancode := ET_PLUS;
      RunEditor(#Picture.editor);
    end_if;
  end_if;

END_FUNCTION // _ET_RunTime::Control_VarPos





FUNCTION _ET_RunTime::get_TXTBUF
VAR_INPUT
	src		: ^ET_TXTBUF;
	no		: UINT;
END_VAR
VAR_OUTPUT
	retcode		: ^CHAR;
END_VAR
VAR
    hp      : ^UINT; 
END_VAR
  
  if(no >= src^.no) then
    retcode := #src^.dummy[0];
  else
    hp      := src^.ptr + no * sizeof(UINT); 
    retcode := src^.ptr + hp^;
  end_if;

END_FUNCTION //_ET_RunTime::get_TXTBUF

FUNCTION _ET_RunTime::load_TXTBUF
VAR_INPUT
	dest	: ^ET_TXTBUF;
	src		: ^VOID;
END_VAR
VAR_OUTPUT
	retcode		: UDINT;
END_VAR
  // src --> Pointer auf Tabelle von Robert
  // retcode --> Größe eines TXTBuffers im Robert Format

  // [2] ......... size (incl. sizeof(size))
  // [2] ......... anz texte
  // [anz*2] ..... offsetliste beginnend mit ersten offset
  // [?........... beginn erster text

#pragma warning(disable:172); // HubChr v1.23
  ET_Init::init_TXTBUF(dest);
#pragma warning(default:172); // HubChr v1.23

  retcode  := src$^UINT^;     // size auslesen
  src      += 2; 

  dest^.no := src$^UINT^;     // anzahl texte auslesen
  src      += 2;
  
  if(dest^.no > 0) then
  //#GR
    dest^.ptr := src$^UINT;
  end_if; 


END_FUNCTION //_ET_RunTime::load_TXTBUF

FUNCTION _ET_RunTime::jump_TXTBUF
VAR_INPUT
	src		: ^VOID;
END_VAR
VAR_OUTPUT
	retcode		: UDINT;
END_VAR

  retcode := src$^UINT^;

END_FUNCTION //_ET_RunTime::jump_TXTBUF

FUNCTION _ET_RunTime::load_SPRACHE
VAR_INPUT
	dest		: ^ET_SPRACHE;
	src		    : ^VOID;
	sprache	: UINT;
END_VAR
VAR_OUTPUT
	retcode		: UDINT;
END_VAR
VAR
  no   : UINT; 
  i    : UINT; 
  size : UDINT; 
END_VAR

  // [2] ... anzahl der sprachen
  // [ ..... sprachen

#pragma warning(disable:172); // HubChr v1.23
  ET_Init::init_SPRACHE(dest); 
#pragma warning(default:172); // HubChr v1.23

  no      := src$^UINT^;   // anzahl der vorhandenen sprachen
  retcode := 2; 

  if(no > 0) then
    src += 2; 
    if(sprache >= no) then
      sprache := 0; 
    end_if; 

    Language.Write(sprache);

    no -= 1; 
	for i:=0 to no do
	  if(i = sprache) then
        size := load_TXTBUF(#dest^.txtbuf ,src);
      else
	    size := jump_TXTBUF(src); 
      end_if; 

	  retcode += size; 
	  src     += size; 
    end_for; 
  end_if; 

END_FUNCTION //_ET_RunTime::load_SPRACHE

FUNCTION _ET_RunTime::get_SPRACHE
VAR_INPUT
	src		: ^ET_SPRACHE;
	no		: UINT;
END_VAR
VAR_OUTPUT
	retcode		: ^CHAR;
END_VAR

  retcode := get_TXTBUF(#src^.txtbuf, no);

END_FUNCTION //_ET_RunTime::get_SPRACHE

FUNCTION _ET_RunTime::load_REFTXT
VAR_INPUT
	dst		: ^ET_REFTXT;
	src		: ^VOID;
END_VAR
VAR_OUTPUT
	retcode		: UDINT;
END_VAR

  dst^.no  := src$^UINT^;
  dst^.ptr := src$^ET_BTX + 2; //#GR
  retcode  := 2 + dst^.no * sizeof(ET_BTX); 

END_FUNCTION //_ET_RunTime::load_REFTXT

FUNCTION _ET_RunTime::load_PICTURE
VAR_INPUT
	dst		: ^ET_PICTURE;
	no		: UINT;
	lan		: UINT;
END_VAR
VAR_OUTPUT
	retcode		: BOOL;
END_VAR
VAR
  pudi   : ^UDINT; 
  offset : UDINT; 
  src    : ^VOID;
END_VAR 

  src     := #tab_PIC00() + 4;
  retcode := FALSE; 

  if(no < src$^UINT^) then
    pudi    := src + sizeof(UINT) + no * sizeof(UDINT); 
    offset  := pudi^;

	if(offset <> 16#FFFFFFFF) then 
      src += offset; 
      src += load_REFTXT(#dst^.reftxt, src); 
      src += load_SPRACHE(#dst^.sprache, src, lan);
      src += load_REFOUTPUT(#dst^.refoutput, src);
      src += load_REFINPUT(#dst^.refinput, src); 
      src += load_REFKEY(#dst^.prefkey, src); 
	  dst^.picno := no; 
      retcode := TRUE; 
    end_if;
  end_if;

END_FUNCTION //_ET_RunTime::load_PICTURE

FUNCTION _ET_RunTime::load_REFOUTPUT
VAR_INPUT
	dst		: ^ET_REFOUTPUT;
	src		: ^VOID;
END_VAR
VAR_OUTPUT
	retcode		: UDINT;
END_VAR

  dst^.no  := src$^UINT^;
  dst^.ptr := src$^ET_IO + 2; //#GR
  retcode  := 2 + dst^.no * (sizeof(ET_IO));

END_FUNCTION //_ET_RunTime::load_REFOUTPUT

FUNCTION _ET_RunTime::load_REFINPUT
VAR_INPUT
	dst		: ^ET_REFINPUT;
	src		: ^VOID;
END_VAR
VAR_OUTPUT
	retcode		: UDINT;
END_VAR

  dst^.no  := src$^UINT^;
  dst^.ptr := src$^ET_IO + 2; //#GR
  retcode  := 2 + dst^.no * (sizeof(ET_IO));

END_FUNCTION //_ET_RunTime::load_REFINPUT

FUNCTION _ET_RunTime::load_REFKEY
VAR_INPUT
	pdst		: ^ET_PREFKEY;
	src		: ^VOID;
END_VAR
VAR_OUTPUT
	retcode		: UDINT;
END_VAR
VAR
  no    : UINT;
  anz	: UINT;
  i		: USINT;
  pu	: ^UINT;
  pb	: ^USINT;
END_VAR
  
  pdst^ := src$ET_PREFKEY; //#GR 
  no := src$^UINT^;

  retcode := 2 + no * 2;
  pu := src + 2;
  anz := 0;
  if (no > 0) then
    no -= 1;    
    for i:=0 to no do
      if (pu^ <> 16#FFFF) then
	    anz += 1;
      end_if;
      pu += 2;
	end_for;
   end_if;  
  
  if(anz > 0) then
    for i:=1 to anz do
      pb := src + retcode;
      retcode += to_uint(pb^) * sizeof(ET_INTERZLE) +1;
	end_for;
  end_if;

END_FUNCTION //_ET_RunTime::load_REFKEY

FUNCTION _ET_RunTime::dtoa
VAR_INPUT
	pt		: ^CHAR;
	value		: DINT;
	format		: HINT;
END_VAR
VAR
  tmp    : DINT; 
  hp     : ^CHAR; 
  pd     : UINT; 
  dig    : UINT; 
  h      : UINT;
END_VAR

  // ********** Wandelt DINT in ASCII um **********

  // xxxx xxx0 0000 0000
  //        .. .... ****  no of digits
  //        .. **** ....  position decimalpoint
  //        .* .... ....  hasty zeros   
  //        *. .... ....  descendant zeros
  //       *.. .... ....  space instead of plus/minus


 // ********** Erklährung Format **********

 // 16#0524$HINT
 //     |||........   Anzahl der Ausgabestellen
 //     ||.........   Position Dezimalpunkt
 //     |..........   0 ohne Vornullen   
 //                   1 mit Vornullen 
 //                   4 Vorzeichen u. ohne Vornullen   
 //                   5 Vorzeicehn u. Vornullen
 //      Gillt für 4 u 5 -> Bei positiver Zahl wird Space und 
 //      bei negativer Zahl wird ein Minus ausgegeben!!!   

  dig := (format and 16#0F);
  hp  := pt + dig; 
  tmp := value; 
  pd  := (format shr 4) and 16#0F;

  
  if(value < 0) then  // look for negative value
	hp    += 1;    
    value := -value;
    pt^   := '-';
  elsif(format and 16#0400) then
	hp    += 1;    
    pt^   := ' ';
  end_if; 	 

  if(format and 16#0200) then   // delete descendant zeros
    h := pd; 
	while(h) do
	  h -= 1; 
	  if((value mod 10) = 0) then
	    value := value / 10; 
		pd -= 1; 
      else
	    h := 0; 
      end_if; 

	end_while; 
  end_if; 
  
  if(pd <> 0) then    // look for dezimalpoint
    hp += 1;
  end_if; 

  hp^ := 0;           // final 0 (ascii-0-string)
  hp  -= 1;   

  repeat
    hp^   := '0' + TO_USINT(value mod 10); 
	hp    -= 1; 
	pd    -= 1; 
	dig   -= 1; 
	if(pd = 0) then
	  hp^ := '.';
	  hp -= 1; 
    end_if; 

    value := value / 10; 
    
    if((dig = 0) & (value <> 0)) then
	  // value too big 
	  pt^   := '?'; 
	  value := 0; 
	end_if; 
  until(value = 0) end_repeat; 
 
 
  if(dig > 0) then    // fill with space or hasty zero
	repeat
      if((format and 16#100)|(pd$INT >= 0)) then
        hp^ := '0'; 
      else
	    hp^ := ' ';
      end_if; 
      pd -= 1;
	  hp -= 1;
      if(pd = 0) then
	    hp^ := '.';
	    hp -= 1; 
      end_if; 
	  dig -= 1; 
	until(dig = 0) end_repeat; 
  end_if; 

END_FUNCTION //_ET_RunTime::dtoa
(*
// ************************ old com *********************
        
FUNCTION GLOBAL __cdecl shut_down  
VAR
  batman     : BOOL;
END_VAR

  batman := FALSE;  

END_FUNCTION //GLOBAL shut_down
*)
FUNCTION __cdecl _ET_RunTime::irq_PLC 
VAR_INPUT
#pragma warning(disable:73)
  cd         : ^ET_COMDEF;  
#pragma warning(default:73)
  pd         : ^UDINT;
END_VAR
VAR
  refno      : UDINT;
  // cd         : ^_COMDEF;
  // vl         : ET_Variable;
END_VAR


  // cd .... --> to _COMDEF
  // pd .... --> 4 byte varlistid (typ_typcommregdata.varlistid), 
  //             2 byte refno, 
  //             data


  refno := pd$^UDINT^; 
  pVarList^.RefreshIRQ(refno, pd$^USINT+6);
	

  // VORRAUSSETZUNG: 
  // globale variable pVarList beinhaltet einen pointer auf das 
  // objekt Varlist. dieser pointer wird im ET_Varlist::Init() 
  // mit this initialisiert. 
  // ist dies nicht der fall so gibt's totenköpfe !!!
  // (an jedn programmiera stoets dabei d'hor auf, oba geht ned anders) 



END_FUNCTION //_ET_RunTime::irq_PLC 
//[#DEUTSCH]
//Neu Funktion weil this pointer breits von Callback übergeben wird.
FUNCTION __cdecl _ET_RunTime::irq_PLC2
VAR_INPUT
#pragma warning(disable:73)
  cd         : ^ET_COMDEF;  
#pragma warning(default:73)
  pd         : ^UDINT;
END_VAR
VAR
  refno      : UDINT;
  // cd         : ^_COMDEF;
  // vl         : ET_Variable;
END_VAR

  // cd .... --> to _COMDEF
  // pd .... --> 4 byte varlistid (typ_typcommregdata.varlistid), 
  //             2 byte refno, 
  //             data


  refno := pd$^UDINT^; 
  RefreshIRQ(refno, pd$^USINT+6);
	

END_FUNCTION // _ET_RunTime::irq_PLC2
FUNCTION _ET_RunTime::MyMemory
VAR_INPUT
  dest    : ^_PVOIDL; 
  size    : UDINT; 
END_VAR
VAR_OUTPUT
  retcode : BOOL; 
END_VAR
VAR 
  ptr     : _PVOIDL; 
END_VAR

  retcode := TRUE; 

  if(size > 0) then
    if(dest^ = NIL) then
      ptr := OS_SSR_Malloc(size)$^usint; //#GR
      if(ptr <> NIL) then
        dest^   := ptr; 
        retcode := TRUE;
      end_if; 
    else
      ptr := OS_SSR_Realloc(dest^, size)$^USINT; //#GR
      if(ptr <> NIL) then
        dest^   := ptr;
	      retcode := TRUE; 
      end_if; 
    end_if; 
  else
    retcode := TRUE; 
    if(dest^ <> 0) then
      OS_SSR_Free(dest^);
      dest^ := NIL; 
    end_if; 
  end_if; 
END_FUNCTION  //_ET_RunTime::

FUNCTION _ET_RunTime::Lasal_To_SYSTIME
VAR_INPUT
	ptr		: ^SYSTIME;
	src		: DINT;
END_VAR
VAR
  tmp       : UDINT; 
END_VAR

  tmp          := src$UDINT; 
  ptr^.wHour   := TO_USINT((tmp shr 24) and 16#FF);
  ptr^.wMinute := TO_USINT((tmp shr 16) and 16#FF);
  ptr^.wSecond := TO_USINT((tmp shr  8) and 16#FF);

END_FUNCTION //_ET_RunTime::Lasal_To_SYSTIME

FUNCTION _ET_RunTime::Lasal_To_SYSDATE
VAR_INPUT
	ptr		: ^SYSDATE;
	src		: DINT;
END_VAR
VAR
  tmp       : UDINT;
END_VAR

  tmp             := src$UDINT;
  ptr^.wDay       := TO_USINT((tmp shr  4) and 16#00FF);
  ptr^.wMonth     := TO_USINT((tmp shr 12) and 16#000F); 
  ptr^.wYear      := TO_UINT((tmp  shr 16) and 16#FFFF);  
  ptr^.wDayOfWeek := TO_USINT(((tmp) and 16#0F) mod 7);


END_FUNCTION //_ET_RunTime::Lasal_To_SYSDATE
FUNCTION _ET_RunTime::SYSTIME_To_Lasal
VAR_INPUT
	src		: ^DINT;
	ptr		: ^SYSTIME;
END_VAR
VAR
    tmp     : UDINT;
END_VAR


//  tmp  := src$UDINT;  
  tmp  := ptr^.wHour and 16#FF; 
  tmp  := (tmp shl 8) or (ptr^.wMinute and 16#FF); 
  tmp  := (tmp shl 8) or (ptr^.wSecond and 16#FF);
  tmp  := tmp shl 8; 
  src^ := tmp$DINT;

END_FUNCTION //_ET_RunTime::SYSTIME_To_Lasal

FUNCTION _ET_RunTime::SYSDATE_To_Lasal
VAR_INPUT
	src		: ^DINT;
	ptr		: ^SYSDATE;
END_VAR
VAR
  tmp       : UDINT;
END_VAR

//  tmp  := src$UDINT; 
  tmp  := TO_UDINT(ptr^.wYear); 
  tmp  := (tmp shl 4) or (ptr^.wMonth     and 16#0F); 
  tmp  := (tmp shl 8) or (ptr^.wDay       and 16#FF);
  tmp  := (tmp shl 4) or (ptr^.wDayOfWeek and 16#0F); 
  src^ := tmp$DINT;

END_FUNCTION //_ET_RunTime::SYSDATE_To_Lasal
FUNCTION GLOBAL _ET_RunTime::GetLasalId
VAR_INPUT
	varno		: DINT;
END_VAR
VAR_OUTPUT
	retcode	: UDINT;
END_VAR
VAR
  ptr : ^ET_SYMBOL; 
end_var

 retcode  := 0; 
 if(varno < Symboltable.no) then
   ptr     := Symboltable.ptr + varno * sizeof(ET_SYMBOL); 
	 retcode := ptr^.id.id; 
 end_if;  

END_FUNCTION //GLOBAL _ET_RunTime::GetLasalId
FUNCTION GLOBAL _ET_RunTime::LenLabelPart
VAR_INPUT
	label		: ^char;
END_VAR
VAR_OUTPUT
	retcode		: UINT;
END_VAR

  retcode := 0; 

  while 1 do
    case label^ of
		  0  ,  
			46 , 
      92 : return;  
    end_case; 

		retcode += 1; 
		label   += 1; 
	end_while; 

END_FUNCTION
FUNCTION GLOBAL _ET_RunTime::GetIDVarNo
VAR_INPUT
	ID		: UDINT;
END_VAR
VAR_OUTPUT
	VarNo	:  UINT;
END_VAR
VAR
  no  	:  UINT; 
	ptr 	: ^ET_SYMBOL; 
END_VAR

	 no 			:= 0;
	 VarNo		:= 16#FFFF;	 

	 // on last Server
	 ptr     	:= Symboltable.ptr; //+ no * sizeof(ET_SYMBOL); 
	 
	 IF ( ID <> NIL ) THEN

	   WHILE no < Varlist.no DO  
			 IF ID = ptr^.id.id THEN
			 		VarNo := no;
					RETURN;
			 END_IF;
	 	 	 ptr += sizeof(ET_SYMBOL);
			 no  += 1;
		 END_WHILE;

	 END_IF;  


END_FUNCTION //GLOBAL _ET_RunTime::GetIDVarNo
(* 
// noch nicht fertig getestet
FUNCTION GLOBAL _ET_RunTime::GetVarNoSub
VAR_INPUT
	label		: ^char;
	scope		: UINT;
END_VAR
VAR_OUTPUT
	retcode		: UINT;
END_VAR
VAR
  no  : UINT; 
	ptr : ^ET_VARINFO; 
	pt  : ^char; 
	chr : char; 
	len : UINT; 
	pl	: ^USINT;
END_VAR

  retcode := scope; 
  no      := Varlist.no; 
	ptr     := VarList.ptr; 
// muss erst genauer geprüft werden
//  pl      := #VarList.txtbuf; 
	chr     := label^;
	len     := LenLabelPart(label);  

  if(len) then
    while(no) do  // suchen
	    if(ptr^.scope = scope) then // nur wenn scope passt
        if(pl^ = chr) THEN  // schnell suchen 
				  if((pl+len)^ = 0) then // nur wenn 0 string
            if(_MemCmp(pl, label, len) = 0) then  // gleicher labelteil
              retcode := GetVarNoSub(label + len + 1, no); // kinky recursiv !!
						  no := 1;   // schleife beenden
            end_if; 
          end_if; 
			  end_if; 
		  end_if; 
		  pl  += _StrLen(pt) + 1; // string ++
      ptr += sizeof(ET_VARINFO); // varinfo ++
	  no  -= 1; // no --
	  end_while; 
  end_if; 

END_FUNCTION //GLOBAL _ET_RunTime::GetVarNo

FUNCTION GLOBAL _ET_RunTime::GetVarNo
VAR_INPUT
	label		: ^char;
END_VAR
VAR_OUTPUT
	retcode		: UINT;
END_VAR

  retcode := GetVarNoSub(label, 16#FFFF); 

END_FUNCTION //GLOBAL _ET_RunTime::GetVarNo
*)




