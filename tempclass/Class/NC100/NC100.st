//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define DEVICE_ID_NC100 1014

#define NC100_ADDR_CYC_WRITE        16#03
#define NC100_ADDR_CYC_READ         16#03
#define NC100_ADDR_CYC_READ_LATCH   16#20
#define NC100_ADDR_INIT_MODULE      16#00

#define NC100_SDO_RESPONSE_TIMEOUT  SDIAS_SDO_TIMEOUT * 2

#define NC100_CFG1_SIZE             3
#define NC100_CFG2_OFFSET           16#10
#define NC100_CFG2_SIZE             14

#define NC100_NOENCODER             0
#define NC100_TTL_MODE              1
#define NC100_RS422_MODE            2

#define NC100_LATCH_BIT_MASK      2#101111

#define NC100_SUPPORT_ZPULS_LATCH               16#14 // FPGA V1.4 or greater
#define NC100_SUPPORT_ADDITIONAL_LATCH_VALUES   16#15 // FPGA V1.5 or greater
#define NC100_INVALID_VALUE       16#80000010$DINT
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "NC100"
	Revision           = "1.38"
	GUID               = "{74BA367D-5B94-47EF-A860-66330D4499F9}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\s-dias.ico"
	SharedCommandTable = "true"
	Objectsize         = "(598,120)"
	Comment            = "SDIAS Incremental Encoder Module which supports&#13;&#10;1x Incremental Encoder Input (TTL or RS422)&#13;&#10;4x Digital Out 24V 2A&#13;&#10;4x Digital In 24V">
	<Channels>
		<Server Name="IncPerMs" GUID="{3BDB81FE-44C5-4FE9-8454-2E531555D75A}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Increments per ms"/>
		<Server Name="Input1" GUID="{41318399-6FC9-4ABE-8207-5CD9736BDB54}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="digital Input (0=off, 1=on)"/>
		<Server Name="Input1Latched" GUID="{B86C2234-AE6F-4A5E-AF3D-BD20DEFC976E}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Requires FPGA Version 1.4 or higher&#13;&#10;&#13;&#10;1 = input has been latched (is reset when read() method is called)"/>
		<Server Name="Input2" GUID="{E76B0330-7BFA-4F34-967D-339F55AFEA14}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="digital Input (0=off, 1=on)"/>
		<Server Name="Input2Latched" GUID="{B94F3782-498B-4BDD-8F77-8AB70197A018}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Requires FPGA Version 1.4 or higher&#13;&#10;&#13;&#10;1 = input has been latched (is reset when read() method is called)"/>
		<Server Name="Input3" GUID="{75833C0E-CD95-493F-AD17-8F972B12BC96}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="digital Input (0=off, 1=on)"/>
		<Server Name="Input3Latched" GUID="{4814F004-14D2-4022-989F-2F21DEB878A2}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Requires FPGA Version 1.4 or higher&#13;&#10;&#13;&#10;1 = input has been latched (is reset when read() method is called)"/>
		<Server Name="Input4" GUID="{6AFDB9B1-12FF-433B-9C93-25C89B7AC489}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="digital Input (0=off, 1=on)"/>
		<Server Name="Input4Latched" GUID="{9DC73317-6506-4273-8140-117801A45E48}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Requires FPGA Version 1.4 or higher&#13;&#10;&#13;&#10;1 = input has been latched (is reset when read() method is called)"/>
		<Server Name="Output1" GUID="{BE29C543-5319-4943-B774-7507944DB24F}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="digital Output (0=off, 1=on)"/>
		<Server Name="Output2" GUID="{64EB257C-D269-4582-A50A-71AA621E9AF1}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="digital Output (0=off, 1=on)"/>
		<Server Name="Output3" GUID="{34A84869-771F-4B10-9245-5D2999CDFD45}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="digital Output (0=off, 1=on)"/>
		<Server Name="Output4" GUID="{EFDA3134-7131-4D99-8F32-9451390FD0F7}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="digital Output (0=off, 1=on)"/>
		<Server Name="Position" GUID="{DEB632CC-E392-4FBF-BABD-47F5BF78E0AA}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="incremental Encoder Position"/>
		<Server Name="PositionLatch" GUID="{259E197F-B55C-4405-A4B1-80050A046A5A}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="actual Latch-Value of the Incremental Encoder."/>
		<Server Name="PosLatchedInput1" GUID="{B0537D75-A8A6-4CCB-BEB8-00480AA55CB2}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Requires FPGA Version 1.5 or higher&#13;&#10;&#13;&#10;actual Latch-Value of the Incremental Encoder latched by the respective input."/>
		<Server Name="PosLatchedInput2" GUID="{9C77FC9D-7912-46E1-B22D-64460371A073}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Requires FPGA Version 1.5 or higher&#13;&#10;&#13;&#10;actual Latch-Value of the Incremental Encoder latched by the respective input."/>
		<Server Name="PosLatchedInput3" GUID="{863375DD-4041-43C2-A4E9-EF8D56693E47}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Requires FPGA Version 1.5 or higher&#13;&#10;&#13;&#10;actual Latch-Value of the Incremental Encoder latched by the respective input."/>
		<Server Name="PosLatchedInput4" GUID="{806DAA06-1013-4E2F-9F70-BDC5D7779F0B}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Requires FPGA Version 1.5 or higher&#13;&#10;&#13;&#10;actual Latch-Value of the Incremental Encoder latched by the respective input."/>
		<Server Name="PosLatchedZPuls" GUID="{E219D8BD-8705-466F-991E-D08C3BE6D264}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Requires FPGA Version 1.5 or higher&#13;&#10;&#13;&#10;actual Latch-Value of the Incremental Encoder latched by the respective input."/>
		<Server Name="Speed" GUID="{806C0772-1887-4B59-B6D5-87F06B236CB4}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="actual Speed [rpm]"/>
		<Server Name="VoltageOkEncoder" GUID="{095697F2-6343-4F23-9403-BEBF920A309A}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Voltage Supply for Incremental Encoder ok"/>
		<Server Name="VoltageOkOutput" GUID="{0AB63462-5FCC-45BA-94EC-E36A08F2D51D}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Voltage Supply for Output ok"/>
		<Server Name="ZPuls" GUID="{5EB630BC-45EE-4B50-BA7B-C867726C0471}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Zero Position"/>
		<Server Name="ZPulsLatched" GUID="{70FDC230-EC85-472C-87B2-9D22A81C1509}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Zero Position latched (is reset when read() method is called)"/>
		<Client Name="AdditionalLatchInfo" Required="false" Internal="false" DefValue="0" Comment="Requires FPGA Version 1.5 or higher&#13;&#10;&#13;&#10;0 ... Only one latched value for every latch configuration.&#13;&#10;1 ... Enables Latchpositions for each input (Input1-4 and Zero Pos)."/>
		<Client Name="EncCPR" Required="false" Internal="false" DefValue="500" Comment="Resolution of the Incremental Encoder in Increments per Turn. &#13;&#10;Value is used for Speed Measurement.&#13;&#10;Default: 500 CPR&#13;&#10;"/>
		<Client Name="EncDirection" Required="false" Internal="false" Comment="Counting Direction of the Encoder&#13;&#10;&#13;&#10;0 .. Normal&#13;&#10;1 .. Invers"/>
		<Client Name="EncMode" Required="false" Internal="false" DefValue="1" Comment="Mode of the Incremental Encoder&#13;&#10;&#13;&#10;0 .. No Encoder (disable)&#13;&#10;1 .. TTL&#13;&#10;2 .. RS422&#13;&#10;"/>
		<Client Name="EncSampling" Required="false" Internal="false" DefValue="3" Comment="Sampling of the Incremental Encoder&#13;&#10;&#13;&#10;0 .. Encoder off&#13;&#10;1 .. 1-edge&#13;&#10;2 .. 2-edge&#13;&#10;3 .. 4-edge&#13;&#10;"/>
		<Client Name="EncSpeed" Required="false" Internal="false" Comment="Mode for the Speed Measurement&#13;&#10;&#13;&#10;0 .. Measurement inactiv&#13;&#10;1 .. Measurement activ&#13;&#10;"/>
		<Client Name="Input1Latch" Required="false" Internal="false" DefValue="0" Comment="The digital input latches the incremental encoder value&#13;&#10;0..not active&#13;&#10;1..rising edge&#13;&#10;2..falling edge&#13;&#10;3..both edges&#13;&#10;Note: The signals are connected via an OR gate.&#13;&#10;Every configured input latches the encoder value."/>
		<Client Name="Input2Latch" Required="false" Internal="false" DefValue="0" Comment="The digital input latches the incremental encoder value&#13;&#10;0..not active&#13;&#10;1..rising edge&#13;&#10;2..falling edge&#13;&#10;3..both edges&#13;&#10;Note: The signals are connected via an OR gate.&#13;&#10;Every configured input latches the encoder value."/>
		<Client Name="Input3Latch" Required="false" Internal="false" DefValue="0" Comment="The digital input latches the incremental encoder value&#13;&#10;0..not active&#13;&#10;1..rising edge&#13;&#10;2..falling edge&#13;&#10;3..both edges&#13;&#10;Note: The signals are connected via an OR gate.&#13;&#10;Every configured input latches the encoder value."/>
		<Client Name="Input4Latch" Required="false" Internal="false" DefValue="0" Comment="The digital input latches the incremental encoder value&#13;&#10;0..not active&#13;&#10;1..rising edge&#13;&#10;2..falling edge&#13;&#10;3..both edges&#13;&#10;Note: The signals are connected via an OR gate.&#13;&#10;Every configured input latches the encoder value."/>
		<Client Name="InvertZeroPosition" Required="false" Internal="false" Comment="inverts server ZeroPosition (0..normal, 1..inverted)"/>
		<Client Name="PeriodCounterBits" Required="false" Internal="false" DefValue="16" Comment="Bit-Length of signed PeriodCounter&#13;&#10;Lower values for measurement of higher speed, high values for measurement of slower speed.&#13;&#10;The higher this value is, that more time is needed to reconize a stop.&#13;&#10;For detailed setting info look at library help.&#13;&#10;Range:   1 - 32 Bit&#13;&#10;Default: 16 bit"/>
		<Client Name="PeriodPrescale" Required="false" Internal="false" DefValue="4" Comment="PeriodPrescaler for Incremental Period Counter. &#13;&#10;Lower values for measurement of higher speed, high values for measurement of slower speed.&#13;&#10;The higher this value is, that more time is needed to reconize a stop.&#13;&#10;For detailed setting info look at library help.&#13;&#10;Range:   1 - 255&#13;&#10;Default: 4"/>
		<Client Name="SpeedMeasureLimit" Required="false" Internal="false" DefValue="100" Comment="Upper Limit for the Speed Measurement with PeriodCounter in Increments / ms&#13;&#10;Default: 100&#13;&#10;&#13;&#10;If the Speed is higher than this Limit, the Speed Measurement is done with the Frequencymeasurement instead of the PeriodCounter."/>
		<Client Name="ZPulseLatch" Required="false" Internal="false" DefValue="0" Comment="Requires FPGA Version 1.4 or higher&#13;&#10;&#13;&#10;The Z-Pulse latches the incremental encoder value&#13;&#10;0..not active&#13;&#10;1..rising edge&#13;&#10;2..falling edge&#13;&#10;3..both edges&#13;&#10;Note: The signals are connected via an OR gate.&#13;&#10;Every configured input latches the encoder value."/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="ObeChr"/>
		<Dokumentation Revision="1.38" Date="12.08.2019" Author="LazJos" Company="Sigmatek" Description="Added support for HWAlarms."/>
		<Dokumentation Revision="1.37" Date="09.01.2019" Author="FurDom" Company="Sigmatek" Description="Added function for Spi Write in SdiasBase class."/>
		<Dokumentation Revision="1.36" Date="08.06.2018" Author="RamAnd" Company="Sigmatek" Description="LASAL Hardware Description (.lhd) file has been updated."/>
		<Dokumentation Revision="1.35" Date="23.01.2018" Author="RamAnd" Company="Sigmatek" Description="Log messages have been standardized for easier maintenance, easier use in any class and to allow spam filtering. Code for the logging functions is now only located in HwControl."/>
		<Dokumentation Revision="1.34" Date="16.05.2017" Author="RamAnd" Company="Sigmatek" Description="When adding an SDO (i.e. via ReadSPIData) from background priority it was possible that the adding process got interrupted by receiving the answer to this SDO which is handled in cyclic priority. In the error case the answer was unexpected and therefore ignored. Then the class signals a timeout while waiting for the answer, which already arrived before waiting for it. Added mutex and changed instruction order to prevent this error."/>
		<Dokumentation Revision="1.33" Date="31.03.2017" Author="PieSte" Company="Sigmatek" Description="Correct hardware description file for sdias time calculation. "/>
		<Dokumentation Revision="1.32" Date="24.10.2016" Author="EisMic" Company="Sigmatek" Description="Added support for extended latch informations."/>
		<Dokumentation Revision="1.31" Date="01.09.2016" Author="ZoePat" Company="Sigmatek" Description="The settings for Latch=2 and EncSampling=2 now works also with compiler version &gt;= C29."/>
		<Dokumentation Revision="1.30" Date="12.07.2016" Author="SeiChr" Company="Sigmatek" Description="Added Values for the total Current calculation. SA 31571"/>
		<Dokumentation Revision="1.29" Date="01.03.2016" Author="EisMic" Company="Sigmatek" Description="Corrected BoundExceed Error in base class at Write method of LEDControl Server when Place = LSL_DEACTIVATED."/>
		<Dokumentation Revision="1.28" Date="17.06.2015" Author="EisMic" Company="Sigmatek" Description="The servers FPGAVersion, SerialNo, Device ID and status and input servers are now not reset anymore when the module is disconnected."/>
		<Dokumentation Revision="1.27" Date="16.04.2015" Author="EisMic&#13;&#10;LanSte" Company="Sigmatek" Description="Added support for visualisation in graphical hardware editor.&#13;&#10;Added support for calculating resources for graphical hardware editor."/>
		<Dokumentation Revision="1.26" Date="17.03.2015" Author="RamAnd" Company="Sigmatek" Description="Added HW Version for sdias clients."/>
		<Dokumentation Revision="1.25" Date="11.02.2015" Author="PieSte" Company="Sigmatek" Description="Corrected read spi data for hardwaretree in methode GetSPIDataFromID from baseclass."/>
		<Dokumentation Revision="1.24" Date="18.11.2014" Author="PieSte" Company="Sigmatek" Description="Added possibility  to read more data from spi flash then one sdo access.&#13;&#10;Set methode GetDeviceID to global.&#13;&#10;Add methode to calculate checksum of spi flash."/>
		<Dokumentation Revision="1.23" Date="09.07.2014" Author="EisMic" Company="Sigmatek" Description="Added support for reading hardware diagnosis and hardwaretree entry."/>
		<Dokumentation Revision="1.22" Date="22.07.2014" Author="ZoePat" Company="Sigmatek" Description="Z-puls latch now also works if encoder has 65535 inc per turn.&#13;&#10;Imroved readout of Latched-status, so the user can read the flag one bus-cycle long after first readout."/>
		<Dokumentation Revision="1.21" Date="27.05.2014" Author="RamAnd" Company="Sigmatek" Description="Added new features which require FPGA Version 1.4 or higher:&#13;&#10; - Client to configure Z-Pulse latching&#13;&#10; - Servers to show if there was a latch on digital inputs"/>
		<Dokumentation Revision="1.20" Date="20.01.2014" Author="PieSte" Company="Sigmatek" Description="Read Client Required and Place in Init SdiasBase"/>
		<Dokumentation Revision="1.10" Date="05.12.2013" Author="RamAnd" Company="Sigmatek" Description="Changed login mechanism to sdias manager class to be independent of bus accesses."/>
		<Dokumentation Revision="1.0" Date="01.08.2013" Author="ObeChr" Company="Sigmatek" Description="Initial Version"/>
	</RevDoku>
	<Network Name="NC100">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{66BC5378-491D-4A85-A0FC-12C7CD180730}"
				Class      = "SdiasBase"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassState"/>
					<Server Name="DeviceID"/>
					<Server Name="FPGAVersion"/>
					<Server Name="HwVersion"/>
					<Server Name="LEDControl" Value="0"/>
					<Server Name="RetryCounter"/>
					<Server Name="SDOState"/>
					<Server Name="SerialNo"/>
					<Client Name="Place" Value="0"/>
					<Client Name="Required" Value="1"/>
					<Client Name="SdiasIn"/>
					<Client Name="ToStdLib"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassState" Destination="_base.ClassState" Vertices="(804,210),(632,210),"/>
			<Connection Source="this.DeviceID" Destination="_base.DeviceID" Vertices="(804,270),(632,270),"/>
			<Connection Source="this.SerialNo" Destination="_base.SerialNo" Vertices="(804,450),(632,450),"/>
			<Connection Source="this.RetryCounter" Destination="_base.RetryCounter" Vertices="(804,510),(632,510),"/>
			<Connection Source="this.LEDControl" Destination="_base.LEDControl" Vertices="(804,570),(632,570),"/>
			<Connection Source="_base.SdiasIn" Destination="this.SdiasIn" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.Place" Destination="this.Place" Vertices="(218,270),(38,270),"/>
			<Connection Source="_base.Required" Destination="this.Required" Vertices="(218,330),(38,330),"/>
			<Connection Source="this.FPGAVersion" Destination="_base.FPGAVersion" Vertices="(804,330),(632,330),"/>
			<Connection Source="this.HwVersion" Destination="_base.HwVersion" Vertices="(804,390),(632,390),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using SdiasBase

NC100 : CLASS
: SdiasBase
	TYPE
	  t_e_InitSSW :
	  (
	    Init_SetVariables,
	    Init_ReadClockFreq,
	    Init_ConfigModule1,
	    Init_ConfigModule2,
	    Init_Finish,
	    Init_Error
	  )$UDINT;
	  t_e_ResponseState :
	  (
	    SDO_Idle,
	    SDO_Wait,
	    SDO_Valid
	  )$UDINT;
#pragma pack(push, 1)
	  t_s_LatchData : STRUCT
	    LatchInput1 : INT;
	    LatchInput2 : INT;
	    LatchInput3 : INT;
	    LatchInput4 : INT;
	    LatchInputZeroPos : INT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_ReadAccess : STRUCT
	    AccessHandle : UDINT;
	    pControlByte : t_SDIAS_pControlByte;
	    pStateByte : t_SDIAS_pStateByte;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_ReadData : STRUCT
	    DigitalInput : BSINT
	    [
	      1 Input1,
	      2 Input2,
	      3 Input3,
	      4 Input4,
	    ];
	    PeriodCounter : DINT;
	    IncEncCount : INT;
	    IncEncCountLatch : INT;
	    IncEncStatus : BSINT
	    [
	      1 DigIn1Latched,  //! <Type Comment="available at FPGA version 1.4 or higher" Name="t_s_ReadData.IncEncStatus.DigIn1Latched"/>
	      2 DigIn2Latched,  //! <Type Comment="available at FPGA version 1.4 or higher" Name="t_s_ReadData.IncEncStatus.DigIn2Latched"/>
	      3 DigIn3Latched,  //! <Type Comment="available at FPGA version 1.4 or higher" Name="t_s_ReadData.IncEncStatus.DigIn3Latched"/>
	      4 DigIn4Latched,  //! <Type Comment="available at FPGA version 1.4 or higher" Name="t_s_ReadData.IncEncStatus.DigIn4Latched"/>
	      5 ZeroPosition,
	      6 ZeroPositionLatch,
	      7 DcOkOutput,
	      8 DcOkIncEnc,
	    ];
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_ReadDataLatch : STRUCT
	    PosLatchedInput1 : INT;
	    PosLatchedInput2 : INT;
	    PosLatchedInput3 : INT;
	    PosLatchedInput4 : INT;
	    PosLatchedZPuls : INT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_Settings : STRUCT
	    biLatchConfig : BINT  //! <Type Comment="Input Latch Configuration" Name="t_s_Settings.biLatchConfig"/>
	    [
	      1 Input1Rising,  //! <Type Comment="Configuration Input 1 for latching the Position.&#13;&#10;Bit0=1, Bit1=0 =&gt; Rising Edge&#13;&#10;Bit0=0, Bit1=1 =&gt; Falling Edge&#13;&#10;Bit0=1, Bit1=1 =&gt; Both Edges" Name="t_s_Settings.biLatchConfig.Input1Rising"/>
	      2 Input1Falling,  //! <Type Comment="Configuration Input 1 for latching the Position.&#13;&#10;Bit0=1, Bit1=0 =&gt; Rising Edge&#13;&#10;Bit0=0, Bit1=1 =&gt; Falling Edge&#13;&#10;Bit0=1, Bit1=1 =&gt; Both Edges" Name="t_s_Settings.biLatchConfig.Input1Falling"/>
	      3 Input2Rising,  //! <Type Comment="Configuration Input 2 for latching the Position.&#13;&#10;Bit0=1, Bit1=0 =&gt; Rising Edge&#13;&#10;Bit0=0, Bit1=1 =&gt; Falling Edge&#13;&#10;Bit0=1, Bit1=1 =&gt; Both Edges" Name="t_s_Settings.biLatchConfig.Input2Rising"/>
	      4 Input2Falling,  //! <Type Comment="Configuration Input 2 for latching the Position.&#13;&#10;Bit0=1, Bit1=0 =&gt; Rising Edge&#13;&#10;Bit0=0, Bit1=1 =&gt; Falling Edge&#13;&#10;Bit0=1, Bit1=1 =&gt; Both Edges" Name="t_s_Settings.biLatchConfig.Input2Falling"/>
	      5 Input3Rising,  //! <Type Comment="Configuration Input 3 for latching the Position.&#13;&#10;Bit0=1, Bit1=0 =&gt; Rising Edge&#13;&#10;Bit0=0, Bit1=1 =&gt; Falling Edge&#13;&#10;Bit0=1, Bit1=1 =&gt; Both Edges" Name="t_s_Settings.biLatchConfig.Input3Rising"/>
	      6 Input3Falling,  //! <Type Comment="Configuration Input 3 for latching the Position.&#13;&#10;Bit0=1, Bit1=0 =&gt; Rising Edge&#13;&#10;Bit0=0, Bit1=1 =&gt; Falling Edge&#13;&#10;Bit0=1, Bit1=1 =&gt; Both Edges" Name="t_s_Settings.biLatchConfig.Input3Falling"/>
	      7 Input4Rising,  //! <Type Comment="Configuration Input 4 for latching the Position.&#13;&#10;Bit0=1, Bit1=0 =&gt; Rising Edge&#13;&#10;Bit0=0, Bit1=1 =&gt; Falling Edge&#13;&#10;Bit0=1, Bit1=1 =&gt; Both Edges" Name="t_s_Settings.biLatchConfig.Input4Rising"/>
	      8 Input4Falling,  //! <Type Comment="Configuration Input 4 for latching the Position.&#13;&#10;Bit0=1, Bit1=0 =&gt; Rising Edge&#13;&#10;Bit0=0, Bit1=1 =&gt; Falling Edge&#13;&#10;Bit0=1, Bit1=1 =&gt; Both Edges" Name="t_s_Settings.biLatchConfig.Input4Falling"/>
	      9 ZPulseRising,  //! <Type Comment="Configuration Z-Pulse for latching the Position.&#13;&#10;Bit0=1, Bit1=0 =&gt; Rising Edge&#13;&#10;Bit0=0, Bit1=1 =&gt; Falling Edge&#13;&#10;Bit0=1, Bit1=1 =&gt; Both Edges&#13;&#10;&#13;&#10;Feature is available at FPGA Version 1.4 or higher" Name="t_s_Settings.biLatchConfig.ZPulseRising"/>
	      10 ZPulseFalling,  //! <Type Comment="Configuration Z-Pulse for latching the Position.&#13;&#10;Bit0=1, Bit1=0 =&gt; Rising Edge&#13;&#10;Bit0=0, Bit1=1 =&gt; Falling Edge&#13;&#10;Bit0=1, Bit1=1 =&gt; Both Edges&#13;&#10;&#13;&#10;Feature is available at FPGA Version 1.4 or higher" Name="t_s_Settings.biLatchConfig.ZPulseFalling"/>
	    ];
	    bsEncoderControl : BSINT  //! <Type Comment="Incremental Encoder Control Register" Name="t_s_Settings.bsEncoderControl"/>
	    [
	      1 RS422,  //! <Type Comment="0 .. TTL Incremental Encoder&#13;&#10;1 .. RS422 Incremental Encoder" Name="t_s_Settings.bsEncoderControl.RS422"/>
	    ];
	    aReserved1 : ARRAY [0..12] OF SINT;
	    dPeriodCounterLevel : DINT;  //! <Type Comment="Period Counter&#13;&#10;&#13;&#10;Read Access = Period Counter&#13;&#10;Write Access = Period Counter Level" Name="t_s_Settings.dPeriodCounterLevel"/>
	    iReserved2 : INT;
	    usPeriodPrescale : USINT;  //! <Type Comment="Period Prescale Register&#13;&#10;&#13;&#10;Period Prescale = Clk [Hz] * Measure Time [sec]" Name="t_s_Settings.usPeriodPrescale"/>
	    usClockFreq : USINT;  //! <Type Comment="Clock Frequency [MHz]" Name="t_s_Settings.usClockFreq"/>
	    iEncoderCounter : INT;  //! <Type Comment="Incremental Encoder Counter.&#13;&#10;The Counter Value represents the number of rising/falling incremental encoder edges. The counter value is incremented/decremented upon 1,2 or 4 Edges per Pulse (see Encoder CommandRegister)" Name="t_s_Settings.iEncoderCounter"/>
	    bsEncoderCommand : BSINT  //! <Type Comment="Incremental Encoder Command Register" Name="t_s_Settings.bsEncoderCommand"/>
	    [
	      3 InvertZeroPosition,  //! <Type Comment="0 .. no Inversion of ZeroPosition&#13;&#10;1 .. Invert ZeroPosition" Name="t_s_Settings.bsEncoderCommand.InvertZeroPosition"/>
	      4 InvertPhaseB,  //! <Type Comment="0 .. no Inversion of Phase B&#13;&#10;1 .. Invert Phase B" Name="t_s_Settings.bsEncoderCommand.InvertPhaseB"/>
	      5 EdgeSamplingBit0,  //! <Type Comment="Bit0=0, Bit1=0 =&gt; Encoder Off&#13;&#10;Bit0=1, Bit1=0 =&gt; 1 Edge&#13;&#10;Bit0=0, Bit1=1 =&gt; 2 Edges&#13;&#10;Bit0=1, Bit1=1 =&gt; 4 Edges" Name="t_s_Settings.bsEncoderCommand.EdgeSamplingBit0"/>
	      6 EdgeSamplingBit1,  //! <Type Comment="Bit0=0, Bit1=0 =&gt; Encoder Off&#13;&#10;Bit0=1, Bit1=0 =&gt; 1 Edge&#13;&#10;Bit0=0, Bit1=1 =&gt; 2 Edges&#13;&#10;Bit0=1, Bit1=1 =&gt; 4 Edges" Name="t_s_Settings.bsEncoderCommand.EdgeSamplingBit1"/>
	    ];
	    bsEncoderStatus : BSINT
	    [
	      5 ZeroPosition,  //! <Type Comment="ZeroPosition" Name="t_s_Settings.bsEncoderStatus.ZeroPosition"/>
	      6 ZeroPositionLatch,  //! <Type Comment="ZeroPosition latched" Name="t_s_Settings.bsEncoderStatus.ZeroPositionLatch"/>
	    ];
	    iEncoderLatchValue : INT;  //! <Type Comment="Incremental Encoder Counter latched. &#13;&#10;This Register is the latched Version of the Incremental Encoder Counter." Name="t_s_Settings.iEncoderLatchValue"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_WriteData : STRUCT
	    bsDigitalOut : BSINT
	    [
	      1 Out1,
	      2 Out2,
	      3 Out3,
	      4 Out4,
	    ];
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	Position 	: SvrCh_DINT;
	PositionLatch 	: SvrCh_DINT;
	Speed 	: SvrCh_DINT;
	IncPerMs 	: SvrCh_DINT;
	ZPuls 	: SvrCh_DINT;
	ZPulsLatched 	: SvrCh_DINT;
	Input1 	: SvrCh_DINT;
	Input1Latched 	: SvrCh_DINT;
	Input2 	: SvrCh_DINT;
	Input2Latched 	: SvrCh_DINT;
	Input3 	: SvrCh_DINT;
	Input3Latched 	: SvrCh_DINT;
	Input4 	: SvrCh_DINT;
	Input4Latched 	: SvrCh_DINT;
	Output1 	: SvrCh_DINT;
	Output2 	: SvrCh_DINT;
	Output3 	: SvrCh_DINT;
	Output4 	: SvrCh_DINT;
	VoltageOkOutput 	: SvrCh_DINT;
	VoltageOkEncoder 	: SvrCh_DINT;
	PosLatchedInput1 	: SvrCh_DINT;
	PosLatchedInput2 	: SvrCh_DINT;
	PosLatchedInput3 	: SvrCh_DINT;
	PosLatchedInput4 	: SvrCh_DINT;
	PosLatchedZPuls 	: SvrCh_DINT;
  //Clients:
	EncMode 	: CltCh_DINT;
	EncDirection 	: CltCh_DINT;
	EncSpeed 	: CltCh_DINT;
	EncCPR 	: CltCh_DINT;
	EncSampling 	: CltCh_DINT;
	SpeedMeasureLimit 	: CltCh_DINT;
	PeriodPrescale 	: CltCh_DINT;
	PeriodCounterBits 	: CltCh_UDINT;
	InvertZeroPosition 	: CltCh_DINT;
	Input1Latch 	: CltCh_DINT;
	Input2Latch 	: CltCh_DINT;
	Input3Latch 	: CltCh_DINT;
	Input4Latch 	: CltCh_DINT;
	ZPulseLatch 	: CltCh_DINT;
	AdditionalLatchInfo 	: CltCh_DINT;
  //Variables:
		bRunPostScan 	: BOOL;
		dEncoderValue 	: DINT;
		dFreqFactor 	: DINT;
		dSpeedFactor 	: DINT;
		eInitSSW 	: t_e_InitSSW;
		eResponseState 	: t_e_ResponseState;
		iEncoderValueBinary 	: INT;
		iLatchValueBinary 	: INT;
		InitSSWErrorStep 	: t_e_InitSSW;
		pReadData 	: ^t_s_ReadData;
		pWriteData 	: ^t_s_WriteData;
		sConfiguration 	: t_s_Settings;
		sReadData 	: t_s_ReadData;
		sWriteData 	: t_s_WriteData;
		udDeltaTime 	: UDINT;			//! <Variable Comment="DeltaTime between to Meassurements [us]" Name="udDeltaTime"/>
		udSDOTimeout 	: UDINT;
		bsLatchReaded : BSINT
		[
		  1 DigIn1,
		  2 DigIn2,
		  3 DigIn3,
		  4 DigIn4,
		  6 ZPos,
		];

		bsSelectedLatch : BSINT
		[
		  1 DigIn1,
		  2 DigIn2,
		  3 DigIn3,
		  4 DigIn4,
		  6 ZPos,
		];

		sReadAccess 	: t_s_ReadAccess;			//! <Variable Comment="Structure of additional read access for additional latch values information." Name="sReadAccess"/>
		pReadDataLatch 	: ^t_s_ReadDataLatch;			//! <Variable Comment="Pointer to read data of additional latch values." Name="pReadDataLatch"/>
		sReadDataLatch 	: t_s_ReadDataLatch;			//! <Variable Comment="Read Data of additional latch values." Name="sReadDataLatch"/>
		bAdditionalLatchValuesAvailable 	: BOOL;			//! <Variable Comment="Flag which indicates if the additional latch values are available." Name="bAdditionalLatchValuesAvailable"/>
  //Functions:
				//! <Function Comment="Constructor of Class." Name="NC100"/>
	FUNCTION NC100
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL UpdateRt;
	
	FUNCTION VIRTUAL GLOBAL UpdateRtPostScan;
	
	FUNCTION VIRTUAL GLOBAL AddAccesses
		VAR_OUTPUT
			eModuleInitState 	: iprStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ConnectEvent;
	
	FUNCTION VIRTUAL GLOBAL DisconnectEvent;
				//! <Function Comment="Methode should be used to run a Statemachine to Initialize the Module." Name="InitModule"/>
	FUNCTION VIRTUAL GLOBAL InitModule
		VAR_OUTPUT
			eModuleInitState 	: iprStates;			//! <Variable Comment="Return BUSY until the Initialisation is finished." Name="InitModule.eModuleInitState"/>
		END_VAR;
				//! <Function Comment="This Methode should be used, to check the DeviceID of the Module." Name="CheckDeviceID"/>
	FUNCTION VIRTUAL GLOBAL CheckDeviceID
		VAR_INPUT
			udID2Check 	: UDINT;			//! <Variable Comment="Device ID of connected Module." Name="CheckDeviceID.udID2Check"/>
		END_VAR
		VAR_OUTPUT
			bIsOK 	: BOOL;			//! <Variable Comment="FALSE = Wrong DeviceID for Module&#13;&#10;TRUE  = DeviceID of Module is correct" Name="CheckDeviceID.bIsOK"/>
		END_VAR;
				//! <Function Comment="Methode to receive the Response in case of SDO-Communication." Name="ReceiveSDOResponse"/>
	FUNCTION VIRTUAL ReceiveSDOResponse
		VAR_INPUT
			eCommand 	: t_SDIAS_SDO_Cmd;			//! <Variable Comment="Type of SDO-Command" Name="ReceiveSDOResponse.eCommand"/>
			hOffset 	: HINT;			//! <Variable Comment="Address-Offset in Module." Name="ReceiveSDOResponse.hOffset"/>
			usLength 	: USINT;			//! <Variable Comment="Length of Data." Name="ReceiveSDOResponse.usLength"/>
			eResult 	: iprStates;			//! <Variable Comment="State of SDO-Communication." Name="ReceiveSDOResponse.eResult"/>
			pResponseBuffer 	: ^USINT;			//! <Variable Comment="Pointer of ResponseBuffer, where the SDO-Data is located." Name="ReceiveSDOResponse.pResponseBuffer"/>
			ResponseLength 	: USINT;			//! <Variable Comment="Size of the ResponseBuffer." Name="ReceiveSDOResponse.ResponseLength"/>
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;			//! <Variable Comment="Indicates if the Methode was successful." Name="ReceiveSDOResponse.ret_code"/>
		END_VAR;
	
	FUNCTION VIRTUAL GetTaskCfg
		VAR_OUTPUT
			TaskCfg 	: BDINT;			//! <Variable Comment="Select which tasks will be available for this module:&#13;&#10;Bit0..Realtime PreScan&#13;&#10;Bit1..Realtime PostScan&#13;&#10;Bit2..Cyclic&#13;&#10;&#13;&#10;e.g. if only realtime postscan is needed:&#13;&#10;2#010" Name="GetTaskCfg.TaskCfg"/>
		END_VAR;
	
	FUNCTION VIRTUAL GetDeviceID
		VAR_OUTPUT
			output 	: UDINT;
		END_VAR;
	
	FUNCTION CheckLatchSetting
		VAR_INPUT
			dLatch 	: DINT;
		END_VAR
		VAR_OUTPUT
			dSetting 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ZPulsLatched::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Input1Latched::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Input2Latched::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Input3Latched::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Input4Latched::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Output1::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Output2::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Output3::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Output4::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB NC100::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_NC100
1$UINT, 38$UINT, (SIZEOF(::NC100))$UINT, 
25$UINT, 15$UINT, 0$UINT, 
TO_UDINT(1953918750), "NC100", //Class
TO_UDINT(3175101883), "SdiasBase", 1$UINT, 60$UINT, //Baseclass
//Servers:
(::NC100.Position.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2149546169), "Position", 
(::NC100.PositionLatch.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(801812501), "PositionLatch", 
(::NC100.Speed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4168236102), "Speed", 
(::NC100.IncPerMs.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2187123797), "IncPerMs", 
(::NC100.ZPuls.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3142960073), "ZPuls", 
(::NC100.ZPulsLatched.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3904789169), "ZPulsLatched", 
(::NC100.Input1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1344628668), "Input1", 
(::NC100.Input1Latched.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(751816755), "Input1Latched", 
(::NC100.Input2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3375117830), "Input2", 
(::NC100.Input2Latched.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2722158544), "Input2Latched", 
(::NC100.Input3.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3190490768), "Input3", 
(::NC100.Input3Latched.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1860884302), "Input3Latched", 
(::NC100.Input4.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(542085939), "Input4", 
(::NC100.Input4Latched.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1680858711), "Input4Latched", 
(::NC100.Output1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2425114930), "Output1", 
(::NC100.Output2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(159711368), "Output2", 
(::NC100.Output3.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2122461214), "Output3", 
(::NC100.Output4.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3773212093), "Output4", 
(::NC100.VoltageOkOutput.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2955355844), "VoltageOkOutput", 
(::NC100.VoltageOkEncoder.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2453190080), "VoltageOkEncoder", 
(::NC100.PosLatchedInput1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2239033022), "PosLatchedInput1", 
(::NC100.PosLatchedInput2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(478002948), "PosLatchedInput2", 
(::NC100.PosLatchedInput3.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1803194258), "PosLatchedInput3", 
(::NC100.PosLatchedInput4.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4112390705), "PosLatchedInput4", 
(::NC100.PosLatchedZPuls.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2325554667), "PosLatchedZPuls", 
//Clients:
(::NC100.EncMode.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(558217510), "EncMode", 
(::NC100.EncDirection.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3190248247), "EncDirection", 
(::NC100.EncSpeed.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2818027101), "EncSpeed", 
(::NC100.EncCPR.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3442963858), "EncCPR", 
(::NC100.EncSampling.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(826259315), "EncSampling", 
(::NC100.SpeedMeasureLimit.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3538184243), "SpeedMeasureLimit", 
(::NC100.PeriodPrescale.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2756836755), "PeriodPrescale", 
(::NC100.PeriodCounterBits.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(994128073), "PeriodCounterBits", 
(::NC100.InvertZeroPosition.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2091988656), "InvertZeroPosition", 
(::NC100.Input1Latch.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1200938485), "Input1Latch", 
(::NC100.Input2Latch.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3238047579), "Input2Latch", 
(::NC100.Input3Latch.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(173833470), "Input3Latch", 
(::NC100.Input4Latch.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(391728198), "Input4Latch", 
(::NC100.ZPulseLatch.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(898682994), "ZPulseLatch", 
(::NC100.AdditionalLatchInfo.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(544581510), "AdditionalLatchInfo", 
END_FUNCTION


#define USER_CNT_NC100 25

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_NC100] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION NC100::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= SdiasBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= SdiasBase::ClassState.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, SdiasBase::ClassState.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_NC100;
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #UpdateRt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #UpdateRtPostScan();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #AddAccesses();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #ConnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #DisconnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #InitModule();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #CheckDeviceID();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #ReceiveSDOResponse();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #GetTaskCfg();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #GetDeviceID();

#pragma warning (default : 74)
	SdiasBase::ClassState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF SdiasBase::ClassState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Position.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF Position.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ZPulsLatched.pMeth			:= StoreMethod( #ZPulsLatched::Read(), #M_NO_F() );
	IF ZPulsLatched.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Input1Latched.pMeth			:= StoreMethod( #Input1Latched::Read(), #M_NO_F() );
	IF Input1Latched.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Input2Latched.pMeth			:= StoreMethod( #Input2Latched::Read(), #M_NO_F() );
	IF Input2Latched.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Input3Latched.pMeth			:= StoreMethod( #Input3Latched::Read(), #M_NO_F() );
	IF Input3Latched.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Input4Latched.pMeth			:= StoreMethod( #Input4Latched::Read(), #M_NO_F() );
	IF Input4Latched.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Output1.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Output1::Write() );
	IF Output1.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Output2.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Output2::Write() );
	IF Output2.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Output3.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Output3::Write() );
	IF Output3.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Output4.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Output4::Write() );
	IF Output4.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= NC100();

END_FUNCTION

//{{LSL_IMPLEMENTATION
FUNCTION VIRTUAL GLOBAL NC100::UpdateRt
  VAR
    tmpSpeed        : DINT;
    tmpSpeedByTime	: DINT;
  END_VAR
    
  //Read Information from DPRam
  sReadData := pReadData^;
  
  //Read Infos of DPRAM if this feature is available
  if bAdditionalLatchValuesAvailable then
    sReadDataLatch :=  pReadDataLatch^;
  end_if;
  
  //Input Informations
  //---------------------------------------------------------------
  Input1 := sReadData.DigitalInput.Input1;
  Input2 := sReadData.DigitalInput.Input2;
  Input3 := sReadData.DigitalInput.Input3;
  Input4 := sReadData.DigitalInput.Input4;
    
  //State of Supply
  //---------------------------------------------------------------
  VoltageOkOutput   := sReadData.IncEncStatus.DcOkOutput;
  VoltageOkEncoder  := sReadData.IncEncStatus.DcOkIncEnc;

  //Encoder
  //---------------------------------------------------------------
  
  //Check if Encoder is enabled, otherwise do nothing
  if EncMode then
    
    //Check for invers Mode
    if EncDirection then
    
      //LatchPosition (diff is needed to support of FPGA < 1.4)
      if (sReadData.IncEncCountLatch <> iLatchValueBinary) | (sReadData.IncEncStatus AND bsSelectedLatch) then
        
        //Check Moving Direction
        PositionLatch := Position + to_int(iEncoderValueBinary - sReadData.IncEncCountLatch);
        
        //Save binary Latch Value
        iLatchValueBinary := sReadData.IncEncCountLatch;
        
      end_if;
      
      //Extended Latch Informations
      if bAdditionalLatchValuesAvailable then
      
        if (sReadData.IncEncStatus.DigIn1Latched AND bsSelectedLatch.DigIn1) then
          PosLatchedInput1 := Position + to_int(iEncoderValueBinary - sReadDataLatch.PosLatchedInput1);
        end_if;
        
        if (sReadData.IncEncStatus.DigIn2Latched AND bsSelectedLatch.DigIn2) then
          PosLatchedInput2 := Position + to_int(iEncoderValueBinary - sReadDataLatch.PosLatchedInput2);
        end_if;

        if (sReadData.IncEncStatus.DigIn3Latched AND bsSelectedLatch.DigIn3) then
          PosLatchedInput3 := Position + to_int(iEncoderValueBinary - sReadDataLatch.PosLatchedInput3);
        end_if;

        if (sReadData.IncEncStatus.DigIn4Latched AND bsSelectedLatch.DigIn4) then
          PosLatchedInput4 := Position + to_int(iEncoderValueBinary - sReadDataLatch.PosLatchedInput4);
        end_if;
        
        if (sReadData.IncEncStatus.ZeroPositionLatch AND bsSelectedLatch.ZPos) then
          PosLatchedZPuls := Position + to_int(iEncoderValueBinary - sReadDataLatch.PosLatchedZPuls);
        end_if;
      end_if;
      
      //to_int() is done for Overflow Handling
      Position -= to_int(sReadData.IncEncCount - iEncoderValueBinary);
      
    else
    
      //LatchPosition (diff is needed to support of FPGA < 1.4)
      if (sReadData.IncEncCountLatch <> iLatchValueBinary) | (sReadData.IncEncStatus AND bsSelectedLatch) then
        
        //Check Moving Direction
        PositionLatch := Position - to_int(iEncoderValueBinary - sReadData.IncEncCountLatch);
        
        //Save binary Latch Value
        iLatchValueBinary := sReadData.IncEncCountLatch;
        
      end_if;

      //Extended Latch Informations      
      if bAdditionalLatchValuesAvailable then
        if (sReadData.IncEncStatus.DigIn1Latched AND bsSelectedLatch.DigIn1) then
          PosLatchedInput1 := Position - to_int(iEncoderValueBinary - sReadDataLatch.PosLatchedInput1);
        end_if;
        
        if (sReadData.IncEncStatus.DigIn2Latched AND bsSelectedLatch.DigIn2) then
          PosLatchedInput2 := Position - to_int(iEncoderValueBinary - sReadDataLatch.PosLatchedInput2);
        end_if;

        if (sReadData.IncEncStatus.DigIn3Latched AND bsSelectedLatch.DigIn3) then
          PosLatchedInput3 := Position - to_int(iEncoderValueBinary - sReadDataLatch.PosLatchedInput3);
        end_if;

        if (sReadData.IncEncStatus.DigIn4Latched AND bsSelectedLatch.DigIn4) then
          PosLatchedInput4 := Position - to_int(iEncoderValueBinary - sReadDataLatch.PosLatchedInput4);
        end_if;
        
        if(sReadData.IncEncStatus.ZeroPositionLatch AND bsSelectedLatch.ZPos) then
          PosLatchedZPuls := Position - to_int(iEncoderValueBinary - sReadDataLatch.PosLatchedZPuls);
        end_if;      
      end_if;
    
      //to_int() is done for Overflow Handling
      Position += to_int(sReadData.IncEncCount - iEncoderValueBinary);
  
    end_if;
    
    //Remember actual Encoder Value
    iEncoderValueBinary := sReadData.IncEncCount;
    
        
    //ZPulse
    ZPuls := sReadData.IncEncStatus.ZeroPosition;
    
    // check for latched bits
    if (sReadData.IncEncStatus AND NC100_LATCH_BIT_MASK) | bsLatchReaded then
    
      //ZPulse latched
      if ( sReadData.IncEncStatus.ZeroPositionLatch ) | bsLatchReaded.ZPos then
        bsLatchReaded.ZPos := FALSE;
        ZPulsLatched := sReadData.IncEncStatus.ZeroPositionLatch; //Reset of Bit is done with Read-Access
      end_if;    
    
      //Input1 latched
      if ( sReadData.IncEncStatus.DigIn1Latched ) | bsLatchReaded.DigIn1 then
        bsLatchReaded.DigIn1 := FALSE;
        Input1Latched := sReadData.IncEncStatus.DigIn1Latched; //Reset of Bit is done with Read-Access
      end_if;    
      
      //Input2 latched
      if ( sReadData.IncEncStatus.DigIn2Latched ) | bsLatchReaded.DigIn2 then
        bsLatchReaded.DigIn2 := FALSE;
        Input2Latched := sReadData.IncEncStatus.DigIn2Latched; //Reset of Bit is done with Read-Access
      end_if;    

      //Input3 latched
      if ( sReadData.IncEncStatus.DigIn3Latched ) | bsLatchReaded.DigIn3 then
        bsLatchReaded.DigIn3 := FALSE;
        Input3Latched := sReadData.IncEncStatus.DigIn3Latched; //Reset of Bit is done with Read-Access
      end_if;    

      //Input4 latched
      if ( sReadData.IncEncStatus.DigIn4Latched ) | bsLatchReaded.DigIn4 then
        bsLatchReaded.DigIn4 := FALSE;
        Input4Latched := sReadData.IncEncStatus.DigIn4Latched; //Reset of Bit is done with Read-Access
      end_if;    
    end_if;
 

    //Speed Meassurement
    //---------------------------------------------------------------
    if EncSpeed then
      
      if EncDirection then
        //Invers Direction
        tmpSpeed  := -sReadData.PeriodCounter;
      else
        //Normal Direction
        tmpSpeed  := sReadData.PeriodCounter;
      end_if;

      if tmpSpeed = sConfiguration.dPeriodCounterLevel | tmpSpeed = 0 |tmpSpeed = -sConfiguration.dPeriodCounterLevel then
        tmpSpeedByTime := 0;
      else
        tmpSpeedByTime := dSpeedFactor / tmpSpeed;
      end_if; 
    
        //calculate speed by frequency
      IncPerMs := ( Position - dEncoderValue ) SEC / udDeltaTime$DINT; // *1000 ==> convert to ms
      dEncoderValue := Position;
     
      //Negative Direction
      if ( IncPerMs < 0 ) then
        
        //Limitation of Speed
        if ( IncPerMs > -SpeedMeasureLimit ) then  
          Speed := tmpSpeedByTime;
        else
          Speed := IncPerMs * dFreqFactor;
        end_if;
        
      //Positive Direction
      else
      
        //Limitation of Speed
        if ( IncPerMs < SpeedMeasureLimit ) then  
          Speed := tmpSpeedByTime;
        else
          Speed := IncPerMs * dFreqFactor;
        end_if;
      end_if;
    
    end_if;
  
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL NC100::UpdateRtPostScan

  //Check for Change PostScan-Data
  if bRunPostScan then
  
    //Write to Manager
    pWriteData^ := sWriteData;
    
    //Reset Marker
    bRunPostScan := false;
    
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL NC100::ConnectEvent

  //Read Access
  if DefaultAccesses.ReadAccess.pControlByte then
    pReadData := DefaultAccesses.ReadAccess.pData$^t_s_ReadData;

    //Start Read-Access to Module (Set ControlWord in DPRam)
    DefaultAccesses.ReadAccess.pControlByte^.EnableDO := true;
  else
    //No ControlWord available
    eInitState := _DOHandleInvalid;
    return;
  end_if;
  
  //Read Access Extended
  if AdditionalLatchInfo then
    if sReadAccess.pControlByte then
      sReadAccess.pControlByte^.EnableDO := TRUE;  
    else
      eInitState := _DOHandleInvalid;
      return;
    end_if;
  end_if;
  
  //Write Access
  if DefaultAccesses.WriteAccess.pControlByte then
    pWriteData := DefaultAccesses.WriteAccess.pData$^t_s_WriteData;

    //Start Write-Access to Module (Set ControlWord in DPRam)
    DefaultAccesses.WriteAccess.pControlByte^.EnableDO := true;
  else  
    //No ControlWord available
    eInitState := _DOHandleInvalid;
    return;
  end_if;

  //Reset Statemachines
  eInitSSW       := Init_SetVariables;
  eResponseState := SDO_Idle;
  eInitState    := _NotInitialized;

  //Run PostScan the first Time
  bRunPostScan := true;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL NC100::DisconnectEvent

  //Reset DO-Data
  if pWriteData then
    _memset(dest := pWriteData, usByte := 0, cntr := sizeof(pWriteData^));
  end_if;

 
  //Call Disconnect of Base-Class
  SdiasBase::DisconnectEvent();

END_FUNCTION


FUNCTION NC100::CheckLatchSetting
	VAR_INPUT
		dLatch 	: DINT;
	END_VAR
	VAR_OUTPUT
		dSetting 	: DINT;
	END_VAR

  //Only Values from 0 to 3 are Valid
  if (dLatch >= 0) & (dLatch <= 3) then
    //Value is OK
    dSetting := dLatch;
    
  else
    //Disable Latch
    dSetting := 0;
    LogError("@ZZZZ (NC100::SetDigIn_Latch) Invalid DigIn_Latch setting value");    
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL NC100::Output1::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
  //Only Bool-Value allowed
  Output1 := input AND 1;
  
  //Save Write-Data
  sWriteData.bsDigitalOut.Out1 := to_bool(Output1);
  
  //Start PostScan
  bRunPostScan := true;
  
  result := Output1;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL NC100::Output2::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  //Only Bool-Value allowed
  Output2 := input AND 1;
  
  //Save Write-Data
  sWriteData.bsDigitalOut.Out2 := to_bool(Output2);
  
  //Start PostScan
  bRunPostScan := true;
  
  result := Output2;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL NC100::Output3::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  //Only Bool-Value allowed
  Output3 := input AND 1;
  
  //Save Write-Data
  sWriteData.bsDigitalOut.Out3 := to_bool(Output3);
  
  //Start PostScan
  bRunPostScan := true;
  
  result := Output3;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL NC100::Output4::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  //Only Bool-Value allowed
  Output4 := input AND 1;
  
  //Save Write-Data
  sWriteData.bsDigitalOut.Out4 := to_bool(Output4);
  
  //Start PostScan
  bRunPostScan := true;
  
  result := Output4;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL NC100::ZPulsLatched::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

  //Return Latch
	output := ZPulsLatched;
  
  //Reset Latch in next rt-run
  bsLatchReaded.ZPos := TRUE;

END_FUNCTION


FUNCTION NC100::NC100
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR

	ret_code := C_OK;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL NC100::InitModule
	VAR_OUTPUT
		eModuleInitState 	: iprStates;
	END_VAR
  VAR
  	tmpRetcode : iprStates;
  END_VAR
  
  
  //Init Returncode
  eModuleInitState := BUSY;

  
  //*****************************************************************************
  //** STATEMACHINE FOR INIT OF MODULE                                         **
  //*****************************************************************************
  
  case eInitSSW of
  
    //Init Variables of Class
    //*****************************************************************************
    Init_SetVariables:
    
      //Read Clients
      EncMode             := EncMode.Read();
      EncDirection        := EncDirection.Read();
      EncSpeed            := EncSpeed.Read();
      EncCPR              := EncCPR.Read();
      SpeedMeasureLimit   := SpeedMeasureLimit.Read();
      PeriodPrescale      := PeriodPrescale.Read();
      PeriodCounterBits   := PeriodCounterBits.Read();
      InvertZeroPosition  := InvertZeroPosition.Read();
      Input1Latch         := CheckLatchSetting(dLatch := Input1Latch.Read());
      Input2Latch         := CheckLatchSetting(dLatch := Input2Latch.Read());
      Input3Latch         := CheckLatchSetting(dLatch := Input3Latch.Read());
      Input4Latch         := CheckLatchSetting(dLatch := Input4Latch.Read());
      if FPGAVersion >= NC100_SUPPORT_ZPULS_LATCH then
        ZPulseLatch       := CheckLatchSetting(dLatch := ZPulseLatch.Read());
      else
        LogError("@ZZZZ (NC100::InitModule) Newer FPGA-Version needed to support ZPuls-Latch. (v1.4 or greater)");
        ZPulseLatch       := 0;
      end_if;
      
      // remember flags for further use
      bsSelectedLatch.DigIn1 := Input1Latch <> 0;
      bsSelectedLatch.DigIn2 := Input2Latch <> 0;
      bsSelectedLatch.DigIn3 := Input3Latch <> 0;
      bsSelectedLatch.DigIn4 := Input4Latch <> 0;
      bsSelectedLatch.ZPos   := ZPulseLatch <> 0;
      
      //Limit PeriodPreScaler
      if ( PeriodPrescale < 1 ) then
        PeriodPrescale := 1;
      elsif ( PeriodPrescale > 255 ) then
        PeriodPrescale := 255;
      end_if;

      //Limit PeriodCounter
      if ( PeriodCounterBits < 1 ) then
        PeriodCounterBits := 16;
      elsif ( PeriodCounterBits > 32 ) then
        PeriodCounterBits := 32;
      end_if;

      //Limit Encoder Sampling
      if ( EncSampling < 0 ) then
        EncSampling := 0;
      elsif ( EncSampling > 3 ) then
        EncSampling := 3;
      end_if;

      //Speed Measurement only possible if Encoder is active
      if ( EncMode = 0 ) then
        EncSpeed := 0;
      end_if;
      
      //Calculate Settings for Speed Meassurement
      if ( EncSpeed = 1 ) then  
        sConfiguration.dPeriodCounterLevel := ((1 shl (PeriodCounterBits - 1)) - 1)$DINT;
        sConfiguration.usPeriodPrescale    := PeriodPrescale$USINT;
      else
        sConfiguration.dPeriodCounterLevel := 0;
        sConfiguration.usPeriodPrescale    := 0;
      end_if; 
      
      //Latch Configuration
      sConfiguration.biLatchConfig.Input1Rising  := to_bool(Input1Latch and 1);
      sConfiguration.biLatchConfig.Input1Falling := to_bool((Input1Latch shr 1) and 1);
      sConfiguration.biLatchConfig.Input2Rising  := to_bool(Input2Latch and 1);
      sConfiguration.biLatchConfig.Input2Falling := to_bool((Input2Latch shr 1) and 1);
      sConfiguration.biLatchConfig.Input3Rising  := to_bool(Input3Latch and 1);
      sConfiguration.biLatchConfig.Input3Falling := to_bool((Input3Latch shr 1) and 1);
      sConfiguration.biLatchConfig.Input4Rising  := to_bool(Input4Latch and 1);
      sConfiguration.biLatchConfig.Input4Falling := to_bool((Input4Latch shr 1) and 1);
      sConfiguration.biLatchConfig.ZPulseRising  := to_bool(ZPulseLatch and 1);
      sConfiguration.biLatchConfig.ZPulseFalling := to_bool((ZPulseLatch shr 1) and 1);
      

      //Set Mode of Encoder
      case EncMode of
        NC100_NOENCODER:
        NC100_TTL_MODE:
          sConfiguration.bsEncoderControl.RS422 := 0;
        NC100_RS422_MODE:
          sConfiguration.bsEncoderControl.RS422 := 1; 
      else
        LogError("@ZZZZ (NC100::InitModule) Invalid incremental encoder");
      end_case;
      
      //Inversion of ZeroPosition
      sConfiguration.bsEncoderCommand.InvertZeroPosition := to_bool(InvertZeroPosition);
      
      //Sampling of Encoder
      sConfiguration.bsEncoderCommand.EdgeSamplingBit0 := to_bool(EncSampling and 1);
      sConfiguration.bsEncoderCommand.EdgeSamplingBit1 := to_bool((EncSampling shr 1) and 1);
            
      //Calculate DeltaTime for SpeedCalculation
      udDeltaTime := udBusTime / 1000;  // (Delta t s)   /1000 ==> convert to s              
      
      eInitSSW := Init_ConfigModule1;
      
      bAdditionalLatchValuesAvailable := FALSE;
      
      //Check for new latch feature activated and available   
      if AdditionalLatchInfo then
        if FPGAVersion >= NC100_SUPPORT_ADDITIONAL_LATCH_VALUES then
          bAdditionalLatchValuesAvailable := TRUE;
        else
          eInitSSW := Init_Error; //Set to error that user will be notified that this feature is not supported
          LogError("@ZZZZ (NC100::InitModule) Newer FPGA-Version needed to support additional latch values. (v1.5 or greater)");
        end_if;
      end_if;
     
      //Show state on servers
      if bAdditionalLatchValuesAvailable = FALSE then
        PosLatchedInput1 := NC100_INVALID_VALUE;
        PosLatchedInput2 := NC100_INVALID_VALUE;
        PosLatchedInput3 := NC100_INVALID_VALUE;
        PosLatchedInput4 := NC100_INVALID_VALUE;
        PosLatchedZPuls := NC100_INVALID_VALUE;      
      end_if;
     
    //Write Configuration Nr. 1 to Module
    //*****************************************************************************
    Init_ConfigModule1:
       
      //Statemachine for SDO-Communication
      case eResponseState of
        
        //Idle
        //-------------------------------------------------------
        SDO_Idle:
        
          //Start SDO-Command
          tmpRetcode := StartWriteSDO(hOffset       := NC100_ADDR_INIT_MODULE, 
                                      usLength      := NC100_CFG1_SIZE, 
                                      pWriteBuffer  := (#sConfiguration)$^USINT, 
                                      eCommand      := SDIAS_SDO_CMD_MEM_WRITE);
          
          //Evaluate Returncode
          if tmpRetcode = READY then
            
            //Timestamp for TimeoutCheck
            udSDOTimeout    := ops.tAbsolute;
            eResponseState  := SDO_Wait; 
          
          //Error occured  
          elsif tmpRetcode = ERROR then
            eModuleInitState := ERROR;
            LogError("@ZZZZ (NC100::InitModule) Failed to add write SDO for Module configuration1");
            eInitState := _NoMem;
          end_if;
        
        //Wait for Response
        //-------------------------------------------------------
        SDO_Wait:
        
          //Timeout-Check
          if ((ops.tAbsolute - udSDOTimeout) > NC100_SDO_RESPONSE_TIMEOUT) then
            LogError("@ZZZZ (NC100::InitModule) SDO Response timeout config module1");
            InitSSWErrorStep  := eInitSSW;
            eInitSSW          := Init_Error;
          end_if;
          
        //Response received
        //-------------------------------------------------------
        SDO_Valid:
          eInitSSW        := Init_ConfigModule2;
          eResponseState  := SDO_Idle;
          
      end_case;
      
      
    //Write Configuration Nr. 2 to Module
    //*****************************************************************************
    Init_ConfigModule2:
      
      //Statemachine for SDO-Communication
      case eResponseState of
        
        //Idle
        //-------------------------------------------------------
        SDO_Idle:
        
          //Start SDO-Command
          tmpRetcode := StartWriteSDO(hOffset       := NC100_ADDR_INIT_MODULE + NC100_CFG2_OFFSET, 
                                      usLength      := NC100_CFG2_SIZE, 
                                      pWriteBuffer  := (#sConfiguration  + NC100_CFG2_OFFSET)$^USINT, 
                                      eCommand      := SDIAS_SDO_CMD_MEM_WRITE);
          
          //Evaluate Returncode
          if tmpRetcode = READY then
            
            //Timestamp for TimeoutCheck
            udSDOTimeout    := ops.tAbsolute;
            eResponseState  := SDO_Wait; 
          
          //Error occured  
          elsif tmpRetcode = ERROR then
            eModuleInitState := ERROR;
            LogError("@ZZZZ (NC100::InitModule) Failed to add write SDO for Module configuration2");
            eInitState := _NoMem;
          end_if;
        
        //Wait for Response
        //-------------------------------------------------------
        SDO_Wait:
        
          //Timeout-Check
          if ((ops.tAbsolute - udSDOTimeout) > NC100_SDO_RESPONSE_TIMEOUT) then
            LogError("@ZZZZ (NC100::InitModule) SDO Response timeout config module2");
            InitSSWErrorStep  := eInitSSW;
            eInitSSW          := Init_Error;
          end_if;
          
        //Response received
        //-------------------------------------------------------
        SDO_Valid:
          if EncSpeed then
            eInitSSW := Init_ReadClockFreq;
          else
            eInitSSW := Init_Finish;
          end_if;

          eResponseState  := SDO_Idle;
          
      end_case;
     
     
    //Step for Reading Frequency
    //*****************************************************************************
    Init_ReadClockFreq:
      
      //Statemachine for SDO-Communication
      case eResponseState of
      
        //Idle
        //-------------------------------------------------------
        SDO_Idle:
          
          //Start SDO-Command
          tmpRetcode  := StartReadSDO(hOffset   := (NC100_ADDR_INIT_MODULE + t_s_Settings.usClockFreq) , 
                                      usLength  := sizeof(t_s_Settings.usClockFreq), 
                                      eCommand  := SDIAS_SDO_CMD_MEM_READ);
                                      
          
          //Evaluate Returncode
          if tmpRetcode = READY then
          
            //Timestamp for TimeoutCheck
            udSDOTimeout    := ops.tAbsolute;
            eResponseState  := SDO_Wait; 
            
          //Error occured
          elsif tmpRetcode = ERROR then
          
            eInitState        := _NoMem;
            eModuleInitState  := ERROR;
            LogError("@ZZZZ (NC100::InitModule) Failed to add read SDO for read clock");
            
          end_if; 
          
        //Wait for Response
        //-------------------------------------------------------
        SDO_Wait:
        
          //Timeout-Check
          if ((ops.tAbsolute - udSDOTimeout) > NC100_SDO_RESPONSE_TIMEOUT) then
            LogError("@ZZZZ (NC100::InitModule) SDO Response timeout read clock");
            InitSSWErrorStep  := eInitSSW;
            eInitSSW          := Init_Error;
          end_if;
          
        //Response received
        //-------------------------------------------------------
        SDO_Valid:
          //60 * => Unit of Speed [rpm]
          //sConfiguration.usClockFreq [MHz] => * 1000000 for Value in [Hz]         
          //MeassureTime = PeriodPreScale / Clock => Prescaler is necessary to measure slow Speed
          //Time of one Count of Encoder per sec => Measuretime * PeriodCounter
          //Time of one Rotoation in sec = Measuretime * PeriodCounter * CPR
          //dSpeedFactor := 60 * to_dint(sConfiguration.usClockFreq) * 1000000 / ( EncCPR * to_dint(sConfiguration.usPeriodPrescale) );
          dSpeedFactor := DIV_AB_BY_C(sConfiguration.usClockFreq, 60000000, EncCPR * to_dint(sConfiguration.usPeriodPrescale));
          dFreqFactor  := 60 * 1000 / ( 4 * EncCPR );
          
          eInitSSW := Init_Finish;
          
      end_case;
    
    

    //Initialization of Module finished
    //*****************************************************************************
    Init_Finish:
            
      eInitSSW          := Init_SetVariables;
      eInitState        := _ClassOk;
      eModuleInitState  := READY;
     
   
   //Error during Initialization
   //*****************************************************************************
   Init_Error:
      
      eInitState        := _ClientNotready;
      eModuleInitState  := ERROR; 
      
  END_CASE;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL NC100::CheckDeviceID
	VAR_INPUT
		udID2Check 	: UDINT;
	END_VAR
	VAR_OUTPUT
		bIsOK 	: BOOL;
	END_VAR
  
	//Check DeviceID of Module
	if ( udID2Check <> DEVICE_ID_NC100 ) then
		bIsOK := false;
	else
    bIsOK := true;
	end_if;

END_FUNCTION


FUNCTION VIRTUAL NC100::ReceiveSDOResponse
	VAR_INPUT
		eCommand 	: t_SDIAS_SDO_Cmd;
		hOffset 	: HINT;
		usLength 	: USINT;
		eResult 	: iprStates;
		pResponseBuffer 	: ^USINT;
		ResponseLength 	: USINT;
	END_VAR
	VAR_OUTPUT
		ret_code 	: iprStates;
	END_VAR
  
  //Call Response of Base-Class
  ret_code := SdiasBase::ReceiveSDOResponse(eCommand        := eCommand, 
                                            hOffset         := hOffset, 
                                            usLength        := usLength, 
                                            eResult         := eResult, 
                                            pResponseBuffer := pResponseBuffer, 
                                            ResponseLength  := ResponseLength);
  
  // spi access from baseclass                                         
  if bSDOResponseHandle = TRUE then
    return;
  end_if;
  
  //Evaluate Result of SDO
  //----------------------------------------------------------------------------
  if eResult = READY then
    
    //Check Type of SDO-Command
    case eCommand of
    
      //Memory Write
      SDIAS_SDO_CMD_MEM_WRITE:
      
        //Check Address
        case hOffset of
          NC100_ADDR_INIT_MODULE:
            if eResponseState = SDO_Wait then
              eResponseState := SDO_Valid;
            end_if; 
          NC100_ADDR_INIT_MODULE + NC100_CFG2_OFFSET:
            if eResponseState = SDO_Wait then
              eResponseState := SDO_Valid;
            end_if; 
          else
            LogError("@ZZZZ (NC100::ReceiveSDOResponse) Invalid Offset in Write-Response of SDO");
        end_case;
        
      //Memory Read
      SDIAS_SDO_CMD_MEM_READ:
      
        //Check Address
        case hOffset of
          NC100_ADDR_INIT_MODULE + t_s_Settings.usClockFreq:
            if eResponseState = SDO_Wait then
              eResponseState := SDO_Valid;
            end_if;
            sConfiguration.usClockFreq := pResponseBuffer^;
          else
            LogError("@ZZZZ (NC100::ReceiveSDOResponse) Invalid Offset in Read-Response of SDO");
        end_case;
        
    end_case;
    
    //Check if Class was in Valid State for SDO Response
    if eResponseState <> SDO_Valid then
      LogError("@ZZZZ (NC100::ReceiveSDOResponse) Class in wrong State during Response of SDO");
      eInitSSW := Init_Error;      
    end_if;
  
  
  //Problem with Response
  //----------------------------------------------------------------------------
  else
  
    //Check Type of SDO-Command to set correct Log-Message
    case eCommand of
      SDIAS_SDO_CMD_MEM_WRITE:
        LogError("@ZZZZ (NC100::ReceiveSDOResponse) Error while writing the Firmware Configuration");
      SDIAS_SDO_CMD_MEM_READ:
        LogError("@ZZZZ (NC100::ReceiveSDOResponse) Error while waiting for the Clock Settings");
    end_case;
    
    eInitSSW := Init_Error;
    
  end_if;

END_FUNCTION


FUNCTION VIRTUAL NC100::GetTaskCfg
	VAR_OUTPUT
		TaskCfg 	: BDINT;
	END_VAR

  TaskCfg := SDIAS_TASK_MASK_RT_PRE OR SDIAS_TASK_MASK_RT_POST;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL NC100::Input1Latched::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

  //Return Latch
	output := Input1Latched;
  
  //Reset Latch in next rt-run
  bsLatchReaded.DigIn1 := TRUE;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL NC100::Input2Latched::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

  //Return Latch
	output := Input2Latched;
  
  //Reset Latch in next rt-run
  bsLatchReaded.DigIn2 := TRUE;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL NC100::Input3Latched::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

  //Return Latch
	output := Input3Latched;
  
  //Reset Latch in next rt-run
  bsLatchReaded.DigIn3 := TRUE;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL NC100::Input4Latched::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

  //Return Latch
	output := Input4Latched;
  
  //Reset Latch in next rt-run
  bsLatchReaded.DigIn4 := TRUE;

END_FUNCTION


FUNCTION VIRTUAL NC100::GetDeviceID
	VAR_OUTPUT
		output 	: UDINT;
	END_VAR
  
  output := DEVICE_ID_NC100;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL NC100::AddAccesses
	VAR_OUTPUT
		eModuleInitState 	: iprStates;
	END_VAR
     
  // Only add accesss when enabled
  if AdditionalLatchInfo then
    
    // No default access available, add write access here
    if AddRdAccess(hOffset              := NC100_ADDR_CYC_READ_LATCH
                 , uLength              := sizeof(t_s_ReadDataLatch)
                 , ppData               := #pReadDataLatch
                 , ppStateByte          := #sReadAccess.pStateByte
                 , ppControlByte        := #sReadAccess.pControlByte
                 , pAccessHandle        := #sReadAccess.AccessHandle
                 ) <> READY then
      LogError("@ZZZZ (NC100::AddAccesses) Adding read access for additional Latch values failed.");
    end_if;
  end_if;
  
  eModuleInitState := READY; 

END_FUNCTION
