//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
//*****************************************************************************
//** constants for interfacing the vst011-module through async-interface     **
//*****************************************************************************
#define VST_ASYNC_CHOPPEROFFTIME                     0
#define VST_ASYNC_FASTDECAYTIME                      1
#define VST_ASYNC_FREQUENCYLIMIT32                   2
#define VST_ASYNC_FREQUENCYLIMIT16                   3
#define VST_ASYNC_FREQUENCYLIMIT8                    4 
#define VST_ASYNC_FREQUENCYLIMIT4                    5 
#define VST_ASYNC_FREQUENCYLIMIT2                    6 
#define VST_ASYNC_FREQUENCYLIMIT1                    7
#define VST_ASYNC_EXTERNALLOCKDELTAFREQUENCY         8
#define VST_ASYNC_EXTERNALLOCKDELTATIME              9
#define VST_ASYNC_INCREMENTALENCODERSETTINGS        10
#define VST_ASYNC_BLANKINGTIMEREGISTER              11
#define VST_ASYNC_BRIDGE2OFF                        12
#define VST_ASYNC_BRIDGE2MUL                        13
#define VST_ASYNC_BRIDGE2DIV                        14
#define VST_ASYNC_BRIDGE1OFF                        15
#define VST_ASYNC_BRIDGE1MUL                        16
#define VST_ASYNC_BRIDGE1DIV                        17
#define VST_ASYNC_BRIDGESUPPLYVOLTAGELOWERTHRESHOLD 18
#define VST_ASYNC_BRIDGESUPPLYVOLTAGEUPPERTHRESHOLD 19
#define VST_ASYNC_BRIDGETEMPERATUREWARNINGTHRESHOLD 20
#define VST_ASYNC_BRIDGETEMPERATUREERRORTHRESHOLD   21
#define VST_ASYNC_EXTENDEDSTATEWORD                 22
#define VST_ASYNC_COMMUTATIONCOUNTERBRIDGE1         23
#define VST_ASYNC_COMMUTATIONCOUNTERBRIDGE2         24
#define VST_ASYNC_ONTIMECOUNTERBRIDGE1              25
#define VST_ASYNC_ONTIMECOUNTERBRIDGE2              26
#define VST_ASYNC_HBRIDGE_VOLTAGE                   27
#define VST_ASYNC_HBRIDGE_TEMPERATURE               28

#define VST011_MAXASYNCPARAMETER VST_ASYNC_HBRIDGE_TEMPERATURE

//*****************************************************************************
//** error values for returncodes of async-interface                         **
//*****************************************************************************
#define VST_ERROR_ASYNC_NOERROR 0
#define VST_ERROR_ASYNC_INVALIDPARAMETER -1   
        //Invalid Parameter-Number
#define VST_ERROR_ASYNC_NOVALUEPTR -2         
        //ReadParameter has been called but p_ud_Value was NIL
#define VST_ERROR_ASYNC_WRITENOTALLOWED -3    
        //This Parameter cannot be written
#define VST_ERROR_ASYNC_ALREADYACTIVE -4      
        //RequestParameter: This Parameter is already active for reading,
        //                  Request not started
        //WriteParameter: This Parameter is already active for writing,
        //                New Value will be sent


//*****************************************************************************
//** ID Numbers for extern Call (ExtendedStateWord, HBridgeInfo)             **
//*****************************************************************************
#define   VST_ID_CLASSESAVAILABLE     2
#define   VST_ID_EXTENDEDSTATEWORD    0
#define   VST_ID_HBRIDGEINFO          1

//*****************************************************************************
//** constants for internal use in hw-class                                  **
//*****************************************************************************
#define VST011_DEVICE_ID              1114
#define VST011_OFFSET_READ_DATA       16#40
#define VST011_OFFSET_WRITE_DATA      16#00
#define VST011_OFFSET_SETTINGS        16#08

//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "VST011"
	Revision           = "1.53"
	GUID               = "{00DEA3D6-9AE2-4D3C-84CD-EA7185C3921A}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\Varan_16x16.ico"
	SharedCommandTable = "true"
	Objectsize         = "(924,120)"
	Comment            = "The VST 011 is a VARAN module designed for the&#13;&#10;control of a stepper motor up to a maximum 5.0 A.&#13;&#10;The available operating modes are full step, half&#13;&#10;step and micro step. The maximum switching&#13;&#10;frequency of the output stage is 50 kHz.">
	<Channels>
		<Server Name="ActPosition" GUID="{CB4741F9-619E-4B17-A4CD-B2DE0877AB5D}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Actual internal Step-Position of VST011"/>
		<Server Name="BlankingTime" GUID="{0305DD18-E0C5-4BC0-A103-18E5EF1FE7B7}" Visualized="true" Initialize="true" DefValue="10" WriteProtected="false" Retentive="false" Comment="[20ns steps]&#13;&#10;minimum on-time of the PWM"/>
		<Server Name="ChopperOffTime" GUID="{12AF8807-BCED-44E1-84A2-6A8C8231D43E}" Visualized="true" Initialize="true" DefValue="200" WriteProtected="false" Retentive="false" Comment="[20ns steps]&#13;&#10;fixed off-time of the PWM"/>
		<Server Name="ControlWord" GUID="{FB73BA67-7C1C-44FD-A58C-604806DB1B1F}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="SwitchOn + Enable: Enable Motor&#13;&#10;ResetFault: Quit Error&#13;&#10;ManufactureSpec1: CurrentIncrease allowed"/>
		<Server Name="CurrentIncrease" GUID="{9CE8E6E9-0BA3-40ED-AEDA-9DD374A29306}" Visualized="true" Initialize="true" DefValue="1" WriteProtected="false" Retentive="false" Comment="allow sqrt(2) current increase in halfstep mode&#13;&#10;&#13;&#10;in microstep mode the increase is always active"/>
		<Server Name="Enable" GUID="{D20046BC-08FE-4E69-924E-B31DC7577FDA}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Turn on the output stage of the VST011"/>
		<Server Name="EncoderPosition" GUID="{2040F036-2364-4DD7-94B9-62DFEE5DF3B9}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="actual number of edges counted"/>
		<Server Name="Error" GUID="{A800904E-319F-4A8E-BE57-7048CB1ACBF3}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Fault of power-stage&#13;&#10;(eg. over temperature, over current, power not connected)"/>
		<Server Name="ErrorQuit" GUID="{638636F2-BD4A-4D1A-B4FD-75B451C389E5}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="quits error if server &quot;Error&quot; is set"/>
		<Server Name="ExternalEnable" GUID="{4396BBE9-270A-453B-9E40-9DCAC86BEDDC}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="State of the external enable input (0 = Error)"/>
		<Server Name="FastDecayTime" GUID="{38DFF8E4-D7DC-4749-8F57-7F0F98D0166A}" Visualized="true" Initialize="true" DefValue="120" WriteProtected="false" Retentive="false" Comment="[20ns steps]&#13;&#10;ATTENTION:&#13;&#10;Must not be greater than chopper off time!"/>
		<Server Name="FrequencyBandwidth" GUID="{86DF3772-BEB3-46C1-AA8E-E5133F8DAA63}" Visualized="true" Initialize="true" DefValue="0" WriteProtected="false" Retentive="false" Comment="Bandwith for the FrequencyLimits&#13;&#10;Example:&#13;&#10;Frequencylimit = 8000&#13;&#10;Frequencybandwith = 100&#13;&#10; &#13;&#10;=&gt; Frequencyhighlimit = 8050&#13;&#10;=&gt; Frequencylowlimit  = 7950&#13;&#10;"/>
		<Server Name="FrequencyLimit1" GUID="{A394CE44-00BD-413B-93F4-D6D2FF6CAE5F}" Visualized="true" Initialize="true" DefValue="140000" WriteProtected="false" Retentive="false" Comment="Frequency limit for entering fullstep mode&#13;&#10;If frequency is greater or equal this limit fullstep mode is used&#13;&#10;Set to 16#FFFFFFFF to disable this limit"/>
		<Server Name="FrequencyLimit16" GUID="{7CBAAE20-EF7D-4527-A41B-08F524ADD4A6}" Visualized="true" Initialize="true" DefValue="16#FFFF_FFFF" WriteProtected="false" Retentive="false" Comment="Frequency limit for entering 16-microstep mode&#13;&#10;If frequency is greater or equal this limit 16-microstep mode is used&#13;&#10;Set to 16#FFFFFFFF to disable this limit"/>
		<Server Name="FrequencyLimit2" GUID="{D564F5F4-23CC-4917-98E3-3F881E7FF3B3}" Visualized="true" Initialize="true" DefValue="80000" WriteProtected="false" Retentive="false" Comment="Frequency limit for entering halfstep mode&#13;&#10;If frequency is greater or equal this limit halfstep mode is used&#13;&#10;Set to 16#FFFFFFFF to disable this limit"/>
		<Server Name="FrequencyLimit32" GUID="{3B0AE01A-6F25-4202-A11D-606C0C45C4DD}" Visualized="true" Initialize="true" DefValue="0" WriteProtected="false" Retentive="false" Comment="Frequency limit for entering 32-microstep mode&#13;&#10;If frequency is greater or equal to this limit 32-microstep mode is used&#13;&#10;Set to 16#FFFFFFFF to disable this limit"/>
		<Server Name="FrequencyLimit4" GUID="{9FB7EBA3-68AA-40C6-9060-C0F74E3B9E21}" Visualized="true" Initialize="true" DefValue="16#FFFF_FFFF" WriteProtected="false" Retentive="false" Comment="Frequency limit for entering 4-microstep mode&#13;&#10;If frequency is greater or equal this limit 4-microstep mode is used&#13;&#10;Set to 16#FFFFFFFF to disable this limit"/>
		<Server Name="FrequencyLimit8" GUID="{4FFEFCEE-D8B7-4948-8ABB-79C36699CC95}" Visualized="true" Initialize="true" DefValue="30000" WriteProtected="false" Retentive="false" Comment="Frequency limit for entering 8-microstep mode&#13;&#10;If frequency is greater or equal this limit 8-microstep mode is used&#13;&#10;Set to 16#FFFFFFFF to disable this limit"/>
		<Server Name="HWEnableSoftwareRampdown" GUID="{CA7E1234-B862-4227-A48F-D71311721ED8}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment=" 0 ... HardwareRampdown&#13;&#10; 1 ... SoftwareRampdown"/>
		<Server Name="HWError" GUID="{02D8BF38-7478-4010-ADC1-13D7ECE36EF2}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Hardwareerror state for CNC Class ( 1 = Error )"/>
		<Server Name="HWRampdownDeltaFrequency" GUID="{CDC7DC98-E6CE-40ED-9D42-E9EBCC75EB78}" Visualized="true" Initialize="true" DefValue="40" WriteProtected="false" Retentive="false" Comment="If the enable-signal is lost the output frequency is decreased by HWRampdownDeltaFrequency every HWRampdownDeltaTime"/>
		<Server Name="HWRampdownDeltaTime" GUID="{74C8269A-0DCB-4DBE-9B67-B0E6463E76B8}" Visualized="true" Initialize="true" DefValue="1" WriteProtected="false" Retentive="false" Comment="[20ns steps]&#13;&#10;If the enable-signal is lost the output frequency is decreased by HWRampdownDeltaFrequency every HWRampdownDeltaTime"/>
		<Server Name="Input1" GUID="{AF726CED-D4F9-4589-AC2F-DF8855B29CF7}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="first digital input"/>
		<Server Name="Input1LatchedFalling" GUID="{095100EE-7FC8-4F37-B867-AD3E7FF7464E}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="latched falling edge of first digital input&#13;&#10;signal will stay until read-method is called"/>
		<Server Name="Input1LatchedRising" GUID="{14352005-9866-42D1-9215-CBFA43E5743E}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="latched rising edge of first digital input&#13;&#10;signal will stay until read-method is called"/>
		<Server Name="Input2" GUID="{D06D9F8F-3480-4211-AED3-84B88AE834FA}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="second digital input"/>
		<Server Name="Input2LatchedFalling" GUID="{81A8ACDE-1528-4F0D-86C5-3DE3D72106A1}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="latched falling edge of second digital input&#13;&#10;signal will stay until read-method is called"/>
		<Server Name="Input2LatchedRising" GUID="{D77CEA77-B0A4-4A27-9FF9-2C12C531A360}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="latched rising edge of second digital input&#13;&#10;signal will stay until read-method is called"/>
		<Server Name="Input3" GUID="{606B2011-F413-45BD-A050-82B70545C4FF}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="third digital input"/>
		<Server Name="Input4" GUID="{D782AE27-3BD8-41A1-BB00-D1270E5E07AD}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="fourth digital input"/>
		<Server Name="LatchPositionEncoderZeroPulse" GUID="{53461B08-0FCA-4711-9F56-64E074A78A0C}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Latched position of encoder zero pulse"/>
		<Server Name="LatchPositionInput1Falling" GUID="{D9E87B23-A108-4AB2-AAB8-110B1F2699B9}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Latched position of falling edge of input 1"/>
		<Server Name="LatchPositionInput1Rising" GUID="{C14BD202-0041-4802-AF22-A9F87954808F}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Latched position of rising edge of input 1"/>
		<Server Name="LatchPositionInput2Falling" GUID="{2D3A6C73-4514-4C20-B888-F681E9000E9E}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Latched position of falling edge of input 2"/>
		<Server Name="LatchPositionInput2Rising" GUID="{69C7D4FC-9C71-4D31-A82C-CD3FA8BB7F59}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Latched position of rising edge of input 2"/>
		<Server Name="MaxCurrent" GUID="{60426EEE-209C-4723-BFBD-239CA763ACEE}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="File" Comment="[mA] maximum output current (effectiv value)&#13;&#10;&#13;&#10;Value is retentive in File, no cyclic Change of Value recommended."/>
		<Server Name="Output1" GUID="{2E944A80-74B6-4A3F-9AF1-7FCDB9BB1769}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="first digital output"/>
		<Server Name="Output2" GUID="{837BB2FA-3179-4B3E-A2F1-BF46816D85C2}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="second digital output"/>
		<Server Name="Output3" GUID="{5225BBBE-2CB4-4412-BDEB-E807AEA0C105}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="third digital output"/>
		<Server Name="Output4" GUID="{D74142C0-21C8-4BF6-8A5E-B652FC45A705}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="fourth digital output"/>
		<Server Name="SetFreqOut" GUID="{EC6FFC46-03C7-476C-9E73-D3AC32F98810}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Frequency in Hz of one Microstep&#13;&#10;32 Microsteps = 1 Fullstep"/>
		<Server Name="StallCurrentReduction" GUID="{9955352B-0992-4F71-A26C-59DD17676E4B}" Visualized="true" Initialize="true" DefValue="0" WriteProtected="false" Retentive="false" Comment="Value to reduce MaxCurrent for the Stop Position [0,1%]. Defaultvalue: 0 (no reduction in the stop position)&#13;&#10;Range: 0 - 1000 (0-100%)&#13;&#10;Stop Position means, the value of the server SetFreqOut is lower than the StallCurrentWindow, which can be set via the method SetStallCurrentWindow and is 0 by default."/>
		<Server Name="StateWord" GUID="{F76CD397-F943-4E14-B2BA-6344A5C37D80}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Statusword with DS402 Standard :&#13;&#10;&#13;&#10;Bit00 .. ReadyToSwitchOn&#13;&#10;Bit01 .. SwitchedOn&#13;&#10;Bit02 .. OperationEnabled&#13;&#10;Bit03 .. Fault&#13;&#10;Bit04 .. VoltageDisabled&#13;&#10;Bit05 .. QuickStop&#13;&#10;Bit06 .. SwitchOnDisabled&#13;&#10;Bit07 .. Warning&#13;&#10;Bit08 .. ManufactureSpecific1&#13;&#10;Bit09 .. Remote&#13;&#10;Bit10 .. TargetReached&#13;&#10;Bit11 .. InternalLimitActive&#13;&#10;Bit12 .. OperationModeSpecific1&#13;&#10;Bit13 .. OperationModeSpecific2&#13;&#10;Bit14 .. Manufacture Specific2&#13;&#10;Bit15 .. Manufacture Specific3"/>
		<Server Name="VaranOut_1" GUID="{18B6C5E8-D690-45F5-8ADD-5DCF200BD28C}" Class="Hub_Base" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="connect a varan client class"/>
		<Server Name="ZeroPulse_latched" GUID="{BD2B4B80-3A27-4D41-9670-A15B07A4C215}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="is 1 if incremental zero position is passed&#13;&#10;signal will stay until read-method is called"/>
		<Client Name="EncoderSampling" Required="true" Internal="false" DefValue="3" Comment="0 .. Encoder off&#13;&#10;1 .. 1-edge&#13;&#10;2 .. 2-edge&#13;&#10;3 .. 4-edge&#13;&#10;as initvalue"/>
		<Client Name="Hub_Base1" Required="true" Internal="true"/>
		<Client Name="InvertEncoder" Required="true" Internal="false" DefValue="0" Comment="0 .. Phase B non-inverted&#13;&#10;1 .. Phase B inverted&#13;&#10;(as initvalue)&#13;&#10;&#13;&#10;"/>
		<Client Name="InvertZeroPosition" Required="true" Internal="false" DefValue="0" Comment="inverts server ZeroPosition (0..normal, 1..inverted)&#13;&#10;as initvalue"/>
		<Client Name="LatchedValueInput1Falling" Required="false" Internal="false" Comment="latched value is written once directly after fetching"/>
		<Client Name="LatchedValueInput1Rising" Required="false" Internal="false" Comment="latched value is written once directly after fetching"/>
		<Client Name="LatchedValueInput2Falling" Required="false" Internal="false" Comment="latched value is written once directly after fetching"/>
		<Client Name="LatchedValueInput2Rising" Required="false" Internal="false" Comment="latched value is written once directly after fetching"/>
		<Client Name="LatchedValueZeroPosition" Required="false" Internal="false" Comment="latched value is written once directly after fetching"/>
		<Client Name="LatchType" Required="true" Internal="false" DefValue="0" Comment="0 .. latch virtual counter&#13;&#10;1 .. latch incremental encoder&#13;&#10;as initvalue"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="BleErn"/>
		<Dokumentation Revision="1.53" Date="07.04.2020" Author="EisMic" Company="Sigmatek" Description="Changed comment of client &quot;UserAction&quot; in Varan_Base class."/>
		<Dokumentation Revision="1.52" Date="09.12.2019" Author="LanSte" Company="Sigmatek" Description="Added Server ProtocolVersion. InterframeGap is included in the resource calculation."/>
		<Dokumentation Revision="1.51" Date="08.06.2018" Author="RamAnd" Company="Sigmatek" Description="LASAL Hardware Description (.lhd) file has been updated."/>
		<Dokumentation Revision="1.50" Date="16.01.2018" Author="LanSte" Company="Sigmatek" Description="Added PostInit Support."/>
		<Dokumentation Revision="1.49" Date="19.09.2017" Author="LanSte" Company="Sigmatek" Description="Fixed Access Exception when using PayloadFrame/DMA. Error only occurred in revision 1.48."/>
		<Dokumentation Revision="1.48" Date="06.12.2016" Author="PieSte" Company="Sigmatek" Description="Changed &quot;Online&quot; server behavior to set online first if cyclic data is valid due to SA35740."/>
		<Dokumentation Revision="1.47" Date="10.05.2016" Author="RamAnd" Company="Sigmatek" Description="Suppressed warning that would occur with target ARM on compiler version 30 or higher."/>
		<Dokumentation Revision="1.46" Date="15.05.2015" Author="EisMic" Company="Sigmatek" Description="Added ifdef IsTransparent_IS_AVAILABLE at call of IsTransparent in initialisation method."/>
		<Dokumentation Revision="1.45" Date="16.04.2015" Author="PieSte&#13;&#10;LanSte" Company="Sigmatek" Description="Added support for visualisation in graphical hardware editor.&#13;&#10;Added support for calculating resources for graphical hardware editor."/>
		<Dokumentation Revision="1.44" Date="24.03.2015" Author="EisMic" Company="Sigmatek" Description="Check pointer p_NodeInfo for validity in method GetRetryTimeout due to access exception error if method Varan_HWDisconnect is called and no hardware was available."/>
		<Dokumentation Revision="1.43" Date="25.07.2014" Author="LanSte" Company="Sigmatek" Description="Added Support for reading hardware diagnose and hardwaretree entry."/>
		<Dokumentation Revision="1.42" Date="06.05.2014" Author="LanSte" Company="Sigmatek" Description="Improved Transparent property description in HW-Tree and activated greying out of the object in the HW-Tree.&#13;&#10;Minimized the interface request via CILGET by useing private pointers to reduce time in init."/>
		<Dokumentation Revision="1.41" Date="07.04.2014" Author="EisMic" Company="Sigmatek" Description="Called SetDOsOff in method Varan_HWInterrupt."/>
		<Dokumentation Revision="1.40" Date="12.02.2014" Author="PieSte" Company="Sigmatek" Description="Add Required client in HWEditor"/>
		<Dokumentation Revision="1.30" Date="04.12.2013" Author="ObeChr&#13;&#10;LanSte" Company="Sigmatek" Description="Following Server are now retentive in File: MaxCurrent, StallCurrentReduction&#13;&#10;Added Payload Support"/>
		<Dokumentation Revision="1.20" Date="07.03.2013" Author="LanSte" Company="Sigmatek" Description="Improved Client/Server Comments"/>
		<Dokumentation Revision="1.10" Date="31.10.2012" Author="ZoePat&#13;&#10;RamAnd&#13;&#10;RamAnd" Company="Sigmatek" Description="Corrected error where a latched input wasn&apos;t fetched any more (if the edge occurs at least twice within 6 cycles)&#13;&#10;Changed default init value of server FrequencyBandwidth from 500 to 0 for compatibility reasons.&#13;&#10;Asynchronous parameters are now only written if they have changed."/>
		<Dokumentation Revision="1.3" Date="29.08.2012" Author="RamAnd" Company="Sigmatek" Description="The Init-Value of the Latchtype wasn&apos;t used. Now it&apos;s written to the control word."/>
		<Dokumentation Revision="1.2" Date="27.06.2012" Author="ObeChr" Company="Sigmatek" Description="Reduced cyclic load due to asynchrony communication by about factor 2&#13;&#10;Changed initvalues of server CurrentIncrease, ChopperOffTime, FastDecayTime, FrequencyLimit 1/2/8/32 to more reasonable values&#13;&#10;Additional VST-classes are now called from this class instead of having an own task&#13;&#10;Removed macros for DO handling to improve clarity&#13;&#10;Added stall current setting to avoid motor overheating&#13;&#10;Implementation of a Hysteresis for the frequency-limits to avoid continous changing of the stepping modes if the motor is used in a limit area.&#13;&#10;Implemented time measurement for internal tests in methods UpdateRt, UpdateRtPostScan and UpdateCy"/>
		<Dokumentation Revision="1.1" Date="19.04.2012" Author="HasHan" Company="Sigmatek" Description="Server CurrentIncrease can now be initialized"/>
		<Dokumentation Revision="1.0" Date="20.04.2011" Author="BleErn" Company="Sigmatek" Description="First library version"/>
		<Dokumentation Revision="0.5" Date="18.03.2011" Author="BleErn" Company="Sigmatek" Description="changed handling of calibration data"/>
		<Dokumentation Revision="0.4" Date="11.03.2011" Author="BleErn" Company="Sigmatek" Description="added safety-toggle-bit, added server safety ok"/>
		<Dokumentation Revision="0.3" Date="09.03.2011" Author="BleErn" Company="Sigmatek" Description="third testversion"/>
		<Dokumentation Revision="0.2" Date="09.03.2011" Author="BleErn" Company="Sigmatek" Description="second testversion"/>
		<Dokumentation Revision="0.1" Date="29.09.2010" Author="RamAnd" Company="Sigmatek" Description="First testversion"/>
	</RevDoku>
	<Network Name="VST011">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{C64867F1-C281-4DF5-8511-88FAD2BE1B96}"
				Class      = "Varan_Base"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ConnectCounter"/>
					<Server Name="DeviceAddress"/>
					<Server Name="DeviceID"/>
					<Server Name="DiagControl"/>
					<Server Name="FaultCounter"/>
					<Server Name="Online"/>
					<Server Name="ProtocolVersion"/>
					<Server Name="Release"/>
					<Server Name="RetryCounter"/>
					<Server Name="RXLost"/>
					<Server Name="SerialNo"/>
					<Server Name="State"/>
					<Server Name="TXLost"/>
					<Server Name="ValidateSerNo"/>
					<Server Name="VendorID"/>
					<Client Name="Required" Value="1"/>
					<Client Name="SerNoValidation"/>
					<Client Name="TimeBase" Value="0"/>
					<Client Name="TimeBaseOffset" Value="0"/>
					<Client Name="To_MultiTask"/>
					<Client Name="To_StdLib"/>
					<Client Name="Transparent" Value="0"/>
					<Client Name="UserAction"/>
					<Client Name="VaranIn"/>
				</Channels>
			</Object>
			<Object
				Name       = "Hub_Base1"
				GUID       = "{EBB55E07-864F-40D7-8E47-2B928C29A485}"
				Class      = "Hub_Base"
				Position   = "(720,3000)"
				Visualized = "true">
				<Channels>
					<Server Name="Control"/>
					<Client Name="Splitter_Place" Value="0"/>
					<Client Name="VaranIn"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.State" Destination="_base.State" Vertices="(1318,210),(702,210),"/>
			<Connection Source="this.Online" Destination="_base.Online" Vertices="(1318,270),(702,270),"/>
			<Connection Source="this.Release" Destination="_base.Release" Vertices="(1318,330),(702,330),"/>
			<Connection Source="this.DeviceAddress" Destination="_base.DeviceAddress" Vertices="(1318,390),(702,390),"/>
			<Connection Source="this.VendorID" Destination="_base.VendorID" Vertices="(1318,450),(702,450),"/>
			<Connection Source="this.DeviceID" Destination="_base.DeviceID" Vertices="(1318,510),(702,510),"/>
			<Connection Source="this.SerialNo" Destination="_base.SerialNo" Vertices="(1318,570),(702,570),"/>
			<Connection Source="this.RetryCounter" Destination="_base.RetryCounter" Vertices="(1318,630),(702,630),"/>
			<Connection Source="this.ValidateSerNo" Destination="_base.ValidateSerNo" Vertices="(1318,690),(702,690),"/>
			<Connection Source="this.Hub_Base1" Destination="Hub_Base1.Control"/>
			<Connection Source="this.VaranOut_1" Destination="Hub_Base1.Control" Vertices="(1318,3450),(1146,3090),"/>
			<Connection Source="Hub_Base1.VaranIn" Destination="_base.State" Vertices="(720,3090),(720,210),(702,210),"/>
			<Connection Source="_base.VaranIn" Destination="this.VaranIn" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.Required" Destination="this.Required" Vertices="(218,270),(38,270),"/>
			<Connection Source="_base.UserAction" Destination="this.UserAction" Vertices="(218,330),(38,330),"/>
			<Connection Source="_base.SerNoValidation" Destination="this.SerNoValidation" Vertices="(218,390),(38,390),"/>
			<Connection Source="_base.Transparent" Destination="this.Transparent" Vertices="(218,450),(38,450),"/>
			<Connection Source="this.ProtocolVersion" Destination="_base.ProtocolVersion" Vertices="(1318,750),(702,1050),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using Varan_Base

VST011 : CLASS
: Varan_Base
	TYPE
#pragma pack(push, 1)
	  t_AsyncDO : STRUCT
	    p_Handle : ^LSL_VARANFRAME;
	    p_DOSettings : ^t_VaranDOSettingsRdWr;
	    p_DataRead : ^UDINT;
	    p_DataWrite : ^UDINT;
	    us_OldRetryCounter : USINT;
	    b_DOIsRunning : t_SingleRunState;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_AsyncReadData : STRUCT
	    ud_Value : UDINT;
	    b_Valid : BOOL;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_AsyncWriteData : STRUCT
	    us_ID : USINT;
	    ud_Value : UDINT;
	  END_STRUCT;
#pragma pack(pop)
	  t_bd_Values : BDINT
	  [
	    1 ChopperOffTime,
	    2 FastDecayTime,
	    3 FrequencyLimit32,
	    4 FrequencyLimit16,
	    5 FrequencyLimit8,
	    6 FrequencyLimit4,
	    7 FrequencyLimit2,
	    8 FrequencyLimit1,
	    9 SafetyDeltaFrequency,
	    10 SafetyDeltaTime,
	    11 IncrementalEncoderSettings,
	    12 BlankingTimeRegister,
	    13 Bridge2Off,
	    14 Bridge2Mul,
	    15 Bridge2Div,
	    16 Bridge1Off,
	    17 Bridge1Mul,
	    18 Bridge1Div,
	    19 BridgeSupplyVoltageLowerThreshold,
	    20 BridgeSupplyVoltageUpperThreshold,
	    21 BridgeTemperatureWarningThreshold,
	    22 BridgeTemperatureErrorThreshold,
	    23 ExtendedStateWord,
	    24 CommutationCounterBridge1,
	    25 CommutationCounterBridge2,
	    26 OntimeCounterBridge1,
	    27 OntimeCounterBridge2,
	  ];
	  t_bs_IsyncValue : BSINT
	  [
	    1 IncZero,
	    2 DigIn1Rise,
	    3 DigIn1Fall,
	    4 DigIn2Rise,
	    5 DigIn2Fall,
	  ];
#pragma pack(push, 1)
	  t_Call : STRUCT
	    bActive : BOOL;
	    pThis : ^void;
	  END_STRUCT;
#pragma pack(pop)
	  t_ControlWord : BINT
	  [
	    1 SwitchOn,
	    2 FaultReset,
	    3 CurrentDropEnable,
	    4 CurrentIncrease,
	    5 HWEnableSofwareRampdownToggleBit,
	    12 LatchType,  //! <Type Comment="0 .. internal counter&#13;&#10;1 .. incremental encoder" Name="t_ControlWord.LatchType"/>
	    13 DigOut1,
	    14 DigOut2,
	    15 DigOut3,
	    16 DigOut4,
	  ];
#pragma pack(push, 1)
	  t_FrequencyLimits : STRUCT
	    LimitLow : UDINT;  //! <Type Comment="save the lower limit" Name="t_FrequencyLimits.LimitLow"/>
	    LimitHigh : UDINT;  //! <Type Comment="save the higher limit" Name="t_FrequencyLimits.LimitHigh"/>
	  END_STRUCT;
#pragma pack(pop)
	  t_StatusWord : BINT
	  [
	    1 MotorEnabled,
	    2 Fault,
	    3 TemperatureOk,
	    4 OverCurrent,
	    5 ExternalEnable,
	    6 BridgeOK,
	    8 LatchIncZero,
	    9 LatchDigIn1Rise,
	    10 LatchDigIn1Fall,
	    11 LatchDigIn2Rise,
	    12 LatchDigIn2Fall,
	    13 DigIn1,
	    14 DigIn2,
	    15 DigIn3,  //! <Type Comment="Low bit of failure state depending on InternalLimitActive bit&#13;&#10;&#13;&#10;Meaning:&#13;&#10;2#00...No failure&#13;&#10;2#01...Overtemperature failure&#13;&#10;2#10...Overcurrent failure" Name="t_StatusWord.DigIn3"/>
	    16 DigIn4,  //! <Type Comment="High bit of failure state depending on InternalLimitActive bit&#13;&#10;&#13;&#10;Meaning:&#13;&#10;2#00...No failure&#13;&#10;2#01...Overtemperature failure&#13;&#10;2#10...Overcurrent failure" Name="t_StatusWord.DigIn4"/>
	  ];
#pragma pack(push, 1)
	  t_ReadDataType : STRUCT
	    StateWord : t_StatusWord;
	    ActPos : UINT;
	    IncrementalEncoderValue : UINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_WriteDataType : STRUCT
	    SetFrequency : DINT;
	    ControlWord : t_ControlWord;
	    MaximumCurrent : UINT;
	  END_STRUCT;
#pragma pack(pop)
	  t_IO_DO : STRUCT
	    p_Handle : ^LSL_VARANFRAME;
	    p_DOSettings : ^t_VaranDOSettingsRdWr;
	    p_DataRead : ^t_ReadDataType;
	    p_DataWrite : ^t_WriteDataType;
	    s_DataWrite : t_WriteDataType;
	    us_OldRetryCounter : USINT;
	  END_STRUCT;
#pragma pack(push, 1)
	  t_ISyncReadDO : STRUCT
	    p_Handle : ^LSL_VARANFRAME;
	    p_DOSettings : ^t_VaranDOSettingsRd;
	    p_DataRead : ^UINT;
	    us_OldRetryCounter : USINT;
	    b_DOIsRunning : t_SingleRunState;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_LastWrittenValues : STRUCT
	    Value : UDINT;
	    AlreadyUsed : BOOL;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_SettingsDataType : STRUCT
	    ChopperOffTime : UINT;
	    FastDecayTime : UINT;
	    FrequencyLimit32 : UDINT;
	    FrequencyLimit16 : UDINT;
	    FrequencyLimit8 : UDINT;
	    FrequencyLimit4 : UDINT;
	    FrequencyLimit2 : UDINT;
	    FrequencyLimit1 : UDINT;
	    HWRampdownDeltaFrequency : UINT;
	    HWRampdownDeltaTime : UINT;
	    IncrementalEncoderSettings : BSINT
	    [
	      1 ZeroPosInversion,
	      2 PhaseBInversion,
	      3 EdgeSampling1,
	      4 EdgeSampling2,
	      5 TestInputSignal,
	      6 DCDC_VCCInEnable,
	      7 DCDC_VCCOutEnable,
	    ];
	    BlankingTimeRegister : USINT;
	    Bridge2Off : INT;
	    Bridge2Mul : INT;
	    Bridge2Div : UINT;
	    Bridge1Off : INT;
	    Bridge1Mul : INT;
	    Bridge1Div : UINT;
	    BridgeSupplyVoltageLowerThreshold : UINT;
	    BridgeSupplyVoltageUpperThreshold : UINT;
	    BridgeTemperatureWarningThreshold : UINT;
	    BridgeTemperatureErrorThreshold : UINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_SPI_CalibData : STRUCT
	    SPI_Header : t_SPI_CalibHeader;
	    Offset0 : INT;
	    Multiplier0 : INT;
	    Divisor0 : UINT;
	    Offset1 : INT;
	    Multiplier1 : INT;
	    Divisor1 : UINT;
	    AI1Offset : INT;
	    AI1Multiplikator : INT;
	    AI1Divisor : INT;
	    AI2Offset : INT;
	    AI2Multiplikator : INT;
	    AI2Divisor : INT;
	    BridgeMaximumCurrent : UINT;
	    BridgeSupplyVoltageLowerThreshold : UINT;
	    BridgeSupplyVoltageUpperThreshold : UINT;
	    BridgeTemperatureWarningThreshold : UINT;
	    BridgeTemperatureErrorThreshold : UINT;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	ActPosition 	: SvrCh_DINT;
	SetFreqOut 	: SvrCh_DINT;
	MaxCurrent 	: SvrCh_DINT;
	StallCurrentReduction 	: SvrCh_DINT;
	StateWord 	: SvrCh_DS402_State;
	ControlWord 	: SvrCh_DS402_Control;
	Enable 	: SvrCh_DINT;
	CurrentIncrease 	: SvrCh_DINT;
	Error 	: SvrCh_DINT;
	ErrorQuit 	: SvrCh_DINT;
	ZeroPulse_latched 	: SvrCh_DINT;
	ExternalEnable 	: SvrCh_DINT;
	HWError 	: SvrCh_DINT;
	HWEnableSoftwareRampdown 	: SvrCh_DINT;
	Input1 	: SvrCh_DINT;
	Input1LatchedRising 	: SvrCh_DINT;
	Input1LatchedFalling 	: SvrCh_DINT;
	Input2 	: SvrCh_DINT;
	Input2LatchedRising 	: SvrCh_DINT;
	Input2LatchedFalling 	: SvrCh_DINT;
	Input3 	: SvrCh_DINT;
	Input4 	: SvrCh_DINT;
	Output1 	: SvrCh_DINT;
	Output2 	: SvrCh_DINT;
	Output3 	: SvrCh_DINT;
	Output4 	: SvrCh_DINT;
	EncoderPosition 	: SvrCh_DINT;
	LatchPositionEncoderZeroPulse 	: SvrCh_DINT;
	LatchPositionInput1Rising 	: SvrCh_DINT;
	LatchPositionInput1Falling 	: SvrCh_DINT;
	LatchPositionInput2Rising 	: SvrCh_DINT;
	LatchPositionInput2Falling 	: SvrCh_DINT;
	ChopperOffTime 	: SvrCh_DINT;
	BlankingTime 	: SvrCh_DINT;
	FastDecayTime 	: SvrCh_DINT;
	FrequencyLimit1 	: SvrCh_UDINT;
	FrequencyLimit2 	: SvrCh_UDINT;
	FrequencyLimit4 	: SvrCh_UDINT;
	FrequencyLimit8 	: SvrCh_UDINT;
	FrequencyLimit16 	: SvrCh_UDINT;
	FrequencyLimit32 	: SvrCh_UDINT;
	FrequencyBandwidth 	: SvrCh_UDINT;
	HWRampdownDeltaFrequency 	: SvrCh_DINT;
	HWRampdownDeltaTime 	: SvrCh_DINT;
	VaranOut_1 	: SvrChCmd_DINT;
  //Clients:
	Hub_Base1 	: CltChCmd_Hub_Base;
	InvertEncoder 	: CltCh_DINT;
	InvertZeroPosition 	: CltCh_DINT;
	EncoderSampling 	: CltCh_DINT;
	LatchType 	: CltCh_DINT;
	LatchedValueZeroPosition 	: CltCh_DINT;
	LatchedValueInput1Rising 	: CltCh_DINT;
	LatchedValueInput1Falling 	: CltCh_DINT;
	LatchedValueInput2Rising 	: CltCh_DINT;
	LatchedValueInput2Falling 	: CltCh_DINT;
  //Variables:
		a_CalibData 	: t_SPI_CalibData;
		a_FrequencyLimit : ARRAY [0..5] OF t_FrequencyLimits;

		a_ParameterReadRequest : ARRAY [0..VST011_MAXASYNCPARAMETER] OF USINT;

		a_ReadDataBuffer : ARRAY [0..VST011_MAXASYNCPARAMETER] OF t_AsyncReadData;

		a_WriteDataBuffer : ARRAY [0..VST011_MAXASYNCPARAMETER] OF t_AsyncWriteData;

		a_LastWrittenAsyValues : ARRAY [0..VST011_MAXASYNCPARAMETER] OF t_LastWrittenValues;

		ActStateWord 	: t_StatusWord;
		bs_ActiveISyncValue 	: t_bs_IsyncValue;			//! <Variable Comment="mask containing all latched values" Name="bs_ActiveISyncValue"/>
		bs_ActualISyncValue 	: t_bs_IsyncValue;			//! <Variable Comment="1 rotating bit" Name="bs_ActualISyncValue"/>
		bs_ValidISyncValue 	: t_bs_IsyncValue;			//! <Variable Comment="1 bit containing information on valid data for actual cycle" Name="bs_ValidISyncValue"/>
		s_ControlWord 	: t_ControlWord;
		s_IODataObject 	: t_IO_DO;
		s_ISyncDO 	: t_ISyncReadDO;
		s_Settings2Write 	: t_s_SettingsDataType;
		s_SettingsDataObject 	: t_AsyncDO;
		sAsyCalls : ARRAY [0..VST_ID_CLASSESAVAILABLE-1] OF t_Call;

		sd_ISyncDigIn1FallOldPosition 	: DINT;
		sd_ISyncDigIn1RiseOldPosition 	: DINT;
		sd_ISyncDigIn2FallOldPosition 	: DINT;
		sd_ISyncDigIn2RiseOldPosition 	: DINT;
		sd_ISyncIncZeroOldPosition 	: DINT;
		sd_MaxAllowedCurrent 	: DINT;
		sd_MaxDiff 	: DINT;
		sd_SyncOffset 	: DINT;
		temp_raw_raw 	: HINT;
		u_MaxCurrent 	: UINT;
		ud_IsoStartPoint 	: UDINT;
		ud_SPIOffset 	: UDINT;
		ud_VaranTime 	: UDINT;
		ui_ISyncDigIn1FallOldCounter 	: UINT;
		ui_ISyncDigIn1RiseOldCounter 	: UINT;
		ui_ISyncDigIn2FallOldCounter 	: UINT;
		ui_ISyncDigIn2RiseOldCounter 	: UINT;
		ui_ISyncIncZeroOldCounter 	: UINT;
		ui_oldCounter 	: UINT;
		ui_oldCounterVirtual 	: UINT;
		us_ActFrequencyStep 	: USINT;
		us_Firstscan 	: USINT;
		us_ParameterReadRequestActive 	: USINT;
		us_ReadNumber 	: USINT;
		us_ReadPosition 	: USINT;
		us_WriteNumber 	: USINT;
		us_WritePosition 	: USINT;
		volt_raw_raw 	: HINT;
		udStallCurrentWindow 	: UDINT;
  //Functions:
				//! <Function Comment="Init for Varan Client" Name="Init"/>
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="Cy - Funktion of Varan class ( called bei VaranMaster )" Name="UpdateCy"/>
	FUNCTION VIRTUAL GLOBAL UpdateCy;
				//! <Function Comment="Rt - Funktion of Varan class ( called bei VaranMaster )" Name="UpdateRt"/>
	FUNCTION VIRTUAL GLOBAL UpdateRt;
				//! <Function Comment="Function is called by VaranRtPostScan if used" Name="UpdateRtPostScan"/>
	FUNCTION VIRTUAL GLOBAL UpdateRtPostScan;
				//! <Function Comment="Function is called if a varan module is connected&#13;&#10;" Name="Varan_HwConnect"/>
	FUNCTION AWL VIRTUAL GLOBAL Varan_HwConnect
		VAR_INPUT
			ud_data 	: UDINT;			//! <Variable Comment="data of callback function" Name="Varan_HwConnect.ud_data"/>
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;			//! <Variable Comment="return value of OS" Name="Varan_HwConnect.sd_retval"/>
		END_VAR;
				//! <Function Comment="Function is called if a varan interrupt occures" Name="Varan_HwInterrupt"/>
	FUNCTION VIRTUAL GLOBAL Varan_HwInterrupt
		VAR_INPUT
			ud_reason 	: UDINT;
			ud_data 	: ^t_CallBackInterrupt;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="Function is called if a varan module is disconnected&#13;&#10;" Name="Varan_HwDisconnect"/>
	FUNCTION AWL VIRTUAL GLOBAL Varan_HwDisconnect
		VAR_INPUT
			ud_data 	: UDINT;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="Function to set all Data Objects off" Name="SetDOsOff"/>
	FUNCTION VIRTUAL GLOBAL SetDOsOff;
				//! <Function Comment="Function to update module retry counter" Name="UpdateRetryCounter"/>
	FUNCTION VIRTUAL GLOBAL UpdateRetryCounter;
				//! <Function Comment="Check if DeviceID is supported by class" Name="CheckDeviceID"/>
	FUNCTION VIRTUAL GLOBAL CheckDeviceID
		VAR_INPUT
			ID2Check 	: UDINT;			//! <Variable Comment="VARAN DeviceID, which should be checked" Name="CheckDeviceID.ID2Check"/>
		END_VAR
		VAR_OUTPUT
			IsOK 	: BOOL;			//! <Variable Comment="TRUE...DeviceID is ok with this class&#13;&#10;FALSE..DeviceID is not ok with this class" Name="CheckDeviceID.IsOK"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetDeviceID
		VAR_OUTPUT
			output 	: UDINT;
		END_VAR;
				//! <Function Comment="Returns true if this class needs the postinitphase. &#13;&#10;Default in the base is false." Name="CheckPostInitNeeded"/>
	FUNCTION VIRTUAL GLOBAL CheckPostInitNeeded
		VAR_INPUT
			pbPostInitSettings 	: ^t_VM_CMD_NEED_POST_INIT_CALL_SETTINGS;
		END_VAR
		VAR_OUTPUT
			PostInitNeeded 	: BOOL;
		END_VAR;
				//! <Function Comment="only for internal use&#13;&#10;&#13;&#10;Methode adds a call for the class VST011ExtendedStateWord or VST011HBridgeInfo" Name="AddAsyCall"/>
	FUNCTION GLOBAL AddAsyCall
		VAR_INPUT
			usID 	: USINT;			//! <Variable Comment="ID-Number of the Class" Name="AddAsyCall.usID"/>
			pThis 	: ^void;			//! <Variable Comment="This-Pointer of Class" Name="AddAsyCall.pThis"/>
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;			//! <Variable Comment="0 .. Operation failed&#13;&#10;1 .. Operation successful" Name="AddAsyCall.bSuccessful"/>
		END_VAR;
				//! <Function Comment="only for internal use&#13;&#10;&#13;&#10;Methode starts/stops Call of extern Class" Name="ChangeCallMode"/>
	FUNCTION GLOBAL ChangeCallMode
		VAR_INPUT
			usID 	: USINT;			//! <Variable Comment="ID-Number of the Class" Name="ChangeCallMode.usID"/>
			bActive 	: BOOL;			//! <Variable Comment="0 .. stops Call&#13;&#10;1 .. start Call" Name="ChangeCallMode.bActive"/>
		END_VAR;
				//! <Function Comment="Readout the last read-value of the passed ParameterNr" Name="ReadParameter"/>
	FUNCTION GLOBAL ReadParameter
		VAR_INPUT
			us_ParameterNr 	: USINT;			//! <Variable Comment="number of parameter (according to constants defined in defines-area)" Name="ReadParameter.us_ParameterNr"/>
			p_b_Valid 	: ^BOOL;			//! <Variable Comment="If a vaild pointer is passed the information &#13;&#10;if the read value has been updated since last&#13;&#10;request (RequestParameter) is written to this memory address" Name="ReadParameter.p_b_Valid"/>
			p_ud_Value 	: ^UDINT;			//! <Variable Comment="The read value is written to this&#13;&#10;memory location as a 4-byte-Value&#13;&#10;Must not be NIL!" Name="ReadParameter.p_ud_Value"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="0 (VST_ERROR_ASYNC_NOERROR) .. ok&#13;&#10;otherwise errorcodes as defined in defines-area" Name="ReadParameter.retcode"/>
		END_VAR;
				//! <Function Comment="Put a request for a read value into the buffer" Name="RequestParameter"/>
	FUNCTION GLOBAL RequestParameter
		VAR_INPUT
			us_ParameterNr 	: USINT;			//! <Variable Comment="number of parameter (according to constants defined in defines-area)" Name="RequestParameter.us_ParameterNr"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="0 (VST_ERROR_ASYNC_NOERROR) .. ok&#13;&#10;otherwise errorcodes as defined in defines-area" Name="RequestParameter.retcode"/>
		END_VAR;
				//! <Function Comment="Put a write-request into the buffer" Name="WriteParameter"/>
	FUNCTION GLOBAL WriteParameter
		VAR_INPUT
			us_ParameterNr 	: USINT;			//! <Variable Comment="number of parameter (according to constants defined in defines-area)" Name="WriteParameter.us_ParameterNr"/>
			ud_Value 	: UDINT;			//! <Variable Comment="value to be written" Name="WriteParameter.ud_Value"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="0 (VST_ERROR_ASYNC_NOERROR) .. ok&#13;&#10;otherwise errorcodes as defined in defines-area" Name="WriteParameter.retcode"/>
		END_VAR;
	
	FUNCTION AsyReadAddress
		VAR_INPUT
			udAddress 	: UDINT;
			usLength 	: USINT;
		END_VAR;
	
	FUNCTION AsyWriteAddress
		VAR_INPUT
			udAddress 	: UDINT;
			usLength 	: USINT;
		END_VAR;
	
	FUNCTION CalcFrequencyLimits;
	
	FUNCTION IsoReadAddress
		VAR_INPUT
			udAddress 	: UDINT;
		END_VAR;
	
	FUNCTION ReadAsyncParameter;
	
	FUNCTION WriteAsyncParameter;
				//! <Function Comment="Change the StopPosition window for the use of the StallCurrentReduction setting (default init value: 0)&#13;&#10;&#13;&#10;Stop Position means, the value of the server SetFreqOut is lower than the StallCurrentWindow.&#13;&#10;&#13;&#10;e.g.: if you set a window of 2, the stop position is from -2 to +2" Name="SetStallCurrentWindow"/>
	FUNCTION GLOBAL SetStallCurrentWindow
		VAR_INPUT
			NewWindow 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SetFreqOut::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL MaxCurrent::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL StallCurrentReduction::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ControlWord::Write
		VAR_INPUT
			input (EAX) 	: DS402_Control;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DS402_Control;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Enable::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL CurrentIncrease::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ErrorQuit::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ZeroPulse_latched::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL HWEnableSoftwareRampdown::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Input1LatchedRising::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Input1LatchedFalling::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Input2LatchedRising::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Input2LatchedFalling::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Output1::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Output2::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Output3::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Output4::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ChopperOffTime::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL BlankingTime::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL FastDecayTime::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL FrequencyLimit1::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL FrequencyLimit2::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL FrequencyLimit4::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL FrequencyLimit8::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL FrequencyLimit16::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL FrequencyLimit32::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL FrequencyBandwidth::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL HWRampdownDeltaFrequency::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL HWRampdownDeltaTime::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using Hub_Base


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB VST011::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_VST011
1$UINT, 53$UINT, (SIZEOF(::VST011))$UINT, 
45$UINT, 10$UINT, 0$UINT, 
TO_UDINT(3810624959), "VST011", //Class
TO_UDINT(862125188), "Varan_Base", 2$UINT, 18$UINT, //Baseclass
//Servers:
(::VST011.ActPosition.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3276766410), "ActPosition", 
(::VST011.SetFreqOut.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2717077001), "SetFreqOut", 
(::VST011.MaxCurrent.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(3107851838), "MaxCurrent", 
(::VST011.StallCurrentReduction.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1882885897), "StallCurrentReduction", 
(::VST011.StateWord.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1307193485), "StateWord", 
(::VST011.ControlWord.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2412184912), "ControlWord", 
(::VST011.Enable.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(56102836), "Enable", 
(::VST011.CurrentIncrease.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3186795653), "CurrentIncrease", 
(::VST011.Error.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2861137601), "Error", 
(::VST011.ErrorQuit.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(971218924), "ErrorQuit", 
(::VST011.ZeroPulse_latched.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1850367652), "ZeroPulse_latched", 
(::VST011.ExternalEnable.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2700946704), "ExternalEnable", 
(::VST011.HWError.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2544391667), "HWError", 
(::VST011.HWEnableSoftwareRampdown.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3920155135), "HWEnableSoftwareRampdown", 
(::VST011.Input1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1344628668), "Input1", 
(::VST011.Input1LatchedRising.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2444548434), "Input1LatchedRising", 
(::VST011.Input1LatchedFalling.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3245332642), "Input1LatchedFalling", 
(::VST011.Input2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3375117830), "Input2", 
(::VST011.Input2LatchedRising.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3990224009), "Input2LatchedRising", 
(::VST011.Input2LatchedFalling.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3490886363), "Input2LatchedFalling", 
(::VST011.Input3.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3190490768), "Input3", 
(::VST011.Input4.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(542085939), "Input4", 
(::VST011.Output1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2425114930), "Output1", 
(::VST011.Output2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(159711368), "Output2", 
(::VST011.Output3.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2122461214), "Output3", 
(::VST011.Output4.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3773212093), "Output4", 
(::VST011.EncoderPosition.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1101453613), "EncoderPosition", 
(::VST011.LatchPositionEncoderZeroPulse.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2850658915), "LatchPositionEncoderZeroPulse", 
(::VST011.LatchPositionInput1Rising.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(779300112), "LatchPositionInput1Rising", 
(::VST011.LatchPositionInput1Falling.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1493319658), "LatchPositionInput1Falling", 
(::VST011.LatchPositionInput2Rising.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(530265997), "LatchPositionInput2Rising", 
(::VST011.LatchPositionInput2Falling.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3616356361), "LatchPositionInput2Falling", 
(::VST011.ChopperOffTime.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3473064912), "ChopperOffTime", 
(::VST011.BlankingTime.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(509049754), "BlankingTime", 
(::VST011.FastDecayTime.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4141564292), "FastDecayTime", 
(::VST011.FrequencyLimit1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1023132948), "FrequencyLimit1", 
(::VST011.FrequencyLimit2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2784138414), "FrequencyLimit2", 
(::VST011.FrequencyLimit4.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1284583835), "FrequencyLimit4", 
(::VST011.FrequencyLimit8.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1160215984), "FrequencyLimit8", 
(::VST011.FrequencyLimit16.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(123622828), "FrequencyLimit16", 
(::VST011.FrequencyLimit32.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(839250743), "FrequencyLimit32", 
(::VST011.FrequencyBandwidth.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3602224436), "FrequencyBandwidth", 
(::VST011.HWRampdownDeltaFrequency.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(379348510), "HWRampdownDeltaFrequency", 
(::VST011.HWRampdownDeltaTime.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3778472805), "HWRampdownDeltaTime", 
(::VST011.VaranOut_1.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2138873746), "VaranOut_1", 
//Clients:
(::VST011.Hub_Base1.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(58231171), "Hub_Base1", TO_UDINT(3238133653), "Hub_Base", 1$UINT, 21$UINT, 
(::VST011.InvertEncoder.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(164824020), "InvertEncoder", 
(::VST011.InvertZeroPosition.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2091988656), "InvertZeroPosition", 
(::VST011.EncoderSampling.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1045480734), "EncoderSampling", 
(::VST011.LatchType.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2520966561), "LatchType", 
(::VST011.LatchedValueZeroPosition.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3008997340), "LatchedValueZeroPosition", 
(::VST011.LatchedValueInput1Rising.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3635724339), "LatchedValueInput1Rising", 
(::VST011.LatchedValueInput1Falling.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(4220750197), "LatchedValueInput1Falling", 
(::VST011.LatchedValueInput2Rising.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3915176622), "LatchedValueInput2Rising", 
(::VST011.LatchedValueInput2Falling.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1964805782), "LatchedValueInput2Falling", 
END_FUNCTION


#define USER_CNT_VST011 48

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_VST011] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION VST011::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= Varan_Base::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= Varan_Base::State.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, Varan_Base::State.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_VST011;
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #UpdateCy();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #UpdateRt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #UpdateRtPostScan();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #Varan_HwConnect();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #Varan_HwInterrupt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #Varan_HwDisconnect();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[16]		:= #SetDOsOff();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[20]		:= #UpdateRetryCounter();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[27]		:= #CheckDeviceID();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[43]		:= #GetDeviceID();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[45]		:= #CheckPostInitNeeded();

#pragma warning (default : 74)
	Varan_Base::State.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF Varan_Base::State.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SetFreqOut.pMeth			:= StoreMethod( #M_RD_DIRECT(), #SetFreqOut::Write() );
	IF SetFreqOut.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	MaxCurrent.pMeth			:= StoreMethod( #M_RD_DIRECT(), #MaxCurrent::Write() );
	IF MaxCurrent.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	StallCurrentReduction.pMeth			:= StoreMethod( #M_RD_DIRECT(), #StallCurrentReduction::Write() );
	IF StallCurrentReduction.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ControlWord.pMeth			:= StoreMethod( #M_RD_DIRECT(), #ControlWord::Write() );
	IF ControlWord.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Enable.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Enable::Write() );
	IF Enable.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	CurrentIncrease.pMeth			:= StoreMethod( #M_RD_DIRECT(), #CurrentIncrease::Write() );
	IF CurrentIncrease.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ErrorQuit.pMeth			:= StoreMethod( #M_RD_DIRECT(), #ErrorQuit::Write() );
	IF ErrorQuit.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ZeroPulse_latched.pMeth			:= StoreMethod( #ZeroPulse_latched::Read(), #M_NO_F() );
	IF ZeroPulse_latched.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	HWEnableSoftwareRampdown.pMeth			:= StoreMethod( #M_RD_DIRECT(), #HWEnableSoftwareRampdown::Write() );
	IF HWEnableSoftwareRampdown.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Input1LatchedRising.pMeth			:= StoreMethod( #Input1LatchedRising::Read(), #M_NO_F() );
	IF Input1LatchedRising.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Input1LatchedFalling.pMeth			:= StoreMethod( #Input1LatchedFalling::Read(), #M_NO_F() );
	IF Input1LatchedFalling.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Input2LatchedRising.pMeth			:= StoreMethod( #Input2LatchedRising::Read(), #M_NO_F() );
	IF Input2LatchedRising.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Input2LatchedFalling.pMeth			:= StoreMethod( #Input2LatchedFalling::Read(), #M_NO_F() );
	IF Input2LatchedFalling.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Output1.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Output1::Write() );
	IF Output1.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Output2.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Output2::Write() );
	IF Output2.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Output3.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Output3::Write() );
	IF Output3.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Output4.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Output4::Write() );
	IF Output4.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ChopperOffTime.pMeth			:= StoreMethod( #M_RD_DIRECT(), #ChopperOffTime::Write() );
	IF ChopperOffTime.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	BlankingTime.pMeth			:= StoreMethod( #M_RD_DIRECT(), #BlankingTime::Write() );
	IF BlankingTime.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	FastDecayTime.pMeth			:= StoreMethod( #M_RD_DIRECT(), #FastDecayTime::Write() );
	IF FastDecayTime.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	FrequencyLimit1.pMeth			:= StoreMethod( #M_RD_DIRECT(), #FrequencyLimit1::Write() );
	IF FrequencyLimit1.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	FrequencyLimit2.pMeth			:= StoreMethod( #M_RD_DIRECT(), #FrequencyLimit2::Write() );
	IF FrequencyLimit2.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	FrequencyLimit4.pMeth			:= StoreMethod( #M_RD_DIRECT(), #FrequencyLimit4::Write() );
	IF FrequencyLimit4.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	FrequencyLimit8.pMeth			:= StoreMethod( #M_RD_DIRECT(), #FrequencyLimit8::Write() );
	IF FrequencyLimit8.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	FrequencyLimit16.pMeth			:= StoreMethod( #M_RD_DIRECT(), #FrequencyLimit16::Write() );
	IF FrequencyLimit16.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	FrequencyLimit32.pMeth			:= StoreMethod( #M_RD_DIRECT(), #FrequencyLimit32::Write() );
	IF FrequencyLimit32.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	FrequencyBandwidth.pMeth			:= StoreMethod( #M_RD_DIRECT(), #FrequencyBandwidth::Write() );
	IF FrequencyBandwidth.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	HWRampdownDeltaFrequency.pMeth			:= StoreMethod( #M_RD_DIRECT(), #HWRampdownDeltaFrequency::Write() );
	IF HWRampdownDeltaFrequency.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	HWRampdownDeltaTime.pMeth			:= StoreMethod( #M_RD_DIRECT(), #HWRampdownDeltaTime::Write() );
	IF HWRampdownDeltaTime.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, VaranOut_1.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	VaranOut_1.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF VaranOut_1.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION

FUNCTION VIRTUAL GLOBAL VST011::Init
  VAR
    sd_retval   : DINT;
  END_VAR

#ifdef IsTransparent_IS_AVAILABLE
  IF IsTransparent() THEN
    return;
  END_IF;
#endif

  // first init phase
  if ( us_Firstscan = 0 ) then
    us_Firstscan += 1;

    //-----------------------------------------------------------------------------------------------
    //init the base class
    Varan_Base::Init();

    //if an error in base class occurs return
    if ( State <> _NotInitialized ) then
      return;
    end_if;

    //get varan time and calculate offset for sync
    ud_VaranTime := VaranIn.GetVaranTime( #ud_IsoStartPoint );
    sd_SyncOffset := ( ud_VaranTime - ud_IsoStartPoint )$DINT / 10;

    //calculate maximum number of steps per cycle
    sd_MaxDiff := to_DINT(ud_VaranTime / 20_000);
    
    if b_PayloadSupport then
      //-----------------------------------------------------------------------------------------------
      //install data object for latch-values
      
      sd_retval := AddRdPayloadDO(  ud_dol_type   := VARAN_DOL_ISO
                                  , p_ud_handle   := ( #s_ISyncDO.p_Handle)$^UDINT
                                  , ud_offset_read:= 0                                // Changes every RT cycle
                                  , ud_length_read:= SIZEOF( UINT )
                                  , p_ud_data_read:= ( #s_ISyncDO.p_DataRead)$^UDINT
                                  , ud_type       := VM_MEMORY_ACCESS);
      

      
      //look if an error occurs
      if ( sd_retval <> VARANMANAGER_OK ) then
        State := _CreateDOFailed;
        return;
      end_if; 

    //-----------------------------------------------------------------------------------------------
      //install default ISO data object
      sd_retval := AddRdWrPayloadDO(  ud_dol_type     := VARAN_DOL_ISO
                                    , p_ud_handle     := ( #s_IODataObject.p_Handle )$^UDINT
                                    , ud_offset_read  := VST011_OFFSET_READ_DATA
                                    , ud_length_read  := sizeof(t_ReadDataType)
                                    , p_ud_data_read  := ( #s_IODataObject.p_DataRead )$^UDINT
                                    , ud_offset_write := VST011_OFFSET_WRITE_DATA
                                    , ud_length_write := sizeof(t_WriteDataType)
                                    , p_ud_data_write := ( #s_IODataObject.p_DataWrite )$^UDINT
                                    , ud_type         := VM_MEMORY_ACCESS);
      
      //look if an error occurs
      if ( sd_retval <> VARANMANAGER_OK ) then
        State := _CreateDOFailed;
        return;
      end_if; 


      //-----------------------------------------------------------------------------------------------
      //install default ASY data object
      sd_retval := AddRdWrPayloadDO(  ud_dol_type         := VARAN_DOL_ASY
                                    , p_ud_handle         := ( #s_SettingsDataObject.p_Handle )$^UDINT
                                    , ud_offset_read      := 0                                    // Changes every CY cycle
                                    , ud_length_read      := sizeof(UDINT)
                                    , p_ud_data_read      := ( #s_SettingsDataObject.p_DataRead )$^UDINT
                                    , ud_offset_write     := 0                                    // Changes every CY cycle
                                    , ud_length_write     :=  sizeof(UDINT)
                                    , p_ud_data_write     := ( #s_SettingsDataObject.p_DataWrite )$^UDINT
                                    , ud_type             := VM_MEMORY_ACCESS
                                    , ud_WritePayloadType := 1);
      
      //look if an error occurs
      if ( sd_retval <> VARANMANAGER_OK ) then
        State := _CreateDOFailed;
        return;
      end_if; 
      
    else
      
      //-----------------------------------------------------------------------------------------------
      //install data object for latch-values
      
      sd_retval := VaranIn.AddRdDO( p_us_position_info := p_VaranPosition
                                  , ud_dol_type        := VARAN_DOL_ISO
                                  , p_ud_handle        := ( #s_ISyncDO.p_Handle)$^UDINT
                                  , ud_address         := 0
                                  , ud_length          := SIZEOF( UINT )
                                  , p_ud_data          := ( #s_ISyncDO.p_DataRead)$^UDINT
                                  , ud_type            := VM_MEMORY_ACCESS );
      
      //look if an error occurs
      if ( sd_retval <> VARANMANAGER_OK ) then
        State := _CreateDOFailed;
        return;
      end_if; 

      //get address pointer to change address later when module is connected  
      s_ISyncDO.p_DOSettings := s_ISyncDO.p_DataRead - VM_DO_OFFSET_RD;

      //-----------------------------------------------------------------------------------------------
      //install default data object
      sd_retval := VaranIn.AddRdWrDO( p_us_position_info  := p_VaranPosition
                                    , ud_dol_type         := VARAN_DOL_ISO
                                    , p_ud_handle         := ( #s_IODataObject.p_Handle )$^UDINT
                                    , ud_address_read     := 0
                                    , ud_length_read      := sizeof(t_ReadDataType)
                                    , p_ud_data_read      := ( #s_IODataObject.p_DataRead )$^UDINT
                                    , ud_address_write    := 0
                                    , ud_length_write     := sizeof(t_WriteDataType)
                                    , p_ud_data_write     := ( #s_IODataObject.p_DataWrite )$^UDINT
                                    , ud_type             := VM_MEMORY_ACCESS
                                    );
      
      //look if an error occurs
      if ( sd_retval <> VARANMANAGER_OK ) then
        State := _CreateDOFailed;
        return;
      end_if; 

      //get address pointer to change address later when module is connected  
      s_IODataObject.p_DOSettings := s_IODataObject.p_DataWrite - VM_DO_OFFSET_RDWR;

      //-----------------------------------------------------------------------------------------------
      //install default data object
      sd_retval := VaranIn.AddRdWrDO( p_us_position_info  := p_VaranPosition
                                    , ud_dol_type         := VARAN_DOL_ASY
                                    , p_ud_handle         := ( #s_SettingsDataObject.p_Handle )$^UDINT
                                    , ud_address_read     := 0
                                    , ud_length_read      := sizeof(UDINT)
                                    , p_ud_data_read      := ( #s_SettingsDataObject.p_DataRead )$^UDINT
                                    , ud_address_write    := 0
                                    , ud_length_write     := sizeof(UDINT)
                                    , p_ud_data_write     := ( #s_SettingsDataObject.p_DataWrite )$^UDINT
                                    , ud_type             := VM_MEMORY_ACCESS
                                    );
      
      //look if an error occurs
      if ( sd_retval <> VARANMANAGER_OK ) then
        State := _CreateDOFailed;
        return;
      end_if; 

      //get address pointer to change address later when module is connected  
      s_SettingsDataObject.p_DOSettings := s_SettingsDataObject.p_DataWrite - VM_DO_OFFSET_RDWR;
    end_if;
   
    
    //install Varantask
    VaranIn.AddVaranTask( ud_dol_type := VARAN_DOL_ISO
                        , p_this    := this
                        , callOptions := CALL_OPTION_RT_PRESCAN OR CALL_OPTION_RT_POSTSCAN
                        );
                        
    //install Varantask
    VaranIn.AddVaranTask( ud_dol_type := VARAN_DOL_ASY
                        , p_this    := this
                        );

    InvertEncoder := InvertEncoder.Read() <> 0;
    InvertZeroPosition := InvertZeroPosition.Read() <> 0;
    EncoderSampling := EncoderSampling.Read();
    CASE EncoderSampling OF
      0,1,2,3:
    ELSE
      EncoderSampling := 0;
    END_CASE;
    
    LatchType := s_ControlWord.LatchType := LatchType.Read() <> 0;   
    s_ControlWord.CurrentIncrease := ControlWord.ManufactureSpec2 := to_bool(CurrentIncrease);
    
    // Max Frequency is 1 Mhz 
    IF FrequencyLimit32 > 1000000 & FrequencyLimit32 <> 16#FFFF_FFFF THEN
      FrequencyLimit32 := 1000000;
    END_IF;
    IF FrequencyLimit16 > 1000000 & FrequencyLimit16 <> 16#FFFF_FFFF THEN
      FrequencyLimit16 := 1000000;
    END_IF;
    IF FrequencyLimit8 > 1000000 & FrequencyLimit8 <> 16#FFFF_FFFF THEN
      FrequencyLimit8 := 1000000;
    END_IF;
    IF FrequencyLimit4 > 1000000 & FrequencyLimit4 <> 16#FFFF_FFFF THEN
      FrequencyLimit4 := 1000000;
    END_IF;
    IF FrequencyLimit2 > 1000000 & FrequencyLimit2 <> 16#FFFF_FFFF THEN
      FrequencyLimit2 := 1000000;
    END_IF;
    IF FrequencyLimit1 > 1000000 & FrequencyLimit1 <> 16#FFFF_FFFF THEN
      FrequencyLimit1 := 1000000;
    END_IF;
    
    //Calculate FrequencyLimits for Hysterese
    CalcFrequencyLimits();
    
    #pragma warning(disable: 74 )
    s_Settings2Write.IncrementalEncoderSettings.1 := InvertZeroPosition <> 0;
    s_Settings2Write.IncrementalEncoderSettings.2 := InvertEncoder <> 0;
    IF (EncoderSampling AND 2#11) <> 0 THEN
      s_Settings2Write.IncrementalEncoderSettings.3 := EncoderSampling$BSINT.1;
      s_Settings2Write.IncrementalEncoderSettings.4 := EncoderSampling$BSINT.2;
    END_IF;
    #pragma warning(default: 74 )

    //-----------------------------------------------------------------------------------------------
    //call connect hardware function
    sd_retval := Varan_CallBack ( ud_reason := VARANMANAGER_CB_CONNECT
                                , ud_data := 0
                                );

    //produce Varan Error if module not ok
    if ( sd_retval <> VARANMANAGER_OK ) then
      VaranIn.SetVaranError( p_Node := p_VaranPosition );
    end_if;
    
    //check the stall current    
    if StallCurrentReduction < 0 then
      StallCurrentReduction.Write(0);
    elsif StallCurrentReduction > 1000 then
      StallCurrentReduction.Write(1000);
    end_if;
        
    u_MaxCurrent := to_uint(MaxCurrent - ((MaxCurrent * StallCurrentReduction) / 1000));
    
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL VST011::Varan_HwConnect
  VAR_INPUT
    ud_data   : UDINT;
  END_VAR
  VAR_OUTPUT
    sd_retval   : DINT;
  END_VAR
  VAR
    i : USINT;
  END_VAR
  
  //*****************************************************************************
  //** (re)set variables for transfer of asynchronous values                   **
  //*****************************************************************************

  _memset(dest:=#a_WriteDataBuffer, usByte:=0, cntr:=SIZEOF(a_WriteDataBuffer));
  _memset(dest:=#a_ParameterReadRequest, usByte:=0, cntr:=SIZEOF(a_ParameterReadRequest));
  us_ParameterReadRequestActive := 0;
  us_WriteNumber                := 0;
  us_ReadNumber                 := 0;
  bs_ActualISyncValue.8         := 1;
  bs_ActiveISyncValue           := 0;
  bs_ValidISyncValue            := 0;
  
  FOR i := 0 TO VST011_MAXASYNCPARAMETER DO
    a_ReadDataBuffer[i].b_Valid := FALSE;
  END_FOR;
  
  //------------------------------------------------------------------------------------------------
  //get node information
  sd_retval := GetNodeInfo();

  //look for an error
  if ( sd_retval <> VARANMANAGER_OK ) then
    return;
  end_if;

  //we must wait because peripherie reset needs 15ms
  To_MultiTask.TASKDELAY( timeout0 := 15ms ); 

  //get offset to calib data
  sd_retval := GetCalibDataPointer( p_offset := #ud_SPIOffset );

  //look for an error
  if ( sd_retval <> VARANMANAGER_OK ) then
    return;
  end_if;

  //read calib data
  sd_retval := ReadSPIData( ud_offset := ud_SPIOffset
              , ud_length := sizeof( t_SPI_CalibData )
              , p_data  := ( #a_CalibData )$^USINT
              );

  //look for an error
  if ( sd_retval <> VARANMANAGER_OK ) then
    return;
  end_if;

  //save maximum allowed current for internal use
  sd_MaxAllowedCurrent := a_CalibData.BridgeMaximumCurrent;

  IF MaxCurrent < 0 THEN
    MaxCurrent.Write(0);
  END_IF;
  IF MaxCurrent > sd_MaxAllowedCurrent THEN
    MaxCurrent.Write(sd_MaxAllowedCurrent);
  END_IF;

  //create structure to write to FPGA
  s_Settings2Write.ChopperOffTime := to_UINT(ChopperOffTime);
  s_Settings2Write.FastDecayTime := to_UINT(FastDecayTime);
  
  s_Settings2Write.FrequencyLimit32 := FrequencyLimit32;
  s_Settings2Write.FrequencyLimit16 := FrequencyLimit16;
  s_Settings2Write.FrequencyLimit8 := FrequencyLimit8;
  s_Settings2Write.FrequencyLimit4 := FrequencyLimit4;
  s_Settings2Write.FrequencyLimit2 := FrequencyLimit2;
  s_Settings2Write.FrequencyLimit1 := FrequencyLimit1;
  
  s_Settings2Write.HWRampdownDeltaFrequency := to_UINT(HWRampdownDeltaFrequency);
  s_Settings2Write.HWRampdownDeltaTime := to_UINT(HWRampdownDeltaTime);
  
  //s_Settings2Write.IncrementalEncoderSettings //Already set from Init (clients)
  
  s_Settings2Write.BlankingTimeRegister := to_USINT(BlankingTime);
  
  s_Settings2Write.Bridge1Off := a_CalibData.Offset0;
  s_Settings2Write.Bridge1Mul := a_CalibData.Multiplier0;
  s_Settings2Write.Bridge1Div := a_CalibData.Divisor0;
  s_Settings2Write.Bridge2Off := a_CalibData.Offset1;
  s_Settings2Write.Bridge2Mul := a_CalibData.Multiplier1;
  s_Settings2Write.Bridge2Div := a_CalibData.Divisor1;

  s_Settings2Write.BridgeSupplyVoltageLowerThreshold := a_CalibData.BridgeSupplyVoltageLowerThreshold;
  s_Settings2Write.BridgeSupplyVoltageUpperThreshold := a_CalibData.BridgeSupplyVoltageUpperThreshold;
  s_Settings2Write.BridgeTemperatureWarningThreshold := a_CalibData.BridgeTemperatureWarningThreshold;
  s_Settings2Write.BridgeTemperatureErrorThreshold := a_CalibData.BridgeTemperatureErrorThreshold;

 if b_PayloadSupport then  // -------------------------------------------------------------------------------------------------
  //write calibration data & settings to FPGA
    sd_retval := MULTI_VARAN_iExecuteDirectAccess(  hNodeHandle := ud_HandleModule
                                                  , udCommand   := VARAN_CMD_MEMORY_WRITE
                                                  , udOffset    := VST011_OFFSET_SETTINGS
                                                  , udLength    := sizeof(t_s_SettingsDataType)
                                                  , pusData     := ( #s_Settings2Write )$^USINT
                                                  , pudErrorInfo:= NIL);  

    //look if an error occurs
    if ( sd_retval <> VARANMANAGER_OK ) then
      State := _DirectAccessFailed;
      return;
    end_if;
    
    sd_retval := MULTI_VARAN_iExecuteDirectAccess(  hNodeHandle := ud_HandleModule
                                                  , udCommand   := VARAN_CMD_MEMORY_READ
                                                  , udOffset    := VST011_OFFSET_READ_DATA + t_ReadDataType.ActPos
                                                  , udLength    := sizeof(t_ReadDataType.ActPos)
                                                  , pusData     := ( #ui_oldCounterVirtual )$^USINT
                                                  , pudErrorInfo:= NIL); 

    if ( sd_retval <> VARANMANAGER_OK ) then
      State := _DirectAccessFailed;
      return;
    end_if;
    
    sd_retval := MULTI_VARAN_iExecuteDirectAccess(  hNodeHandle := ud_HandleModule
                                                  , udCommand   := VARAN_CMD_MEMORY_READ
                                                  , udOffset    := VST011_OFFSET_READ_DATA + t_ReadDataType.IncrementalEncoderValue
                                                  , udLength    := sizeof(t_ReadDataType.IncrementalEncoderValue)
                                                  , pusData     := ( #ui_oldCounter )$^USINT
                                                  , pudErrorInfo:= NIL); 
                                   
    if ( sd_retval <> VARANMANAGER_OK ) then
      State := _DirectAccessFailed;
      return;
    end_if;
    
  else // if b_PayloadSupport then  // -------------------------------------------------------------------------------------------------
    //write calibration data & settings to FPGA
    sd_retval := VARAN_iWriteMemoryDA ( uiManager       := ud_VaranManagerNr
                                      , uiAddress       := DeviceAddress + VST011_OFFSET_SETTINGS
                                      , uiLen           := sizeof(t_s_SettingsDataType)
                                      , uiRetryTimeout  := GetRetryTimeout( ud_bytes := sizeof(t_s_SettingsDataType) )
                                      , pvData          := #s_Settings2Write
                                      , puiError        := NIL
                                      );

    //look if an error occurs
    if ( sd_retval <> VARANMANAGER_OK ) then
      State := _DirectAccessFailed;
      return;
    end_if;

    sd_retval := VARAN_iReadMemoryDA(  uiManager := ud_VaranManagerNr
                                     , uiAddress := DeviceAddress + VST011_OFFSET_READ_DATA + t_ReadDataType.ActPos
                                       , uiLen := sizeof(t_ReadDataType.ActPos)
                                       , uiRetryTimeout := GetRetryTimeout( ud_bytes := sizeof(t_ReadDataType.ActPos) )
                                     , pvData :=  #ui_oldCounterVirtual
                                     , puiError := NIL);

    if ( sd_retval <> VARANMANAGER_OK ) then
      State := _DirectAccessFailed;
      return;
    end_if;

    sd_retval := VARAN_iReadMemoryDA(  uiManager := ud_VaranManagerNr
                                     , uiAddress := DeviceAddress + VST011_OFFSET_READ_DATA + t_ReadDataType.IncrementalEncoderValue
                                       , uiLen := sizeof(t_ReadDataType.IncrementalEncoderValue)
                                       , uiRetryTimeout := GetRetryTimeout( ud_bytes := sizeof(t_ReadDataType.IncrementalEncoderValue) )
                                     , pvData :=  #ui_oldCounter
                                     , puiError := NIL);
                                     
    if ( sd_retval <> VARANMANAGER_OK ) then
      State := _DirectAccessFailed;
      return;
    end_if;   
    
    //------------------------------------------------------------------------------------------------
    //correct address fo data object read/write 
    s_SettingsDataObject.p_DOSettings^.ud_AddressRd := DeviceAddress;
    s_SettingsDataObject.p_DOSettings^.ud_AddressWr := DeviceAddress;
    
    s_IODataObject.p_DOSettings^.ud_AddressRd := DeviceAddress + VST011_OFFSET_READ_DATA;
    s_IODataObject.p_DOSettings^.ud_AddressWr := DeviceAddress + VST011_OFFSET_WRITE_DATA;

  end_if; // if b_PayloadSupport then  // -------------------------------------------------------------------------------------------------  

  //set pll time
  sd_retval := SetPllData();

  //look for an error
  if ( sd_retval <> VARANMANAGER_OK ) then
    return;
  end_if;

  //set sync out counter
  sd_retval := EnableSyncOut  ( us_sync_nr              := 0
                              , sd_offset               := sd_SyncOffset
                              , us_period_multiplier    := 0
                              , us_frame_count_treshold := 0
                              , us_enable_frame_count   := 0
                              );

  //look for an error
  if ( sd_retval <> VARANMANAGER_OK ) then
    return;
  end_if;

  //set all outputs off
  s_IODataObject.s_DataWrite.ControlWord.DigOut1 := 0;
  s_IODataObject.s_DataWrite.ControlWord.DigOut2 := 0;
  s_IODataObject.s_DataWrite.ControlWord.DigOut3 := 0;
  s_IODataObject.s_DataWrite.ControlWord.DigOut4 := 0;
  Output1 := Output2 := Output3 := Output4 := 0;

  //------------------------------------------------------------------------------------------------
  //class is ok
  //set class online
  bOnline     := TRUE;
  // start state machine for initalizing DOs
  eCycleWork  := _CycleStartAsyDO;
  State       := _ClassOk;
  sd_retval   := VARANMANAGER_OK;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL VST011::UpdateCy
VAR
  tmpCounter : UDINT;
  tmpClass   : ^void;
END_VAR

//=================================================================================================
#ifdef VM_CLASS_TIME_MEASUREMENT
  StartTimeMeasurement(VARANTIME_CY);
#endif
//=================================================================================================
  
  // call cy of base to disable device if necessary
  Varan_Base::UpdateCy();
  
  if State = _ClassOk then
    case eCycleWork of
      //**************************************************************************************
      t_CycleWork::_CycleInitIdle:
      
      //**************************************************************************************
      t_CycleWork::_CycleStartAsyDO:
        if b_PayloadSupport then
          DisableDO(ud_DOHandle:=s_SettingsDataObject.p_Handle$UDINT);
        else
          DisableDO(ud_DOHandle:=s_SettingsDataObject.p_Handle$UDINT, s_SettingsDataObject.p_DOSettings^.us_ByteCntRd + s_SettingsDataObject.p_DOSettings^.us_ByteCntWr);
        end_if;
        eCycleWork := _CycleStartIsoDO;
      
      //**************************************************************************************
      t_CycleWork::_CycleOperational, t_CycleWork::_CyclePreOperational:    
        //Call external Classes
        //*****************************************************************************
        for tmpCounter := 0 to VST_ID_CLASSESAVAILABLE - 1 do
          if sAsyCalls[tmpCounter].bActive then
            tmpClass := sAsyCalls[tmpCounter].pThis;
            tmpClass$^VirtualBase^.CyWork(0);   
          end_if;
        end_for;        
        
        //*****************************************************************************
        //** set the asynchronous data object off                                    **
        //*****************************************************************************    
        if b_PayloadSupport then    
          // Get the read pointer before changing the data object. 
          // The read pointer must point to the data defined by the last ChangeDO commands (from the previous UpdateCy)
          MULTI_VARAN_iGetDataPointers (  hDoHandle := s_SettingsDataObject.p_Handle$UDINT
                                        , ppvReadData := #(s_SettingsDataObject.p_DataRead$pVoid)
                                        , ppvWriteData:= #(s_SettingsDataObject.p_DataWrite$pVoid) );
        
          // usLengthOfExpAnswer and usSendBufferLength are automatically adjusted to the correct length when us_ByteCntRd and us_ByteCntWr in MULTI_VARAN_i 
          ChangeDOLengthOffset( ud_DOHandle         := s_SettingsDataObject.p_Handle$UDINT
                              , ud_offset_read      := 16#0
                              , ud_length_read      := 0
                              , ud_offset_write     := 16#0
                              , ud_length_write     := 0);
        else
          s_SettingsDataObject.p_DOSettings^.ud_AddressRd     := DeviceAddress + 16#0;
          s_SettingsDataObject.p_DOSettings^.ud_AddressWr     := DeviceAddress + 16#0;
          s_SettingsDataObject.p_DOSettings^.us_ByteCntRd     := 0;
          s_SettingsDataObject.p_Handle^.usLengthOfExpAnswer  := 1 + 0;
          s_SettingsDataObject.p_Handle^.usSendBufferLength   := 11 + 0;
          // Here be Dragons
          // The pointer to the read data is modified because the position of the read data is dependant on the size of the write data
          // As the length of the write data is variable during runtime the start position of the read data (=p_DataRead) must also change during runtime
          s_SettingsDataObject.p_DataRead                     := s_SettingsDataObject.p_DataWrite + 1 + s_SettingsDataObject.p_DOSettings^.us_ByteCntWr;
          s_SettingsDataObject.p_DOSettings^.us_ByteCntWr     := 0;
        end_if;
                
        // Read asynchronous Parameter
        //*****************************************************************************
        ReadAsyncParameter();      
      
        // Write asynchronous Parameter
        //*****************************************************************************
        WriteAsyncParameter();

        //Start SingleRun of DataObject
        //*****************************************************************************
        if b_PayloadSupport then
          
          // s_DO_AcyRd xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
          case s_SettingsDataObject.b_DOIsRunning of          
            SR_STATE_ENABLE_ME :  // DO is not running and start request is set ----------------------------------------
              EnableDO(ud_DOHandle := s_SettingsDataObject.p_Handle$UDINT);        
              s_SettingsDataObject.b_DOIsRunning  := SR_STATE_DISABLE_ME;
              
            SR_STATE_DISABLE_ME : // DO is running and start request is not set ----------------------------------------
              DisableDO(ud_DOHandle:= s_SettingsDataObject.p_Handle$UDINT);
              s_SettingsDataObject.b_DOIsRunning := SR_STATE_NOTHING;
              
            SR_STATE_LEAVE_ME_ENABLED : // DO is running and another start request is set ------------------------------
              s_SettingsDataObject.b_DOIsRunning := SR_STATE_DISABLE_ME;              
          end_case;          
        else
          if s_SettingsDataObject.p_DOSettings^.us_ByteCntRd  | s_SettingsDataObject.p_DOSettings^.us_ByteCntWr then    
            ResetDataObject(p_handleDO  := s_SettingsDataObject.p_Handle, 
                            us_state    := VARAN_DO_SINGLE_RUN, 
                            ud_bytes    := s_SettingsDataObject.p_DOSettings^.us_ByteCntRd + s_SettingsDataObject.p_DOSettings^.us_ByteCntWr);
          end_if;
        end_if;
    end_case;
  end_if;

//=================================================================================================
#ifdef VM_CLASS_TIME_MEASUREMENT
  StopTimeMeasurement(VARANTIME_CY);
#endif
//=================================================================================================
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL VST011::UpdateRt
  VAR
    //ActStateWord : t_StatusWord;
    ui_temp : UINT;
    si_delta : DINT;
    i : USINT;
    b_started : BOOL;
  END_VAR

//=================================================================================================
#ifdef VM_CLASS_TIME_MEASUREMENT
  StartTimeMeasurement(VARANTIME_RT);
#endif
//=================================================================================================

  if State = _ClassOk then  
    case eCycleWork of
      //**************************************************************************************
      t_CycleWork::_CycleInitIdle:
      
      //**************************************************************************************
      t_CycleWork::_CycleStartIsoDO:
        DisableDO(ud_DOHandle:=s_ISyncDO.p_Handle$UDINT, 2);
        EnableDO(ud_DOHandle := s_IODataObject.p_Handle$UDINT, sizeof(t_WriteDataType) + sizeof(t_ReadDataType));
        eCycleWork := _CyclePreOperational;
      
      //**************************************************************************************
      t_CycleWork::_CycleOperational, t_CycleWork::_CyclePreOperational:    
        ActStateWord := s_IODataObject.p_DataRead^.StateWord;

        Input1 := ActStateWord.DigIn1;
        Input2 := ActStateWord.DigIn2;
        Input3 := ActStateWord.DigIn3;
        Input4 := ActStateWord.DigIn4;
        
        bs_ActiveISyncValue.DigIn1Rise := bs_ActiveISyncValue.DigIn1Rise OR ActStateWord.LatchDigIn1Rise;
        bs_ActiveISyncValue.DigIn1Fall := bs_ActiveISyncValue.DigIn1Fall OR ActStateWord.LatchDigIn1Fall;
        bs_ActiveISyncValue.DigIn2Rise := bs_ActiveISyncValue.DigIn2Rise OR ActStateWord.LatchDigIn2Rise;
        bs_ActiveISyncValue.DigIn2Fall := bs_ActiveISyncValue.DigIn2Fall OR ActStateWord.LatchDigIn2Fall;

        Input1LatchedRising  := Input1LatchedRising OR bs_ActiveISyncValue.DigIn1Rise;
        Input1LatchedFalling := Input1LatchedFalling OR bs_ActiveISyncValue.DigIn1Fall;
        Input2LatchedRising  := Input2LatchedRising OR bs_ActiveISyncValue.DigIn2Rise;
        Input2LatchedFalling := Input2LatchedFalling OR bs_ActiveISyncValue.DigIn2Fall;
        
        IF EncoderSampling & LatchType THEN
          IF bs_ActiveISyncValue.DigIn1Rise THEN
            ui_ISyncDigIn1RiseOldCounter  := ui_oldCounter;
            sd_ISyncDigIn1RiseOldPosition := EncoderPosition;
          END_IF;
          IF bs_ActiveISyncValue.DigIn1Fall THEN
            ui_ISyncDigIn1FallOldCounter  := ui_oldCounter;
            sd_ISyncDigIn1FallOldPosition := EncoderPosition;
          END_IF;
          IF bs_ActiveISyncValue.DigIn2Rise THEN
            ui_ISyncDigIn2RiseOldCounter  := ui_oldCounter;
            sd_ISyncDigIn2RiseOldPosition := EncoderPosition;
          END_IF;
          IF bs_ActiveISyncValue.DigIn2Fall THEN
            ui_ISyncDigIn2FallOldCounter  := ui_oldCounter;
            sd_ISyncDigIn2FallOldPosition := EncoderPosition;
          END_IF;
        ELSE
          IF bs_ActiveISyncValue.DigIn1Rise THEN
            ui_ISyncDigIn1RiseOldCounter  := ui_oldCounterVirtual;
            sd_ISyncDigIn1RiseOldPosition := ActPosition;
          END_IF;
          IF bs_ActiveISyncValue.DigIn1Fall THEN
            ui_ISyncDigIn1FallOldCounter  := ui_oldCounterVirtual;
            sd_ISyncDigIn1FallOldPosition := ActPosition;
          END_IF;
          IF bs_ActiveISyncValue.DigIn2Rise THEN
            ui_ISyncDigIn2RiseOldCounter  := ui_oldCounterVirtual;
            sd_ISyncDigIn2RiseOldPosition := ActPosition;
          END_IF;
          IF bs_ActiveISyncValue.DigIn2Fall THEN
            ui_ISyncDigIn2FallOldCounter  := ui_oldCounterVirtual;
            sd_ISyncDigIn2FallOldPosition := ActPosition;
          END_IF;
        END_IF;
        
        IF EncoderSampling <> 0 THEN

          bs_ActiveISyncValue.IncZero := bs_ActiveISyncValue.IncZero OR ActStateWord.LatchIncZero;
          
          ZeroPulse_latched := ZeroPulse_latched OR bs_ActiveISyncValue.IncZero;
          
          IF bs_ActiveISyncValue.IncZero THEN
            ui_ISyncIncZeroOldCounter := ui_oldCounter;
            sd_ISyncIncZeroOldPosition := EncoderPosition;
          END_IF;
          
          //actual encoder position
          ui_temp := s_IODataObject.p_DataRead^.IncrementalEncoderValue;
          si_delta := to_INT(ui_temp - ui_oldCounter);
          EncoderPosition += TO_DINT(si_delta);
          ui_oldCounter := ui_temp;
        
        END_IF;

        b_started := FALSE;
        FOR i := 0 TO 7 DO
          bs_ActualISyncValue := bs_ActualISyncValue ROL 1;
          IF ((bs_ValidISyncValue AND bs_ActualISyncValue) = 0) & ( bs_ActiveISyncValue AND bs_ActualISyncValue ) THEN
            IF bs_ActualISyncValue.IncZero THEN
              IsoReadAddress(udAddress :=  VST011_OFFSET_READ_DATA + 16#6);
              bs_ActiveISyncValue.IncZero := 0;
            ELSIF bs_ActualISyncValue.DigIn1Rise THEN
              IsoReadAddress(udAddress := VST011_OFFSET_READ_DATA + 16#8);
              bs_ActiveISyncValue.DigIn1Rise := 0;
            ELSIF bs_ActualISyncValue.DigIn1Fall THEN
              IsoReadAddress(udAddress := VST011_OFFSET_READ_DATA + 16#A);
              bs_ActiveISyncValue.DigIn1Fall := 0;
            ELSIF bs_ActualISyncValue.DigIn2Rise THEN
              IsoReadAddress(udAddress := VST011_OFFSET_READ_DATA + 16#C);
              bs_ActiveISyncValue.DigIn2Rise := 0;
            ELSIF bs_ActualISyncValue.DigIn2Fall THEN
              IsoReadAddress(udAddress := VST011_OFFSET_READ_DATA + 16#E);
              bs_ActiveISyncValue.DigIn2Fall := 0;
            END_IF;
            b_started := TRUE;
            EXIT;
          END_IF;
        END_FOR;

        if bs_ValidISyncValue then
          ui_temp := s_ISyncDO.p_DataRead^;
          IF bs_ValidISyncValue.IncZero THEN
            bs_ValidISyncValue.IncZero := 0;
            si_delta := to_INT(ui_temp - ui_ISyncIncZeroOldCounter);
            LatchedValueZeroPosition := LatchPositionEncoderZeroPulse := sd_ISyncIncZeroOldPosition + TO_DINT(si_delta);
            LatchedValueZeroPosition.Write (LatchedValueZeroPosition);
          ELSIF bs_ValidISyncValue.DigIn1Rise THEN
            bs_ValidISyncValue.DigIn1Rise := 0;
            si_delta := to_INT(ui_temp - ui_ISyncDigIn1RiseOldCounter);
            LatchedValueInput1Rising := LatchPositionInput1Rising := sd_ISyncDigIn1RiseOldPosition + TO_DINT(si_delta);
            LatchedValueInput1Rising.Write (LatchedValueInput1Rising);
          ELSIF bs_ValidISyncValue.DigIn1Fall THEN
            bs_ValidISyncValue.DigIn1Fall := 0;
            si_delta := to_INT(ui_temp - ui_ISyncDigIn1FallOldCounter);
            LatchedValueInput1Falling := LatchPositionInput1Falling := sd_ISyncDigIn1FallOldPosition + TO_DINT(si_delta);
            LatchedValueInput1Falling.Write (LatchedValueInput1Falling);
          ELSIF bs_ValidISyncValue.DigIn2Rise THEN
            bs_ValidISyncValue.DigIn2Rise := 0;
            si_delta := to_INT(ui_temp - ui_ISyncDigIn2RiseOldCounter);
            LatchedValueInput2Rising := LatchPositionInput2Rising := sd_ISyncDigIn2RiseOldPosition + TO_DINT(si_delta);
            LatchedValueInput2Rising.Write (LatchedValueInput2Rising);
          ELSIF bs_ValidISyncValue.DigIn2Fall THEN
            bs_ValidISyncValue.DigIn2Fall := 0;
            si_delta := to_INT(ui_temp - ui_ISyncDigIn2FallOldCounter);
            LatchedValueInput2Falling := LatchPositionInput2Falling := sd_ISyncDigIn2FallOldPosition + TO_DINT(si_delta);
            LatchedValueInput2Falling.Write (LatchedValueInput2Falling);
          END_IF;
        end_if;

        if b_started = TRUE then
          bs_ValidISyncValue := bs_ActualISyncValue;
        end_if;
        
        //actual virtual position
        ui_temp := s_IODataObject.p_DataRead^.ActPos;
        si_delta := to_INT(ui_temp - ui_oldCounterVirtual);
        ActPosition += TO_DINT(si_delta);
        ui_oldCounterVirtual := ui_temp;

        StateWord.OperationEnabled := ActStateWord.MotorEnabled;
        StateWord.SwitchedOn := ( ActStateWord.ExternalEnable AND ( ActStateWord.Fault = 0 ) );
        ExternalEnable := ActStateWord.ExternalEnable;
        StateWord.ReadyToSwitchOn := ActStateWord.BridgeOK;
        StateWord.Warning := ( ActStateword.TemperatureOK = 0 );
        Error := Stateword.Fault := ActStateword.Fault;
        
        HWError := NOT StateWord.SwitchedOn;
        
        // Handle Single run DO
        if b_PayloadSupport then          
          // s_SettingsDataObjectxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
          case s_ISyncDO.b_DOIsRunning of
          
            SR_STATE_ENABLE_ME :  // DO is not running and start request is set ----------------------------------------
              EnableDO(ud_DOHandle := s_ISyncDO.p_Handle$UDINT);        
              s_ISyncDO.b_DOIsRunning  := SR_STATE_DISABLE_ME;
              
            SR_STATE_DISABLE_ME : // DO is running and start request is not set ----------------------------------------
              DisableDO(ud_DOHandle:= s_ISyncDO.p_Handle$UDINT);
              s_ISyncDO.b_DOIsRunning := SR_STATE_NOTHING;
              
            SR_STATE_LEAVE_ME_ENABLED : // DO is running and another start request is set ------------------------------
              s_ISyncDO.b_DOIsRunning := SR_STATE_DISABLE_ME;
              
          end_case;          
        end_if;        
      
        //rt is passed through => data is valid
        if eCycleWork = _CyclePreOperational then
          Online     := 1;
          eCycleWork := _CycleOperational;
        end_if;      
        
    end_case;          
  end_if;

//=================================================================================================
#ifdef VM_CLASS_TIME_MEASUREMENT
  StopTimeMeasurement(VARANTIME_RT);
#endif
//=================================================================================================

END_FUNCTION


FUNCTION VIRTUAL GLOBAL VST011::UpdateRtPostScan

//=================================================================================================
#ifdef VM_CLASS_TIME_MEASUREMENT
  StartTimeMeasurement(VARANTIME_RTPOSTSCAN);
#endif
//=================================================================================================

  if State = _ClassOk then
    s_IODataObject.p_DataWrite^.SetFrequency := SetFreqOut;
    s_IODataObject.s_DataWrite.ControlWord.HWEnableSofwareRampdownToggleBit := s_IODataObject.s_DataWrite.ControlWord.HWEnableSofwareRampdownToggleBit XOR to_BOOL(HWEnableSoftwareRampdown);
    s_IODataObject.s_DataWrite.ControlWord.SwitchOn := s_ControlWord.SwitchOn;
    s_IODataObject.s_DataWrite.ControlWord.FaultReset := s_ControlWord.FaultReset;
    s_IODataObject.s_DataWrite.ControlWord.CurrentDropEnable := s_ControlWord.CurrentDropEnable;
    s_IODataObject.s_DataWrite.ControlWord.CurrentIncrease := s_ControlWord.CurrentIncrease;
    s_IODataObject.s_DataWrite.ControlWord.LatchType := s_ControlWord.LatchType;
    s_IODataObject.p_DataWrite^.ControlWord := s_IODataObject.s_DataWrite.ControlWord;
    s_IODataObject.p_DataWrite^.MaximumCurrent := u_MaxCurrent;
    ErrorQuit := ControlWord.ResetFault := s_ControlWord.FaultReset := 0;
  end_if;
  
//=================================================================================================
#ifdef VM_CLASS_TIME_MEASUREMENT
  StopTimeMeasurement(VARANTIME_RTPOSTSCAN);
#endif
//=================================================================================================

END_FUNCTION


FUNCTION VIRTUAL GLOBAL VST011::SetDOsOff

  // Payload Support
  DisableDO(ud_DOHandle := s_IODataObject.p_Handle$UDINT);
  DisableDO(ud_DOHandle := s_SettingsDataObject.p_Handle$UDINT);
  DisableDO(ud_DOHandle := s_ISyncDO.p_Handle$UDINT);
  
  s_SettingsDataObject.b_DOIsRunning  := 0;
  s_ISyncDO.b_DOIsRunning             := 0;

END_FUNCTION

#pragma warning(disable: 73)
FUNCTION VIRTUAL GLOBAL VST011::Varan_HwDisconnect
  VAR_INPUT
    ud_data   : UDINT;
  END_VAR
  VAR_OUTPUT
    sd_retval   : DINT;
  END_VAR
#pragma warning(default: 73)

  SetDOsOff();

  StateWord := 0;

  sd_MaxAllowedCurrent := 0;

  sd_retval := Varan_Base::Varan_HwDisconnect(ud_data);

END_FUNCTION


FUNCTION VIRTUAL GLOBAL VST011::CheckDeviceID
  VAR_INPUT
    ID2Check  : UDINT;
  END_VAR
  VAR_OUTPUT
    IsOK  : BOOL;
  END_VAR

  //look if it is right hardware
  if ( ID2Check <> VST011_DEVICE_ID ) then
    IsOK := FALSE;
  else
    IsOK := TRUE;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL VST011::Output1::Write
  VAR_INPUT
    input (EAX)   : DINT;
  END_VAR
  VAR_OUTPUT
    result (EAX)  : DINT;
  END_VAR

  if input then
    result  := 1;
    Output1 := 1;
    s_IODataObject.s_DataWrite.ControlWord.DigOut1 := 1;
  else
    result  := 0;
    Output1 := 0;
    s_IODataObject.s_DataWrite.ControlWord.DigOut1 := 0;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL VST011::Output2::Write
  VAR_INPUT
    input (EAX)   : DINT;
  END_VAR
  VAR_OUTPUT
    result (EAX)  : DINT;
  END_VAR

  if input then
    result  := 1;
    Output2 := 1;
    s_IODataObject.s_DataWrite.ControlWord.DigOut2 := 1;
  else
    result  := 0;
    Output2 := 0;
    s_IODataObject.s_DataWrite.ControlWord.DigOut2 := 0;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL VST011::Output3::Write
  VAR_INPUT
    input (EAX)   : DINT;
  END_VAR
  VAR_OUTPUT
    result (EAX)  : DINT;
  END_VAR

  if input then
    result  := 1;
    Output3 := 1;
    s_IODataObject.s_DataWrite.ControlWord.DigOut3 := 1;
  else
    result  := 0;
    Output3 := 0;
    s_IODataObject.s_DataWrite.ControlWord.DigOut3 := 0;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL VST011::Output4::Write
  VAR_INPUT
    input (EAX)   : DINT;
  END_VAR
  VAR_OUTPUT
    result (EAX)  : DINT;
  END_VAR

  if input then
    result  := 1;
    Output4 := 1;
    s_IODataObject.s_DataWrite.ControlWord.DigOut4 := 1;
  else
    result  := 0;
    Output4 := 0;
    s_IODataObject.s_DataWrite.ControlWord.DigOut4 := 0;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL VST011::Enable::Write
  VAR_INPUT
    input (EAX)   : DINT;
  END_VAR
  VAR_OUTPUT
    result (EAX)  : DINT;
  END_VAR

  result := Enable := s_ControlWord.SwitchOn := ControlWord.SwitchOn := ControlWord.EnableOperation := to_bool(input);

END_FUNCTION


FUNCTION VIRTUAL GLOBAL VST011::ErrorQuit::Write
  VAR_INPUT
    input (EAX)   : DINT;
  END_VAR
  VAR_OUTPUT
    result (EAX)  : DINT;
  END_VAR

  result := ErrorQuit := s_ControlWord.FaultReset := ControlWord.ResetFault := to_bool(input);

END_FUNCTION


FUNCTION VIRTUAL GLOBAL VST011::CurrentIncrease::Write
  VAR_INPUT
    input (EAX)   : DINT;
  END_VAR
  VAR_OUTPUT
    result (EAX)  : DINT;
  END_VAR

  result := CurrentIncrease := s_ControlWord.CurrentIncrease := ControlWord.ManufactureSpec2 := to_bool(input);

END_FUNCTION


FUNCTION VIRTUAL GLOBAL VST011::ControlWord::Write
  VAR_INPUT
    input (EAX)   : DS402_Control;
  END_VAR
  VAR_OUTPUT
    result (EAX)  : DS402_Control;
  END_VAR

  result := ControlWord := input;
  
  Enable := ControlWord.SwitchOn AND ControlWord.EnableOperation;
  s_ControlWord.SwitchOn := to_BOOL(Enable);
  s_ControlWord.FaultReset := ControlWord.ResetFault;
  s_ControlWord.CurrentIncrease := ControlWord.ManufactureSpec1;
  CurrentIncrease := to_DINT(s_ControlWord.CurrentIncrease);
  ErrorQuit := ControlWord.ResetFault;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL VST011::SetFreqOut::Write
  VAR_INPUT
    input (EAX)   : DINT;
  END_VAR
  VAR_OUTPUT
    result (EAX)  : DINT;
  END_VAR
  VAR
    tmpCounter : SINT;
  END_VAR
  
  // Max Frequency is 1 Mhz, if negative: move to negative dir
  // 18.01.11  am
  
  if input <> SetFreqOut then //just do something when the value changed
  
    IF input > 1000000 THEN
      input := 1000000;
    ELSIF input < -1000000 THEN
      input := -1000000;
    END_IF;
        
        
    //Hysterese Control
    //*****************************************************************************
    if FrequencyBandwidth then
    
      //Rising
      //---------------------------------------------------------------
      if input > SetFreqOut then
      
        //Check which Step is active
        for tmpCounter := 0 to (sizeof(a_FrequencyLimit) / sizeof(a_FrequencyLimit[0])) - 1  do
        
          //Check if Limit of Frequencyrange for this Mode is reached
          if a_FrequencyLimit[tmpCounter].LimitHigh <> 16#FFFF_FFFF & a_FrequencyLimit[tmpCounter].LimitHigh <= ABS(input)$USINT then
            us_ActFrequencyStep := tmpCounter$USINT;
            exit;
          end_if;
        
        end_for;
        
        //Set correct FrequencyLimit
        case us_ActFrequencyStep of
          
          0:  tmpCounter := VST_ASYNC_FREQUENCYLIMIT1;
          1:  tmpCounter := VST_ASYNC_FREQUENCYLIMIT2;
          2:  tmpCounter := VST_ASYNC_FREQUENCYLIMIT4;
          3:  tmpCounter := VST_ASYNC_FREQUENCYLIMIT8;
          4:  tmpCounter := VST_ASYNC_FREQUENCYLIMIT16;
          5:  tmpCounter := VST_ASYNC_FREQUENCYLIMIT32;
          
        end_case;
        
        //Set new Limit (LowLimit for Hysterese)
        WriteParameter( us_ParameterNr  := tmpCounter$USINT, 
                        ud_Value        := a_FrequencyLimit[us_ActFrequencyStep].LimitLow);
      
      //Falling
      //---------------------------------------------------------------
      elsif input < SetFreqOut then
      
        us_ActFrequencyStep := 0;
        
        //Check which Step is active
        for tmpCounter := 0 to (sizeof(a_FrequencyLimit) / sizeof(a_FrequencyLimit[0])) - 1 do
        
          //Check if Limit of Frequencyrange for this Mode is reached
          if a_FrequencyLimit[tmpCounter].LimitLow <> 16#FFFF_FFFF & a_FrequencyLimit[tmpCounter].LimitLow >= ABS(input)$USINT then
            us_ActFrequencyStep := tmpCounter$USINT;
          end_if;
          
        end_for;
        
        //Set correct FrequencyLimit
        case us_ActFrequencyStep of
          
          0:  tmpCounter := VST_ASYNC_FREQUENCYLIMIT1;
          1:  tmpCounter := VST_ASYNC_FREQUENCYLIMIT2;
          2:  tmpCounter := VST_ASYNC_FREQUENCYLIMIT4;
          3:  tmpCounter := VST_ASYNC_FREQUENCYLIMIT8;
          4:  tmpCounter := VST_ASYNC_FREQUENCYLIMIT16;
          5:  tmpCounter := VST_ASYNC_FREQUENCYLIMIT32;
          
        end_case;
        
        //Set new Limit (HighLimit for Hysterese)
        WriteParameter( us_ParameterNr  := tmpCounter$USINT, 
                        ud_Value        := a_FrequencyLimit[us_ActFrequencyStep].LimitHigh);
      
      end_if;
      
      //---------------------------------------------------------------
      
    end_if;

    //*****************************************************************************

    SetFreqOut := input;
    
    //Calculate Current
    if abs(SetFreqOut)$UDINT <= udStallCurrentWindow then
      u_MaxCurrent := to_uint(MaxCurrent - ((MaxCurrent * StallCurrentReduction) / 1000));
    else
      u_MaxCurrent := to_uint(MaxCurrent);
    end_if;
    
  end_if;
  
  result := input;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL VST011::ChopperOffTime::Write
  VAR_INPUT
    input (EAX)   : DINT;
  END_VAR
  VAR_OUTPUT
    result (EAX)  : DINT;
  END_VAR

  WriteParameter(us_ParameterNr := VST_ASYNC_CHOPPEROFFTIME, ud_Value := input$UDINT);
  result := input;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL VST011::BlankingTime::Write
  VAR_INPUT
    input (EAX)   : DINT;
  END_VAR
  VAR_OUTPUT
    result (EAX)  : DINT;
  END_VAR

  WriteParameter(us_ParameterNr := VST_ASYNC_BLANKINGTIMEREGISTER, ud_Value := input$UDINT);
  result := input;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL VST011::FastDecayTime::Write
  VAR_INPUT
    input (EAX)   : DINT;
  END_VAR
  VAR_OUTPUT
    result (EAX)  : DINT;
  END_VAR

  WriteParameter(us_ParameterNr := VST_ASYNC_FASTDECAYTIME, ud_Value := input$UDINT);
  result := input;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL VST011::FrequencyLimit1::Write
  VAR_INPUT
    input (EAX)   : UDINT;
  END_VAR
  VAR_OUTPUT
    result (EAX)  : UDINT;
  END_VAR

  // Max Frequency is 1 Mhz  
  IF input > 1000000 & input <> 16#FFFF_FFFF THEN
    input := 1000000;
  END_IF;
  
  if FrequencyLimit1 <> input then //do we have a new value?
  
    //Save Input
    FrequencyLimit1 := input;
    
    //Set new Limit
    WriteParameter(us_ParameterNr:= VST_ASYNC_FREQUENCYLIMIT1, ud_Value:=FrequencyLimit1);
    
    //Calculate Limits for Hysterese
    //*****************************************************************************
    if FrequencyLimit1 <> 16#FFFF_FFFF then
    
      //LowLomit
      if FrequencyLimit1 > FrequencyBandwidth / 2 then
        a_FrequencyLimit[0].LimitLow := FrequencyLimit1 - (FrequencyBandwidth / 2);
      else
        a_FrequencyLimit[0].LimitLow := FrequencyLimit1;
      end_if;
      
      //High Limit
      if FrequencyLimit1 + (FrequencyBandwidth / 2) < 1000000 then
        a_FrequencyLimit[0].LimitHigh  := FrequencyLimit1 + (FrequencyBandwidth / 2);
      else
        a_FrequencyLimit[0].LimitHigh := FrequencyLimit1;
      end_if;
      
    else
    
      //Set inactive
      a_FrequencyLimit[0].LimitHigh := a_FrequencyLimit[0].LimitLow := 16#FFFF_FFFF;
      
    end_if;
    
  end_if;

  result := input;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL VST011::FrequencyLimit2::Write
  VAR_INPUT
    input (EAX)   : UDINT;
  END_VAR
  VAR_OUTPUT
    result (EAX)  : UDINT;
  END_VAR

  // Max Frequency is 1 Mhz  
  IF input > 1000000 & input <> 16#FFFF_FFFF THEN
    input := 1000000;
  END_IF;
  
  if FrequencyLimit2 <> input then //do we have a new value?
    
    //Save Input
    FrequencyLimit2 := input;
    
    //Set new Limit
    WriteParameter(us_ParameterNr:= VST_ASYNC_FREQUENCYLIMIT2, ud_Value:=FrequencyLimit2);
    
    //Calculate Limits for Hysterese
    //*****************************************************************************
    if FrequencyLimit2 <> 16#FFFF_FFFF then
    
      //LowLomit
      if FrequencyLimit2 > FrequencyBandwidth / 2 then
        a_FrequencyLimit[1].LimitLow := FrequencyLimit2 - (FrequencyBandwidth / 2);
      else
        a_FrequencyLimit[1].LimitLow := FrequencyLimit2;
      end_if;
      
      //High Limit
      if FrequencyLimit2 + (FrequencyBandwidth / 2) < 1000000 then
        a_FrequencyLimit[1].LimitHigh  := FrequencyLimit2 + (FrequencyBandwidth / 2);
      else
        a_FrequencyLimit[1].LimitHigh := FrequencyLimit2;
      end_if;
      
    else
    
      //Set inactive
      a_FrequencyLimit[1].LimitHigh := a_FrequencyLimit[1].LimitLow := 16#FFFF_FFFF;
      
    end_if;
    
  end_if;

  result := input;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL VST011::FrequencyLimit4::Write
  VAR_INPUT
    input (EAX)   : UDINT;
  END_VAR
  VAR_OUTPUT
    result (EAX)  : UDINT;
  END_VAR

  // Max Frequency is 1 Mhz  
  IF input > 1000000 & input <> 16#FFFF_FFFF THEN
    input := 1000000;
  END_IF;
  
  if FrequencyLimit4 <> input then //do we have a new value?
  
    //Save Input
    FrequencyLimit4 := input;
    
    //Set new Limit
    WriteParameter(us_ParameterNr:= VST_ASYNC_FREQUENCYLIMIT4, ud_Value:=FrequencyLimit4);
    
    //Calculate Limits for Hysterese
    //*****************************************************************************
    if FrequencyLimit4 <> 16#FFFF_FFFF then
    
      //LowLomit
      if FrequencyLimit4 > FrequencyBandwidth / 2 then
        a_FrequencyLimit[2].LimitLow := FrequencyLimit4 - (FrequencyBandwidth / 2);
      else
        a_FrequencyLimit[2].LimitLow := FrequencyLimit4;
      end_if;
      
      //High Limit
      if FrequencyLimit4 + (FrequencyBandwidth / 2) < 1000000 then
        a_FrequencyLimit[2].LimitHigh  := FrequencyLimit4 + (FrequencyBandwidth / 2);
      else
        a_FrequencyLimit[2].LimitHigh := FrequencyLimit4;
      end_if;
      
    else
    
      //Set inactive
      a_FrequencyLimit[2].LimitHigh := a_FrequencyLimit[2].LimitLow := 16#FFFF_FFFF;
      
    end_if;
    
  end_if;

  result := input;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL VST011::FrequencyLimit8::Write
  VAR_INPUT
    input (EAX)   : UDINT;
  END_VAR
  VAR_OUTPUT
    result (EAX)  : UDINT;
  END_VAR

  // Max Frequency is 1 Mhz  
  IF input > 1000000 & input <> 16#FFFF_FFFF THEN
    input := 1000000;
  END_IF;
  
  if FrequencyLimit8 <> input then //do we have a new value?
  
    //Save Input
    FrequencyLimit8 := input;
    
    //Set new Limit
    WriteParameter(us_ParameterNr:= VST_ASYNC_FREQUENCYLIMIT8, ud_Value:=FrequencyLimit8);
    
    //Calculate Limits for Hysterese
    //*****************************************************************************
    if FrequencyLimit8 <> 16#FFFF_FFFF then
    
      //LowLomit
      if FrequencyLimit8 > FrequencyBandwidth / 2 then
        a_FrequencyLimit[3].LimitLow := FrequencyLimit8 - (FrequencyBandwidth / 2);
      else
        a_FrequencyLimit[3].LimitLow := FrequencyLimit8;
      end_if;
      
      //High Limit
      if FrequencyLimit8 + (FrequencyBandwidth / 2) < 1000000 then
        a_FrequencyLimit[3].LimitHigh  := FrequencyLimit8 + (FrequencyBandwidth / 2);
      else
        a_FrequencyLimit[3].LimitHigh := FrequencyLimit8;
      end_if;
      
    else
    
      //Set inactive
      a_FrequencyLimit[3].LimitHigh := a_FrequencyLimit[3].LimitLow := 16#FFFF_FFFF;
      
    end_if;
    
  end_if;

  result := input;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL VST011::FrequencyLimit16::Write
  VAR_INPUT
    input (EAX)   : UDINT;
  END_VAR
  VAR_OUTPUT
    result (EAX)  : UDINT;
  END_VAR

  // Max Frequency is 1 Mhz  
  IF input > 1000000 & input <> 16#FFFF_FFFF THEN
    input := 1000000;
  END_IF;
  
  if FrequencyLimit16 <> input then //do we have a new value?
  
    //Save Input
    FrequencyLimit16 := input;
    
    //Set new Limit
    WriteParameter(us_ParameterNr:= VST_ASYNC_FREQUENCYLIMIT16, ud_Value:=FrequencyLimit16);
    
    //Calculate Limits for Hysterese
    //*****************************************************************************
    if FrequencyLimit16 <> 16#FFFF_FFFF then
    
      //LowLomit
      if FrequencyLimit16 > FrequencyBandwidth / 2 then
        a_FrequencyLimit[4].LimitLow := FrequencyLimit16 - (FrequencyBandwidth / 2);
      else
        a_FrequencyLimit[4].LimitLow := FrequencyLimit16;
      end_if;
      
      //High Limit
      if FrequencyLimit16 + (FrequencyBandwidth / 2) < 1000000 then
        a_FrequencyLimit[4].LimitHigh  := FrequencyLimit16 + (FrequencyBandwidth / 2);
      else
        a_FrequencyLimit[4].LimitHigh := FrequencyLimit16;
      end_if;
      
    else
    
      //Set inactive
      a_FrequencyLimit[4].LimitHigh := a_FrequencyLimit[4].LimitLow := 16#FFFF_FFFF;
      
    end_if;
    
  end_if;

  result := input;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL VST011::FrequencyLimit32::Write
  VAR_INPUT
    input (EAX)   : UDINT;
  END_VAR
  VAR_OUTPUT
    result (EAX)  : UDINT;
  END_VAR

  // Max Frequency is 1 Mhz 
  IF input > 1000000 & input <> 16#FFFF_FFFF THEN
    input := 1000000;
  END_IF;
  
  if FrequencyLimit32 <> input then //do we have a new value?
  
    //Save Input
    FrequencyLimit32 := input;
    
    //Set new Limit
    WriteParameter(us_ParameterNr:= VST_ASYNC_FREQUENCYLIMIT32, ud_Value:=FrequencyLimit32);
    
    //Calculate Limits for Hysterese
    //*****************************************************************************
    if FrequencyLimit32 <> 16#FFFF_FFFF then
    
      //LowLomit
      if FrequencyLimit32 > FrequencyBandwidth / 2 then
        a_FrequencyLimit[5].LimitLow := FrequencyLimit32 - (FrequencyBandwidth / 2);
      else
        a_FrequencyLimit[5].LimitLow := FrequencyLimit32;
      end_if;
      
      //High Limit
      if FrequencyLimit32 + (FrequencyBandwidth / 2) < 1000000 then
        a_FrequencyLimit[5].LimitHigh  := FrequencyLimit32 + (FrequencyBandwidth / 2);
      else
        a_FrequencyLimit[5].LimitHigh := FrequencyLimit32;
      end_if;
      
    else
    
      //Set inactive
      a_FrequencyLimit[5].LimitHigh := a_FrequencyLimit[5].LimitLow := 16#FFFF_FFFF;
      
    end_if;
    
  end_if;

  result := input;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL VST011::HWRampdownDeltaFrequency::Write
  VAR_INPUT
    input (EAX)   : DINT;
  END_VAR
  VAR_OUTPUT
    result (EAX)  : DINT;
  END_VAR

  WriteParameter(us_ParameterNr := VST_ASYNC_EXTERNALLOCKDELTAFREQUENCY, ud_Value := input$UDINT);
  result := input;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL VST011::HWRampdownDeltaTime::Write
  VAR_INPUT
    input (EAX)   : DINT;
  END_VAR
  VAR_OUTPUT
    result (EAX)  : DINT;
  END_VAR

  WriteParameter(us_ParameterNr := VST_ASYNC_EXTERNALLOCKDELTATIME, ud_Value := input$UDINT);
  result := input;

END_FUNCTION


FUNCTION GLOBAL VST011::RequestParameter
  VAR_INPUT
    us_ParameterNr  : USINT;
  END_VAR
  VAR_OUTPUT
    retcode   : DINT;
  END_VAR
  VAR
    tmpCounter : USINT;
  END_VAR

  retcode := VST_ERROR_ASYNC_NOERROR;

  if us_ParameterNr <= VST011_MAXASYNCPARAMETER &  us_ReadNumber <= VST011_MAXASYNCPARAMETER then

    // Check if Element is already active
    //*****************************************************************************
    if us_ReadNumber then
    
      //No Overflow of Buffer (to be Thread-Safe)
      //---------------------------------------------------------------------------
      if us_ReadPosition + us_ReadNumber - 1 <= VST011_MAXASYNCPARAMETER then
      
        for tmpCounter := us_ReadPosition to us_ReadPosition + us_ReadNumber - 1 do
          if a_ParameterReadRequest[tmpCounter] = us_ParameterNr then
            retcode := VST_ERROR_ASYNC_ALREADYACTIVE;
            return;
          end_if;
        end_for;
      
      //Overflow of Buffer (to be Thread-Safe)
      //---------------------------------------------------------------------------
      else
      
        //Check actual Position to End of Buffer
        for tmpCounter := us_ReadPosition to VST011_MAXASYNCPARAMETER do
          if a_ParameterReadRequest[tmpCounter] = us_ParameterNr then
            retcode := VST_ERROR_ASYNC_ALREADYACTIVE;
            return;
          end_if;
        end_for;    
        
        //Check from Zero to actual Element
        for tmpCounter := 0 to us_ReadNumber - VST011_MAXASYNCPARAMETER + us_ReadPosition - 2 do
          if a_ParameterReadRequest[tmpCounter] = us_ParameterNr then
            retcode := VST_ERROR_ASYNC_ALREADYACTIVE;
            return;
          end_if;
        end_for;  
      end_if;

    end_if;    

    // Save into Queue for asynchronous ReadAccess
    //*****************************************************************************
    if us_ReadPosition + us_ReadNumber <= VST011_MAXASYNCPARAMETER  then
      a_ParameterReadRequest[us_ReadPosition + us_ReadNumber]   := us_ParameterNr;
    else
      a_ParameterReadRequest[us_ReadPosition + us_ReadNumber - VST011_MAXASYNCPARAMETER - 1] := us_ParameterNr;
    end_if;

    us_ReadNumber += 1;
    a_ReadDataBuffer[us_ParameterNr].b_Valid := false;

  else
    retcode := VST_ERROR_ASYNC_INVALIDPARAMETER;
  end_if;

END_FUNCTION


FUNCTION GLOBAL VST011::WriteParameter
  VAR_INPUT
    us_ParameterNr  : USINT;
    ud_Value  : UDINT;
  END_VAR
  VAR_OUTPUT
    retcode   : DINT;
  END_VAR
  VAR
    tmpCounter : USINT;
    pAsyWrData  : ^t_AsyncWriteData;
    pLastWritten: ^t_LastWrittenValues;
    ForEnd : USINT;
  END_VAR

  retcode := VST_ERROR_ASYNC_NOERROR;
  
  IF (us_ParameterNr <= VST011_MAXASYNCPARAMETER) & (us_WriteNumber <= VST011_MAXASYNCPARAMETER) THEN
    CASE us_ParameterNr OF
      VST_ASYNC_INCREMENTALENCODERSETTINGS, //not implemented (user otherwise might access internal test-registers)
      VST_ASYNC_BRIDGE2OFF, //implemented but may not be called (user could damage the card)!
      VST_ASYNC_BRIDGE2MUL,
      VST_ASYNC_BRIDGE2DIV,
      VST_ASYNC_BRIDGE1OFF,
      VST_ASYNC_BRIDGE1MUL,
      VST_ASYNC_BRIDGE1DIV,
      VST_ASYNC_BRIDGESUPPLYVOLTAGELOWERTHRESHOLD,
      VST_ASYNC_BRIDGESUPPLYVOLTAGEUPPERTHRESHOLD,
      VST_ASYNC_BRIDGETEMPERATUREWARNINGTHRESHOLD,
      VST_ASYNC_BRIDGETEMPERATUREERRORTHRESHOLD,
      VST_ASYNC_EXTENDEDSTATEWORD,
      VST_ASYNC_COMMUTATIONCOUNTERBRIDGE1,
      VST_ASYNC_COMMUTATIONCOUNTERBRIDGE2,
      VST_ASYNC_ONTIMECOUNTERBRIDGE1,
      VST_ASYNC_ONTIMECOUNTERBRIDGE2,
      VST_ASYNC_HBRIDGE_VOLTAGE,
      VST_ASYNC_HBRIDGE_TEMPERATURE:
        retcode := VST_ERROR_ASYNC_WRITENOTALLOWED;
    ELSE
      // if the value is the same as the last value we wrote on this parameter => don't do it
      pLastWritten := #a_LastWrittenAsyValues[0] + us_ParameterNr * sizeof(t_LastWrittenValues);
      if (pLastWritten^.AlreadyUsed = TRUE) & (ud_Value = pLastWritten^.Value) then
        // this is already the actual value of this parameter
        return;
      end_if;

      // Check if Element is already active
      //*****************************************************************************
      if us_WriteNumber then
      
        //No Overflow of Buffer (to be Thread-Safe)
        //---------------------------------------------------------------------------
        if us_WritePosition + us_WriteNumber - 1 <= VST011_MAXASYNCPARAMETER then
          // calculate the end only once
          ForEnd := (us_WritePosition + us_WriteNumber - 1);
          pAsyWrData := #a_WriteDataBuffer[0] + us_WritePosition * sizeof(t_AsyncWriteData);
          for tmpCounter := us_WritePosition to ForEnd do
            if pAsyWrData^.us_ID = us_ParameterNr then
              retcode := VST_ERROR_ASYNC_ALREADYACTIVE;
              pAsyWrData^.ud_Value := ud_Value;
              return;
            end_if;
            pAsyWrData += sizeof(a_WriteDataBuffer);
          end_for;
        
        //Overflow of Buffer (to be Thread-Safe)
        //---------------------------------------------------------------------------
        else
          //Check actual Position to End of Buffer
          pAsyWrData := #a_WriteDataBuffer[0] + us_WritePosition * sizeof(t_AsyncWriteData);
          for tmpCounter := us_WritePosition to VST011_MAXASYNCPARAMETER do
            if pAsyWrData^.us_ID = us_ParameterNr then
              retcode := VST_ERROR_ASYNC_ALREADYACTIVE;
              pAsyWrData^.ud_Value := ud_Value;
              return;
            end_if;
            pAsyWrData += sizeof(t_AsyncWriteData);
          end_for;    
          
          //Check from Zero to actual Element
          ForEnd := us_WriteNumber - VST011_MAXASYNCPARAMETER + us_WritePosition - 2;
          pAsyWrData := #a_WriteDataBuffer[0];
          for tmpCounter := 0 to ForEnd do
            if pAsyWrData^.us_ID = us_ParameterNr then
              retcode := VST_ERROR_ASYNC_ALREADYACTIVE;
              pAsyWrData^.ud_Value := ud_Value;
              return;
            end_if;
            pAsyWrData += sizeof(t_AsyncWriteData);
          end_for; 
        end_if;

      end_if;
      
      // Save into Queue for asynchronous WriteAccess
      //*****************************************************************************
      if us_WritePosition + us_WriteNumber <= VST011_MAXASYNCPARAMETER  then
        pAsyWrData := #a_WriteDataBuffer[0] + (us_WritePosition + us_WriteNumber) * sizeof(t_AsyncWriteData);
      else
        pAsyWrData := #a_WriteDataBuffer[0] + (us_WriteNumber + us_WritePosition - VST011_MAXASYNCPARAMETER - 1) * sizeof(t_AsyncWriteData);
      end_if;
      
      pAsyWrData^.us_ID    := us_ParameterNr;
      pAsyWrData^.ud_Value := ud_Value;
      
      pLastWritten^.Value := ud_Value;
      pLastWritten^.AlreadyUsed := TRUE;

      us_WriteNumber += 1;
    END_CASE;
  ELSE
    retcode := VST_ERROR_ASYNC_INVALIDPARAMETER;
  END_IF;

END_FUNCTION


FUNCTION GLOBAL VST011::ReadParameter
  VAR_INPUT
    us_ParameterNr  : USINT;
    p_b_Valid   : ^BOOL;
    p_ud_Value  : ^UDINT;
  END_VAR
  VAR_OUTPUT  
    retcode   : DINT;
  END_VAR

  retcode := VST_ERROR_ASYNC_NOERROR;

  IF us_ParameterNr <= VST011_MAXASYNCPARAMETER THEN
    IF p_b_Valid <> NIL THEN
      p_b_Valid^ := a_ReadDataBuffer[us_ParameterNr].b_Valid;
    END_IF;
    a_ReadDataBuffer[us_ParameterNr].b_Valid := FALSE;
    IF p_ud_Value <> NIL THEN
      p_ud_Value^ := a_ReadDataBuffer[us_ParameterNr].ud_Value;
    ELSE
      retcode := VST_ERROR_ASYNC_NOVALUEPTR;
    END_IF;
  ELSE
    retcode := VST_ERROR_ASYNC_INVALIDPARAMETER;
  END_IF;

END_FUNCTION



FUNCTION VIRTUAL GLOBAL VST011::MaxCurrent::Write
  VAR_INPUT
    input (EAX)   : DINT;
  END_VAR
  VAR_OUTPUT
    result (EAX)  : DINT;
  END_VAR

  //Check for Change
  if input <> MaxCurrent then
  
    //Check Limit
    if input < 0 then
      input := 0;
    elsif input > sd_MaxAllowedCurrent then
      input := sd_MaxAllowedCurrent;
    end_if;
  
    //Calculate Current
    if abs(SetFreqOut)$UDINT <= udStallCurrentWindow then
      u_MaxCurrent := to_uint(input - ((input * StallCurrentReduction) / 1000));
    else
      u_MaxCurrent := to_uint(input);
    end_if;

  end_if;

  result := MaxCurrent := input;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL VST011::UpdateRetryCounter  
  VAR
    tempRetryCounter : USINT;
  END_VAR
  
  // LanSte 16.04.2013 10:49
  // Updated to use new Method for Payload support
  tempRetryCounter := GetRetryCounter(ud_DOHandle := s_IODataObject.p_Handle$UDINT);
  if ( tempRetryCounter <> s_IODataObject.us_OldRetryCounter ) then
    RetryCounter += TO_USINT( tempRetryCounter - s_IODataObject.us_OldRetryCounter );
    s_IODataObject.us_OldRetryCounter := tempRetryCounter;
  end_if;

  tempRetryCounter := GetRetryCounter(ud_DOHandle := s_ISyncDO.p_Handle$UDINT);
  if ( tempRetryCounter <> s_ISyncDO.us_OldRetryCounter ) then
    RetryCounter += TO_USINT( tempRetryCounter - s_ISyncDO.us_OldRetryCounter );
    s_ISyncDO.us_OldRetryCounter := tempRetryCounter;
  end_if;
  
  tempRetryCounter := GetRetryCounter(ud_DOHandle := s_SettingsDataObject.p_Handle$UDINT);
  if ( tempRetryCounter <> s_SettingsDataObject.us_OldRetryCounter ) then
    RetryCounter += TO_USINT( tempRetryCounter - s_SettingsDataObject.us_OldRetryCounter );
    s_SettingsDataObject.us_OldRetryCounter := tempRetryCounter;
  end_if;  

END_FUNCTION


FUNCTION VIRTUAL GLOBAL VST011::Input1LatchedRising::Read
  VAR_OUTPUT
    output (EAX)  : DINT;
  END_VAR

  output := Input1LatchedRising;
  Input1LatchedRising := 0;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL VST011::Input1LatchedFalling::Read
  VAR_OUTPUT
    output (EAX)  : DINT;
  END_VAR

  output := Input1LatchedFalling;
  Input1LatchedFalling := 0;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL VST011::Input2LatchedRising::Read
  VAR_OUTPUT
    output (EAX)  : DINT;
  END_VAR

  output := Input2LatchedRising;
  Input2LatchedRising := 0;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL VST011::Input2LatchedFalling::Read
  VAR_OUTPUT
    output (EAX)  : DINT;
  END_VAR

  output := Input2LatchedFalling;
  Input2LatchedFalling := 0;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL VST011::ZeroPulse_latched::Read
  VAR_OUTPUT
    output (EAX)  : DINT;
  END_VAR

  output := ZeroPulse_latched;
  ZeroPulse_latched := 0;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL VST011::HWEnableSoftwareRampdown::Write
  VAR_INPUT
    input (EAX)   : DINT;
  END_VAR
  VAR_OUTPUT
    result (EAX)  : DINT;
  END_VAR

  IF input THEN
    HWEnableSoftwareRampdown := 1;
  ELSE
    HWEnableSoftwareRampdown := 0;
  END_IF;
  result := HWEnableSoftwareRampdown;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL VST011::FrequencyBandwidth::Write
  VAR_INPUT
    input (EAX)   : UDINT;
  END_VAR
  VAR_OUTPUT
    result (EAX)  : UDINT;
  END_VAR

  if FrequencyBandwidth <> input then //just do something, if the values differ 
  
    FrequencyBandwidth := input;
    
    //Calculate FrequencyLimits for Hysterese
    CalcFrequencyLimits();
  
  end_if;

  result := FrequencyBandwidth;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL VST011::StallCurrentReduction::Write
  VAR_INPUT
    input (EAX)   : DINT;
  END_VAR
  VAR_OUTPUT
    result (EAX)  : DINT;
  END_VAR

  if input <> StallCurrentReduction then //just do something when the value changes
    
    StallCurrentReduction := input;
    
    //Check for Limits
    if StallCurrentReduction < 0 then
      StallCurrentReduction := 0;
    elsif StallCurrentReduction > 1000 then
      StallCurrentReduction := 1000;
    end_if;
    
    //Calculate Current
    if abs(SetFreqOut)$UDINT <= udStallCurrentWindow then
      u_MaxCurrent := to_uint(MaxCurrent - ((MaxCurrent * StallCurrentReduction) / 1000));
    else
      u_MaxCurrent := to_uint(MaxCurrent);
    end_if;
    
  end_if;

  result := StallCurrentReduction;

END_FUNCTION


FUNCTION VST011::WriteAsyncParameter
  
  // check if any asynchronous Parameter must be sent
  //*****************************************************************************
  if us_WriteNumber then

    //*****************************************************************************
    //** Depending of the ParameterID, access another Register                   **
    //*****************************************************************************
    case a_WriteDataBuffer[us_WritePosition].us_ID of

     //*****************************************************************************
      
      VST_ASYNC_CHOPPEROFFTIME:
        s_SettingsDataObject.p_DataWrite$^UINT^ := a_WriteDataBuffer[us_WritePosition].ud_Value$UINT;
        ChopperOffTime$UINT := a_WriteDataBuffer[us_WritePosition].ud_Value$UINT;
        a_ReadDataBuffer[VST_ASYNC_CHOPPEROFFTIME].b_Valid := false;
        
        AsyWriteAddress(udAddress := VST011_OFFSET_SETTINGS + t_s_SettingsDataType.ChopperOffTime, 
                        usLength  := sizeof(t_s_SettingsDataType.ChopperOffTime));
        
      //*****************************************************************************

      VST_ASYNC_FASTDECAYTIME:
        s_SettingsDataObject.p_DataWrite$^UINT^ := a_WriteDataBuffer[us_WritePosition].ud_Value$UINT;
        FastDecayTime$UINT := a_WriteDataBuffer[us_WritePosition].ud_Value$UINT;
        a_ReadDataBuffer[VST_ASYNC_FASTDECAYTIME].b_Valid := false;
        
        AsyWriteAddress(udAddress := VST011_OFFSET_SETTINGS + t_s_SettingsDataType.FastDecayTime, 
                        usLength  := sizeof(t_s_SettingsDataType.FastDecayTime));
                      
      //*****************************************************************************
      
      VST_ASYNC_FREQUENCYLIMIT32:
        s_SettingsDataObject.p_DataWrite$^UDINT^ := a_WriteDataBuffer[us_WritePosition].ud_Value;
        
        if FrequencyBandwidth = 0 then
          FrequencyLimit32 := a_WriteDataBuffer[us_WritePosition].ud_Value;
        end_if;

        a_ReadDataBuffer[VST_ASYNC_FREQUENCYLIMIT32].b_Valid := false;
      
        AsyWriteAddress(udAddress := VST011_OFFSET_SETTINGS + t_s_SettingsDataType.FrequencyLimit32, 
                        usLength  := sizeof(t_s_SettingsDataType.FrequencyLimit32));

      //*****************************************************************************
      
      VST_ASYNC_FREQUENCYLIMIT16:
        s_SettingsDataObject.p_DataWrite$^UDINT^ := a_WriteDataBuffer[us_WritePosition].ud_Value;
        
        if FrequencyBandwidth = 0 then
          FrequencyLimit16 := a_WriteDataBuffer[us_WritePosition].ud_Value;
        end_if;

        a_ReadDataBuffer[VST_ASYNC_FREQUENCYLIMIT16].b_Valid := false;
        
        AsyWriteAddress(udAddress := VST011_OFFSET_SETTINGS + t_s_SettingsDataType.FrequencyLimit16, 
                        usLength  := sizeof(t_s_SettingsDataType.FrequencyLimit16));

      //*****************************************************************************
      
      VST_ASYNC_FREQUENCYLIMIT8:
        s_SettingsDataObject.p_DataWrite$^UDINT^ := a_WriteDataBuffer[us_WritePosition].ud_Value;
        
        if FrequencyBandwidth = 0 then
          FrequencyLimit8 := a_WriteDataBuffer[us_WritePosition].ud_Value;
        end_if;

        a_ReadDataBuffer[VST_ASYNC_FREQUENCYLIMIT8].b_Valid := false;
        
        AsyWriteAddress(udAddress := VST011_OFFSET_SETTINGS + t_s_SettingsDataType.FrequencyLimit8, 
                        usLength  := sizeof(t_s_SettingsDataType.FrequencyLimit8));

      //*****************************************************************************
      
      VST_ASYNC_FREQUENCYLIMIT4:
        s_SettingsDataObject.p_DataWrite$^UDINT^ := a_WriteDataBuffer[us_WritePosition].ud_Value;
        
        if FrequencyBandwidth = 0 then
          FrequencyLimit4 := a_WriteDataBuffer[us_WritePosition].ud_Value;
        end_if;

        a_ReadDataBuffer[VST_ASYNC_FREQUENCYLIMIT4].b_Valid := false;
      
        AsyWriteAddress(udAddress := VST011_OFFSET_SETTINGS + t_s_SettingsDataType.FrequencyLimit4, 
                        usLength  := sizeof(t_s_SettingsDataType.FrequencyLimit4));

      //*****************************************************************************
      
      VST_ASYNC_FREQUENCYLIMIT2:
        s_SettingsDataObject.p_DataWrite$^UDINT^ := a_WriteDataBuffer[us_WritePosition].ud_Value;
        
        if FrequencyBandwidth = 0 then
          FrequencyLimit2:= a_WriteDataBuffer[us_WritePosition].ud_Value;
        end_if;

        a_ReadDataBuffer[VST_ASYNC_FREQUENCYLIMIT2].b_Valid := false;
      
        AsyWriteAddress(udAddress := VST011_OFFSET_SETTINGS + t_s_SettingsDataType.FrequencyLimit2, 
                        usLength  := sizeof(t_s_SettingsDataType.FrequencyLimit2));

      //*****************************************************************************
      
      VST_ASYNC_FREQUENCYLIMIT1:
        s_SettingsDataObject.p_DataWrite$^UDINT^ := a_WriteDataBuffer[us_WritePosition].ud_Value;
        
        if FrequencyBandwidth = 0 then
          FrequencyLimit1:= a_WriteDataBuffer[us_WritePosition].ud_Value;
        end_if;

        a_ReadDataBuffer[VST_ASYNC_FREQUENCYLIMIT1].b_Valid := false;
      
        AsyWriteAddress(udAddress := VST011_OFFSET_SETTINGS + t_s_SettingsDataType.FrequencyLimit1, 
                        usLength  := sizeof(t_s_SettingsDataType.FrequencyLimit1));
                        
      //*****************************************************************************
      
      VST_ASYNC_EXTERNALLOCKDELTAFREQUENCY:
        s_SettingsDataObject.p_DataWrite$^UINT^ := a_WriteDataBuffer[us_WritePosition].ud_Value$UINT;
        HWRampdownDeltaFrequency$UINT := a_WriteDataBuffer[us_WritePosition].ud_Value$UINT;
        a_ReadDataBuffer[VST_ASYNC_EXTERNALLOCKDELTAFREQUENCY].b_Valid := false;
      
        AsyWriteAddress(udAddress := VST011_OFFSET_SETTINGS + t_s_SettingsDataType.HWRampdownDeltaFrequency, 
                        usLength  := sizeof(t_s_SettingsDataType.HWRampdownDeltaFrequency));

      //*****************************************************************************
      
      VST_ASYNC_EXTERNALLOCKDELTATIME:
        s_SettingsDataObject.p_DataWrite$^UINT^ := a_WriteDataBuffer[us_WritePosition].ud_Value$UINT;
        HWRampdownDeltaTime$UINT := a_WriteDataBuffer[us_WritePosition].ud_Value$UINT;
        a_ReadDataBuffer[VST_ASYNC_EXTERNALLOCKDELTATIME].b_Valid := false;
        
        AsyWriteAddress(udAddress := VST011_OFFSET_SETTINGS + t_s_SettingsDataType.HWRampdownDeltaTime, 
                        usLength  := sizeof(t_s_SettingsDataType.HWRampdownDeltaTime));

      //*****************************************************************************
      
      VST_ASYNC_INCREMENTALENCODERSETTINGS:
        //** not implemented    *******************************************************
      
      //*****************************************************************************
        
      VST_ASYNC_BLANKINGTIMEREGISTER:
        s_SettingsDataObject.p_DataWrite$^UINT^ := a_WriteDataBuffer[us_WritePosition].ud_Value$UINT;
        BlankingTime$UINT := a_WriteDataBuffer[us_WritePosition].ud_Value$UINT;
        a_ReadDataBuffer[VST_ASYNC_BLANKINGTIMEREGISTER].b_Valid := false;
      
        AsyWriteAddress(udAddress := VST011_OFFSET_SETTINGS + t_s_SettingsDataType.BlankingTimeRegister, 
                        usLength  := sizeof(t_s_SettingsDataType.BlankingTimeRegister));

      //*****************************************************************************
      
      VST_ASYNC_BRIDGE2OFF:
        s_SettingsDataObject.p_DataWrite$^UINT^ := a_WriteDataBuffer[us_WritePosition].ud_Value$UINT;
        a_ReadDataBuffer[VST_ASYNC_BRIDGE2OFF].b_Valid := false;
        
        AsyWriteAddress(udAddress := VST011_OFFSET_SETTINGS + t_s_SettingsDataType.Bridge2Off, 
                        usLength  := sizeof(t_s_SettingsDataType.Bridge2Off));

      //*****************************************************************************
      
      VST_ASYNC_BRIDGE2MUL:
        s_SettingsDataObject.p_DataWrite$^UINT^ := a_WriteDataBuffer[us_WritePosition].ud_Value$UINT;
        a_ReadDataBuffer[VST_ASYNC_BRIDGE2MUL].b_Valid := false;
      
        AsyWriteAddress(udAddress := VST011_OFFSET_SETTINGS + t_s_SettingsDataType.Bridge2Mul, 
                        usLength  := sizeof(t_s_SettingsDataType.Bridge2Mul));

      //*****************************************************************************
      
      VST_ASYNC_BRIDGE2DIV:
        s_SettingsDataObject.p_DataWrite$^UINT^ := a_WriteDataBuffer[us_WritePosition].ud_Value$UINT;
        a_ReadDataBuffer[VST_ASYNC_BRIDGE2DIV].b_Valid := false;
      
        AsyWriteAddress(udAddress := VST011_OFFSET_SETTINGS + t_s_SettingsDataType.Bridge2Div, 
                        usLength  := sizeof(t_s_SettingsDataType.Bridge2Div));

      //*****************************************************************************
      
      VST_ASYNC_BRIDGE1OFF:
        s_SettingsDataObject.p_DataWrite$^UINT^ := a_WriteDataBuffer[us_WritePosition].ud_Value$UINT;
        a_ReadDataBuffer[VST_ASYNC_BRIDGE1OFF].b_Valid := false;
      
        AsyWriteAddress(udAddress := VST011_OFFSET_SETTINGS + t_s_SettingsDataType.Bridge1Off, 
                        usLength  := sizeof(t_s_SettingsDataType.Bridge1Off));

      //*****************************************************************************
      
      VST_ASYNC_BRIDGE1MUL:
        s_SettingsDataObject.p_DataWrite$^UINT^ := a_WriteDataBuffer[us_WritePosition].ud_Value$UINT;
        a_ReadDataBuffer[VST_ASYNC_BRIDGE1MUL].b_Valid := false;
      
        AsyWriteAddress(udAddress := VST011_OFFSET_SETTINGS + t_s_SettingsDataType.Bridge1Mul, 
                        usLength  := sizeof(t_s_SettingsDataType.Bridge1Mul));
                      
      //*****************************************************************************
      
      VST_ASYNC_BRIDGE1DIV:
        s_SettingsDataObject.p_DataWrite$^UINT^ := a_WriteDataBuffer[us_WritePosition].ud_Value$UINT;
        a_ReadDataBuffer[VST_ASYNC_BRIDGE1DIV].b_Valid := false;
      
        AsyWriteAddress(udAddress := VST011_OFFSET_SETTINGS + t_s_SettingsDataType.Bridge1Div, 
                        usLength  := sizeof(t_s_SettingsDataType.Bridge1Div));

      //*****************************************************************************
      
      VST_ASYNC_BRIDGESUPPLYVOLTAGELOWERTHRESHOLD:
        s_SettingsDataObject.p_DataWrite$^UINT^ := a_WriteDataBuffer[us_WritePosition].ud_Value$UINT;
        a_ReadDataBuffer[VST_ASYNC_BRIDGESUPPLYVOLTAGELOWERTHRESHOLD].b_Valid := false;
      
        AsyWriteAddress(udAddress := VST011_OFFSET_SETTINGS + t_s_SettingsDataType.BridgeSupplyVoltageLowerThreshold, 
                        usLength  := sizeof(t_s_SettingsDataType.BridgeSupplyVoltageLowerThreshold));

      //*****************************************************************************
      
      VST_ASYNC_BRIDGESUPPLYVOLTAGEUPPERTHRESHOLD:
        s_SettingsDataObject.p_DataWrite$^UINT^ := a_WriteDataBuffer[us_WritePosition].ud_Value$UINT;
        a_ReadDataBuffer[VST_ASYNC_BRIDGESUPPLYVOLTAGEUPPERTHRESHOLD].b_Valid := false;
      
        AsyWriteAddress(udAddress := VST011_OFFSET_SETTINGS + t_s_SettingsDataType.BridgeSupplyVoltageUpperThreshold, 
                        usLength  := sizeof(t_s_SettingsDataType.BridgeSupplyVoltageUpperThreshold));

      //*****************************************************************************
      
      VST_ASYNC_BRIDGETEMPERATUREWARNINGTHRESHOLD:
        s_SettingsDataObject.p_DataWrite$^UINT^ := a_WriteDataBuffer[us_WritePosition].ud_Value$UINT;
        a_ReadDataBuffer[VST_ASYNC_BRIDGETEMPERATUREWARNINGTHRESHOLD].b_Valid := false;
      
        AsyWriteAddress(udAddress := VST011_OFFSET_SETTINGS + t_s_SettingsDataType.BridgeTemperatureWarningThreshold, 
                        usLength  := sizeof(t_s_SettingsDataType.BridgeTemperatureWarningThreshold));

      //*****************************************************************************
      
      VST_ASYNC_BRIDGETEMPERATUREERRORTHRESHOLD:
        s_SettingsDataObject.p_DataWrite$^UINT^ := a_WriteDataBuffer[us_WritePosition].ud_Value$UINT;
        a_ReadDataBuffer[VST_ASYNC_BRIDGETEMPERATUREERRORTHRESHOLD].b_Valid := false;
      
        AsyWriteAddress(udAddress := VST011_OFFSET_SETTINGS + t_s_SettingsDataType.BridgeTemperatureErrorThreshold, 
                        usLength  := sizeof(t_s_SettingsDataType.BridgeTemperatureErrorThreshold));

      //*****************************************************************************
      
    end_case;

    // One Element is done
    us_WritePosition  += 1;
    
    // Handle Overflow of Bufferposition
    if us_WritePosition > VST011_MAXASYNCPARAMETER then
      us_WritePosition := 0;
    end_if;
    
    us_WriteNumber    -= 1;
  end_if;

END_FUNCTION


FUNCTION VST011::ReadAsyncParameter
VAR
  tmpValue : DINT;
END_VAR

  //*****************************************************************************
  //** check if we requested data in last cycle                                **
  //*****************************************************************************
  if us_ParameterReadRequestActive then
  
    case us_ParameterReadRequestActive - 1 of
    
      //*****************************************************************************
      
      VST_ASYNC_CHOPPEROFFTIME:
        a_ReadDataBuffer[VST_ASYNC_CHOPPEROFFTIME].ud_Value := to_UDINT(s_SettingsDataObject.p_DataRead$^UINT^);
        a_ReadDataBuffer[VST_ASYNC_CHOPPEROFFTIME].b_Valid := TRUE;
      
      //*****************************************************************************
      
      VST_ASYNC_FASTDECAYTIME:
        a_ReadDataBuffer[VST_ASYNC_FASTDECAYTIME].ud_Value := to_UDINT(s_SettingsDataObject.p_DataRead$^UINT^);
        a_ReadDataBuffer[VST_ASYNC_FASTDECAYTIME].b_Valid := TRUE;
      
      //*****************************************************************************
      
      VST_ASYNC_FREQUENCYLIMIT32:
        a_ReadDataBuffer[VST_ASYNC_FREQUENCYLIMIT32].ud_Value := s_SettingsDataObject.p_DataRead^;
        a_ReadDataBuffer[VST_ASYNC_FREQUENCYLIMIT32].b_Valid := TRUE;
      
      //*****************************************************************************
      
      VST_ASYNC_FREQUENCYLIMIT16:
        a_ReadDataBuffer[VST_ASYNC_FREQUENCYLIMIT16].ud_Value := s_SettingsDataObject.p_DataRead^;
        a_ReadDataBuffer[VST_ASYNC_FREQUENCYLIMIT16].b_Valid := TRUE;
      
      //*****************************************************************************
      
      VST_ASYNC_FREQUENCYLIMIT8:
        a_ReadDataBuffer[VST_ASYNC_FREQUENCYLIMIT8].ud_Value := s_SettingsDataObject.p_DataRead^;
        a_ReadDataBuffer[VST_ASYNC_FREQUENCYLIMIT8].b_Valid := TRUE;
      
      //*****************************************************************************
      
      VST_ASYNC_FREQUENCYLIMIT4:
        a_ReadDataBuffer[VST_ASYNC_FREQUENCYLIMIT4].ud_Value := s_SettingsDataObject.p_DataRead^;
        a_ReadDataBuffer[VST_ASYNC_FREQUENCYLIMIT4].b_Valid := TRUE;
      
      //*****************************************************************************
      
      VST_ASYNC_FREQUENCYLIMIT2:
        a_ReadDataBuffer[VST_ASYNC_FREQUENCYLIMIT2].ud_Value := s_SettingsDataObject.p_DataRead^;
        a_ReadDataBuffer[VST_ASYNC_FREQUENCYLIMIT2].b_Valid := TRUE;
      
      //*****************************************************************************
      
      VST_ASYNC_FREQUENCYLIMIT1:
        a_ReadDataBuffer[VST_ASYNC_FREQUENCYLIMIT1].ud_Value := s_SettingsDataObject.p_DataRead^;
        a_ReadDataBuffer[VST_ASYNC_FREQUENCYLIMIT1].b_Valid := TRUE;
      
      //*****************************************************************************
      
      VST_ASYNC_EXTERNALLOCKDELTAFREQUENCY:
        a_ReadDataBuffer[VST_ASYNC_EXTERNALLOCKDELTAFREQUENCY].ud_Value := s_SettingsDataObject.p_DataRead$^UINT^;
        a_ReadDataBuffer[VST_ASYNC_EXTERNALLOCKDELTAFREQUENCY].b_Valid := TRUE;
      
      //*****************************************************************************
      
      VST_ASYNC_EXTERNALLOCKDELTATIME:
        a_ReadDataBuffer[VST_ASYNC_EXTERNALLOCKDELTATIME].ud_Value := to_UDINT(s_SettingsDataObject.p_DataRead$^UINT^);
        a_ReadDataBuffer[VST_ASYNC_EXTERNALLOCKDELTATIME].b_Valid := TRUE;
      
      //*****************************************************************************
      
      VST_ASYNC_INCREMENTALENCODERSETTINGS:
        a_ReadDataBuffer[VST_ASYNC_INCREMENTALENCODERSETTINGS].ud_Value := to_UDINT(s_SettingsDataObject.p_DataRead$^USINT^);
        a_ReadDataBuffer[VST_ASYNC_INCREMENTALENCODERSETTINGS].b_Valid := TRUE;
      
      //*****************************************************************************
      
      VST_ASYNC_BLANKINGTIMEREGISTER:
        a_ReadDataBuffer[VST_ASYNC_BLANKINGTIMEREGISTER].ud_Value := to_UDINT(s_SettingsDataObject.p_DataRead$^USINT^);
        a_ReadDataBuffer[VST_ASYNC_BLANKINGTIMEREGISTER].b_Valid := TRUE;
      
      //*****************************************************************************
      
      VST_ASYNC_BRIDGE2OFF:
        a_ReadDataBuffer[VST_ASYNC_BRIDGE2OFF].ud_Value := to_UDINT(s_SettingsDataObject.p_DataRead$^UINT^);
        a_ReadDataBuffer[VST_ASYNC_BRIDGE2OFF].b_Valid := TRUE;
        
      //*****************************************************************************
        
      VST_ASYNC_BRIDGE2MUL:
        a_ReadDataBuffer[VST_ASYNC_BRIDGE2MUL].ud_Value := to_UDINT(s_SettingsDataObject.p_DataRead$^UINT^);
        a_ReadDataBuffer[VST_ASYNC_BRIDGE2MUL].b_Valid := TRUE;
      
      //*****************************************************************************
      
      VST_ASYNC_BRIDGE2DIV:
        a_ReadDataBuffer[VST_ASYNC_BRIDGE2DIV].ud_Value := to_UDINT(s_SettingsDataObject.p_DataRead$^UINT^);
        a_ReadDataBuffer[VST_ASYNC_BRIDGE2DIV].b_Valid := TRUE;
      
      //*****************************************************************************
      
      VST_ASYNC_BRIDGE1OFF:
        a_ReadDataBuffer[VST_ASYNC_BRIDGE1OFF].ud_Value := to_UDINT(s_SettingsDataObject.p_DataRead$^UINT^);
        a_ReadDataBuffer[VST_ASYNC_BRIDGE1OFF].b_Valid := TRUE;
      
      //*****************************************************************************
      
      VST_ASYNC_BRIDGE1MUL:
        a_ReadDataBuffer[VST_ASYNC_BRIDGE1MUL].ud_Value := to_UDINT(s_SettingsDataObject.p_DataRead$^UINT^);
        a_ReadDataBuffer[VST_ASYNC_BRIDGE1MUL].b_Valid := TRUE;
      
      //*****************************************************************************
      
      VST_ASYNC_BRIDGE1DIV:
        a_ReadDataBuffer[VST_ASYNC_BRIDGE1DIV].ud_Value := to_UDINT(s_SettingsDataObject.p_DataRead$^UINT^);
        a_ReadDataBuffer[VST_ASYNC_BRIDGE1DIV].b_Valid := TRUE;
      
      //*****************************************************************************
      
      VST_ASYNC_BRIDGESUPPLYVOLTAGELOWERTHRESHOLD:
        a_ReadDataBuffer[VST_ASYNC_BRIDGESUPPLYVOLTAGELOWERTHRESHOLD].ud_Value := to_UDINT(s_SettingsDataObject.p_DataRead$^UINT^);
        a_ReadDataBuffer[VST_ASYNC_BRIDGESUPPLYVOLTAGELOWERTHRESHOLD].b_Valid := TRUE;
      
      //*****************************************************************************
      
      VST_ASYNC_BRIDGESUPPLYVOLTAGEUPPERTHRESHOLD:
        a_ReadDataBuffer[VST_ASYNC_BRIDGESUPPLYVOLTAGEUPPERTHRESHOLD].ud_Value := to_UDINT(s_SettingsDataObject.p_DataRead$^UINT^);
        a_ReadDataBuffer[VST_ASYNC_BRIDGESUPPLYVOLTAGEUPPERTHRESHOLD].b_Valid := TRUE;
      
      //*****************************************************************************
      
      VST_ASYNC_BRIDGETEMPERATUREWARNINGTHRESHOLD:
        a_ReadDataBuffer[VST_ASYNC_BRIDGETEMPERATUREWARNINGTHRESHOLD].ud_Value := to_UDINT(s_SettingsDataObject.p_DataRead$^UINT^);
        a_ReadDataBuffer[VST_ASYNC_BRIDGETEMPERATUREWARNINGTHRESHOLD].b_Valid := TRUE;
      
      //*****************************************************************************
      
      VST_ASYNC_BRIDGETEMPERATUREERRORTHRESHOLD:
        a_ReadDataBuffer[VST_ASYNC_BRIDGETEMPERATUREERRORTHRESHOLD].ud_Value := to_UDINT(s_SettingsDataObject.p_DataRead$^UINT^);
        a_ReadDataBuffer[VST_ASYNC_BRIDGETEMPERATUREERRORTHRESHOLD].b_Valid := TRUE;
      
      //*****************************************************************************
      
      VST_ASYNC_EXTENDEDSTATEWORD:
        a_ReadDataBuffer[VST_ASYNC_EXTENDEDSTATEWORD].ud_Value := to_UDINT(s_SettingsDataObject.p_DataRead$^UINT^);
        a_ReadDataBuffer[VST_ASYNC_EXTENDEDSTATEWORD].b_Valid := TRUE;
      
      //*****************************************************************************
      
      VST_ASYNC_COMMUTATIONCOUNTERBRIDGE1:
        a_ReadDataBuffer[VST_ASYNC_COMMUTATIONCOUNTERBRIDGE1].ud_Value := to_UDINT(s_SettingsDataObject.p_DataRead$^UINT^);
        a_ReadDataBuffer[VST_ASYNC_COMMUTATIONCOUNTERBRIDGE1].b_Valid := TRUE;
      
      //*****************************************************************************
      
      VST_ASYNC_COMMUTATIONCOUNTERBRIDGE2:
        a_ReadDataBuffer[VST_ASYNC_COMMUTATIONCOUNTERBRIDGE2].ud_Value := to_UDINT(s_SettingsDataObject.p_DataRead$^UINT^);
        a_ReadDataBuffer[VST_ASYNC_COMMUTATIONCOUNTERBRIDGE2].b_Valid := TRUE;
      
      //*****************************************************************************
      
      VST_ASYNC_ONTIMECOUNTERBRIDGE1:
        a_ReadDataBuffer[VST_ASYNC_ONTIMECOUNTERBRIDGE1].ud_Value := to_UDINT(s_SettingsDataObject.p_DataRead$^UINT^);
        a_ReadDataBuffer[VST_ASYNC_ONTIMECOUNTERBRIDGE1].b_Valid := TRUE;
      
      //*****************************************************************************
      
      VST_ASYNC_ONTIMECOUNTERBRIDGE2:
        a_ReadDataBuffer[VST_ASYNC_ONTIMECOUNTERBRIDGE2].ud_Value := to_UDINT(s_SettingsDataObject.p_DataRead$^UINT^);
        a_ReadDataBuffer[VST_ASYNC_ONTIMECOUNTERBRIDGE2].b_Valid := TRUE;
      
      //*****************************************************************************
      
      VST_ASYNC_HBRIDGE_VOLTAGE:
        volt_raw_raw := s_SettingsDataObject.p_DataRead$^HINT^;
        tmpValue := DIV_AB_BY_C(volt_raw_raw + a_CalibData.AI1Offset, a_CalibData.AI1Multiplikator, a_CalibData.AI1Divisor);
        a_ReadDataBuffer[VST_ASYNC_HBRIDGE_VOLTAGE].ud_Value := to_UDINT(tmpValue);
        a_ReadDataBuffer[VST_ASYNC_HBRIDGE_VOLTAGE].b_Valid := TRUE;
      
      //*****************************************************************************
      
      VST_ASYNC_HBRIDGE_TEMPERATURE:
        temp_raw_raw := s_SettingsDataObject.p_DataRead$^HINT^;
        tmpValue := DIV_AB_BY_C(temp_raw_raw + a_CalibData.AI2Offset, a_CalibData.AI2Multiplikator, a_CalibData.AI2Divisor);
        a_ReadDataBuffer[VST_ASYNC_HBRIDGE_TEMPERATURE].ud_Value := to_UDINT(tmpValue); 
        a_ReadDataBuffer[VST_ASYNC_HBRIDGE_TEMPERATURE].b_Valid := TRUE;
      
      //*****************************************************************************
        
    end_case;
    
    //Request is done
    us_ParameterReadRequestActive := 0;
  
  end_if;


  // check if any asynchronous Parameter must be read
  //*****************************************************************************
  if us_ReadNumber then
  
    //*****************************************************************************
    //** Depending of the ParameterID, access another Register                   **
    //*****************************************************************************
    case a_ParameterReadRequest[us_ReadPosition] of
      
      //*****************************************************************************
      
      VST_ASYNC_CHOPPEROFFTIME:
        AsyReadAddress( udAddress := VST011_OFFSET_SETTINGS + t_s_SettingsDataType.ChopperOffTime, 
                        usLength  := sizeof(t_s_SettingsDataType.ChopperOffTime));
      
      //*****************************************************************************
      
      VST_ASYNC_FASTDECAYTIME:
        AsyReadAddress( udAddress := VST011_OFFSET_SETTINGS + t_s_SettingsDataType.FastDecayTime, 
                        usLength  := sizeof(t_s_SettingsDataType.FastDecayTime));  
                    
      //*****************************************************************************
      
      VST_ASYNC_FREQUENCYLIMIT32:
        AsyReadAddress( udAddress := VST011_OFFSET_SETTINGS + t_s_SettingsDataType.FrequencyLimit32, 
                        usLength  := sizeof(t_s_SettingsDataType.FrequencyLimit32)); 
      
      //*****************************************************************************
      
      VST_ASYNC_FREQUENCYLIMIT16:
        AsyReadAddress( udAddress := VST011_OFFSET_SETTINGS + t_s_SettingsDataType.FrequencyLimit16, 
                        usLength  := sizeof(t_s_SettingsDataType.FrequencyLimit16)); 
      
      //*****************************************************************************
      
      VST_ASYNC_FREQUENCYLIMIT8:
        AsyReadAddress( udAddress := VST011_OFFSET_SETTINGS + t_s_SettingsDataType.FrequencyLimit8, 
                        usLength  := sizeof(t_s_SettingsDataType.FrequencyLimit8)); 
      
      //*****************************************************************************
      
      VST_ASYNC_FREQUENCYLIMIT4:
        AsyReadAddress( udAddress := VST011_OFFSET_SETTINGS + t_s_SettingsDataType.FrequencyLimit4, 
                        usLength  := sizeof(t_s_SettingsDataType.FrequencyLimit4)); 
      
      //*****************************************************************************
      
      VST_ASYNC_FREQUENCYLIMIT2:
        AsyReadAddress( udAddress := VST011_OFFSET_SETTINGS + t_s_SettingsDataType.FrequencyLimit2, 
                        usLength  := sizeof(t_s_SettingsDataType.FrequencyLimit2)); 
      
      //*****************************************************************************
      
      VST_ASYNC_FREQUENCYLIMIT1:
        AsyReadAddress(udAddress := VST011_OFFSET_SETTINGS + t_s_SettingsDataType.FrequencyLimit1, 
                    usLength  := sizeof(t_s_SettingsDataType.FrequencyLimit1)); 
      
      //*****************************************************************************
      
      VST_ASYNC_EXTERNALLOCKDELTAFREQUENCY:
        AsyReadAddress( udAddress := VST011_OFFSET_SETTINGS + t_s_SettingsDataType.HWRampdownDeltaFrequency, 
                        usLength  := sizeof(t_s_SettingsDataType.HWRampdownDeltaFrequency)); 
                    
      //*****************************************************************************
      
      VST_ASYNC_EXTERNALLOCKDELTATIME:
        AsyReadAddress( udAddress := VST011_OFFSET_SETTINGS + t_s_SettingsDataType.HWRampdownDeltaTime, 
                        usLength  := sizeof(t_s_SettingsDataType.HWRampdownDeltaTime)); 
      
      //*****************************************************************************
      
      VST_ASYNC_INCREMENTALENCODERSETTINGS:
        AsyReadAddress( udAddress := VST011_OFFSET_SETTINGS + t_s_SettingsDataType.IncrementalEncoderSettings, 
                        usLength  := sizeof(t_s_SettingsDataType.IncrementalEncoderSettings)); 
      
      //*****************************************************************************
      
      VST_ASYNC_BLANKINGTIMEREGISTER:
        AsyReadAddress( udAddress := VST011_OFFSET_SETTINGS + t_s_SettingsDataType.BlankingTimeRegister, 
                        usLength  := sizeof(t_s_SettingsDataType.BlankingTimeRegister)); 
                    
      //*****************************************************************************
      
      VST_ASYNC_BRIDGE2OFF:
        AsyReadAddress( udAddress := VST011_OFFSET_SETTINGS + t_s_SettingsDataType.Bridge2Off, 
                        usLength  := sizeof(t_s_SettingsDataType.Bridge2Off)); 
      
      //*****************************************************************************
      
      VST_ASYNC_BRIDGE2MUL:
        AsyReadAddress( udAddress := VST011_OFFSET_SETTINGS + t_s_SettingsDataType.Bridge2Mul, 
                        usLength  := sizeof(t_s_SettingsDataType.Bridge2Mul)); 
      
      //*****************************************************************************
      
      VST_ASYNC_BRIDGE2DIV:
        AsyReadAddress( udAddress := VST011_OFFSET_SETTINGS + t_s_SettingsDataType.Bridge2Div, 
                        usLength  := sizeof(t_s_SettingsDataType.Bridge2Div)); 
      
      //*****************************************************************************
      
      VST_ASYNC_BRIDGE1OFF:
        AsyReadAddress( udAddress := VST011_OFFSET_SETTINGS + t_s_SettingsDataType.Bridge1Off, 
                        usLength  := sizeof(t_s_SettingsDataType.Bridge1Off)); 
      
      //*****************************************************************************
      
      VST_ASYNC_BRIDGE1MUL:
        AsyReadAddress( udAddress := VST011_OFFSET_SETTINGS + t_s_SettingsDataType.Bridge1Mul, 
                        usLength  := sizeof(t_s_SettingsDataType.Bridge1Mul)); 
      
      //*****************************************************************************
      
      VST_ASYNC_BRIDGE1DIV:
        AsyReadAddress( udAddress := VST011_OFFSET_SETTINGS + t_s_SettingsDataType.Bridge1Div, 
                        usLength  := sizeof(t_s_SettingsDataType.Bridge1Div)); 
      
      //*****************************************************************************
      
      VST_ASYNC_BRIDGESUPPLYVOLTAGELOWERTHRESHOLD:
        AsyReadAddress( udAddress := VST011_OFFSET_SETTINGS + t_s_SettingsDataType.BridgeSupplyVoltageLowerThreshold, 
                        usLength  := sizeof(t_s_SettingsDataType.BridgeSupplyVoltageLowerThreshold)); 
      
      //*****************************************************************************
      
      VST_ASYNC_BRIDGESUPPLYVOLTAGEUPPERTHRESHOLD:
        AsyReadAddress( udAddress := VST011_OFFSET_SETTINGS + t_s_SettingsDataType.BridgeSupplyVoltageUpperThreshold, 
                        usLength  := sizeof(t_s_SettingsDataType.BridgeSupplyVoltageUpperThreshold)); 
      
      //*****************************************************************************
      
      VST_ASYNC_BRIDGETEMPERATUREWARNINGTHRESHOLD:
        AsyReadAddress( udAddress := VST011_OFFSET_SETTINGS + t_s_SettingsDataType.BridgeTemperatureWarningThreshold, 
                        usLength  := sizeof(t_s_SettingsDataType.BridgeTemperatureWarningThreshold)); 
      
      //*****************************************************************************
      
      VST_ASYNC_BRIDGETEMPERATUREERRORTHRESHOLD:
        AsyReadAddress( udAddress := VST011_OFFSET_SETTINGS + t_s_SettingsDataType.BridgeTemperatureErrorThreshold, 
                        usLength  := sizeof(t_s_SettingsDataType.BridgeTemperatureErrorThreshold)); 
      
      //*****************************************************************************
      
      VST_ASYNC_EXTENDEDSTATEWORD:
        AsyReadAddress( udAddress := 16#50, 
                        usLength  := 2); 
      
      //*****************************************************************************
      
      VST_ASYNC_COMMUTATIONCOUNTERBRIDGE1:
        AsyReadAddress( udAddress := 16#52, 
                        usLength  := 2); 
      
      //*****************************************************************************
      
      VST_ASYNC_COMMUTATIONCOUNTERBRIDGE2:
        AsyReadAddress( udAddress := 16#54, 
                        usLength  := 2); 
      
      //*****************************************************************************
      
      VST_ASYNC_ONTIMECOUNTERBRIDGE1:
        AsyReadAddress( udAddress := 16#56, 
                        usLength  := 2); 
      
      //*****************************************************************************
      
      VST_ASYNC_ONTIMECOUNTERBRIDGE2:
        AsyReadAddress( udAddress := 16#58, 
                        usLength  := 2); 
      
      //*****************************************************************************
      
      VST_ASYNC_HBRIDGE_VOLTAGE:
        AsyReadAddress( udAddress := 16#5A, 
                        usLength  := 2); 
      
      //*****************************************************************************
      
      VST_ASYNC_HBRIDGE_TEMPERATURE:
        AsyReadAddress( udAddress := 16#5C, 
                        usLength  := 2); 
        
      
      //*****************************************************************************
      
    end_case;

    //Read Request is active
    us_ParameterReadRequestActive := a_ParameterReadRequest[us_ReadPosition] + 1;
    
    // One Element is done
    us_ReadPosition  += 1;
    
    // Handle Overflow of Bufferposition
    if us_ReadPosition > VST011_MAXASYNCPARAMETER then
      us_ReadPosition := 0;
    end_if;

    //One Element is done
    us_ReadNumber -= 1;
  
  end_if;

END_FUNCTION


FUNCTION GLOBAL VST011::ChangeCallMode
  VAR_INPUT
    usID  : USINT;
    bActive   : BOOL;
  END_VAR
  
  //Check Input-Parameter
  if usID < 0 | usID >= VST_ID_CLASSESAVAILABLE then
    return;
  end_if;

  //Set Call to active
  sAsyCalls[usID].bActive := bActive;
  
END_FUNCTION


FUNCTION GLOBAL VST011::AddAsyCall
  VAR_INPUT
    usID  : USINT;
    pThis   : ^void;
  END_VAR
  VAR_OUTPUT
    bSuccessful   : BOOL;
  END_VAR

  //Init Returncode
  bSuccessful := false;
 
  //Check Input-Parameter
  if usID < 0 | usID >= VST_ID_CLASSESAVAILABLE | pThis = NIL then
    return;
  end_if;

  //Already active
  if sAsyCalls[usID].pThis <> NIL then
    return;
  end_if;

  //Add Element
  sAsyCalls[usID].bActive := false;
  sAsyCalls[usID].pThis   := pThis;
  
  //Everything successful
  bSuccessful := true;
  
END_FUNCTION


FUNCTION VST011::AsyReadAddress
  VAR_INPUT
    udAddress   : UDINT;
    usLength  : USINT;
  END_VAR
  
  if b_PayloadSupport then
    // usLengthOfExpAnswer and usSendBufferLength are automatically adjusted to the correct length when us_ByteCntRd and us_ByteCntWr in MULTI_VARAN_i 
    ChangeDOLengthOffset( ud_DOHandle           := s_SettingsDataObject.p_Handle$UDINT
                        , ud_offset_read        := udAddress
                        , ud_length_read        := usLength);
                        
    s_SettingsDataObject.b_DOIsRunning.StartRequest := true;
  else
    //Set Address which should be read
    s_SettingsDataObject.p_DOSettings^.ud_AddressRd := DeviceAddress + udAddress;
    
    //Set Length of Package
    s_SettingsDataObject.p_DOSettings^.us_ByteCntRd := usLength;
    
    //Set Length of expected Answer
    s_SettingsDataObject.p_Handle^.usLengthofExpAnswer := 1 + usLength;
  end_if;  
  
END_FUNCTION


FUNCTION VST011::AsyWriteAddress
  VAR_INPUT
    udAddress   : UDINT;
    usLength  : USINT;
  END_VAR
  
  if b_PayloadSupport then
    // usLengthOfExpAnswer and usSendBufferLength are automatically adjusted to the correct length when us_ByteCntRd and us_ByteCntWr in MULTI_VARAN_i 
    ChangeDOLengthOffset( ud_DOHandle         := s_SettingsDataObject.p_Handle$UDINT
                        , ud_offset_write     := udAddress
                        , ud_length_write     := usLength);
                        
    s_SettingsDataObject.b_DOIsRunning.StartRequest := true;
  else
    //Set Address which should be written
    s_SettingsDataObject.p_DOSettings^.ud_AddressWr := DeviceAddress + udAddress;
    
    //Set Length of Package
    s_SettingsDataObject.p_DOSettings^.us_ByteCntWr := usLength;
    
    //Set Length of Package
    s_SettingsDataObject.p_Handle^.usSendBufferLength :=  11 + usLength;    
  end_if;
  
END_FUNCTION


FUNCTION VST011::IsoReadAddress
  VAR_INPUT
    udAddress   : UDINT;
  END_VAR
  VAR
    s_PropertyValuePair : LSL_PROPERTY_VALUE_PAIR;    
  END_VAR
  
  // Payload support
  if b_PayloadSupport then
  
    // Use IF call as we are in RT      
      s_PropertyValuePair.udPropertyId    := DO_PROP_READ_OFFSET;
      s_PropertyValuePair.udPropertyValue := udAddress;
      
      // us_ByteCnt: stays the same all the time
      
      MULTI_VARAN_iSetDoProperties(s_ISyncDO.p_Handle$UDINT, 1, #s_PropertyValuePair );
  
    s_ISyncDO.b_DOIsRunning.StartRequest := true;
  else
  //Set Address which should be read
  s_ISyncDO.p_DOSettings^.ud_Address := DeviceAddress + udAddress;
  
  //Set Length of Package
  s_ISyncDO.p_DOSettings^.us_ByteCnt := 2;
  
  //Start SingleRun of DataObject
  ResetDataObject(p_handleDO  := s_ISyncDO.p_Handle, 
                  us_state    := VARAN_DO_SINGLE_RUN, 
                  ud_bytes    := 2);
  end_if;  

END_FUNCTION


FUNCTION VST011::CalcFrequencyLimits
VAR
  tmpCounter    : USINT;
  tmpFrequency  : UDINT;
END_VAR

  //Loop to check all FrequencyLimits
  //*****************************************************************************
  for tmpCounter := 0 to (sizeof(a_FrequencyLimit) / sizeof(a_FrequencyLimit[0])) - 1 do
  
    //Get the selected FrequencyLimit
    case tmpCounter of
    
      0:  tmpFrequency := FrequencyLimit1;
      1:  tmpFrequency := FrequencyLimit2;
      2:  tmpFrequency := FrequencyLimit4;
      3:  tmpFrequency := FrequencyLimit8;
      4:  tmpFrequency := FrequencyLimit16;
      5:  tmpFrequency := FrequencyLimit32;
    
    end_case;
  
  
    //Check if FrequencyLimit is active
    if tmpFrequency <> 16#FFFF_FFFF then
    
      //Calculate Hysterese
      //---------------------------------------------------------
      //LowLomit
      if tmpFrequency > FrequencyBandwidth / 2 then
        a_FrequencyLimit[tmpCounter].LimitLow := tmpFrequency - (FrequencyBandwidth / 2);
      else
        a_FrequencyLimit[tmpCounter].LimitLow := tmpFrequency;
      end_if;
      
      //High Limit
      if tmpFrequency + (FrequencyBandwidth / 2) < 1000000 then
        a_FrequencyLimit[tmpCounter].LimitHigh  := tmpFrequency + (FrequencyBandwidth / 2);
      else
        a_FrequencyLimit[tmpCounter].LimitHigh := tmpFrequency;
      end_if;

    else
      
      //Set Inactive
      a_FrequencyLimit[tmpCounter].LimitHigh  := 16#FFFF_FFFF;
      a_FrequencyLimit[tmpCounter].LimitLow   := 16#FFFF_FFFF;
      
    end_if;

  end_for;

  //*****************************************************************************
  
END_FUNCTION


FUNCTION GLOBAL VST011::SetStallCurrentWindow
  VAR_INPUT
    NewWindow   : UDINT;
  END_VAR

  udStallCurrentWindow := NewWindow;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL VST011::Varan_HwInterrupt
  VAR_INPUT
    ud_reason   : UDINT;
    ud_data   : ^t_CallBackInterrupt;
  END_VAR
  VAR_OUTPUT
    sd_retval   : DINT;
  END_VAR
  
  SetDOsOff();
  sd_retval := Varan_Base::Varan_HwInterrupt(ud_reason:=ud_reason, ud_data:=ud_data);

END_FUNCTION


FUNCTION VIRTUAL GLOBAL VST011::GetDeviceID
  VAR_OUTPUT
    output  : UDINT;
  END_VAR

  output := VST011_DEVICE_ID;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL VST011::CheckPostInitNeeded
	VAR_INPUT
		pbPostInitSettings 	: ^t_VM_CMD_NEED_POST_INIT_CALL_SETTINGS;
	END_VAR
	VAR_OUTPUT
		PostInitNeeded 	: BOOL;
	END_VAR
    
  if pbPostInitSettings <> NIL then
    pbPostInitSettings^ := 0;
  end_if;
  
  PostInitNeeded := TRUE;

END_FUNCTION
