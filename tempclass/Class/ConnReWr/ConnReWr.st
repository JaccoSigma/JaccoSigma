//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#ifndef cMaxAsciiLine
	#define	cMaxAsciiLine	15 // 1024 //4096	// Max length of an ASCII line
	#define cSeparator		';'			// Separator between two elements
	#define cTestChar		'~'			// Test character
#endif
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "ConnReWr"
	Revision           = "0.0"
	GUID               = "{9FD2BB15-59AF-4448-BE6E-BF2D482DFEC1}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	DefCyclictime      = "10 ms"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Server Name="FromNr" GUID="{396C5AEA-6DD7-486C-86FE-BD661E42E0F0}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="ReadNr" GUID="{D349CF68-6009-47E8-8471-6FC6C614BFB1}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="State" GUID="{2378644F-31BD-48B0-ACAF-C68631F80A1E}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ToNr" GUID="{7713157F-8039-4C59-BE73-BA907207BD76}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="Value" GUID="{466DFCCE-AAF3-41FD-98BB-0519A19993C0}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Client Name="In" Required="false" Internal="false"/>
		<Client Name="Out" Required="false" Internal="false"/>
	</Channels>
</Class>
*)
ConnReWr : CLASS
  //Servers:
	Value 	: SvrChCmd_DINT;
	FromNr 	: SvrCh_DINT;
	ToNr 	: SvrCh_DINT;
	ReadNr 	: SvrCh_DINT;
	State 	: SvrCh_DINT;
  //Clients:
	In 	: CltCh_DINT;
	Out 	: CltCh_DINT;
  //Variables:
		RetCode 	: DINT;
		FromName : ARRAY [0..cMaxAsciiLine] OF CHAR;

		ToName : ARRAY [0..cMaxAsciiLine] OF CHAR;

		ReadName : ARRAY [0..cMaxAsciiLine] OF CHAR;

  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL Connect;
	
	FUNCTION VIRTUAL BuildFromName;
	
	FUNCTION VIRTUAL BuildToName;
	
	FUNCTION VIRTUAL BuildReadName;
	
	FUNCTION VIRTUAL GLOBAL Value::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL FromNr::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ToNr::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ReadNr::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB ConnReWr::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_CONNREWR
0$UINT, 0$UINT, (SIZEOF(::ConnReWr))$UINT, 
5$UINT, 2$UINT, 0$UINT, 
TO_UDINT(3307790730), "ConnReWr", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::ConnReWr.Value.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(3928201860), "Value", 
(::ConnReWr.FromNr.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2059063506), "FromNr", 
(::ConnReWr.ToNr.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4117946183), "ToNr", 
(::ConnReWr.ReadNr.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3744700273), "ReadNr", 
(::ConnReWr.State.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1422331979), "State", 
//Clients:
(::ConnReWr.In.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(4043737636), "In", 
(::ConnReWr.Out.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(793587475), "Out", 
END_FUNCTION


#define USER_CNT_ConnReWr 4

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_ConnReWr] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION ConnReWr::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_ConnReWr, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Read		:= #Read();
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Connect();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #BuildFromName();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #BuildToName();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #BuildReadName();

#pragma warning (default : 74)
	Value.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF Value.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	FromNr.pMeth			:= StoreMethod( #M_RD_DIRECT(), #FromNr::Write() );
	IF FromNr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ToNr.pMeth			:= StoreMethod( #M_RD_DIRECT(), #ToNr::Write() );
	IF ToNr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ReadNr.pMeth			:= StoreMethod( #M_RD_DIRECT(), #ReadNr::Write() );
	IF ReadNr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


(*
 * state
 *         0  => OK
 *        -1  => Invalid FromNr
 *        -2  => Invalid ToNr
 *        -3  => Invalid ReadNr
 *        -4  => Invalid return from "ConnectCltSvr()" on server side
 *        -5  => Invalid return from "ConnectCltSvr()" with from name.
 *        -6  => Invalid return from "ConnectCltSvr()" with to name.
 *
 *)


FUNCTION VIRTUAL GLOBAL ConnReWr::Init

  If _FirstScan Then
    FromNr  := 1;
    ToNr    := 1;
    ReadNr  := 1;
    Connect(); 
  End_If;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ConnReWr::CyWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
  
  In  := In.Read();
  Out := In;
  Out.Write (Out);

	state := READY;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ConnReWr::FromNr::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	FromNr := input;
  Connect();
 	result := FromNr;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ConnReWr::ToNr::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	ToNr := input;
  Connect();
 	result := ToNr;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ConnReWr::ReadNr::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	ReadNr := input;
  Connect();
 	result := ReadNr;

END_FUNCTION


FUNCTION VIRTUAL ConnReWr::Connect

  state  := 0;
  BuildReadName();
  BuildFromName();
  BuildToName();
  RetCode := ConnectCltSvr( pCltName := #ReadName[0], pSvrName := "ConnReWr.Value");
  if RetCode<> 0 then
    state  := -4;
  else
//    RetCode := ConnectCltSvr( pCltName := "ConnReWr.In1", pSvrName := "In3.Value");
//    RetCode := ConnectCltSvr( pCltName := "ConnReWr.In1", pSvrName := #FromName[0]);
    RetCode := ConnectCltSvr( pCltName := "ConnReWr.In", pSvrName := #FromName[0]);
    if RetCode<> 0 then 
      state  := -5;
    else
      RetCode := ConnectCltSvr( pCltName := "ConnReWr.Out", pSvrName := #ToName[0]);
      if RetCode<> 0 then
        state  := -6;
      end_if; 
    end_if;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL ConnReWr::BuildFromName

  case FromNr of
  1:
    _MemCpy( #FromName[0], "In1.Value", 10);
  2:
    _MemCpy( #FromName[0], "In2.Value", 10);
  3:  // Test error
    _MemCpy( #FromName[0], "In3.Value", 10);
  else
    state  := -1;
  end_case;

END_FUNCTION


FUNCTION VIRTUAL ConnReWr::BuildToName

  case ToNr of
  1:
    _MemCpy( #ToName[0], "Out1.Data", 10);
  2:
    _MemCpy( #ToName[0], "Out2.Data", 10);
  3:  // Test error
    _MemCpy( #ToName[0], "Out3.Data", 10);
  else
    state  := -2;
  end_case;

END_FUNCTION


FUNCTION VIRTUAL ConnReWr::BuildReadName

  case ReadNr of
  1:
    _MemCpy( #ReadName[0], "Read1.Client_Read", 18);
  2:
    _MemCpy( #ReadName[0], "Read2.Client_Read", 18);
  3:  // Test error
    _MemCpy( #ReadName[0], "Read3.Client_Read", 18);
  else
    state  := -3;
  end_case;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ConnReWr::Value::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	output := Value := In;

END_FUNCTION
