//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION
#include "..\..\Class\_CanOpenMng\_CanOpenMng.h"
#include <.\OS Interface\Class\SigCLib\CPipe.h>

(*!
<Class
	Name               = "_CanOpenBasicDS301"
	Revision           = "1.15"
	GUID               = "{C2E0CFD3-A6FF-4970-8EA0-1BE2FA78C807}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\_CanOpenBasicDS301\Drive1.ico"
	SharedCommandTable = "true"
	Objectsize         = "(872,120)"
	Comment            = "Class can be used, to establish CANOpen Communication (DS301) to one Node">
	<Channels>
		<Server Name="AsyncState" GUID="{446040A2-D8EB-40EA-82E8-C5355043D4B2}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the state of asynchronous SDO data tranfer."/>
		<Server Name="CanDisabled" GUID="{AB666B05-5DB9-4FFF-AA41-E7B44CA564D9}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the state of can&#13;&#10;0..Can communication is ok &#13;&#10;1..Can communication is not ok"/>
		<Server Name="DataReady" GUID="{77D60E4C-6A03-4FAD-9BE0-A3AE1791813D}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the state of Pdo communication&#13;&#10;0 .. no Pdo data has been received&#13;&#10;1 .. Pdo data has been received"/>
		<Server Name="DeviceState" GUID="{135F01C7-BF9F-473C-84AC-1D6941FE5166}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Actual mode of the can-bus communication."/>
		<Server Name="EmcyStatusByte0_3" GUID="{08F26C95-DDC4-41DC-B8E8-D83AD47C9B0A}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Result of the emergency object byte 0 - 3"/>
		<Server Name="EmcyStatusByte4_7" GUID="{D1CAE644-1106-4C83-9CA8-67F7576C733B}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Result of the emergency object byte 4 - 7"/>
		<Server Name="ErrorAlloc" GUID="{650CE94C-7AF1-4A62-AD49-B5AE6E122C06}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Error allocate memory for user SDO handling"/>
		<Server Name="ErrorQuit" GUID="{A954D68D-EC64-4AD3-8C3D-2AA5C701B499}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Quit error with write methode of this server, if DeviceState is in an error state&#13;&#10;0/1 .. quit general communication errors on class&#13;&#10;2 .. call of ResetCom() function&#13;&#10;3 .. call of ReinitObject() function&#13;&#10;4 .. Send of NMT command &quot;Reset Communication&quot; (0x82) &#13;&#10;5 .. Send of NMT command &quot;Reset Node&quot; (0x81) "/>
		<Server Name="ErrorSDO" GUID="{D4D2C043-44C7-4E93-930D-E49CC0486A71}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows how many SDO transmissions were faulty.&#13;&#10;For further information on the last sdo error, the function GetComSDOData() must be called."/>
		<Client Name="_CanOpenLSSControl1" Required="true" Internal="true"/>
		<Client Name="_XMLReaderXDC" Required="true" Internal="true"/>
		<Client Name="CheckNMTState" Required="false" Internal="false" DefValue="0" Comment="Check NMT messages from node.&#13;&#10;0 .. deactivated&#13;&#10;1 .. activated"/>
		<Client Name="ChkRxPdo" Required="false" Internal="false" Comment="0 .. Monitoring Pdo´s inactive&#13;&#10;1 .. Monitoring Pdo´s active "/>
		<Client Name="DisableEmergencyObject" Required="false" Internal="false" Comment="Disable the use of emergency object as init value.&#13;&#10;0 .. use emergency object&#13;&#10;1 .. no emergency object is used"/>
		<Client Name="FileSys" Required="false" Internal="false" Comment="FileSys is connected automatically to class _FileSys."/>
		<Client Name="Index" Required="true" Internal="false" DefValue="-1" Comment="Set priority index as init value.&#13;&#10;&gt;= 0 Priority in which order the _CanOpenBasicDS301 Object will be called from Manager. Lower value equals higher priority.&#13;&#10;-1 - No priority defined. The object will be called after objects with priority defined. The order objects with no priority are called is not defined."/>
		<Client Name="MasterDevice" Required="true" Internal="false" Comment="Must be connected to a _CanOpenMng object"/>
		<Client Name="NewNMTState" Required="false" Internal="false" Comment="If a new NMT state is received the write methode of this client is called.&#13;&#10;Only active if client CheckNMTState = 1;&#13;&#10;Possible values are:&#13;&#10;0x00 .. _CAN_BOOT_UP&#13;&#10;0x04 .. _CAN_STOPPED&#13;&#10;0x05 .. _CAN_OPERATIONAL&#13;&#10;0x7F .. _CAN_PRE_OPERATIONAL&#13;&#10;&#13;&#10;"/>
		<Client Name="NodeGuardingSupported" Required="false" Internal="false" Comment="0 .. Node Guarding not supported, &#13;&#10;1 .. Node guarding supported&#13;&#10;If Node Guarding active, Producer Heartbeat is not supported"/>
		<Client Name="Place" Required="true" Internal="false" DefValue="0" Comment="Set CAN-Bus station number as init value.&#13;&#10;Possible values are 1 up to 127.&#13;&#10;To deactivate this object use the &quot;DEACTIVATED_LSL&quot; define (16#FFFF).&#13;&#10;If an XDC file is connected then the place must be set to 0 so that the place setting is taken over by the file."/>
		<Client Name="ProducerHeartbeatSupported" Required="false" Internal="false" Comment="0 .. Producer Heartbeat not supported, &#13;&#10;1 .. Producer Heartbeat supported"/>
		<Client Name="Required" Required="true" Internal="false" DefValue="1" Comment="1 - CanOpenBasicDS301-Object is required and _CanOpenMng is in DeviceState _CAN_OPERATIONAL only when this object is in DeviceState _CAN_OPERATIONAL.&#13;&#10;0 - CanOpenBasicDS301-Object is not required and _CanOpenMng ignores the DeviceSate of the Object."/>
		<Client Name="SDOTable" Required="false" Internal="false" Comment="connect to object from class _CanOpenSDOTab"/>
		<Client Name="SendMode" Required="false" Internal="false" Comment="Set the send mode of Pdo data as init value.&#13;&#10;0 .. Pdo get sent cyclic,&#13;&#10;1 .. Pdo get sent eventtriggered"/>
		<Client Name="StdLib" Required="false" Internal="false" Comment="StdLib is connected automatically to class _StdLib."/>
		<Client Name="toSigCLib" Required="false" Internal="false" Comment="SigClib is connected automatically to class SigClib."/>
		<Client Name="toXDCFile" Required="false" Internal="false" Comment="Must be connect to a string object with file name and file path of xdc file.&#13;&#10;for example: &quot;c:\test1.xdc&quot;"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\_CanOpenMng\_CanOpenMng.h" Include="true"/>
			<File Path=".\OS Interface\Class\SigCLib\CPipe.h" Include="true"/>
			<File Path=".\Class\DiasMaster\DIASMaster.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="Roskri"/>
		<Dokumentation Revision="1.15" Date="25.06.2020" Author="PieSte" Company="Sigmatek" Description="Add LSS (Layer Setting Service) functions for internal use.&#13;&#10;Add flag to reconize new emcy and heartbeat messages.&#13;&#10;Add DIASMaster.h file because of error at compiling without HwControl class in project (SA 57237)."/>
		<Dokumentation Revision="1.14" Date="20.02.2020" Author="PieSte" Company="Sigmatek" Description="Add &quot;CheckNMTState&quot; for reconnection of node if nmt boot up message is received.&#13;&#10;Add client &quot;NewNMTState&quot; to get new nmt states of node if &quot;CheckNMTState&quot; is enabled."/>
		<Dokumentation Revision="1.13" Date="05.08.2019" Author="HaeTho" Company="Sigmatek" Description="segment transfer added"/>
		<Dokumentation Revision="1.12" Date="30.08.2019" Author="PieSte" Company="Sigmatek" Description="Corrected failure at writing of Pdo communication parameters from xdc file if they are not defined.&#13;&#10;Add deactivation of class if &quot;Place&quot; is set to &quot;DEACTIVATED_LSL&quot;. &#13;&#10;Add log messages if a parameter readout of xdc file failed.&#13;&#10;The initialization of device is stopped if there is no answer to sdo from node. &#13;&#10;The ErrorQuit server has been extended so that ResetComm() and ReInitObject() methods can also be triggered."/>
		<Dokumentation Revision="1.11" Date="12.04.2019" Author="PieSte" Company="Sigmatek" Description="It is now evaluated from the xdc file whether the mapping parameter is write-protected. If this is the case, this parameter is not transferred in the initialization.&#13;&#10;The transfer of the highest subindex number to subindex 0, the event timer to subindex 5 and the SYNC start value to subindex 6 at the communication parameters for node config was added."/>
		<Dokumentation Revision="1.10" Date="19.10.2018" Author="PieSte" Company="Sigmatek" Description="The conversion with &quot;to_udint&quot; and assignment to a smaller data type leads from compiler version C47 to an error. The conversion with &quot;to_uint&quot; and &quot;to_usint&quot; converts to the appropriate data types. "/>
		<Dokumentation Revision="1.9" Date="06.08.2018" Author="PieSte" Company="Sigmatek" Description="Add support for xdc files. The rpdo and tpdo data structure has been extended to support more than the 4 default Pdo&apos;s. The Pdo mapping has been extended from 5 to 8 entries.&#13;&#10;Do not cause a communication error with connection abort, if a sdo transmission fails.&#13;&#10;Add logging for errors at initialisation and sdo communication."/>
		<Dokumentation Revision="1.8" Date="16.04.2018" Author="RamAnd" Company="Sigmatek" Description="Create a tx object for SDOs to allow usage of only iso can."/>
		<Dokumentation Revision="1.7" Date="07.11.2017" Author="FurDom" Company="Sigmatek" Description="length for the RemoteTransmitFrame for NodeGuarding changed from 4 bytes to 1 byte"/>
		<Dokumentation Revision="1.6" Date="05.09.2017" Author="RamAnd" Company="Sigmatek" Description="New method SendAllPDOs() for easier overloading if there are new PDOs to send.&#13;&#10;Changed initialisation state machine so the user can easier insert his own initialisation steps into the base class routine."/>
		<Dokumentation Revision="1.5" Date="2016-10-13" Author="Roskri" Company="Sigmatek" Description="When ChkRxPdo = 1 it could lead to an CAN_COMERROR during initialization of the object since the monitoring of the RPDO&apos;s was started to early.&#13;&#10;PDOChoice-mapping parameter is by default deactivated.&#13;&#10;In _PDOSettings the struct-member inactive was added for setting number of mapped objects to 0 when the Pdo is not used"/>
		<Dokumentation Revision="1.4" Date="07.09.2016" Author="EisMic" Company="Sigmatek" Description="Reworked definitions to avoid identical redefinitions."/>
		<Dokumentation Revision="1.3" Date="2016-07-04" Author="Roskri" Company="Sigmatek" Description="MappingPara[0] default active. Example as comment added in ConvertPdo1 and TransmitPdo1"/>
		<Dokumentation Revision="1.2" Date="2016-06-30" Author="Roskri" Company="Sigmatek" Description="Added GetNGorHBtime for checking nodeguarding time or heartbeat time"/>
		<Dokumentation Revision="1.1" Date="2016-06-22" Author="Roskri" Company="Sigmatek" Description="Corrected error that internal mode didn&apos;t change when an communication error occured"/>
		<Dokumentation Revision="1.0" Date="2016-06-20" Author="Roskri" Company="Sigmatek" Description="Class Created"/>
	</RevDoku>
	<Network Name="_CanOpenBasicDS301">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_CanOpenLSSControl1"
				GUID       = "{0E19B58D-8B74-407B-AE03-DA04CD6A99A5}"
				Class      = "_CanOpenLSSControl"
				Position   = "(270,150)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="ActSearchBitrate"/>
					<Server Name="ClassSvr"/>
					<Server Name="NodeID"/>
					<Server Name="ProductCode"/>
					<Server Name="RetCode"/>
					<Server Name="RevisionNumber"/>
					<Server Name="SerialNumber"/>
					<Server Name="VendorID"/>
					<Client Name="toCanOpenMng"/>
				</Channels>
			</Object>
			<Object
				Name       = "_XMLReaderXDC"
				GUID       = "{D180C975-D786-4E82-93DB-EC40F51AB552}"
				Class      = "_XMLReader"
				Position   = "(270,1020)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="ClassSvr"/>
					<Server Name="DoConvert"/>
					<Server Name="ErrorLine"/>
					<Server Name="ErrorSign"/>
					<Server Name="ErrorState"/>
					<Server Name="XmlState"/>
					<Client Name="CreateTask" Value="0"/>
					<Client Name="FileSys"/>
					<Client Name="MultiTask"/>
					<Client Name="SigCLib"/>
					<Client Name="StdLib"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this._XMLReaderXDC" Destination="_XMLReaderXDC.ClassSvr"/>
			<Connection Source="_XMLReaderXDC.SigCLib" Destination="this.toSigCLib" Vertices="(270,1230),(38,1110),"/>
			<Connection Source="_XMLReaderXDC.StdLib" Destination="this.StdLib" Vertices="(270,1170),(38,1050),"/>
			<Connection Source="_XMLReaderXDC.FileSys" Destination="this.FileSys" Vertices="(270,1110),(38,990),"/>
			<Connection Source="this._CanOpenLSSControl1" Destination="_CanOpenLSSControl1.ClassSvr"/>
			<Connection Source="_CanOpenLSSControl1.toCanOpenMng" Destination="this.MasterDevice" Vertices="(270,240),(38,210),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
_CanOpenBasicDS301 : CLASS
	TYPE
	  _CAN_DEVICE_STATE_INT :  //! <Type Public="true" Name="_CAN_DEVICE_STATE_INT"/>
	  (
	    _CAN_BOOT_UP:=0,
	    _CAN_STOPPED:=4,
	    _CAN_OPERATIONAL:=5,
	    _CAN_PRE_OPERATIONAL:=127
	  )$UDINT;
	  _CAN_OPMODE_INT :  //! <Type Public="true" Name="_CAN_OPMODE_INT"/>
	  (
	    _CAN_IDLE,  //! <Type Comment="Idle mode" Name="_CAN_OPMODE_INT._CAN_IDLE"/>
	    _CAN_INIT,  //! <Type Comment="Initialize Device" Name="_CAN_OPMODE_INT._CAN_INIT"/>
	    _CAN_NETENABLE,  //! <Type Comment="Initialization successful. Waiting for Master." Name="_CAN_OPMODE_INT._CAN_NETENABLE"/>
	    _CAN_SYNC,  //! <Type Comment="Running communication (Sending pdos etc.)" Name="_CAN_OPMODE_INT._CAN_SYNC"/>
	    _CAN_NETDISABLE,  //! <Type Comment="Disable Pdo receive on device (stopping remote node)" Name="_CAN_OPMODE_INT._CAN_NETDISABLE"/>
	    _CAN_RESETNODE,  //! <Type Comment="Reset device" Name="_CAN_OPMODE_INT._CAN_RESETNODE"/>
	    _CAN_RESETCOM,  //! <Type Comment="Reset communication" Name="_CAN_OPMODE_INT._CAN_RESETCOM"/>
	    _CAN_NGERROR,  //! <Type Comment="Node Guarding error occurred, e.g. connection disconnected, wrong baudrate" Name="_CAN_OPMODE_INT._CAN_NGERROR"/>
	    _CAN_COMERROR,  //! <Type Comment="Communication Error, e.g SDO-Transfer or Rx Timeout(CheckRxPdo)" Name="_CAN_OPMODE_INT._CAN_COMERROR"/>
	    _CAN_HBERROR,  //! <Type Comment="Heartbeat error occurred, e.g. connection disconnected, wrong baudrate" Name="_CAN_OPMODE_INT._CAN_HBERROR"/>
	    _CAN_LOGINERROR,  //! <Type Comment="Failed to login to manager" Name="_CAN_OPMODE_INT._CAN_LOGINERROR"/>
	    _CAN_CONFIGERROR
	  )$UDINT;
#pragma pack(push, 1)
	  _CAN_SDO_OBJECT : STRUCT
	    Index : INT;
	    SubIndex : HSINT;
	    Data : DINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _CAN_STRUCT : STRUCT
	    CMD : HSINT;
	    IndexLsb : HSINT;
	    IndexMsb : HSINT;
	    SubIndex : HSINT;
	    Data : ARRAY [0..3] OF HSINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DataSDO : STRUCT
	    pThis : ^void;
	    pCallBack : ^void;
	    Active : BOOL;
	    Index : INT;
	    SubIndex : SINT;
	    Data : DINT;
	    RW : BOOL;
	    Len : USINT;
	    pNextSDO : ^_DataSDO;
	  END_STRUCT;
#pragma pack(pop)
	  _PDOSETTINGS : STRUCT
	    ObjNr : INT;  //! <Type Comment="Can-bus object-numer for Pdo" Name="_PDOSETTINGS.ObjNr"/>
	    active : BOOL;  //! <Type Comment="0..Pdo inactiv, 1..Pdo activ have to be set in method getpdosetting() or setpdosetting()" Name="_PDOSETTINGS.active"/>
	    inactive : BOOL;
	    HandleObj : DINT;
	    HighestSubNbr : _CAN_SDO_OBJECT;
	    Deactivate : _CAN_SDO_OBJECT;  //! <Type Comment="Deactivate mapping for Pdo" Name="_PDOSETTINGS.Deactivate"/>
	    TransmissionType : _CAN_SDO_OBJECT;  //! <Type Comment="1..Pdo tranmission via sync, 255..Eventtriggered Pdotranmission " Name="_PDOSETTINGS.TransmissionType"/>
	    InhibitTime : _CAN_SDO_OBJECT;  //! <Type Comment="Time between two objects" Name="_PDOSETTINGS.InhibitTime"/>
	    PdoChoice : _CAN_SDO_OBJECT;  //! <Type Comment="parameter to choose predefined Pdo (f.e.servostar600)" Name="_PDOSETTINGS.PdoChoice"/>
	    EventTimer : _CAN_SDO_OBJECT;
	    SyncStartValue : _CAN_SDO_OBJECT;
	    ActiveNbrOfMappings : DINT;  //! <Type Comment="-1 ... deactivates that the number of mapping parameters are being send to the device" Name="_PDOSETTINGS.ActiveNbrOfMappings"/>
	    MappingPara : ARRAY [0..CO_MAX_PDO_MAPPING_ENTRIES-1] OF _CAN_SDO_OBJECT;  //! <Type Comment="Mapping para" Name="_PDOSETTINGS.MappingPara"/>
	    Activate : _CAN_SDO_OBJECT;  //! <Type Comment="Activate mapping for Pdo" Name="_PDOSETTINGS.Activate"/>
	    pNextPDO : ^_PDOSETTINGS;
	  END_STRUCT;
	  e_SendModeSDO :
	  (
	    _SendFinished,
	    _SendOnce,
	    _SendInfinitive
	  )$UDINT;
	  t_a_CanData : ARRAY [0..7] OF USINT;
	  t_e_AccessTypeXDC :
	  (
	    _TypeNotUsed,
	    _UnknownType,
	    _Constant,
	    _ReadOnly,
	    _WriteOnly,
	    _ReadWrite,
	    _ReadWriteRead,
	    _ReadWriteWrite
	  )$UDINT;
#pragma pack(push, 1)
	  t_s_RxAdditionalVars : STRUCT
	    bRPdoRec : BOOL;
	    ReceiveCntPDO : UDINT;
	    udTimeStamp : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_TxAdditionalVars : STRUCT
	    bSendFlag : BOOL;
	    udTimeStamp : UDINT;
	    udErrorSendCnt : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_AdditionalVars : STRUCT
	    bRxAdditionalUsed : BOOL;
	    bTxAdditionalUsed : BOOL;
	    uiRPDOUsed : UINT;
	    uiTPDOUsed : UINT;
	    RxVars : ARRAY [0..CO_MAX_PDO_OBJECTS-1] OF t_s_RxAdditionalVars;
	    TxVars : ARRAY [0..CO_MAX_PDO_OBJECTS-1] OF t_s_TxAdditionalVars;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_BasicCanObj : STRUCT
	    CanData : t_a_CanData;
	    usLength : USINT;
	    udObjNbr : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_CanOpen_SDO_Dwnld_Initiate_Request : STRUCT
	    Header : BSINT
	    [
	      1 _S,
	      2 _E,
	      3 _N1,
	      4 _N2,
	      5 _X,
	      6 _CCS1,
	      7 _CCS2,
	      8 _CCS3,
	    ];
	    Index : HINT;
	    SubIndex : HSINT;
	    Data : ARRAY [0..3] OF USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_CanOpen_SDO_Dwnld_Segment_Request : STRUCT
	    Header : BSINT
	    [
	      1 _C,
	      2 _N1,
	      3 _N2,
	      4 _N3,
	      5 ToggleBit,
	      6 _CCS1,
	      7 _CCS2,
	      8 _CCS3,
	    ];
	    Data : ARRAY [0..6] OF USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_CanOpen_SDO_Upload_Initiate_Request : STRUCT
	    Header : BSINT
	    [
	      1 X1,
	      2 X2,
	      3 X3,
	      4 X4,
	      5 X5,
	      6 CCS1,
	      7 CCS2,
	      8 CCS3,
	    ];
	    Index : HINT;
	    SubIndex : HSINT;
	    aData : ARRAY [0..3] OF USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_CanOpen_SDO_Upload_Segment_Request : STRUCT
	    Header : BSINT
	    [
	      1 X1,
	      2 X2,
	      3 X3,
	      4 X4,
	      5 ToggleBit,
	      6 CCS1,
	      7 CCS2,
	      8 CCS3,
	    ];
	    aData : ARRAY [0..6] OF USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_CanOpen_SDO_Upload_Segment_Response : STRUCT
	    Header : BSINT
	    [
	      1 C,
	      2 N1,
	      3 N2,
	      4 N3,
	      5 ToggleBit,
	      6 SCS1,
	      7 SCS2,
	      8 SCS3,
	    ];
	    aData : ARRAY [0..6] OF USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_ComSDOCyclic : STRUCT
	    bRW : BOOL;
	    usLen : USINT;
	    hiIndex : HINT;
	    usSubIndex : USINT;
	    dData : DINT;
	    dRetData : DINT;
	    SendMode : e_SendModeSDO;  //! <Type Comment="display send mode of sdo:&#13;&#10;0 .. deactivated&#13;&#10;1 .. send once&#13;&#10;2 .. repeat sending" Name="t_s_ComSDOCyclic.SendMode"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_ComSDOInfo : STRUCT
	    dErrorCounter : DINT;
	    dRxCounter : DINT;
	    dTxCounter : DINT;
	    bRW : BOOL;
	    usLen : USINT;
	    hsCMD : HSINT;
	    hiIndex : HINT;
	    hsSubIndex : HSINT;
	    hdData : HDINT;
	    hdErrorRetCode : HDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_NetworkManagement : STRUCT
	    GeneralFeatures : STRUCT
	      biEntryValid : BINT
	      [
	        1 Bit1,
	        2 Bit2,
	        3 Bit3,
	        4 Bit4,
	        5 Bit5,
	        6 Bit6,
	        7 Bit7,
	        8 Bit8,
	        9 Bit9,
	        10 Bit10,
	        11 Bit11,
	        12 Bit12,
	        13 Bit13,
	        14 Bit14,
	        15 Bit15,
	        16 Bit16,
	      ];
	      bgroupMessaging : BOOL;
	      uddynamicChannels : UDINT;
	      bselfStartingDevice : BOOL;
	      bSDORequestingDevice : BOOL;
	      udgranularity : UDINT;
	      udnrOfRxPDO : UDINT;
	      udnrOfTxPDO : UDINT;
	      bbootUpSlave : BOOL;
	      blayerSettingServiceSlave : BOOL;
	    END_STRUCT;
	    MasterFeatures : STRUCT
	      biEntryValid : BINT
	      [
	        1 Bit1,
	        2 Bit2,
	        3 Bit3,
	        4 Bit4,
	        5 Bit5,
	        6 Bit6,
	        7 Bit7,
	        8 Bit8,
	        9 Bit9,
	        10 Bit10,
	        11 Bit11,
	        12 Bit12,
	        13 Bit13,
	        14 Bit14,
	        15 Bit15,
	        16 Bit16,
	      ];
	      bbootUpMaster : BOOL;
	      bflyingMaster : BOOL;
	      bSDOManager : BOOL;
	      bconfigurationManager : BOOL;
	      blayerSettingServiceMaster : BOOL;
	    END_STRUCT;
	    DeviceCommissioning : STRUCT
	      biEntryValid : BINT
	      [
	        1 Bit1,
	        2 Bit2,
	        3 Bit3,
	        4 Bit4,
	        5 Bit5,
	        6 Bit6,
	        7 Bit7,
	        8 Bit8,
	        9 Bit9,
	        10 Bit10,
	        11 Bit11,
	        12 Bit12,
	        13 Bit13,
	        14 Bit14,
	        15 Bit15,
	        16 Bit16,
	      ];
	      udnodeID : UDINT;
	      strnodeName : ARRAY [0..CO_XDC_MAX_STRING_LENGTH-1] OF CHAR;
	      udactualBaudRate : UDINT;
	      udnetworkNumber : UDINT;
	      strnetworkName : ARRAY [0..CO_XDC_MAX_STRING_LENGTH-1] OF CHAR;
	      bCANopenManager : BOOL;
	    END_STRUCT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_PDOMappingInfo : STRUCT
	    Value : DINT;
	    AccessType : t_e_AccessTypeXDC;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_PDOCommPara : STRUCT
	    Index : HDINT;
	    SubNbrs : UDINT;
	    LargestSubIndex : UDINT;
	    aMappingInfo : ARRAY [0..6] OF t_s_PDOMappingInfo;  //! <Type Comment="Subindex   &#13;&#10;00 .. Number of highest subindex&#13;&#10;01 .. COB - ID&#13;&#10;02 .. Transmission Type&#13;&#10;03 .. Inhibit Time&#13;&#10;04 .. Reserved&#13;&#10;05 .. Event Timer&#13;&#10;06 .. SyncStartValue" Name="t_s_PDOCommPara.aMappingInfo"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_PDOElement : STRUCT
	    index : HDINT;
	    SubNbrs : UDINT;
	    LargestSubIndex : UDINT;
	    aMappingInfo : ARRAY [0..15] OF t_s_PDOMappingInfo;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_PDOMapping : STRUCT
	    index : HDINT;
	    SubNbrs : UDINT;
	    LargestSubIndex : UDINT;
	    aMapEntry : ARRAY [0..CO_MAX_PDO_MAPPING_ENTRIES-1] OF t_s_PDOMappingInfo;  //! <Type Comment="Subindex&#13;&#10;00 .. Number of highest subindex&#13;&#10;01 - 08 .. Pdo Mapping" Name="t_s_PDOMapping.aMapEntry"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_PDOStruct : STRUCT
	    PDOCommPara : t_s_PDOCommPara;
	    PDOMapping : t_s_PDOMapping;
	    pNextPDOData : ^t_s_PDOStruct;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_PDOVars : STRUCT
	    pActPDO : ^_PDOSETTINGS;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_SdoData : STRUCT
	    usNoSDOobj : USINT;
	    udBufferSizeSDO : UDINT;
	    usCounterSDOobj : USINT;
	    SdoHandle : DINT;
	    LastSdoData : DINT;
	    pActSdoEntry : ^_DataSDO;
	    pSdoData : ^_DataSDO;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_SDOErrorLogging : STRUCT
	    usDataInBuffer : USINT;
	    pSDOErrorPipe : ^t_s_ComSDOInfo;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_XDCVars : STRUCT
	    eXDCPDOInfos :
	    (
	      _GetCANOpenObjectList,
	      _GetAdditionalIndexes,
	      _GetNetworkInfo,
	      _GetRPDOCommPara,
	      _GetRPDOMapping,
	      _GetTPDOCommPara,
	      _GetTPDOMapping,
	      _GetInfoFinished,
	      _GetInfoError
	    )$UDINT;
	    dRetcode : iprStates;
	    bUseXDCPdoInfo : BOOL;
	    uiRPDOEntries : UINT;
	    pRPDOData : ^t_s_PDOStruct;
	    uiTPDOEntries : UINT;
	    pTPDOData : ^t_s_PDOStruct;
	    sNetworkManagementInfo : t_s_NetworkManagement;
	    uiFoundObjectIndexes : UINT;
	    aObjectIndexes : ARRAY [0..CO_XDC_MAX_OBJECT_INDEXES-1] OF HINT;
	    bFirstAlloc : BOOL;
	    hdActSearchIndex : HDINT;
	    udActSubIndex : UDINT;
	    pXDCElement : ^_XML_ELEMENT;
	    pActPDOEntry : ^t_s_PDOStruct;
	    sActPDOData : t_s_PDOElement;
	  END_STRUCT;
#pragma pack(pop)
	  t_SegmentTransferResult :
	  (
	    SEGTR_OK:=0,  //! <Type Comment="Segment transfer has run OK." Name="t_SegmentTransferResult.SEGTR_OK"/>
	    SEGTR_ERROR_UpldSegTransAkt:=1,  //! <Type Comment="(_CanOpenBasicDS301::StartSegmentUpload) upload could not be started - another segment transfer is active." Name="t_SegmentTransferResult.SEGTR_ERROR_UpldSegTransAkt"/>
	    SEGTR_ERROR_InvalUpldPtr:=2,  //! <Type Comment="(_CanOpenBasicDS301::StartSegmentUpload) new upload not started: invalid data pointer." Name="t_SegmentTransferResult.SEGTR_ERROR_InvalUpldPtr"/>
	    SEGTR_ERROR_InvalCmdSpec:=3,  //! <Type Comment="(_CanOpenBasicDS301::CANReceiveEEPROMTransfer) Invalid Command specifier for Upload Segment Transfer." Name="t_SegmentTransferResult.SEGTR_ERROR_InvalCmdSpec"/>
	    SEGTR_ERROR_UpldTOPassed:=4,  //! <Type Comment="(_CanOpenBasicDS301::HandleEEPROMTransferCommunication) upload timeout surpassed." Name="t_SegmentTransferResult.SEGTR_ERROR_UpldTOPassed"/>
	    SEGTR_ERROR_DldTOPassed:=5,  //! <Type Comment="(_CanOpenBasicDS301::HandleEEPROMTransferCommunication) download timeout surpassed." Name="t_SegmentTransferResult.SEGTR_ERROR_DldTOPassed"/>
	    SEGTR_ERROR_DldSegTransfAkt:=6,  //! <Type Comment="(_CanOpenBasicDS301::StartSegmentDownload) new Download not started: EEPROM up- or download running at the moment." Name="t_SegmentTransferResult.SEGTR_ERROR_DldSegTransfAkt"/>
	    SEGTR_ERROR_InvalDldPtr:=7,  //! <Type Comment="(_CanOpenBasicDS301::StartSegmentDownload) new Download not started: invalid download pointer." Name="t_SegmentTransferResult.SEGTR_ERROR_InvalDldPtr"/>
	    SEGTR_ERROR_PrepSDOUpldInitNOK:=8  //! <Type Comment="(_CanOpenBasicDS301::StartSegmentUpload) PrepareSDOUploadInitiate was NOK." Name="t_SegmentTransferResult.SEGTR_ERROR_PrepSDOUpldInitNOK"/>
	  )$USINT;
#pragma pack(push, 1)
	  t_SegmentHandling : STRUCT
	    us_SegmentTransferActive : USINT;  //! <Type Comment="Shows the state of the segment transfer:&#13;&#10;CO_SEGMENT_INACTIVE:                     no segment trasnfer is running&#13;&#10;CO_UPLOAD_SEGMENT_ACTIVE         an upload segment transfer is running&#13;&#10;CO_DOWNLOAD_SEGMENT_ACTIVE  a dowload segment transfer is running" Name="t_SegmentHandling.us_SegmentTransferActive"/>
	    b_Wait4ModuleResponse : BOOL;  //! <Type Comment=". If an SDO message is sent to the module:&#13;&#10;the variable is set TRUE to indicate that we wait for an answer&#13;&#10;. If an SDO message is received from the module and has been worked out:&#13;&#10;it is set FALSE to indicate that we have got answe from the module" Name="t_SegmentHandling.b_Wait4ModuleResponse"/>
	    b_IsFirstPacket : BOOL;  //! <Type Comment="is used only for EEPROM download transfer&#13;&#10;TRUE: this is the first message which is sent to the module during the segment transfer&#13;&#10;(an SDO sownload  initiate is sent)&#13;&#10;FALSE: the first message to the module has already been sent&#13;&#10;(an SDO download segment is sent)" Name="t_SegmentHandling.b_IsFirstPacket"/>
	    b_ToggleBit : BOOL;  //! <Type Comment=". For the first message which is sent to the module (SDO down- / upload initiate)&#13;&#10;and  the first SDO download segment message it is FALSE.&#13;&#10;. Then it toggles with every SDO download segment message which is sent to the module&#13;&#10;&#13;&#10;" Name="t_SegmentHandling.b_ToggleBit"/>
	    b_SendResponseToModule : BOOL;  //! <Type Comment="Is used only for segment upload:&#13;&#10;TRUE: if an SDO segment is received from the module&#13;&#10;FALSE: if the answer has been given to the module" Name="t_SegmentHandling.b_SendResponseToModule"/>
	    ud_DataLeftToWrite : UDINT;  //! <Type Comment="Is used only for segment download:&#13;&#10;The number of bytes which still have to be downloaded tot he module." Name="t_SegmentHandling.ud_DataLeftToWrite"/>
	    ud_ActWriteOffset : UDINT;  //! <Type Comment="Only used for segment download:&#13;&#10;Number of bytes which already have been written to the module." Name="t_SegmentHandling.ud_ActWriteOffset"/>
	    ud_SendTime : UDINT;  //! <Type Comment="Starttime for the various TimeOuts during segment transfer." Name="t_SegmentHandling.ud_SendTime"/>
	    ud_ReadActDataLen : UDINT;  //! <Type Comment="Used only for segment upload:&#13;&#10;Number of bytes which already have been uploaded from the module." Name="t_SegmentHandling.ud_ReadActDataLen"/>
	    p_WriteData : ^USINT;  //! <Type Comment="Pointer for the data to be downloaded." Name="t_SegmentHandling.p_WriteData"/>
	    p_UploadData : ^USINT;  //! <Type Comment="Pointer where the uploaded data are stored." Name="t_SegmentHandling.p_UploadData"/>
	    ud_DownloadLength : UDINT;  //! <Type Comment="Used only for download:&#13;&#10;Number of bytes to be downloaded." Name="t_SegmentHandling.ud_DownloadLength"/>
	    ud_UploadLength : UDINT;  //! <Type Comment="Used only for segment upload:&#13;&#10;NUmber of bytes to be uploaded." Name="t_SegmentHandling.ud_UploadLength"/>
	    ui_IndexSegmentUploadModule : UINT;  //! <Type Comment="Index of Object Dictionary for segment upload" Name="t_SegmentHandling.ui_IndexSegmentUploadModule"/>
	    us_SubindexSegmentUploadModule : USINT;  //! <Type Comment="Subindex of Object Dictionary for segment upload" Name="t_SegmentHandling.us_SubindexSegmentUploadModule"/>
	    ui_IndexSegmentDownloadModule : UINT;  //! <Type Comment="Index of Object Dictionary for segment download" Name="t_SegmentHandling.ui_IndexSegmentDownloadModule"/>
	    us_SubindexSegmentDownloadModule : USINT;  //! <Type Comment="Subindex of Object Dictionary for segment download" Name="t_SegmentHandling.us_SubindexSegmentDownloadModule"/>
	    ud_oldReceiveCounterSdo : UDINT;  //! <Type Comment="Latest number of received SDO messages.&#13;&#10;Used to determine whether a new SDO message has been received." Name="t_SegmentHandling.ud_oldReceiveCounterSdo"/>
	    en_SegmentTransferResult : t_SegmentTransferResult;  //! <Type Comment="shows the State of the segment transfer:&#13;&#10;6   ... upload segment transfer is running&#13;&#10;8   ... download segment transfer is running&#13;&#10;99 ... segment transfer was NOT OK" Name="t_SegmentHandling.en_SegmentTransferResult"/>
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	DeviceState 	: SvrChCmd__CAN_OPEN_DEVICE_STATE_EXT_PTofCls__CanOpenMng;
	ErrorQuit 	: SvrCh_DINT;
	CanDisabled 	: SvrCh_DINT;
	DataReady 	: SvrCh_DINT;
	AsyncState 	: SvrCh_iprStates;
	ErrorSDO 	: SvrCh_DINT;
	ErrorAlloc 	: SvrCh_DINT;
	EmcyStatusByte0_3 	: SvrCh_HDINT;
	EmcyStatusByte4_7 	: SvrCh_HDINT;
  //Clients:
	MasterDevice 	: CltChCmd__CanOpenMng;
	Place 	: CltCh_DINT;
	Index 	: CltCh_DINT;
	Required 	: CltCh_DINT;
	ChkRxPdo 	: CltCh_DINT;
	NodeGuardingSupported 	: CltCh_DINT;
	ProducerHeartbeatSupported 	: CltCh_DINT;
	SendMode 	: CltCh_DINT;
	DisableEmergencyObject 	: CltCh_DINT;
	CheckNMTState 	: CltCh_DINT;
	NewNMTState 	: CltCh__CAN_DEVICE_STATE_INT_PTofCls__CanOpenBasicDS301;
	SDOTable 	: CltChCmd__CanOpenSDOTab;
	toXDCFile 	: CltChCmd_String;
	FileSys 	: CltChCmd__FileSys;
	StdLib 	: CltChCmd__StdLib;
	toSigCLib 	: CltChCmd_SigCLib;
	_XMLReaderXDC 	: CltChCmd__XMLReader;
	_CanOpenLSSControl1 	: CltChCmd__CanOpenLSSControl;
  //Variables:
		RPdo1 	: _PDOSETTINGS;			//! <Variable Comment="Pdo Settings" Name="RPdo1"/>
		RPdo2 	: _PDOSETTINGS;			//! <Variable Comment="Pdo Settings" Name="RPdo2"/>
		RPdo3 	: _PDOSETTINGS;			//! <Variable Comment="Pdo Settings" Name="RPdo3"/>
		RPdo4 	: _PDOSETTINGS;			//! <Variable Comment="Pdo Settings" Name="RPdo4"/>
		RPdoAdditional 	: _PDOSETTINGS;
		TPdo1 	: _PDOSETTINGS;			//! <Variable Comment="Pdo Settings" Name="TPdo1"/>
		TPdo2 	: _PDOSETTINGS;			//! <Variable Comment="Pdo Settings" Name="TPdo2"/>
		TPdo3 	: _PDOSETTINGS;			//! <Variable Comment="Pdo Settings" Name="TPdo3"/>
		TPdo4 	: _PDOSETTINGS;			//! <Variable Comment="Pdo Settings" Name="TPdo4"/>
		TPdoAdditional 	: _PDOSETTINGS;
		pTempPdoEntry 	: ^_PDOSETTINGS;
		RxBufferEmcy : ARRAY [0..CO_MAX_CANOPEN_DATASIZE-1] OF HSINT;
			//! <Variable Comment="Receive Buffer for Emergency Object" Name="RxBufferEmcy"/>
		RxBufferNG : ARRAY [0..CO_MAX_CANOPEN_DATASIZE-1] OF HSINT;
			//! <Variable Comment="Receive Buffer for Node Guarding Object" Name="RxBufferNG"/>
		RxBufferSdo : ARRAY [0..CO_MAX_CANOPEN_DATASIZE-1] OF HSINT;
			//! <Variable Comment="Receive Buffer for Service Data Object" Name="RxBufferSdo"/>
		RxBufferPdo1 : ARRAY [0..CO_MAX_CANOPEN_DATASIZE-1] OF HSINT;
			//! <Variable Comment="Receive Buffer for PDO1" Name="RxBufferPdo1"/>
		RxBufferPdo2 : ARRAY [0..CO_MAX_CANOPEN_DATASIZE-1] OF HSINT;
			//! <Variable Comment="Receive Buffer for PDO2" Name="RxBufferPdo2"/>
		RxBufferPdo3 : ARRAY [0..CO_MAX_CANOPEN_DATASIZE-1] OF HSINT;
			//! <Variable Comment="Receive Buffer for PDO3" Name="RxBufferPdo3"/>
		RxBufferPdo4 : ARRAY [0..CO_MAX_CANOPEN_DATASIZE-1] OF HSINT;
			//! <Variable Comment="Receive Buffer for PDO4" Name="RxBufferPdo4"/>
		RxBufferHB : ARRAY [0..CO_MAX_CANOPEN_DATASIZE-1] OF HSINT;

		HandleTxObjNmt 	: DINT;			//! <Variable Comment="Handle for none interruptable can-communication" Name="HandleTxObjNmt"/>
		HandleRxNG 	: DINT;			//! <Variable Comment="Handle for none interruptable can-communication" Name="HandleRxNG"/>
		HandleRxObjEMCY 	: DINT;			//! <Variable Comment="Handle for none interruptable can-communication" Name="HandleRxObjEMCY"/>
		HandleRxObjHB 	: DINT;
		PDOIniSSW 	: DINT;
		InitSSW 	: DINT;
		SDOProcessSSW 	: DINT;
		HandleTxObjSdo 	: DINT;			//! <Variable Comment="Handle for none interruptable can-communication" Name="HandleTxObjSdo"/>
		HandleRxObjSdo 	: DINT;			//! <Variable Comment="Handle for none interruptable can-communication" Name="HandleRxObjSdo"/>
		sDataSDO 	: t_s_SdoData;
		ComSDO 	: t_s_ComSDOInfo;
		SDO_RwError 	: DINT;			//! <Variable Comment="value of sdo rw error (error-returncode of sdo action), set in methods getpdosettings() or setpdosettings()" Name="SDO_RwError"/>
		pSDOTable 	: ^DINT;
		dSDOTabCounter 	: DINT;
		SendCounterSdo 	: UDINT;
		bRPdo1Rec 	: BOOL;
		bRPdo2Rec 	: BOOL;
		bRPdo3Rec 	: BOOL;
		bRPdo4Rec 	: BOOL;
		ReceiveCounterSdo 	: UDINT;			//! <Variable Comment="Receive counter for sdo objects" Name="ReceiveCounterSdo"/>
		ReceiveCounterPdo1 	: UDINT;			//! <Variable Comment="Receive counter for object except Pdo 1" Name="ReceiveCounterPdo1"/>
		ReceiveCounterPdo2 	: UDINT;
		ReceiveCounterPdo3 	: UDINT;
		ReceiveCounterPdo4 	: UDINT;
		TimeRPdo1 	: UDINT;			//! <Variable Comment="Timemark for RX Timeout detection" Name="TimeRPdo1"/>
		TimeRPdo2 	: UDINT;			//! <Variable Comment="Timemark for RX Timeout detection" Name="TimeRPdo2"/>
		TimeRPdo3 	: UDINT;			//! <Variable Comment="Timemark for RX Timeout detection" Name="TimeRPdo3"/>
		TimeRPdo4 	: UDINT;			//! <Variable Comment="Timemark for RX Timeout detection" Name="TimeRPdo4"/>
		SendMarkTpdo1 	: BOOL;
		SendMarkTpdo2 	: BOOL;
		SendMarkTpdo3 	: BOOL;
		SendMarkTpdo4 	: BOOL;
		HeartbeatCounter 	: DINT;
		RequestTimeOut 	: UDINT;
		NGErrorCounter 	: DINT;			//! <Variable Comment="Node Guarding Error Counter" Name="NGErrorCounter"/>
		NGReceiveFlag 	: DINT;			//! <Variable Comment="Node Guarding object receive flag" Name="NGReceiveFlag"/>
		RSdoObjNr 	: INT;			//! <Variable Comment="Can-bus object-number for receive sdo" Name="RSdoObjNr"/>
		TSdoObjNr 	: INT;			//! <Variable Comment="Can-bus object-number for transmit sdo" Name="TSdoObjNr"/>
		NgObjNr 	: INT;			//! <Variable Comment="Can-bus object-number for node guarding object" Name="NgObjNr"/>
		EmcyObjNr 	: INT;			//! <Variable Comment="Can-bus object-number for emergency object" Name="EmcyObjNr"/>
		HlpHandleInit 	: DINT;			//! <Variable Comment="Handle for asynchronous data transfer" Name="HlpHandleInit"/>
		GuardTime 	: _CAN_SDO_OBJECT;			//! <Variable Comment="Node guarding parameter" Name="GuardTime"/>
		Lifetimefactor 	: _CAN_SDO_OBJECT;			//! <Variable Comment="Node guarding parameter" Name="Lifetimefactor"/>
		Heartbeat 	: _CAN_SDO_OBJECT;
		SegmentCmd 	: HSINT;			//! <Variable Comment="Cmd for SDO segment protocoll" Name="SegmentCmd"/>
		usInitCnt 	: USINT;
		HlpHandleRWSDO 	: DINT;
		bHeartbeatRXFlag 	: BOOL;
		udTimeStampHB 	: UDINT;
		udTimestampNG 	: UDINT;
		udRPdoTimeout 	: UDINT;
		bResetCom 	: BOOL;
		udStartResetCom 	: UDINT;
		PlcConsumerHeartBeat 	: UDINT;			//! <Variable Comment="If heartbeat is activated and application don´t receive&#13;&#10;a heartbeat within this timeperiod opmode is changed to _CAN_HBERROR" Name="PlcConsumerHeartBeat"/>
		OpMode 	: _CAN_OPMODE_INT;
		CanDeviceState 	: _CAN_DEVICE_STATE_INT;
		CanDeviceStateInternal 	: _CAN_DEVICE_STATE_INT;
		sXDCVars 	: t_s_XDCVars;
		sPDOAdditionalVars 	: t_s_AdditionalVars;
		sSDOErrorLogging 	: t_s_SDOErrorLogging;
		p_UploadData 	: ^USINT;
		s_SegmentHandling 	: t_SegmentHandling;
		RXCAN_Data : ARRAY [0..7] OF USINT;

		_ToggleBitOKCnt 	: DINT;
		_ToggleBitNotOKCnt 	: DINT;
		TXCAN_Data_Seg : ARRAY [0..7] OF USINT;

		bNewNMTState 	: BOOL;
		bQuitErrorNewNMT 	: BOOL;
		QuitErrorNMTState 	: _CAN_DEVICE_STATE_INT;
		udWaitInitNode 	: UDINT;
		udCheckRxPDOTimeout 	: UDINT;
		bdLogDataFlags : BDINT
		[
		  1 bNewHBError,
		  2 bNewComError,
		  3 bNewDriveError,
		  4 bNewEmcyMsg,
		];

  //Functions:
				//! <Function Comment="Initialization" Name="Init"/>
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="This function is called in Background Task from _CanOpenMng." Name="Background"/>
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="Main step controller for initializing the CanOpen node" Name="InitSettingsAndPdos"/>
	FUNCTION VIRTUAL InitSettingsAndPdos;
				//! <Function Comment="Send NMT object&#13;&#10;" Name="SetNmt"/>
	FUNCTION VIRTUAL SetNmt
		VAR_INPUT
			Para 	: HSINT;			//! <Variable Comment="Commands of the Nmt:&#13;&#10;16#01  // Start Remote Node&#13;&#10;16#02  // Stop Remote Node&#13;&#10;16#80  // Reset Node in Pre-Operational&#13;&#10;16#81  // Reset Node&#13;&#10;16#82  // Reset Communication" Name="SetNmt.Para"/>
		END_VAR
		VAR_OUTPUT
			RetVal 	: DINT;			//! <Variable Comment="0: OK&#13;&#10;1: wrong CAN interface (1 of 2) &#13;&#10;2: Data length greater than 8 of ObjNr greater than 2047 &#13;&#10;4: Buffer full" Name="SetNmt.RetVal"/>
		END_VAR;
				//! <Function Comment="Do Pdo parameter and Pdo mapping during init.&#13;&#10;" Name="SetPdoData"/>
	FUNCTION VIRTUAL SetPdoData
		VAR_INPUT
			pPdoSetting 	: ^_PDOSETTINGS;			//! <Variable Comment="pointer to Pdo element" Name="SetPdoData.pPdoSetting"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="return code of function&#13;&#10;0 .. busy&#13;&#10;1  .. finished" Name="SetPdoData.retcode"/>
		END_VAR;
				//! <Function Comment="This function sets the correct command specifier and  sends the sdo" Name="SendSdo"/>
	FUNCTION VIRTUAL SendSdo
		VAR_INPUT
			Index 	: HINT;			//! <Variable Comment="Index of SDO object as 2 byte value." Name="SendSdo.Index"/>
			SubIndex 	: HSINT;			//! <Variable Comment="Subindex of SDO object as 1 byte value." Name="SendSdo.SubIndex"/>
			Data 	: HDINT;			//! <Variable Comment="Data of SDO object as 4 byte value." Name="SendSdo.Data"/>
			Length 	: USINT;			//! <Variable Comment="Length of SDO Data with range from 0 to 4 byte.&#13;&#10;0 .. length is calculated automatically" Name="SendSdo.Length"/>
			RW 	: BOOL;			//! <Variable Comment="Select Read or Write SDO.&#13;&#10;0 .. Read SDO&#13;&#10;1 .. Write SDO" Name="SendSdo.RW"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="Return code of function.&#13;&#10;0 .. ok&#13;&#10;-1 .. length is more then 4 byte&#13;&#10;&lt;&gt; 0/-1 .. error return code from CanTxObj() function. " Name="SendSdo.retcode"/>
		END_VAR;
				//! <Function Comment="This function checks received sdo&apos;s.&#13;&#10;" Name="SDOCheck"/>
	FUNCTION VIRTUAL SDOCheck;
				//! <Function Comment="Wait for incomming SDO and set timeout if SDO is not received.&#13;&#10;" Name="SdoProcess"/>
	FUNCTION VIRTUAL SdoProcess;
				//! <Function Comment="Callback function for receive can data." Name="ReceiveSDO"/>
	FUNCTION ReceiveSDO
		VAR_INPUT
			PiCanptr 	: ^USINT;			//! <Variable Comment="Pointer to can data." Name="ReceiveSDO.PiCanptr"/>
			RxDataptr 	: ^USINT;			//! <Variable Comment="Pointer to can data." Name="ReceiveSDO.RxDataptr"/>
			Thisptr 	: DINT;			//! <Variable Comment="This pointer - must be set to this pointer of object." Name="ReceiveSDO.Thisptr"/>
		END_VAR;
				//! <Function Comment="Callback function for receive can data." Name="ReceiveEMCY"/>
	FUNCTION ReceiveEMCY
		VAR_INPUT
			PiCanptr 	: ^USINT;			//! <Variable Comment="Pointer to can data." Name="ReceiveEMCY.PiCanptr"/>
			RxDataptr 	: ^USINT;			//! <Variable Comment="Pointer to can data." Name="ReceiveEMCY.RxDataptr"/>
			Thisptr 	: DINT;			//! <Variable Comment="This pointer - must be set to this pointer of object." Name="ReceiveEMCY.Thisptr"/>
		END_VAR;
				//! <Function Comment="Callback function for receive can data." Name="ReceiveNG"/>
	FUNCTION ReceiveNG
		VAR_INPUT
			piCanptr 	: ^USINT;			//! <Variable Comment="Pointer to can data." Name="ReceiveNG.piCanptr"/>
			RxDataptr 	: ^USINT;			//! <Variable Comment="Pointer to can data." Name="ReceiveNG.RxDataptr"/>
			Thisptr 	: DINT;			//! <Variable Comment="This pointer - must be set to this pointer of object." Name="ReceiveNG.Thisptr"/>
		END_VAR;
				//! <Function Comment="Callback function for receive can data." Name="ReceiveHB"/>
	FUNCTION ReceiveHB
		VAR_INPUT
			PiCanptr 	: ^USINT;			//! <Variable Comment="Pointer to can data." Name="ReceiveHB.PiCanptr"/>
			RxDataptr 	: ^USINT;			//! <Variable Comment="Pointer to can data." Name="ReceiveHB.RxDataptr"/>
			Thisptr 	: DINT;			//! <Variable Comment="This pointer - must be set to this pointer of object." Name="ReceiveHB.Thisptr"/>
		END_VAR;
				//! <Function Comment="Callback function for receive Pdo can data." Name="ReceivePdo1"/>
	FUNCTION ReceivePdo1
		VAR_INPUT
			piCanptr 	: ^USINT;			//! <Variable Comment="Pointer to can data." Name="ReceivePdo1.piCanptr"/>
			RxDataptr 	: ^t_s_BasicCanObj;			//! <Variable Comment="Pointer to can data." Name="ReceivePdo1.RxDataptr"/>
			Thisptr 	: DINT;			//! <Variable Comment="This pointer - must be set to this pointer of object." Name="ReceivePdo1.Thisptr"/>
		END_VAR;
				//! <Function Comment="Callback function for receive Pdo can data." Name="ReceivePdo2"/>
	FUNCTION ReceivePdo2
		VAR_INPUT
			piCanptr 	: ^USINT;			//! <Variable Comment="Pointer to can data." Name="ReceivePdo2.piCanptr"/>
			RxDataptr 	: ^t_s_BasicCanObj;			//! <Variable Comment="Pointer to can data." Name="ReceivePdo2.RxDataptr"/>
			Thisptr 	: DINT;			//! <Variable Comment="This pointer - must be set to this pointer of object." Name="ReceivePdo2.Thisptr"/>
		END_VAR;
				//! <Function Comment="Callback function for receive Pdo can data." Name="ReceivePdo3"/>
	FUNCTION ReceivePdo3
		VAR_INPUT
			piCanptr 	: ^USINT;			//! <Variable Comment="Pointer to can data." Name="ReceivePdo3.piCanptr"/>
			RxDataptr 	: ^t_s_BasicCanObj;			//! <Variable Comment="Pointer to can data." Name="ReceivePdo3.RxDataptr"/>
			Thisptr 	: DINT;			//! <Variable Comment="This pointer - must be set to this pointer of object." Name="ReceivePdo3.Thisptr"/>
		END_VAR;
				//! <Function Comment="Callback function for receive Pdo can data." Name="ReceivePdo4"/>
	FUNCTION ReceivePdo4
		VAR_INPUT
			piCanptr 	: ^USINT;			//! <Variable Comment="Pointer to can data." Name="ReceivePdo4.piCanptr"/>
			RxDataptr 	: ^t_s_BasicCanObj;			//! <Variable Comment="Pointer to can data." Name="ReceivePdo4.RxDataptr"/>
			Thisptr 	: DINT;			//! <Variable Comment="This pointer - must be set to this pointer of object." Name="ReceivePdo4.Thisptr"/>
		END_VAR;
				//! <Function Comment="Callback function for receive Pdo can data." Name="RxAdditionalPDO"/>
	FUNCTION RxAdditionalPDO
		VAR_INPUT
			piCanptr 	: ^t_s_BasicCanObj;			//! <Variable Comment="Pointer to can data." Name="RxAdditionalPDO.piCanptr"/>
			RxDataptr 	: ^t_s_BasicCanObj;			//! <Variable Comment="Pointer to can data." Name="RxAdditionalPDO.RxDataptr"/>
			Thisptr 	: DINT;			//! <Variable Comment="This pointer - must be set to this pointer of object." Name="RxAdditionalPDO.Thisptr"/>
		END_VAR;
				//! <Function Comment="This function checks if the choosen Pdo is present. If yes then it will be sent." Name="TxAdditionalPDO"/>
	FUNCTION TxAdditionalPDO
		VAR_INPUT
			uiPDONbr 	: UINT := 0;			//! <Variable Comment="Number of Pdo:&#13;&#10;1-4 Default Pdo&#13;&#10;4-x additional Pdo" Name="TxAdditionalPDO.uiPDONbr"/>
			hiObjNbr 	: HINT := 0;			//! <Variable Comment="COB-ID of transmit Pdo." Name="TxAdditionalPDO.hiObjNbr"/>
			paCanData 	: ^t_a_CanData;			//! <Variable Comment="pointer to the transmit data (8Byte)" Name="TxAdditionalPDO.paCanData"/>
		END_VAR
		VAR_OUTPUT
			dRetCode 	: DINT;			//! <Variable Comment="Returnvalue of transmit function.&#13;&#10;0 .. Pdo sending failed (not existing)&#13;&#10;1 - x .. sending of Pdo number 1 .. x was ok" Name="TxAdditionalPDO.dRetCode"/>
		END_VAR;
				//! <Function Comment="Convert received Pdo to internal&#13;&#10;data structure (for example server)&#13;&#10;" Name="ConvertPdo1"/>
	FUNCTION VIRTUAL GLOBAL ConvertPdo1;
				//! <Function Comment="Convert received Pdo to internal&#13;&#10;data structure (for example server)" Name="ConvertPdo2"/>
	FUNCTION VIRTUAL GLOBAL ConvertPdo2;
				//! <Function Comment="Convert received Pdo to internal&#13;&#10;data structure (for example server)" Name="ConvertPdo3"/>
	FUNCTION VIRTUAL GLOBAL ConvertPdo3;
				//! <Function Comment="Convert received Pdo to internal&#13;&#10;data structure (for example server)&#13;&#10;" Name="ConvertPdo4"/>
	FUNCTION VIRTUAL GLOBAL ConvertPdo4;
				//! <Function Comment="Convert received additional Pdo to internal&#13;&#10;data structure (for example server)&#13;&#10;" Name="ConvertAdditionalPDO"/>
	FUNCTION VIRTUAL GLOBAL ConvertAdditionalPDO
		VAR_INPUT
			uiPDONrb 	: UINT;			//! <Variable Comment="Pdo number of received Pdo. Number 1 to 4 are for default Pdo. &#13;&#10;The numbers are in the order in which they were created at methode AddCanObjects()." Name="ConvertAdditionalPDO.uiPDONrb"/>
			hiObjNbr 	: HINT;			//! <Variable Comment="Objectnumber of the received Pdo." Name="ConvertAdditionalPDO.hiObjNbr"/>
			usLength 	: USINT;			//! <Variable Comment="Length of the received data (0-8 byte)." Name="ConvertAdditionalPDO.usLength"/>
			aCanData 	: t_a_CanData;			//! <Variable Comment="Contains the received Pdo data." Name="ConvertAdditionalPDO.aCanData"/>
		END_VAR;
				//! <Function Comment="Send Pdo to device&#13;&#10;" Name="TransmitPdo1"/>
	FUNCTION VIRTUAL GLOBAL TransmitPdo1;
				//! <Function Comment="Send Pdo to device&#13;&#10;" Name="TransmitPdo2"/>
	FUNCTION VIRTUAL GLOBAL TransmitPdo2;
				//! <Function Comment="Send Pdo to device&#13;&#10;" Name="TransmitPdo3"/>
	FUNCTION VIRTUAL GLOBAL TransmitPdo3;
				//! <Function Comment="Send Pdo to device" Name="TransmitPdo4"/>
	FUNCTION VIRTUAL GLOBAL TransmitPdo4;
				//! <Function Comment="Send additonal Pdo&apos;s to CanOpen device." Name="TransmitAdditionalPDO"/>
	FUNCTION VIRTUAL GLOBAL TransmitAdditionalPDO
		VAR_INPUT
			uiPDONrb 	: UINT;			//! <Variable Comment="Pdo number of transmit Pdo. Number 1 to 4 are for default Pdo. &#13;&#10;The numbers are in the order in which they were created at methode AddCanObjects()." Name="TransmitAdditionalPDO.uiPDONrb"/>
			hiObjNbr 	: HINT;			//! <Variable Comment="objectnumber of transmit Pdo.&#13;&#10;If this parameter is should used the Pdo number must be 0." Name="TransmitAdditionalPDO.hiObjNbr"/>
			paCanData 	: ^t_a_CanData := NIL;			//! <Variable Comment="pointer to the can transmit data (8byte)" Name="TransmitAdditionalPDO.paCanData"/>
		END_VAR
		VAR_OUTPUT
			dRetcode 	: DINT;			//! <Variable Comment="Returnvalue of transmit function.&#13;&#10;0 .. Pdo sending failed (not existing)&#13;&#10;1 - x .. sending of Pdo number 1 .. x was ok" Name="TransmitAdditionalPDO.dRetcode"/>
		END_VAR;
				//! <Function Comment="Overload this function to change Pdo and sdo settings&#13;&#10;The Place is added automatically.&#13;&#10;Rx SDO (default: 0x580 + Place)&#13;&#10;Tx SDO (default: 0x600 + Place)&#13;&#10;NG (default: 0x700 + Place)&#13;&#10;EMCY (default: 0x80 + Place)&#13;&#10;SDO RW Error (default: 0x80)&#13;&#10;and the settings for Node Guarding, Producer Heartbeat, PLC Consumer Heartbeat" Name="GetPdoSettings"/>
	FUNCTION VIRTUAL GLOBAL GetPdoSettings;
				//! <Function Comment="Overload this function to set some application&#13;&#10;specific parameter during initialization&#13;&#10;" Name="UserSettings"/>
	FUNCTION VIRTUAL GLOBAL UserSettings
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="return code of function&#13;&#10;0 .. UserSettings busy&#13;&#10;1 .. UserSettings ready" Name="UserSettings.retcode"/>
		END_VAR;
				//! <Function Comment="Check Rx Timeout&#13;&#10;" Name="CheckRxPdo"/>
	FUNCTION VIRTUAL CheckRxPdo
		VAR_OUTPUT
			dRetCode 	: DINT;			//! <Variable Comment="Return value of function.&#13;&#10; 1 .. check of rx Pdo is deactivated&#13;&#10; 0 .. no timeout occured or check rx Pdo is not activated&#13;&#10;-1 to -x .. timeout on rx Pdo with number of dRetCode occured. Only the last number is displayed where a timeout occurred." Name="CheckRxPdo.dRetCode"/>
		END_VAR;
				//! <Function Comment="Get State of asyncrounous communication&#13;&#10;" Name="GetAsyncState"/>
	FUNCTION VIRTUAL GetAsyncState
		VAR_INPUT
			Handle 	: ^DINT;			//! <Variable Comment="get actual sdo handle on given pointer." Name="GetAsyncState.Handle"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: iprStates;			//! <Variable Comment="Return Code of function as ipr state." Name="GetAsyncState.retcode"/>
		END_VAR;
				//! <Function Comment="This function prepares the sending of sdo.&#13;&#10;" Name="AsyncCmd"/>
	FUNCTION VIRTUAL AsyncCmd
		VAR_INPUT
			Index 	: INT;			//! <Variable Comment="Index of SDO object as 2 byte value." Name="AsyncCmd.Index"/>
			SubIndex 	: SINT;			//! <Variable Comment="Subindex of SDO object as 1 byte value." Name="AsyncCmd.SubIndex"/>
			Data 	: DINT;			//! <Variable Comment="Data of SDO object as 4 byte value." Name="AsyncCmd.Data"/>
			RW 	: BOOL;			//! <Variable Comment="Select Read or Write SDO.&#13;&#10;0 .. Read SDO&#13;&#10;1 .. Write SDO" Name="AsyncCmd.RW"/>
			Len 	: USINT;			//! <Variable Comment="Length of SDO Data with range from 0 to 4 byte." Name="AsyncCmd.Len"/>
		END_VAR
		VAR_OUTPUT
			RetCode 	: DINT;			//! <Variable Comment="Return code of function.&#13;&#10;0 .. ok&#13;&#10;-1 .. length is more then 4 byte&#13;&#10;-100 .. there is no sdo object to process&#13;&#10;-101 .. AsynState is not READY&#13;&#10;all other negatives .. error return code from SendSdo() function. " Name="AsyncCmd.RetCode"/>
		END_VAR;
				//! <Function Comment="Get data of asynchronous command&#13;&#10;" Name="GetAsyncData"/>
	FUNCTION VIRTUAL GetAsyncData
		VAR_INPUT
			Handle 	: DINT;			//! <Variable Comment="Actual Used SDO handle." Name="GetAsyncData.Handle"/>
			pBuffer 	: ^HSINT;			//! <Variable Comment="Pointer in which the sdo data is copied." Name="GetAsyncData.pBuffer"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="Return Code with sdo data." Name="GetAsyncData.retcode"/>
		END_VAR;
				//! <Function Comment="Adding CAN-objects" Name="AddCanObjects"/>
	FUNCTION VIRTUAL GLOBAL AddCanObjects;
				//! <Function Comment="Main function to set the node infos.&#13;&#10;Pdo, SDO, Heartbeat, GuardTime, ... etc." Name="ObjectInit"/>
	FUNCTION VIRTUAL GLOBAL ObjectInit;
				//! <Function Comment="Method called from _CanOpenSDOBase to initialise the SDO object" Name="SetSDOobjData"/>
	FUNCTION GLOBAL SetSDOobjData
		VAR_INPUT
			Active 	: BOOL;			//! <Variable Comment="Set sdo active or inactive.&#13;&#10;0 .. inactive&#13;&#10;1 .. active&#13;&#10;" Name="SetSDOobjData.Active"/>
			Index 	: INT;			//! <Variable Comment="Index of sdo object (2byte)." Name="SetSDOobjData.Index"/>
			SubIndex 	: SINT;			//! <Variable Comment="Subindex of sdo object (1byte)" Name="SetSDOobjData.SubIndex"/>
			Data 	: DINT;			//! <Variable Comment="Data of sdo object (max 4Byte)&#13;&#10;The data is only needed for write sdo." Name="SetSDOobjData.Data"/>
			RW 	: BOOL;			//! <Variable Comment="Read or write sdo&#13;&#10;0 .. read&#13;&#10;1 .. write" Name="SetSDOobjData.RW"/>
			Len 	: USINT;			//! <Variable Comment="Datalength of write sdo, max 4 byte." Name="SetSDOobjData.Len"/>
			pThis 	: ^void;			//! <Variable Comment="this pointer to logon object" Name="SetSDOobjData.pThis"/>
			pCallBack 	: ^void;			//! <Variable Comment="pointer to callback method for receiving of sdo data." Name="SetSDOobjData.pCallBack"/>
		END_VAR
		VAR_OUTPUT
			Retcode 	: INT;			//! <Variable Comment="returncode of function&#13;&#10;&gt;0 .. number of added sdo&#13;&#10; -1 .. adding of sdo failed" Name="SetSDOobjData.Retcode"/>
		END_VAR;
				//! <Function Comment="Function for external sdo handling." Name="ReadWriteUserSDO"/>
	FUNCTION VIRTUAL ReadWriteUserSDO;
				//! <Function Comment="Method called from _CanOpenSDOBase to change data on the SDO-object" Name="ChangeSDOobjData"/>
	FUNCTION GLOBAL ChangeSDOobjData
		VAR_INPUT
			NumberSDO 	: INT;			//! <Variable Comment="Number of the sdo which should be changed. The number is the return value of SetSDOobjData() method." Name="ChangeSDOobjData.NumberSDO"/>
			Active 	: BOOL;			//! <Variable Comment="Set sdo active or inactive.&#13;&#10;0 .. inactive&#13;&#10;1 .. active&#13;&#10;" Name="ChangeSDOobjData.Active"/>
			Index 	: INT;			//! <Variable Comment="Index of sdo object (2byte)" Name="ChangeSDOobjData.Index"/>
			SubIndex 	: SINT;			//! <Variable Comment="Subindex of sdo object (1byte)." Name="ChangeSDOobjData.SubIndex"/>
			Data 	: DINT;			//! <Variable Comment="Data of sdo object (max 4Byte)&#13;&#10;The data is only needed for write sdo." Name="ChangeSDOobjData.Data"/>
			RW 	: BOOL;			//! <Variable Comment="Read or write sdo&#13;&#10;0 .. read&#13;&#10;1 .. write" Name="ChangeSDOobjData.RW"/>
			Len 	: USINT;			//! <Variable Comment="Datalength of write sdo, max 4 byte." Name="ChangeSDOobjData.Len"/>
			bOnlyChangeActive 	: BOOL := FALSE;			//! <Variable Comment="Is used to change only the active Flag.&#13;&#10;0 .. all sdo parameters are changed (default)&#13;&#10;1 .. only the active flag is changed" Name="ChangeSDOobjData.bOnlyChangeActive"/>
		END_VAR
		VAR_OUTPUT
			Retcode 	: INT;			//! <Variable Comment="returncode of function&#13;&#10; 0 .. ok&#13;&#10;-1 .. sdo not found" Name="ChangeSDOobjData.Retcode"/>
		END_VAR;
				//! <Function Comment="Callback function for external sdo objects." Name="CallBack"/>
	FUNCTION CallBack
		VAR_INPUT
			udTxCount 	: UDINT;			//! <Variable Comment="actual tx counter" Name="CallBack.udTxCount"/>
			udRxCount 	: UDINT;			//! <Variable Comment="actual rx counter" Name="CallBack.udRxCount"/>
			udErrorCount 	: UDINT;			//! <Variable Comment="actual error counter" Name="CallBack.udErrorCount"/>
			dData 	: DINT;			//! <Variable Comment="Contains the error information or the read data of sdo." Name="CallBack.dData"/>
		END_VAR;
				//! <Function Comment="Methode for adding additional TPdo&apos;s." Name="TPDOAdditionalObject"/>
	FUNCTION TPDOAdditionalObject
		VAR_INPUT
			pPDOElement 	: ^_PDOSETTINGS;			//! <Variable Comment="pointer to additional Pdo element data. &#13;&#10;The Pdo&apos;s are added according to the call sequence." Name="TPDOAdditionalObject.pPDOElement"/>
		END_VAR
		VAR_OUTPUT
			dRetCode 	: DINT;			//! <Variable Comment="Returncode of function.&#13;&#10; 5 - x .. Number of Pdo (1-4 are default Pdo&apos;s), numbered according to the call sequence.&#13;&#10; 0 .. maximum of Pdo objects reached&#13;&#10;-1 .. error for allocate memory&#13;&#10;&#13;&#10;TPdoAdditional ....... Pdo 5&#13;&#10;  -&gt; pNextPDO ......... Pdo 6&#13;&#10;  --&gt; pNextPDO ....... Pdo 7&#13;&#10;  ---&gt; pNextPDO ..... Pdo 8 ..." Name="TPDOAdditionalObject.dRetCode"/>
		END_VAR;
				//! <Function Comment="Methode for adding additional RPdo&apos;s." Name="RPDOAdditionalObject"/>
	FUNCTION RPDOAdditionalObject
		VAR_INPUT
			pPDOElement 	: ^_PDOSETTINGS;			//! <Variable Comment="pointer to additional Pdo element data. &#13;&#10;The Pdo&apos;s are added according to the call sequence." Name="RPDOAdditionalObject.pPDOElement"/>
		END_VAR
		VAR_OUTPUT
			dRetCode 	: DINT;			//! <Variable Comment="Returncode of function.&#13;&#10; 5 - x .. Number of Pdo (1-4 are default Pdo&apos;s), numbered according to the call sequence.&#13;&#10; 0 .. maximum of Pdo objects reached&#13;&#10;-1 .. error for allocate memory&#13;&#10;&#13;&#10;RPdoAdditional ....... Pdo 5&#13;&#10;  -&gt; pNextPDO ......... Pdo 6&#13;&#10;  --&gt; pNextPDO ....... Pdo 7&#13;&#10;  ---&gt; pNextPDO ..... Pdo 8 ..." Name="RPDOAdditionalObject.dRetCode"/>
		END_VAR;
				//! <Function Comment="This function can be called to get the actual SDO info." Name="GetComSDOData"/>
	FUNCTION GLOBAL GetComSDOData
		VAR_OUTPUT
			ComSDOData 	: _ComSDO;			//! <Variable Comment="Struct on which the SDO data is saved." Name="GetComSDOData.ComSDOData"/>
		END_VAR;
				//! <Function Comment="Main function which handles the CAN-Communication" Name="CanControl"/>
	FUNCTION VIRTUAL GLOBAL CanControl;
				//! <Function Comment="Change the Operationmode of the class" Name="SetOpMode"/>
	FUNCTION VIRTUAL GLOBAL SetOpMode
		VAR_INPUT
			opModeSet 	: _CAN_OPMODE_INT;			//! <Variable Comment="Operationmode to be changed to" Name="SetOpMode.opModeSet"/>
		END_VAR
		VAR_OUTPUT
			retCode 	: DINT;			//! <Variable Comment="0 ... mode was set&#13;&#10;-1 .. mode was not set" Name="SetOpMode.retCode"/>
		END_VAR;
				//! <Function Comment="Reinitializes the object (sending the settings by SDO to the device again)" Name="ReInitObject"/>
	FUNCTION VIRTUAL GLOBAL ReInitObject;
				//! <Function Comment="Resets the Communication in case of an Error" Name="ResetComm"/>
	FUNCTION VIRTUAL GLOBAL ResetComm;
				//! <Function Comment="This function is needed to check if the object is done with its initialization and ready to start the cyclic CAN-communication." Name="CheckInitDone"/>
	FUNCTION VIRTUAL GLOBAL CheckInitDone
		VAR_OUTPUT
			RetValue 	: BOOL;			//! <Variable Comment="FALSE ... Object have not finished its initialization&#13;&#10;TRUE  ... Object have finished its initalization" Name="CheckInitDone.RetValue"/>
		END_VAR;
				//! <Function Comment="Method for getting Nodeguarding lifetime (guardtime x lifetimefactor) or Hearbeat time if one of them are defined" Name="GetNGorHBtime"/>
	FUNCTION VIRTUAL GLOBAL GetNGorHBtime
		VAR_OUTPUT
			udTime 	: UDINT;			//! <Variable Comment="Nodeguarding lifetime or heartbeat-time. If nodeguarding and heartbeat are not used 0 is returned" Name="GetNGorHBtime.udTime"/>
		END_VAR;
				//! <Function Comment="This function initiate the sending of Pdo&apos;s if the send flag is set.&#13;&#10;SendMarkTpdo1-4 or for additional Pdo&apos;s sPDOAdditionalVars.TxVars[4-x].bSendFlag" Name="SendAllPDOs"/>
	FUNCTION VIRTUAL SendAllPDOs;
				//! <Function Comment="Methode to set default values for communication parameter of Pdo:&#13;&#10;active = true (add can object and use it internal)&#13;&#10;inactive = false (if true no initialization data is send to node)&#13;&#10;HighestSubnumber = Deactivated (-1)  subindex 0&#13;&#10;Deactivate = Activated (iAddressSetting)  subindex 1&#13;&#10;Transmissiontype = Activated (iAddressSetting) subindex 2&#13;&#10;Inhibittime = Deactivated (-1)   subindex 3&#13;&#10;PdoChoice = Deactivated (-1)   (no default communication para)&#13;&#10;EventTime = Deactivated (-1)   subindex 5&#13;&#10;Activate = Activated (iAddressSetting)  subindex 1" Name="DefaultPDOSetting"/>
	FUNCTION VIRTUAL DefaultPDOSetting
		VAR_INPUT
			pPdoElement 	: ^_PDOSETTINGS;			//! <Variable Comment="pointer to a Pdo element" Name="DefaultPDOSetting.pPdoElement"/>
			iAddressSetting 	: INT;			//! <Variable Comment="Communication parameter address for RPDO or TPDO." Name="DefaultPDOSetting.iAddressSetting"/>
			iCobId 	: INT := 0x00;			//! <Variable Comment="Set the COB-ID of Pdo for deactivate and activate index.&#13;&#10;The place is added automatically." Name="DefaultPDOSetting.iCobId"/>
		END_VAR;
				//! <Function Comment="Methode to deactivate Pdo&#13;&#10;active = false&#13;&#10;inactive = false&#13;&#10;Deactivate =  Deactivated (-1)&#13;&#10;Transmissiontype =  Deactivated (-1)&#13;&#10;Inhibittime = Deactivated (-1)&#13;&#10;PdoChoice = Deactivated (-1)&#13;&#10;Activate = Deactivated (-1)&#13;&#10;ActiveNbrOfMappings = -1&#13;&#10;MappingPara[0-7] = Deactivated (-1)" Name="DeactivatePDO"/>
	FUNCTION DeactivatePDO
		VAR_INPUT
			pPdoElement 	: ^_PDOSETTINGS;			//! <Variable Comment="Pointer to the Pdo Element which should be deactivated." Name="DeactivatePDO.pPdoElement"/>
		END_VAR;
				//! <Function Comment="Function for asynchrone sdo handling." Name="AsyncSDOHandling"/>
	FUNCTION AsyncSDOHandling
		VAR_INPUT
			pHandle 	: ^DINT;			//! <Variable Comment="active sdo handle." Name="AsyncSDOHandling.pHandle"/>
			iIndex 	: INT;			//! <Variable Comment="Index of SDO object as 2 byte value." Name="AsyncSDOHandling.iIndex"/>
			siSubIndex 	: SINT;			//! <Variable Comment="Subindex of SDO object as 1 byte value." Name="AsyncSDOHandling.siSubIndex"/>
			dData 	: DINT;			//! <Variable Comment="Data of SDO object as 4 byte value." Name="AsyncSDOHandling.dData"/>
			bRW 	: BOOL;			//! <Variable Comment="Select Read or Write SDO.&#13;&#10;0 .. Read SDO&#13;&#10;1 .. Write SDO" Name="AsyncSDOHandling.bRW"/>
			usLength 	: USINT;			//! <Variable Comment="Length of SDO Data with range from 0 to 4 byte." Name="AsyncSDOHandling.usLength"/>
			pAsyncData 	: ^DINT;			//! <Variable Comment="pointer on which the sdo data or the error information is copied." Name="AsyncSDOHandling.pAsyncData"/>
		END_VAR
		VAR_OUTPUT
			dRetCode 	: iprStates;			//! <Variable Comment="Return Code of function as ipr state." Name="AsyncSDOHandling.dRetCode"/>
		END_VAR;
				//! <Function Comment="Reset Pdo data receive Flag." Name="ResetReceiveFlag"/>
	FUNCTION ResetReceiveFlag;
				//! <Function Comment="Function to convert hex string to a HDINT value." Name="ConvertHexStringToHDINT"/>
	FUNCTION ConvertHexStringToHDINT
		VAR_INPUT
			pHexString 	: ^CHAR;			//! <Variable Comment="pointer which contains the string in hex format." Name="ConvertHexStringToHDINT.pHexString"/>
		END_VAR
		VAR_OUTPUT
			hdOutputValue 	: HDINT;			//! <Variable Comment="Hexadecimal output value.&#13;&#10;&#13;&#10;16#F8000010 .. wrong formatted hex string." Name="ConvertHexStringToHDINT.hdOutputValue"/>
		END_VAR;
				//! <Function Comment="This function opens a xdc file and copy the data. It&apos;s also used to extract the Pdo informations from file." Name="XDCHandling"/>
	FUNCTION XDCHandling
		VAR_INPUT
			pStringFile 	: ^CHAR;			//! <Variable Comment="path + pathname to xdc file&#13;&#10;(c:\testfile.xdc)" Name="XDCHandling.pStringFile"/>
		END_VAR
		VAR_OUTPUT
			dRetCode 	: DINT;			//! <Variable Comment="0 .. ok&#13;&#10;-1 .. read of xdc file was not successful&#13;&#10;-2 .. parsing of xdc data failed&#13;&#10;-3 .. problem occurred while get Pdo infos from xdc data - xdc data not valid&#13;&#10;-4 .. failed to get xdc file. possible reasons are: add file for parsing failed,&#13;&#10;allocate memory or read file length failed, file handle is not valid" Name="XDCHandling.dRetCode"/>
		END_VAR;
				//! <Function Comment="This function is needed to extract the infos from xdc structure." Name="XDCGetPdoInfo"/>
	FUNCTION XDCGetPdoInfo
		VAR_OUTPUT
			dRetCode 	: iprStates;			//! <Variable Comment="returncode of function&#13;&#10;Ready .. reading of xdc data is finished&#13;&#10;Busy  .. reading of xdc data in progress" Name="XDCGetPdoInfo.dRetCode"/>
		END_VAR;
				//! <Function Comment="This function is needed to get the value to a corresponding name." Name="XDCGetNameValue"/>
	FUNCTION XDCGetNameValue
		VAR_INPUT
			pStringName 	: ^CHAR;			//! <Variable Comment="pointer to the string which contains the name for search" Name="XDCGetNameValue.pStringName"/>
			pAttributeList 	: ^_XML_ATTRIBUTE_LIST;			//! <Variable Comment="pointer to the element in which the name should be searched" Name="XDCGetNameValue.pAttributeList"/>
			pudValue 	: ^UDINT := NIL;			//! <Variable Comment="returns the value corresponding to the searched name." Name="XDCGetNameValue.pudValue"/>
			pStringValue 	: ^CHAR := NIL;			//! <Variable Comment="returns the value as string corresponding to the searched name." Name="XDCGetNameValue.pStringValue"/>
			udStrLength 	: UDINT := CO_XDC_MAX_STRING_LENGTH;			//! <Variable Comment="determines the allowed string length of the pointer pStringValue" Name="XDCGetNameValue.udStrLength"/>
			dDataType 	: DINT := CO_XDC_VALUES_TYPE_UNKNOWN;			//! <Variable Comment="given data type to read out from xml element.&#13;&#10;&#13;&#10;CO_XDC_VALUES_TYPE_UNKNOWN    0&#13;&#10;CO_XDC_VALUES_TYPE_DEC        5&#13;&#10;CO_XDC_VALUES_TYPE_HEX        7&#13;&#10;CO_XDC_VALUES_TYPE_STR_BOOL   1001&#13;&#10;" Name="XDCGetNameValue.dDataType"/>
		END_VAR
		VAR_OUTPUT
			dRetCode 	: DINT;			//! <Variable Comment="0 .. data is ok&#13;&#10;-1 .. value for name not found" Name="XDCGetNameValue.dRetCode"/>
		END_VAR;
				//! <Function Comment="Function to get Pdo info from xdc canopen element." Name="XDCGetPdoCanOpenElement"/>
	FUNCTION XDCGetPdoCanOpenElement
		VAR_INPUT
			hdSearchIndex 	: HDINT;			//! <Variable Comment="Index to search at xdc file." Name="XDCGetPdoCanOpenElement.hdSearchIndex"/>
			pCanElement 	: ^t_s_PDOElement;			//! <Variable Comment="Pointer on which the can element info from xdc file is copied." Name="XDCGetPdoCanOpenElement.pCanElement"/>
		END_VAR
		VAR_OUTPUT
			dRetcode 	: DINT;			//! <Variable Comment="Return code of function.&#13;&#10; 0 .. ok&#13;&#10; 1 .. no info found for the given hdSearchIndex&#13;&#10;-1 .. last entry for this can element is reached" Name="XDCGetPdoCanOpenElement.dRetcode"/>
		END_VAR;
				//! <Function Comment="Function to get Pdo network managment info from xdc canopen element." Name="XDCGetNetworkManagementInfo"/>
	FUNCTION XDCGetNetworkManagementInfo;
				//! <Function Comment="This function writes the Pdo infos from xdc file into the RPdo and TPdo data structure." Name="XDCSetPdoData"/>
	FUNCTION XDCSetPdoData;
				//! <Function Comment="This function writes the Pdo infos from xdc file into the RPdo and TPdo data structure." Name="XDCSetRPdoTPdoData"/>
	FUNCTION XDCSetRPdoTPdoData
		VAR_INPUT
			pActPdoEntry 	: ^_PDOSETTINGS;			//! <Variable Comment="Pointer to first Pdo info entry." Name="XDCSetRPdoTPdoData.pActPdoEntry"/>
			pXDCActPdoEntry 	: ^t_s_PDOStruct;			//! <Variable Comment="Pointer to act Pdo info which is read out from xdc file." Name="XDCSetRPdoTPdoData.pXDCActPdoEntry"/>
		END_VAR
		VAR_OUTPUT
			dRetCode 	: DINT;			//! <Variable Comment="Return value of function.&#13;&#10; 0 .. ok&#13;&#10;-1 .. too much pdo objects" Name="XDCSetRPdoTPdoData.dRetCode"/>
		END_VAR;
				//! <Function Comment="This function reads which indexes are available at xdc file." Name="XDCGetCANOpenObjectList"/>
	FUNCTION XDCGetCANOpenObjectList;
				//! <Function Comment="This function checks if the passed index exists. &#13;&#10;If not, the passed index is automatically incremented up to hdMaxIndex. " Name="XDCCheckIndexExisting"/>
	FUNCTION XDCCheckIndexExisting
		VAR_INPUT
			phdActIndex 	: ^HDINT;			//! <Variable Comment="Actual searched Index." Name="XDCCheckIndexExisting.phdActIndex"/>
			hdMaxIndex 	: HDINT := 0x0000;			//! <Variable Comment="Next index to read from xdc file." Name="XDCCheckIndexExisting.hdMaxIndex"/>
		END_VAR
		VAR_OUTPUT
			dRetCode 	: DINT;			//! <Variable Comment="Return value of function.&#13;&#10; 0 .. ok&#13;&#10;-1 .. no index found" Name="XDCCheckIndexExisting.dRetCode"/>
		END_VAR;
				//! <Function Comment="This function converts the access type string to an enum value." Name="XDCAccessTypeToDec"/>
	FUNCTION XDCAccessTypeToDec
		VAR_INPUT
			pstrAccessType 	: ^CHAR;			//! <Variable Comment="Pointer to string which contains the access type." Name="XDCAccessTypeToDec.pstrAccessType"/>
		END_VAR
		VAR_OUTPUT
			eAccessType 	: t_e_AccessTypeXDC;			//! <Variable Comment="Return value of function as enum." Name="XDCAccessTypeToDec.eAccessType"/>
		END_VAR;
				//! <Function Comment="Sets segment handling variables in a way that the segment transfer is stopped" Name="Stop_SegmentTransfer"/>
	FUNCTION VIRTUAL Stop_SegmentTransfer;
				//! <Function Comment="Sends init message for segment upload&#13;&#10;return value:&#13;&#10;0 ... OK&#13;&#10;!= 0 ... NOK" Name="InitiateSegmentUpload"/>
	FUNCTION VIRTUAL InitiateSegmentUpload
		VAR_OUTPUT
			retval 	: DINT;			//! <Variable Comment="0 ... OK&#13;&#10;!= 0 ... NOK" Name="InitiateSegmentUpload.retval"/>
		END_VAR;
				//! <Function Comment="Handels CANOpen messages which are received from the CANOpen module" Name="CANReceiveSegmentTransfer"/>
	FUNCTION VIRTUAL CANReceiveSegmentTransfer;
				//! <Function Comment="Handels messages which sre sent to the CANOpen module" Name="HandleSegmentTransferCommunication"/>
	FUNCTION VIRTUAL HandleSegmentTransferCommunication;
				//! <Function Comment="Prepares the init message for a CANOpen upload segment transfer&#13;&#10;Parameter:&#13;&#10;pSDOData ... pointer to the SDO data to upload&#13;&#10;Index ... index in the Object Dictionary&#13;&#10;SubIndex ... subindex in the Object Dictionary&#13;&#10;Return:&#13;&#10;0 ... OK&#13;&#10;-2 ... pointer to the SDO data is not valid" Name="PrepareSDOUploadInitiate"/>
	FUNCTION VIRTUAL PrepareSDOUploadInitiate
		VAR_INPUT
			pSDOData 	: ^USINT;			//! <Variable Comment="pSDOData ... pointer to the SDO data to upload" Name="PrepareSDOUploadInitiate.pSDOData"/>
			Index 	: HINT;			//! <Variable Comment="Index ... index in the Object Dictionary" Name="PrepareSDOUploadInitiate.Index"/>
			SubIndex 	: HSINT;			//! <Variable Comment="SubIndex ... subindex in the Object Dictionary" Name="PrepareSDOUploadInitiate.SubIndex"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="Return:&#13;&#10;0 ... OK&#13;&#10;-2 ... pointer to the SDO data is not valid" Name="PrepareSDOUploadInitiate.retcode"/>
		END_VAR;
				//! <Function Comment="Prepares the init message for a CANOpen segment download&#13;&#10;Parameters:&#13;&#10;pSDOData ... pointer to the SDO data&#13;&#10;pSendData ...  pointer to the data which shall be downloaded&#13;&#10;usDataLen ... length of data to download&#13;&#10;hIndex ... index in the Object Dictionary&#13;&#10;hsSubIndex ... subindex in the Object Dictionary&#13;&#10;ExpeditedTransfer ... 1: it is an expetidet transfer, 0: no expedited transfer&#13;&#10;Return:&#13;&#10;0 ... OK&#13;&#10;-1 ... length of data to be downloaded is larger than allowed size&#13;&#10;-2 ... pointer for SDO data or data pointer invalid" Name="PrepareSDODownloadInitiate"/>
	FUNCTION VIRTUAL PrepareSDODownloadInitiate
		VAR_INPUT
			pSDOData 	: ^USINT;			//! <Variable Comment="pSDOData ... pointer to the SDO data" Name="PrepareSDODownloadInitiate.pSDOData"/>
			pSendData 	: ^USINT;			//! <Variable Comment="pSendData ...  pointer to the data which shall be downloaded&#13;&#10;" Name="PrepareSDODownloadInitiate.pSendData"/>
			usDataLen 	: USINT;			//! <Variable Comment="usDataLen ... length of data to download&#13;&#10;" Name="PrepareSDODownloadInitiate.usDataLen"/>
			hIndex 	: HINT;			//! <Variable Comment="hIndex ... index in the Object Dictionary&#13;&#10;" Name="PrepareSDODownloadInitiate.hIndex"/>
			hsSubIndex 	: HSINT;			//! <Variable Comment="hsSubIndex ... subindex in the Object Dictionary&#13;&#10;" Name="PrepareSDODownloadInitiate.hsSubIndex"/>
			ExpeditedTransfer 	: BOOL;			//! <Variable Comment="ExpeditedTransfer ... 1: it is an expetidet transfer, 0: no expedited transfer&#13;&#10;" Name="PrepareSDODownloadInitiate.ExpeditedTransfer"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="Return:&#13;&#10;0 ... OK&#13;&#10;-1 ... length of data to be downloaded is larger than allowed size&#13;&#10;-2 ... pointer for SDO data or data pointer invalid" Name="PrepareSDODownloadInitiate.retcode"/>
		END_VAR;
				//! <Function Comment="Prepares the init message for CANOpen upload segment transfer&#13;&#10;Parameters:&#13;&#10;pSDOData ... pointer to the SDO data&#13;&#10;pToggleBit ... pointer to the toggle bit&#13;&#10;Return:&#13;&#10;0 ... OK&#13;&#10;-2 ... SDO data pointer or toggle bit pointer is invalid&#13;&#10;" Name="PrepareSDOUploadSegmentTransfer"/>
	FUNCTION VIRTUAL PrepareSDOUploadSegmentTransfer
		VAR_INPUT
			pSDOData 	: ^USINT;			//! <Variable Comment="pSDOData ... pointer to the SDO data" Name="PrepareSDOUploadSegmentTransfer.pSDOData"/>
			pToggleBit 	: ^BOOL;			//! <Variable Comment="pToggleBit ... pointer to the toggle bit&#13;&#10;" Name="PrepareSDOUploadSegmentTransfer.pToggleBit"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="Return:&#13;&#10;0 ... OK&#13;&#10;-2 ... SDO data pointer or toggle bit pointer is invalid&#13;&#10;" Name="PrepareSDOUploadSegmentTransfer.retcode"/>
		END_VAR;
				//! <Function Comment="Prepares the message for the CANOpen download segment transfer&#13;&#10;Parameters:&#13;&#10;pSDOData ... SDO data pointer&#13;&#10;pSendData ... data pointer to the download data&#13;&#10;DataLen ... number of bytes to be downloaded&#13;&#10;pToggleBit ... pointer to the current to&#13;&#10;LastPacket ... 1: this is the last packet&#13;&#10;Return:&#13;&#10;0 ... OK&#13;&#10;-1 ... length of data to long&#13;&#10;-2 ... SDO data pointer or download data pointer or toggle bit pointer invalid&#13;&#10;" Name="PrepareSDODownloadSegmentTransfer"/>
	FUNCTION VIRTUAL PrepareSDODownloadSegmentTransfer
		VAR_INPUT
			pSDOData 	: ^USINT;			//! <Variable Comment="pSDOData ... SDO data pointer&#13;&#10;" Name="PrepareSDODownloadSegmentTransfer.pSDOData"/>
			pSendData 	: ^USINT;			//! <Variable Comment="pSendData ... data pointer to the download data&#13;&#10;" Name="PrepareSDODownloadSegmentTransfer.pSendData"/>
			DataLen 	: USINT;			//! <Variable Comment="DataLen ... number of bytes to be downloaded&#13;&#10;" Name="PrepareSDODownloadSegmentTransfer.DataLen"/>
			pToggleBit 	: ^BOOL;			//! <Variable Comment="pToggleBit ... pointer to the current to&#13;&#10;" Name="PrepareSDODownloadSegmentTransfer.pToggleBit"/>
			LastPacket 	: BOOL;			//! <Variable Comment="LastPacket ... 1: this is the last packet&#13;&#10;" Name="PrepareSDODownloadSegmentTransfer.LastPacket"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="Return:&#13;&#10;0 ... OK&#13;&#10;-1 ... length of data to long&#13;&#10;-2 ... SDO data pointer or download data pointer or toggle bit pointer invalid&#13;&#10;" Name="PrepareSDODownloadSegmentTransfer.retcode"/>
		END_VAR;
				//! <Function Comment="Starts an CANOpen upload segment transfer&#13;&#10;. First the CANOpen message for init of uplaod segment transfer is sent,&#13;&#10;. then segment transfer handling variables are set accordingly&#13;&#10;Return:&#13;&#10;0 ... OK&#13;&#10;!= 0: initiate message could not be sent OK" Name="StartSegUploadTransfer"/>
	FUNCTION VIRTUAL StartSegUploadTransfer
		VAR_OUTPUT
			retVal 	: DINT;			//! <Variable Comment="Return:&#13;&#10;0 ... OK&#13;&#10;!= 0: initiate message could not be sent OK" Name="StartSegUploadTransfer.retVal"/>
		END_VAR;
				//! <Function Comment="Starts a CAnOpen download segment transfer&#13;&#10;. segment transfer handling variables are sent accordingly&#13;&#10;Parameter:&#13;&#10;udLength ... number of bytes to be downloaded" Name="StartSegDownloadTransfer"/>
	FUNCTION VIRTUAL StartSegDownloadTransfer
		VAR_INPUT
			udLength 	: UDINT;			//! <Variable Comment="udLength ... number of bytes to be downloaded" Name="StartSegDownloadTransfer.udLength"/>
		END_VAR;
				//! <Function Comment="Transfers a CAN data object - Parameter:&#13;&#10;pData ... data pointer&#13;&#10;Length ... number of bytes to be sent&#13;&#10;ObjNr ... object number of SDO&#13;&#10;" Name="SendDataViaCAN"/>
	FUNCTION GLOBAL SendDataViaCAN
		VAR_INPUT
			pData 	: ^USINT;
			Length 	: USINT;
			ObjNr 	: INT;
		END_VAR
		VAR_OUTPUT
			retval 	: DINT;
		END_VAR;
				//! <Function Comment="Starts a CanOpen segment transfer - parameter:&#13;&#10;uiIndex ... index in the object dictionary&#13;&#10;usSubIndex ... sub index in the object dictionary&#13;&#10;pData ... data pointer of data to read / write&#13;&#10;udLength ... number of bytes to read / write&#13;&#10;bRW ... 0: read, 1: write" Name="StartSegmentTransfer"/>
	FUNCTION GLOBAL StartSegmentTransfer
		VAR_INPUT
			uiIndex 	: UINT;
			usSubIndex 	: USINT;
			pData 	: ^USINT;
			udLength 	: UDINT;
			bRW 	: DINT;			//! <Variable Comment="0 ... upload data&#13;&#10;1 ... download data&#13;&#10;" Name="StartSegmentTransfer.bRW"/>
		END_VAR;
				//! <Function Comment="Starts a CANOpen segment upload&#13;&#10;Parameter:&#13;&#10;uiIndexSegmentUploadModule ... index in Object Dictionary&#13;&#10;usSubindexSegmentUploadModule ... subindex in the Object Dictionary&#13;&#10;pUploadData ... pointer to the upload data&#13;&#10;udUploadLength ... number of bytes to be uploaded&#13;&#10;" Name="StartSegmentUpload"/>
	FUNCTION VIRTUAL StartSegmentUpload
		VAR_INPUT
			uiIndexSegmentUploadModule 	: UINT;			//! <Variable Comment="uiIndexSegmentUploadModule ... index in Object Dictionary&#13;&#10;" Name="StartSegmentUpload.uiIndexSegmentUploadModule"/>
			usSubindexSegmentUploadModule 	: USINT;			//! <Variable Comment="usSubindexSegmentUploadModule ... subindex in the Object Dictionary&#13;&#10;" Name="StartSegmentUpload.usSubindexSegmentUploadModule"/>
			pUploadData 	: ^USINT;			//! <Variable Comment="pUploadData ... pointer to the upload data&#13;&#10;" Name="StartSegmentUpload.pUploadData"/>
			udUploadLength 	: UDINT;			//! <Variable Comment="udUploadLength ... number of bytes to be uploaded&#13;&#10;" Name="StartSegmentUpload.udUploadLength"/>
		END_VAR;
				//! <Function Comment="Starts a CANOpen segment download&#13;&#10;uiIndexSegmentDownloadModule ... index in the Object Dictionary&#13;&#10;usSubindexSegmentDownloadModule ... subindex in the Object Dictionary&#13;&#10;pDownloadData ... pointer to the download data&#13;&#10;udDownloadLength ... number of bytes to be downloaded&#13;&#10;" Name="StartSegmentDownload"/>
	FUNCTION VIRTUAL StartSegmentDownload
		VAR_INPUT
			uiIndexSegmentDownloadModule 	: UINT;			//! <Variable Comment="uiIndexSegmentDownloadModule ... index in the Object Dictionary&#13;&#10;" Name="StartSegmentDownload.uiIndexSegmentDownloadModule"/>
			usSubindexSegmentDownloadModule 	: USINT;			//! <Variable Comment="usSubindexSegmentDownloadModule ... subindex in the Object Dictionary&#13;&#10;" Name="StartSegmentDownload.usSubindexSegmentDownloadModule"/>
			pDownloadData 	: ^USINT;			//! <Variable Comment="pDownloadData ... pointer to the download data&#13;&#10;" Name="StartSegmentDownload.pDownloadData"/>
			udDownloadLength 	: UDINT;			//! <Variable Comment="udDownloadLength ... number of bytes to be downloaded&#13;&#10;" Name="StartSegmentDownload.udDownloadLength"/>
		END_VAR;
				//! <Function Comment="Returns the current status of the CanOpen segment transfer:&#13;&#10;CO_SEGMENT_INACTIVE (0) ... no segment transfer is active&#13;&#10;CO_DOWNLOAD_SEGMENT_ACTIVE (1) ... a download segment transfer (read data from the module) is active&#13;&#10;CO_UPLOAD_SEGMENT_ACTIVE(2) ... an upload segment transfer (write data to the module) is active&#13;&#10;" Name="CheckStatusSegmentTransfer"/>
	FUNCTION GLOBAL CheckStatusSegmentTransfer
		VAR_OUTPUT
			retVal 	: USINT;
		END_VAR;
				//! <Function Comment="Capsules class variable for received SDO messages" Name="GetReceiveCounterSdo"/>
	FUNCTION GLOBAL GetReceiveCounterSdo
		VAR_OUTPUT
			retVal 	: UDINT;
		END_VAR;
				//! <Function Comment="Capsules the class variable for received data from the CANOpen module" Name="GetRxBufferSdo"/>
	FUNCTION GLOBAL GetRxBufferSdo
		VAR_OUTPUT
			retVal 	: ^HSINT;
		END_VAR;
				//! <Function Comment="This function is used to check if parameter of xdc file is writeable." Name="XDCCheckWriteable"/>
	FUNCTION XDCCheckWriteable
		VAR_INPUT
			eAccesMode 	: t_e_AccessTypeXDC;			//! <Variable Comment="Enum with access type of parameter." Name="XDCCheckWriteable.eAccesMode"/>
		END_VAR
		VAR_OUTPUT
			bWriteable 	: BOOL;			//! <Variable Comment="Return value of function.&#13;&#10;0 .. not writeable&#13;&#10;1 .. writeable" Name="XDCCheckWriteable.bWriteable"/>
		END_VAR;
				//! <Function Comment="Handels CanOpen segment up- and download&#13;&#10;. if there is a new CAN receive message the method for received CANOpen from the module is called&#13;&#10;. method for handling CANOpen messages to the module is called" Name="_Segment_Up_Download"/>
	FUNCTION _Segment_Up_Download;
				//! <Function Comment="This function is used to process new received NMT states from node." Name="NMTStateProcess"/>
	FUNCTION NMTStateProcess;
				//! <Function Comment="Method to get data from the choosen property." Name="GetProperty"/>
	FUNCTION VIRTUAL GetProperty
		VAR_INPUT
			udPropertyID 	: UDINT;			//! <Variable Comment="Property ID" Name="GetProperty.udPropertyID"/>
			usDatalength 	: USINT;			//! <Variable Comment="Datalength of property data as byte.&#13;&#10;Minimum value is 4 Byte." Name="GetProperty.usDatalength"/>
			pPropertyValue 	: pVoid;			//! <Variable Comment="Pointer to which the value from the Property ID is written." Name="GetProperty.pPropertyValue"/>
		END_VAR
		VAR_OUTPUT
			dRetCode 	: DINT;			//! <Variable Comment="return code of methode.&#13;&#10; 0 .. ok&#13;&#10;-1 .. property id is not available&#13;&#10;-2 .. property id is not readable&#13;&#10;-3 .. pointer is not valid&#13;&#10;-4 .. datalength is smaller then 4 byte&#13;&#10;-6 .. datalength is to small for available data" Name="GetProperty.dRetCode"/>
		END_VAR;
				//! <Function Comment="Method to set data to the choosen property." Name="SetProperty"/>
	FUNCTION VIRTUAL SetProperty
		VAR_INPUT
			udPropertyID 	: UDINT;			//! <Variable Comment="Property ID" Name="SetProperty.udPropertyID"/>
			usDatalength 	: USINT;			//! <Variable Comment="Datalength of property data as byte.&#13;&#10;Minimum value is 4 Byte." Name="SetProperty.usDatalength"/>
			pPropertyValue 	: pVoid;			//! <Variable Comment="Pointer from which the value of Property ID is written." Name="SetProperty.pPropertyValue"/>
		END_VAR
		VAR_OUTPUT
			dRetCode 	: DINT;			//! <Variable Comment="return code of methode.&#13;&#10; 0 .. ok&#13;&#10;-1 .. property id is not available&#13;&#10;-2 .. property id is not writeable&#13;&#10;-3 .. pointer is not valid&#13;&#10;-4 .. datalength is smaller then 4 byte&#13;&#10;-5 .. VOV is active - write of property is not possible&#13;&#10; " Name="SetProperty.dRetCode"/>
		END_VAR;
				//! <Function Comment="Function for further use of additional xdc canopen indexes." Name="XDCGetAdditionalIndexes"/>
	FUNCTION VIRTUAL XDCGetAdditionalIndexes;
				//! <Function Comment="Capsuled the class variable for TSdo object number (transmitted SDO)" Name="GetTSdoObjNr"/>
	FUNCTION GLOBAL GetTSdoObjNr
		VAR_OUTPUT
			retVal 	: INT;
		END_VAR;
				//! <Function Comment="Returns the current status of the CanOpen segment transfer:&#13;&#10;CO_SEGMENT_INACTIVE (0) ... no segment transfer is active&#13;&#10;CO_DOWNLOAD_SEGMENT_ACTIVE (1) ... a download segment transfer (read data from the module) is active&#13;&#10;CO_UPLOAD_SEGMENT_ACTIVE(2) ... an upload segment transfer (write data to the module) is active&#13;&#10;" Name="CheckResultSegmentTransfer"/>
	FUNCTION GLOBAL CheckResultSegmentTransfer
		VAR_OUTPUT
			retVal 	: t_SegmentTransferResult;
		END_VAR;
				//! <Function Comment="This function is called in CyWork Task from _CanOpenMng." Name="CanControlCy"/>
	FUNCTION VIRTUAL GLOBAL CanControlCy;
				//! <Function Comment="Get Place Number of class as return code &quot;dPlaceNbr&quot;." Name="GetPlaceNbr"/>
	FUNCTION GLOBAL GetPlaceNbr
		VAR_OUTPUT
			dPlaceNbr 	: DINT;			//! <Variable Comment="Return code contains the place number.&#13;&#10;Possible values are 0-127 and 0xFFFF for deactivated." Name="GetPlaceNbr.dPlaceNbr"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ErrorQuit::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using _CanOpenLSSControl
#pragma using _XMLReader
#pragma usingLtd _CanOpenMng
#pragma usingLtd _CanOpenSDOTab
#pragma usingLtd _FileSys
#pragma usingLtd _StdLib
#pragma usingLtd SigCLib
#pragma usingLtd String


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _CanOpenBasicDS301::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__CANOPENBASICDS301
1$UINT, 15$UINT, (SIZEOF(::_CanOpenBasicDS301))$UINT, 
9$UINT, 18$UINT, 0$UINT, 
TO_UDINT(2457842784), "_CanOpenBasicDS301", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::_CanOpenBasicDS301.DeviceState.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(4203537714), "DeviceState", 
(::_CanOpenBasicDS301.ErrorQuit.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(971218924), "ErrorQuit", 
(::_CanOpenBasicDS301.CanDisabled.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1693079503), "CanDisabled", 
(::_CanOpenBasicDS301.DataReady.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2319261881), "DataReady", 
(::_CanOpenBasicDS301.AsyncState.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2623078406), "AsyncState", 
(::_CanOpenBasicDS301.ErrorSDO.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1450708186), "ErrorSDO", 
(::_CanOpenBasicDS301.ErrorAlloc.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1985885325), "ErrorAlloc", 
(::_CanOpenBasicDS301.EmcyStatusByte0_3.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3847551492), "EmcyStatusByte0_3", 
(::_CanOpenBasicDS301.EmcyStatusByte4_7.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3845166785), "EmcyStatusByte4_7", 
//Clients:
(::_CanOpenBasicDS301.MasterDevice.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000110$UINT, TO_UDINT(576749523), "MasterDevice", TO_UDINT(2879897165), "_CanOpenMng", 1$UINT, 11$UINT, 
(::_CanOpenBasicDS301.Place.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2202636669), "Place", 
(::_CanOpenBasicDS301.Index.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1999087025), "Index", 
(::_CanOpenBasicDS301.Required.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(648558917), "Required", 
(::_CanOpenBasicDS301.ChkRxPdo.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2196478080), "ChkRxPdo", 
(::_CanOpenBasicDS301.NodeGuardingSupported.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3533868785), "NodeGuardingSupported", 
(::_CanOpenBasicDS301.ProducerHeartbeatSupported.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(4202255856), "ProducerHeartbeatSupported", 
(::_CanOpenBasicDS301.SendMode.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2961346820), "SendMode", 
(::_CanOpenBasicDS301.DisableEmergencyObject.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2784479700), "DisableEmergencyObject", 
(::_CanOpenBasicDS301.CheckNMTState.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2872608748), "CheckNMTState", 
(::_CanOpenBasicDS301.NewNMTState.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2636647055), "NewNMTState", 
(::_CanOpenBasicDS301.SDOTable.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(933132404), "SDOTable", TO_UDINT(422246758), "_CanOpenSDOTab", 1$UINT, 0$UINT, 
(::_CanOpenBasicDS301.toXDCFile.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(971250974), "toXDCFile", TO_UDINT(1850111279), "String", 1$UINT, 11$UINT, 
(::_CanOpenBasicDS301.FileSys.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000100$UINT, TO_UDINT(1422438244), "FileSys", TO_UDINT(545279513), "_FileSys", 1$UINT, 20$UINT, 
(::_CanOpenBasicDS301.StdLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000100$UINT, TO_UDINT(584375759), "StdLib", TO_UDINT(3689364044), "_StdLib", 0$UINT, 0$UINT, 
(::_CanOpenBasicDS301.toSigCLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000100$UINT, TO_UDINT(2700849093), "toSigCLib", TO_UDINT(77440046), "SigCLib", 0$UINT, 36$UINT, 
(::_CanOpenBasicDS301._XMLReaderXDC.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(565665039), "_XMLReaderXDC", TO_UDINT(3727258101), "_XMLReader", 2$UINT, 3$UINT, 
(::_CanOpenBasicDS301._CanOpenLSSControl1.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3165436658), "_CanOpenLSSControl1", TO_UDINT(3310590118), "_CanOpenLSSControl", 1$UINT, 0$UINT, 
END_FUNCTION


#define USER_CNT__CanOpenBasicDS301 50

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__CanOpenBasicDS301] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _CanOpenBasicDS301::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT__CanOpenBasicDS301, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #InitSettingsAndPdos();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #SetNmt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #SetPdoData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #SendSdo();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #SDOCheck();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #SdoProcess();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #ConvertPdo1();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #ConvertPdo2();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #ConvertPdo3();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[10]		:= #ConvertPdo4();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[11]		:= #ConvertAdditionalPDO();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #TransmitPdo1();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #TransmitPdo2();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #TransmitPdo3();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[15]		:= #TransmitPdo4();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[16]		:= #TransmitAdditionalPDO();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[17]		:= #GetPdoSettings();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[18]		:= #UserSettings();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[19]		:= #CheckRxPdo();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[20]		:= #GetAsyncState();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[21]		:= #AsyncCmd();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[22]		:= #GetAsyncData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[23]		:= #AddCanObjects();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[24]		:= #ObjectInit();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[25]		:= #ReadWriteUserSDO();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[26]		:= #CanControl();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[27]		:= #SetOpMode();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[28]		:= #ReInitObject();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[29]		:= #ResetComm();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[30]		:= #CheckInitDone();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[31]		:= #GetNGorHBtime();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[32]		:= #SendAllPDOs();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[33]		:= #DefaultPDOSetting();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[34]		:= #Stop_SegmentTransfer();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[35]		:= #InitiateSegmentUpload();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[36]		:= #CANReceiveSegmentTransfer();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[37]		:= #HandleSegmentTransferCommunication();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[38]		:= #PrepareSDOUploadInitiate();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[39]		:= #PrepareSDODownloadInitiate();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[40]		:= #PrepareSDOUploadSegmentTransfer();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[41]		:= #PrepareSDODownloadSegmentTransfer();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[42]		:= #StartSegUploadTransfer();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[43]		:= #StartSegDownloadTransfer();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[44]		:= #StartSegmentUpload();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[45]		:= #StartSegmentDownload();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[46]		:= #GetProperty();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[47]		:= #SetProperty();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[48]		:= #XDCGetAdditionalIndexes();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[49]		:= #CanControlCy();

#pragma warning (default : 74)
	DeviceState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF DeviceState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ErrorQuit.pMeth			:= StoreMethod( #M_RD_DIRECT(), #ErrorQuit::Write() );
	IF ErrorQuit.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
// Initialization
FUNCTION VIRTUAL GLOBAL _CanOpenBasicDS301::Init
  VAR
    retcode   : DINT;
    aTempChar : Array[0..CO_MAX_STRING_LENGTH-1] of CHAR;
    udTempLength : UDINT;
  END_VAR 
  
  usInitCnt += 1;
  
  // Initialization the buffer for the sdo handling ------------------------------------------
  if usInitCnt = 2 then
  
    //read client
    Place := Place.read(); 
    
    if Place = DEACTIVATED_LSL then
      DeviceState := _CanOpenMng::_CAN_NODE_DISABLED;
      return;
    end_if;
    
    //initialize Pdo parameter with not used
    DeactivatePDO(pPdoElement:=#TPdo1);
    DeactivatePDO(pPdoElement:=#TPdo2);
    DeactivatePDO(pPdoElement:=#TPdo3);
    DeactivatePDO(pPdoElement:=#TPdo4);
    
    DeactivatePDO(pPdoElement:=#RPdo1);
    DeactivatePDO(pPdoElement:=#RPdo2);
    DeactivatePDO(pPdoElement:=#RPdo3);
    DeactivatePDO(pPdoElement:=#RPdo4);
    
    //set pointer to next Pdo data
    RPdo1.pNextPDO := #RPdo2;
    RPdo2.pNextPDO := #RPdo3;
    RPdo3.pNextPDO := #RPdo4;
    RPdo4.pNextPDO := #RPdoAdditional;
    
    TPdo1.pNextPDO := #TPdo2;
    TPdo2.pNextPDO := #TPdo3;
    TPdo3.pNextPDO := #TPdo4;
    TPdo4.pNextPDO := #TPdoAdditional;
          
    //look for a connected xdc file    
    if IsClientConnected(#toXDCFile) then
      _memset(dest:=#aTempChar, usByte:=0x00, cntr:=sizeof(aTempChar));
      udTempLength := toXDCFile.GetLength();
      if udTempLength < CO_MAX_STRING_LENGTH then
        toXDCFile.GetDataAt(pData:=#aTempChar[0], udSize:=udTempLength, udAt:=0);
        //read xdc file and parse Pdo information from it
        retcode := XDCHandling(#aTempChar[0]);
      else
        //filename is too long
        retcode := -1;
        MasterDevice.LogError("@0412 (_CanOpenBasicDS301::Init) Filename of xdc file is too long.");
      end_if;
      
      if retcode = 0 then
        //xdc Pdo info is ok and can be used
        sXDCVars.bUseXDCPdoInfo := TRUE;
      else
        //error with xdc file -> set class to config error
        DeviceState := _CanOpenMng::_CAN_CONFIGERROR;
        opMOde := _CAN_CONFIGERROR;
        MasterDevice.LogError("@0413 (_CanOpenBasicDS301::Init) Read of connected xdc file failed.");
        return;
      end_if;
    end_if;
    
    // read clients
    ChkRxPdo                    := ChkRxPdo.Read() <> 0;
    NodeGuardingSupported       := NodeGuardingSupported.Read() <> 0;
    SendMode                    := SendMode.Read() <> 0;
    ProducerHeartbeatSupported  := ProducerHeartbeatSupported.Read() <> 0;
    DisableEmergencyObject      := DisableEmergencyObject.Read() <> 0;
    CheckNMTState               := CheckNMTState.Read() <> 0;
        
    // select place from xdc file if there is no place choosen for this object
    if sXDCVars.bUseXDCPdoInfo & Place = 0 then
      Place := sXDCVars.sNetworkManagementInfo.DeviceCommissioning.udnodeID$DINT;
    end_if;
    
    if Place < 1 | Place > CO_MAX_PLACE_NUMBER then
      //place number is not valid
      retcode := -1;       
      MasterDevice.LogValue("@0414 (_CanOpenBasicDS301::Init) Place Number 0x{0} is not in a valid range (1-127).",Place$UDINT);        
    else
      //Login to _CanOpenMng
      retcode := MasterDevice.LoginCanObj(pObj:=this);      
    end_if;

    if retcode <> 0 then
      DeviceState := _CanOpenMng::_CAN_LOGINERROR;
      opMOde := _CAN_LOGINERROR;      
      MasterDevice.LogError("@0415 (_CanOpenBasicDS301::Init) Login to _CanOpenMng failed.");
    end_if;  

  // initialize the variables ------------------------------------------------------------
  elsif usInitCnt = 12 then   
    sDataSDO.SdoHandle  := 100;
    SendMarkTpdo1       := TRUE;
    SendMarkTpdo2       := TRUE;
    SendMarkTpdo3       := TRUE;
    SendMarkTpdo4       := TRUE;
    //if there are additional Pdo`s the send mark is set at add can objects      
    
    //set receive can Pdo timeout
    udRPdoTimeout := CO_RPDO_ALLOWED_RETRYS * MasterDevice.CycleTime$UDINT;
    if udRPdoTimeout < CO_CANPDOTIMEOUT then
      udRPdoTimeout := CO_CANPDOTIMEOUT;
    end_if;    
    
    //Pipe for sdo error data
    sSDOErrorLogging.pSDOErrorPipe$^void := cPipe_CTor(sizeof(t_s_ComSDOInfo), CO_MAX_LOGGING_ENTRIES);
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _CanOpenBasicDS301::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
  VAR
  	sActSdoData : t_s_ComSDOInfo;
  END_VAR
  
  while ((cPipe_Get(pd:=#sActSdoData, p:=sSDOErrorLogging.pSDOErrorPipe) = 1) & (sSDOErrorLogging.usDataInBuffer <> 0)) do
    sSDOErrorLogging.usDataInBuffer -= 1;
    if sActSdoData.bRW = TRUE then
      MasterDevice.LogValue("@0416 (_CanOpenBasicDS301::Background) Sending of write sdo on place 0x{0} with index 0x{1} and subindex 0x{2} failed.", Place$HDINT, sActSdoData.hiIndex, sActSdoData.hsSubIndex);
      MasterDevice.LogValue("(_CanOpenBasicDS301::Background) The error information from the node is 0x{0}. The write data was 0x{1}.", sActSdoData.hdErrorRetCode, sActSdoData.hdData);
    else
      MasterDevice.LogValue("@0417 (_CanOpenBasicDS301::Background) Sending of read sdo on place 0x{0} with index 0x{1} and subindex 0x{2} failed.", Place$HDINT, sActSdoData.hiIndex, sActSdoData.hsSubIndex);
      MasterDevice.LogValue("(_CanOpenBasicDS301::Background) The error information from the node is 0x{0}.", sActSdoData.hdErrorRetCode);
    end_if;
  end_while;

	state := READY;

END_FUNCTION

// Initialization for the objects
// Pdo, SDO, etc.
FUNCTION VIRTUAL GLOBAL _CanOpenBasicDS301::ObjectInit  
  // Get Pdo Settings --------------------------------------------------------------------------
  PDOInissw := 0;
    
  GetPdoSettings();
  //overwrite Pdo settings with xdc infos from file
  if sXDCVars.bUseXDCPdoInfo = TRUE then
    XDCSetPdoData();
  end_if;  
  
END_FUNCTION


FUNCTION VIRTUAL _CanOpenBasicDS301::InitSettingsAndPdos
  
  case InitSSW of
  
    0: //if nmt check activated wait 4 bootup message of node or maximal 4 sec -> then start sdo initialization  
      if CheckNMTState = 0 | (ops.tAbsolute-udWaitInitNode) >= CO_CAN_Device_TIMEOUT | (bQuitErrorNewNMT = TRUE & QuitErrorNMTState = _CAN_BOOT_UP)  then       
        // DO ALL USER SETTINGS, e.g. Nodeguarding or Producer Heartbeat -------- 
        if UserSettings() = 1 then
          InitSSW       := 1;
          pTempPdoEntry := #TPdo1;
          //reset nmt state error quit flag
          bQuitErrorNewNMT  := FALSE;
        end_if;
      end_if;
      
    1: // TPDO SETTINGS -------------------------------------------------------
      if pTempPdoEntry <> NIL then
        if SetPdoData(pPdoSetting:=pTempPdoEntry) = 1 then
          //check next tpdo
          pTempPdoEntry := pTempPdoEntry^.pNextPDO;
        end_if;
      else
        pTempPdoEntry := #RPdo1;
        InitSSW:= 2;
      end_if;
      
    2: // RPDO SETTINGS -------------------------------------------------------
      if pTempPdoEntry <> NIL then
        if SetPdoData(pPdoSetting:=pTempPdoEntry) = 1 then
          //check next rpdo
          pTempPdoEntry := pTempPdoEntry^.pNextPDO;
        end_if;
      else
        InitSSW:= 9;
      end_if;      
   
    9:// DS301 INIT FINISHED ----------------------------------------------------
      InitSSW := 50;
    50:// USER INIT -------------------------------------------------------------
      InitSSW := 99;
    99:// INIT FINISHED ---------------------------------------------------------
      InitSSW := 100;
      OpMode := _CAN_NETENABLE;
      
  END_CASE;
  
END_FUNCTION

// Do Pdo setting during init
FUNCTION VIRTUAL _CanOpenBasicDS301::SetPdoData
  VAR_INPUT
    pPdoSetting   : ^_PDOSETTINGS;
  END_VAR
  VAR_OUTPUT
    retcode       : DINT;
  END_VAR
  VAR
    HlpRetcode    : iprStates;
    HlpData       : DINT;
    i             : DINT;
    HlpIndex      : INT;
    HlpSubIndex   : SINT;
    HlpRW         : BOOL;
    HlpLen        : USINT;
    HlpRetData    : DINT;
    bAsyncDataHandling : BOOL;
    dTempMappingArray : DINT;
  END_VAR;
  
  retcode := 0;
  bAsyncDataHandling := FALSE;
  
  if pPdoSetting^.active = TRUE | pPdoSetting^.inactive = TRUE then  // Check if Pdo active for mapping
    //******************************************************************************************************
    // Pdo MAPPING
    //******************************************************************************************************
    case PDOIniSSW of
  
      0:// DEACTIVATE Pdo --------------------------------------------------------------------------------
        if  pPdoSetting^.Deactivate.Index <> -1 & pPdoSetting^.Deactivate.Index <> 0 then

          HlpIndex    := pPdoSetting^.Deactivate.Index$INT;
          HlpSubIndex := pPdoSetting^.Deactivate.SubIndex$SINT;
          HlpData     := pPdoSetting^.Deactivate.Data$DINT; 
          HlpRW       := 1;
          HlpLen      := 4;
          
        else
          PDOIniSSW   := 1;
          return;
        end_if;
      
      1:// HIGHEST SUBINDEX NUMBER ----------------------------------------------------------------------------- 
        if  pPdoSetting^.HighestSubNbr.Index <> -1 & pPdoSetting^.HighestSubNbr.Index <> 0 then  

          HlpIndex    := pPdoSetting^.HighestSubNbr.Index$INT;
          HlpSubIndex := pPdoSetting^.HighestSubNbr.SubIndex$SINT;
          HlpData     := pPdoSetting^.HighestSubNbr.Data$DINT; 
          HlpRW       := 1;
          HlpLen      := 1;
          
        else
          PDOIniSSW   := 2;
          return;
        end_if;  
        
      2:// TRANSMISSION-TYPE ----------------------------------------------------------------------------- 
        if  pPdoSetting^.Transmissiontype.Index <> -1 & pPdoSetting^.Transmissiontype.Index <> 0 then  

          HlpIndex    := pPdoSetting^.Transmissiontype.Index$INT;
          HlpSubIndex := pPdoSetting^.Transmissiontype.SubIndex$SINT;
          HlpData     := pPdoSetting^.Transmissiontype.Data$DINT; 
          HlpRW       := 1;
          HlpLen      := 1;
          
        else
          PDOIniSSW   := 3;
          return;
        end_if;  
          
      3:// INHIBIT-TIME ----------------------------------------------------------------------------------
        if pPdoSetting^.InhibitTime.Index <> -1 & pPdoSetting^.InhibitTime.Index <> 0 then  
          
          HlpIndex    := pPdoSetting^.InhibitTime.Index$INT;
          HlpSubIndex := pPdoSetting^.InhibitTime.SubIndex$SINT;
          HlpData     := pPdoSetting^.InhibitTime.Data$DINT; 
          HlpRW       := 1;
          HlpLen      := 2;

        else
          PDOIniSSW   := 4; 
          return;
        end_if;  

      4:// Reserved  ---------------------------------------------------------------------------------------
        if pPdoSetting^.PdoChoice.Index <> -1 & pPdoSetting^.PdoChoice.Index <> 0 then  
          
          HlpIndex    := pPdoSetting^.PdoChoice.Index$INT;
          HlpSubIndex := pPdoSetting^.PdoChoice.SubIndex$SINT;
          HlpData     := pPdoSetting^.PdoChoice.Data$DINT; 
          HlpRW       := 1;
          HlpLen      := 2;
          
        else
          PDOIniSSW   := 5;
          return;
        end_if;  
       
        
      5:// Event Timer  ---------------------------------------------------------------------------------------
        if pPdoSetting^.EventTimer.Index <> -1 & pPdoSetting^.EventTimer.Index <> 0 then  
          
          HlpIndex    := pPdoSetting^.EventTimer.Index$INT;
          HlpSubIndex := pPdoSetting^.EventTimer.SubIndex$SINT;
          HlpData     := pPdoSetting^.EventTimer.Data$DINT; 
          HlpRW       := 1;
          HlpLen      := 2;
          
        else
          PDOIniSSW   := 6;
          return;
        end_if;  
        
        
      6:// Sync start value  ---------------------------------------------------------------------------------------
        if pPdoSetting^.SyncStartValue.Index <> -1 & pPdoSetting^.SyncStartValue.Index <> 0 then  
          
          HlpIndex    := pPdoSetting^.SyncStartValue.Index$INT;
          HlpSubIndex := pPdoSetting^.SyncStartValue.SubIndex$SINT;
          HlpData     := pPdoSetting^.SyncStartValue.Data$DINT; 
          HlpRW       := 1;
          HlpLen      := 1;
          
        else
          PDOIniSSW   := 7;
          return;
        end_if;  
        
        
      7:// SET NUMBER of MAPPING ENTRIES TO 0 ------------------------------------------------------------
        if (( pPdoSetting^.MappingPara[0].Index <> -1 ) | ( pPdoSetting^.MappingPara[1].Index <> -1 ) | 
           ( pPdoSetting^.MappingPara[2].Index <> -1 ) | ( pPdoSetting^.MappingPara[3].Index <> -1 ) |
           ( pPdoSetting^.MappingPara[4].Index <> -1 ) | ( pPdoSetting^.MappingPara[5].Index <> -1 ) |
           ( pPdoSetting^.MappingPara[6].Index <> -1 ) | ( pPdoSetting^.MappingPara[7].Index <> -1 ) ) then
           
          //only set number of mapping parameters to zero if it is supported 
          if (pPdoSetting^.ActiveNbrOfMappings <> -1) then                  
            
            HlpIndex    := pPdoSetting^.MappingPara[0].Index$INT;
            HlpSubIndex := 0;
            HlpData     := 0; 
            HlpRW       := 1;
            HlpLen      := 1;
                             
          else            
            PDOIniSSW := 8;
            return;
          end_if;          
        else
          //all Pdo mappings are disabled
          if pPdoSetting^.active = TRUE then
            // activate Pdo 
            PDOIniSSW := 17;
            return;
          else
            //if Pdo is not set to active the mapping is finished here
            PDOIniSSW := 18;
            return;
          end_if;
        end_if;  

      8:// MAPPING PARAMETER 1 ---------------------------------------------------------------------------
        dTempMappingArray := PDOIniSSW - 8;
        if pPdoSetting^.MappingPara[dTempMappingArray].Index > 0 & pPdoSetting^.MappingPara[dTempMappingArray].Index <> 0 then
          
          HlpIndex    := pPdoSetting^.MappingPara[dTempMappingArray].Index$INT;
          HlpSubIndex := pPdoSetting^.MappingPara[dTempMappingArray].SubIndex$SINT;
          HlpData     := pPdoSetting^.MappingPara[dTempMappingArray].Data$DINT; 
          HlpRW       := 1;
          HlpLen      := 4;
          
        else
          PDOIniSSW   := 9;
          return;
        end_if;

        
      9:// MAPPING PARAMETER 2 ---------------------------------------------------------------------------
        dTempMappingArray := PDOIniSSW - 8;
        if pPdoSetting^.MappingPara[dTempMappingArray].Index > 0 & pPdoSetting^.MappingPara[dTempMappingArray].Index <> 0 then
          
          HlpIndex    := pPdoSetting^.MappingPara[dTempMappingArray].Index$INT;
          HlpSubIndex := pPdoSetting^.MappingPara[dTempMappingArray].SubIndex$SINT;
          HlpData     := pPdoSetting^.MappingPara[dTempMappingArray].Data$DINT; 
          HlpRW       := 1;
          HlpLen      := 4;
          
        else
          PDOIniSSW   := 10;
          return;
        end_if;  

      10:// MAPPING  PARAMETER 3 --------------------------------------------------------------------------
        dTempMappingArray := PDOIniSSW - 8;
        if pPdoSetting^.MappingPara[dTempMappingArray].Index > 0 & pPdoSetting^.MappingPara[dTempMappingArray].Index <> 0 then
          
          HlpIndex    := pPdoSetting^.MappingPara[dTempMappingArray].Index$INT;
          HlpSubIndex := pPdoSetting^.MappingPara[dTempMappingArray].SubIndex$SINT;
          HlpData     := pPdoSetting^.MappingPara[dTempMappingArray].Data$DINT; 
          HlpRW       := 1;
          HlpLen      := 4;
          
        else
          PDOIniSSW   := 11;
          return;
        end_if;
        
      11:// MAPPING  PARAMETER 4 --------------------------------------------------------------------------
        dTempMappingArray := PDOIniSSW - 8;
        if pPdoSetting^.MappingPara[dTempMappingArray].Index > 0 & pPdoSetting^.MappingPara[dTempMappingArray].Index <> 0 then
          
          HlpIndex    := pPdoSetting^.MappingPara[dTempMappingArray].Index$INT;
          HlpSubIndex := pPdoSetting^.MappingPara[dTempMappingArray].SubIndex$SINT;
          HlpData     := pPdoSetting^.MappingPara[dTempMappingArray].Data$DINT; 
          HlpRW       := 1;
          HlpLen      := 4;
          
        else
          PDOIniSSW   := 12;
          return;
        end_if;
        
     12:// MAPPING  PARAMETER 5 --------------------------------------------------------------------------
        dTempMappingArray := PDOIniSSW - 8;
        if pPdoSetting^.MappingPara[dTempMappingArray].Index > 0 & pPdoSetting^.MappingPara[dTempMappingArray].Index <> 0 then
          
          HlpIndex    := pPdoSetting^.MappingPara[dTempMappingArray].Index$INT;
          HlpSubIndex := pPdoSetting^.MappingPara[dTempMappingArray].SubIndex$SINT;
          HlpData     := pPdoSetting^.MappingPara[dTempMappingArray].Data$DINT; 
          HlpRW       := 1;
          HlpLen      := 4;
          
        else
          PDOIniSSW   := 13;
          return;
        end_if;          
        
      13:// MAPPING  PARAMETER 6 --------------------------------------------------------------------------
        dTempMappingArray := PDOIniSSW - 8;
        if pPdoSetting^.MappingPara[dTempMappingArray].Index > 0 & pPdoSetting^.MappingPara[dTempMappingArray].Index <> 0 then
          
          HlpIndex    := pPdoSetting^.MappingPara[dTempMappingArray].Index$INT;
          HlpSubIndex := pPdoSetting^.MappingPara[dTempMappingArray].SubIndex$SINT;
          HlpData     := pPdoSetting^.MappingPara[dTempMappingArray].Data$DINT; 
          HlpRW       := 1;
          HlpLen      := 4;
          
        else
          PDOIniSSW   := 14;
          return;
        end_if;          
        
      14:// MAPPING  PARAMETER 7 --------------------------------------------------------------------------
        dTempMappingArray := PDOIniSSW - 8;
        if pPdoSetting^.MappingPara[dTempMappingArray].Index > 0 & pPdoSetting^.MappingPara[dTempMappingArray].Index <> 0 then
          
          HlpIndex    := pPdoSetting^.MappingPara[dTempMappingArray].Index$INT;
          HlpSubIndex := pPdoSetting^.MappingPara[dTempMappingArray].SubIndex$SINT;
          HlpData     := pPdoSetting^.MappingPara[dTempMappingArray].Data$DINT; 
          HlpRW       := 1;
          HlpLen      := 4;
          
        else
          PDOIniSSW   := 15;
          return;
        end_if;
        
      15:// MAPPING  PARAMETER 8 --------------------------------------------------------------------------
        dTempMappingArray := PDOIniSSW - 8;
        if pPdoSetting^.MappingPara[dTempMappingArray].Index > 0 & pPdoSetting^.MappingPara[dTempMappingArray].Index <> 0 then
          
          HlpIndex    := pPdoSetting^.MappingPara[dTempMappingArray].Index$INT;
          HlpSubIndex := pPdoSetting^.MappingPara[dTempMappingArray].SubIndex$SINT;
          HlpData     := pPdoSetting^.MappingPara[dTempMappingArray].Data$DINT; 
          HlpRW       := 1;
          HlpLen      := 4;
          
        else
          PDOIniSSW   := 16;
          return;
        end_if;
        
      16:// SET NUMBER of MAPPING ENTRIES -----------------------------------------------------------------
        if (( pPdoSetting^.MappingPara[0].Index <> -1 ) | ( pPdoSetting^.MappingPara[1].Index <> -1 ) | 
           ( pPdoSetting^.MappingPara[2].Index <> -1 ) | ( pPdoSetting^.MappingPara[3].Index <> -1 ) |
           ( pPdoSetting^.MappingPara[4].Index <> -1 ) | ( pPdoSetting^.MappingPara[5].Index <> -1 ) |
           ( pPdoSetting^.MappingPara[6].Index <> -1 ) | ( pPdoSetting^.MappingPara[7].Index <> -1 ) ) then
           
          //only write number of mapping parameters if it is supported 
          if (pPdoSetting^.ActiveNbrOfMappings <> -1) then
          
            HlpData := 0;
            //only mapping entries 0 to 7 are used
            //start counting with 0 because this is the first subindex to count up
            for i := 0 TO CO_MAX_PDO_MAPPING_ENTRIES-1 DO
              if pPdoSetting^.MappingPara[i].Index <> -1 then
                HlpData += 1;
              end_if;
            end_for;
            //mapping para 0 is not the number of mapping entries, only used to get the correct index
            HlpIndex    := pPdoSetting^.MappingPara[0].Index$INT;
            HlpSubIndex := CO_SUBINDEX_HIGHEST_SUBNBR;
            HlpData     := HlpData; 
            HlpRW       := 1;
            HlpLen      := 1;            
            
          else
            PDOIniSSW   := 17;
            return;
          end_if;
        else  
          PDOIniSSW   := 17;
          return;
        end_if;  
        
      17:// ACTIVATE Pdo ----------------------------------------------------------------------------------
        if  pPdoSetting^.Activate.Index <> -1  & pPdoSetting^.Activate.Index <> 0 
        & pPdoSetting^.inactive = FALSE then 

          HlpIndex    := pPdoSetting^.Activate.Index$INT;
          HlpSubIndex := pPdoSetting^.Activate.SubIndex$SINT;
          HlpData     := pPdoSetting^.Activate.Data$DINT; 
          HlpRW       := 1;
          HlpLen      := 4;
          
        else
          PDOIniSSW   := 18;
          return;
        end_if;  
        
      18:// FINISHED -------------------------------------------------------------------------------------  
        PDOIniSSW := 0;
        retcode   := 1;
        return;

    END_CASE;
    //******************************************************************************************************
    // END Pdo MAPPING
    //******************************************************************************************************

    bAsyncDataHandling := TRUE;
    
  else
    retcode := 1;
  end_if;
  
  if bAsyncDataHandling = TRUE then  
    //**********************************************************************************************
    // ASYNC DATA HANDLING
    //**********************************************************************************************
    
    HlpRetcode := AsyncSDOHandling(pHandle  := #HlpHandleInit
                                , iIndex    := HlpIndex
                                , siSubIndex:= HlpSubIndex
                                , dData     := HlpData
                                , bRW       := HlpRW
                                , usLength  := HlpLen
                                , pAsyncData:= #HlpRetData
                                );
                                
    // Send SDO --------------------------------------------------
    if HlpRetcode = READY then
    
    // Send SDO was not successful -------------------------------
    elsif HlpRetcode = ERROR then
      //set class to error if required or there is no communication to node 
      if Required | HlpRetData = CO_CAN_DEVICE_NOANSWER then
        opMode      := _CAN_COMERROR;
        DeviceState := _CanOpenMng::_CAN_COMERROR;
        //init is aborted with com error to node
        InitSSW     := 200;
      end_if;
      PDOIniSSW += 1;
      
    // Send SDO was successful ------------------------------------  
    elsif HlpRetcode = QUIT then
      PDOIniSSW += 1;
    end_if;    
    
    //****************************************************************************************************
    // END ASYNC DATA HANDLING
    //****************************************************************************************************
  
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL _CanOpenBasicDS301::SendSdo
  VAR_INPUT
    Index     : HINT;
    SubIndex  : HSINT;
    Data       : HDINT;
    Length     : USINT;
    RW         : BOOL;
  END_VAR
  VAR_OUTPUT
    retcode   : DINT;
  END_VAR
  VAR
    CANData   : _CAN_STRUCT;
  END_VAR
  
  // -----------------------------------------------------------------------------------------------------
  // --------------------------       SEND SDO for READ / WRITE          ---------------------------------
  // -----------------------------------------------------------------------------------------------------

  retcode := -1;
  
  if Length <= 4 then                   // Get Data of max 4 Bytes
  
    SegmentCmd := 16#70;
    
    if (RW = 0) then                    // Read Data 
    
      CANData.CMD := 16#40;  
      
    else                               
      // -----------------------------------------------------------------------------------------------------
      // --------------------------       Expedited Write                    ---------------------------------
      // -----------------------------------------------------------------------------------------------------
      // -----------------------------------------------------------------------------------------------------
      //  CommandCode
      //  Bits       	Value 	Meaning
      //  7-5 	      010b   SCS  Server Command Specifier
      //  4 	        0 	   (Not Used) Segment toggle bit
      //  3-2 	      (n)    Data size	
      //                     n=3 (11b) 1 data bytes sent
      //                     n=2 (10b) 2 data bytes sent
      //                     n=1 (01b) 3 data byte sent 
      //                     n=0 (00b) 4 data byte sent 
      //  1 					1 	 	 expedited transfer
      //  0 					1      data set size is indicated
      //
      //  Command Code 	Meaning
      //  0x23 	Write Dictionary Object reply, expedited, 4 bytes sent
      //  0x27 	Write Dictionary Object reply, expedited, 3 bytes sent
      //  0x2B 	Write Dictionary Object reply, expedited, 2 bytes sent
      //  0x2F 	Write Dictionary Object reply, expedited, 1 bytes sent      
      if (Length = 0) then
      
        if (Data < 16#100) then
          CANData.CMD := 16#2F;         // 1 byte data
        elsif (Data < 16#10000) then
          CANData.CMD := 16#2B;         // 2 byte data
        elsif (Data < 16#1000000) then
          CANData.CMD := 16#27;         // 3 byte data
        else
          CANData.CMD := 16#23;         // 4 byte data
        end_if;
        
      elsif (Length = 1) then
        CANData.CMD := 16#2F;           // 1 byte data
      elsif (Length = 2) then
        CANData.CMD := 16#2B;           // 2 byte data
      elsif (Length = 3) then
        CANData.CMD := 16#27;           // 3 byte data
      elsif (Length >= 4) then
        CANData.CMD := 16#23;           // 4 byte data
      end_if;      
    end_if;
      
    CANData.IndexMSB := (Index/16#100)$HSINT;
    CANData.IndexLSB := Index$HSINT;
  
    CANData.SubIndex := SubIndex;
    
    //copy send data
    CANData.Data[0]$HDINT := Data;
        
  else

    // log error
    MasterDevice.LogError("@05A7 (__CanOpenBasicDS301::SendSdo) SDO not sent: for length > 4 please use 'StartSegmentTransfer'.");
    return;
    
  end_if;
  
  retcode := MasterDevice.CanTxObj((TSdoObjNr + Place)$INT,
                                    8,
                                    #CANData,
                                    FALSE);
      
  if retcode = 0 then // --> SUCCESSFUL
    SendCounterSdo    += 1;
    ComSDO.dTxCounter += 1;
  end_if; 

END_FUNCTION

// Send NMT object
FUNCTION VIRTUAL _CanOpenBasicDS301::SetNmt
  VAR_INPUT
    Para     : HSINT;
  END_VAR
  VAR_OUTPUT
    RetVal   : DINT;
  END_VAR
                       
  RetVal := MasterDevice.SetNmt(Para:=Para, ID:=PLace);
    
END_FUNCTION


FUNCTION VIRTUAL GLOBAL _CanOpenBasicDS301::ErrorQuit::Write
  VAR_INPUT
    input (EAX)   : DINT;
  END_VAR
  VAR_OUTPUT
    result (EAX)   : DINT;
  END_VAR

  ErrorQuit := input; 

  //reset after rx timeout or communication errors
  if ( CanDisabled = 1 ) 
  | DeviceState = _CanOpenMng::_CAN_STOPPED | DeviceState = _CanOpenMng::_CAN_PRE_OPERATIONAL 
  | DeviceState = _CanOpenMng::_CAN_NGERROR | DeviceState = _CanOpenMng::_CAN_HBERROR 
  | DeviceState = _CanOpenMng::_CAN_COMERROR | bQuitErrorNewNMT = TRUE then
    if (ErrorQuit = 0 | ErrorQuit = 1) then
      OpMode      := _CAN_SYNC;
      CanDisabled := 0;

      // Set timestamp for Rx Timeout detection
      TimeRPdo1     := ops.tAbsolute;
      TimeRPdo2     := ops.tAbsolute;
      TimeRPdo3     := ops.tAbsolute;
      TimeRPdo4     := ops.tAbsolute;
      udTimeStampHB := ops.tAbsolute;
      
      //reset Pdo receive flag if nmt state changed
      ResetReceiveFlag();
       
      //set timestamp for timeout check of Rx Pdo's
      udCheckRxPDOTimeout := ops.tAbsolute;
      
      //reset async state if it has one
      if AsyncState = ERROR then
        AsyncState := READY;
      end_if; 
      
      if bQuitErrorNewNMT = TRUE then
        if QuitErrorNMTState = _CAN_BOOT_UP then          
          //reinit node if bootup message or can stopped state is received
          ReInitObject();
        elsif (QuitErrorNMTState = _CAN_OPERATIONAL | QuitErrorNMTState = _CAN_PRE_OPERATIONAL) 
        & DeviceState <> _CanOpenMng::_CAN_COMERROR then
          //reset communication if node is at operation state or pre-op state(already initialized)
          ResetComm();
        elsif QuitErrorNMTState = _CAN_STOPPED then
          SetNmt(Para:=CO_STARTREMOTENODE);
        end_if;
        bQuitErrorNewNMT := FALSE;
      end_if;
    
    //reset after communication error 
    elsif ErrorQuit = 2 then
      ResetComm();
    //reset communication to node
    elsif ErrorQuit = 3 then 
      ReInitObject();
    //reset communication to node
    elsif ErrorQuit = 4 then      
      SetOpMode(opModeSet:=_CAN_RESETCOM);
    //reset node and restart initialisation
    elsif ErrorQuit = 5 then
      SetOpMode(opModeSet:=_CAN_RESETNODE);
    end_if;  
  end_if;
  
  result := ErrorQuit; 
  
END_FUNCTION

#pragma warning(disable:73);
FUNCTION _CanOpenBasicDS301::ReceiveSDO
  VAR_INPUT
    PiCanptr     : ^USINT;
    RxDataptr   : ^USINT;
    Thisptr     : DINT;
  END_VAR
  
  this := Thisptr$^_CanOpenBasicDS301;
  
  _MemCpy(#RxBufferSdo,RxDataPtr,sizeof(RxBufferSdo));  

  ReceiveCounterSdo += 1;
  SDOCheck();
  
END_FUNCTION


FUNCTION _CanOpenBasicDS301::ReceiveEMCY
  VAR_INPUT
    PiCanptr     : ^USINT;
    RxDataptr   : ^USINT;
    Thisptr     : DINT;
  END_VAR
  
  this := Thisptr$^_CanOpenBasicDS301;  
  
  _MemCpy(#RxBufferEmcy, RxDataPtr, sizeof(RxBufferEmcy));
  
  EmcyStatusByte0_3 := RxBufferEmcy[0]$HDINT;
  EmcyStatusByte4_7 := RxBufferEmcy[4]$HDINT; 
  bdLogDataFlags.bNewEmcyMsg   := TRUE;
  
END_FUNCTION


FUNCTION _CanOpenBasicDS301::ReceiveNG
  VAR_INPUT
    piCanptr     : ^USINT;
    RxDataptr   : ^USINT;
    Thisptr     : DINT;
  END_VAR
  VAR
    bdHlpState  : BDINT;
  END_VAR

  this := Thisptr$^_CanOpenBasicDS301;  
  
  _MemCpy(#RxBufferNG, RxDataPtr, sizeof(RxBufferNG));  
  
  bdHlpState      := RxBufferNG[0];
  bdHlpState      := bdHlpState AND 2#01111111;
  
  //Don't change the CanDeviceState at init
  if (InitSSW = 100) | (bdHlpState$_CAN_DEVICE_STATE_INT <> _CAN_OPERATIONAL) then
    CanDeviceState := bdHlpState$_CAN_DEVICE_STATE_INT;  
  end_if;
  
  //check for new nmt state from node
  NMTStateProcess();
  
  NGReceiveFlag   := TRUE;
  
END_FUNCTION


FUNCTION _CanOpenBasicDS301::ReceiveHB
  VAR_INPUT
    PiCanptr     : ^USINT;
    RxDataptr   : ^USINT;
    Thisptr     : DINT;
  END_VAR
  VAR
    bdHlpState  : BDINT;
  END_VAR

  this := Thisptr$^_CanOpenBasicDS301;
  
  bHeartbeatRXFlag := true;

  _MemCpy(#RxBufferHB, RxDataPtr, sizeof(RxBufferHB));
  
  bdHlpState   := RxBufferHB[0];
  bdHlpState   := bdHlpState AND 2#01111111;
  
  //Don't change the CanDeviceState at init
  if (InitSSW = 100) | (bdHlpState$_CAN_DEVICE_STATE_INT <> _CAN_OPERATIONAL) then
    CanDeviceState := bdHlpState$_CAN_DEVICE_STATE_INT;  
  end_if;
  
  //store actual device state coming from node
  CanDeviceStateInternal := bdHlpState$_CAN_DEVICE_STATE_INT; 
  
  //check for new nmt state from node
  NMTStateProcess();
  
  HeartbeatCounter += 1;

END_FUNCTION


FUNCTION _CanOpenBasicDS301::ReceivePdo1
  VAR_INPUT
    piCanptr     : ^USINT;
    RxDataptr   : ^t_s_BasicCanObj;
    Thisptr     : DINT;
  END_VAR
  
  this := Thisptr$^_CanOpenBasicDS301;
  
  _MemCpy(#RxBufferPdo1,RxDataPtr,sizeof(RxBufferPdo1));

  ReceiveCounterPdo1  += 1;
  bRPdo1Rec           := TRUE;
  TimeRPdo1           := ops.tabsolute;
  ConvertPDO1();
  
END_FUNCTION


FUNCTION _CanOpenBasicDS301::ReceivePdo2
  VAR_INPUT
    piCanptr     : ^USINT;
    RxDataptr   : ^t_s_BasicCanObj;
    Thisptr     : DINT;
  END_VAR
  
  this := Thisptr$^_CanOpenBasicDS301;
  
  _MemCpy(#RxBufferPdo2,RxDataPtr,sizeof(RxBufferPdo2));
  
  ReceiveCounterPdo2  += 1;
  bRPdo2Rec           := TRUE;
  TimeRPdo2           := ops.tabsolute;
  ConvertPDO2();
  
END_FUNCTION


FUNCTION _CanOpenBasicDS301::ReceivePdo3
  VAR_INPUT
    piCanptr     : ^USINT;
    RxDataptr   : ^t_s_BasicCanObj;
    Thisptr     : DINT;
  END_VAR
  
  this := Thisptr$^_CanOpenBasicDS301;
  
  _MemCpy(#RxBufferPdo3,RxDataPtr,sizeof(RxBufferPdo3));
  
  ReceiveCounterPdo3  += 1;
  bRPdo3Rec           := TRUE;
  TimeRPdo3           := ops.tabsolute;
  ConvertPDO3();
  
END_FUNCTION


FUNCTION _CanOpenBasicDS301::ReceivePdo4
  VAR_INPUT
    piCanptr     : ^USINT;
    RxDataptr   : ^t_s_BasicCanObj;
    Thisptr     : DINT;
  END_VAR
  
  this := Thisptr$^_CanOpenBasicDS301;
  
  _MemCpy(#RxBufferPdo4,RxDataPtr,sizeof(RxBufferPdo4));
  
  ReceiveCounterPdo4  += 1;
  bRPdo4Rec           := TRUE;
  TimeRPdo4           := ops.tabsolute;
  ConvertPDO4();  
  
END_FUNCTION
#pragma warning(default:73);


// Convert received Pdo to internal
// data structure (server aso)
FUNCTION VIRTUAL GLOBAL _CanOpenBasicDS301::ConvertPdo1

// beispiel, Statusword:
//  HlpStatusWord := (RxBufferPdo1[1]*16#100)$BDINT;
//  HlpStatusWord += RxBufferPdo1[0];
//  
//  ActPosition := RxBufferPdo1[2]$DINT;
    
END_FUNCTION

// Convert received Pdo to internal
// data structure (server aso)
FUNCTION VIRTUAL GLOBAL _CanOpenBasicDS301::ConvertPdo2
  
      
END_FUNCTION

// Convert received Pdo to internal
// data structure (server aso)
FUNCTION VIRTUAL GLOBAL _CanOpenBasicDS301::ConvertPdo3



END_FUNCTION

// Convert received Pdo to internal
// data structure (server aso)
FUNCTION VIRTUAL GLOBAL _CanOpenBasicDS301::ConvertPdo4



END_FUNCTION

#pragma warning(disable:073);
// Convert received Pdo to internal
// data structure (server aso)
FUNCTION VIRTUAL GLOBAL _CanOpenBasicDS301::ConvertAdditionalPDO
	VAR_INPUT
		uiPDONrb 	: UINT;
		hiObjNbr 	: HINT;
		usLength 	: USINT;
		aCanData 	: t_a_CanData;
	END_VAR    
      
  //**************************************************************************
  //******* example for get and process additional Pdo receive data **********
  //**************************************************************************  
  
  // get RPdo by Pdo number, it is also possible to get RPdo by COB-ID (hiObjNbr)
  case uiPDONrb of
    //**************************************************
    //default Pdo receive data are handled at methode ConvertPDO1-4()
    //1://RPdo 1
    //2://RPdo 2
    //3://RPdo 3
    //4://RPdo 4
    //default Pdo transmit end
    //**************************************************
    
    
    //**************************************************
    //additional receive Pdo data start
    
    5://example for process read data of RPdo 5         
    //ActPosition := aCanData[2]$DINT;
      
    6://example for process read data of RPdo 6       
    //ActPosition := aCanData[2]$DINT;
      
    7://example for process read data of RPdo 7       
    //ActPosition := aCanData[2]$DINT;
      
    8://example for process read data of RPdo 8       
    //ActPosition := aCanData[2]$DINT;
      
    9://example for process read data of RPdo 9       
    //ActPosition := aCanData[2]$DINT;
    
    // ...  
    //additional receive Pdo data end
    //**************************************************
  end_case;
  
//  //select RPDO 5 or COB-ID of RPDO 5 and process data
//  if uiPDONrb = 5 | hiObjNbr = 0x0189 then    
//    ActPosition := aCanData[2]$DINT;
//  end_if;

  
END_FUNCTION
#pragma warning(default:073);



// Send Pdo
FUNCTION VIRTUAL GLOBAL _CanOpenBasicDS301::TransmitPdo1
  VAR
    TxBuffer : ARRAY[0..7] of HSINT;
    hObjNr   : HINT;
  END_VAR  
    
  _MemSet(#TxBuffer[0],0,sizeof(TxBuffer));
  
  TxBuffer[1] := 0;
  TxBuffer[0] := 0;
  
   // Beispiel:
   //CONTROLWORD -------------------------------------------------------------------------------
   // TxBuffer[0]$HINT := SpecControlWord$HINT;
  
  hObjNr := TPdo1.ObjNr$HINT;
  
  MasterDevice.CanTxObj((hObjNr+Place)$INT,
                         2,
                         #TxBuffer[0],
                         TRUE);
    
  
END_FUNCTION

// Send Pdo
FUNCTION VIRTUAL GLOBAL _CanOpenBasicDS301::TransmitPdo2
  VAR
    TxBuffer : ARRAY[0..7] of HSINT;
    hObjNr   : HINT;
  END_VAR  
    
  _MemSet(#TxBuffer[0],0,sizeof(TxBuffer));
  
  
  TxBuffer[0] := 0;
  
  hObjNr := TPdo2.ObjNr$HINT;
  
  MasterDevice.CanTxObj((hObjNr+Place)$INT,
                         1,
                         #TxBuffer[0],
                         TRUE);
    
  

END_FUNCTION

// Send Pdo 
FUNCTION VIRTUAL GLOBAL _CanOpenBasicDS301::TransmitPdo3
  VAR
    TxBuffer : ARRAY[0..7] of HSINT;
    hObjNr   : HINT;
  END_VAR  
    
  _MemSet(#TxBuffer[0],0,sizeof(TxBuffer));
  
  TxBuffer[0] := 0;
  TxBuffer[1] := 0;
  TxBuffer[2] := 0;
  
  hObjNr := TPdo3.ObjNr$HINT;
  
  MasterDevice.CanTxObj((hObjNr+Place)$INT,
                         3,
                         #TxBuffer[0],
                         TRUE);
    

END_FUNCTION

// Send Pdo 
FUNCTION VIRTUAL GLOBAL _CanOpenBasicDS301::TransmitPdo4
  VAR
    TxBuffer : ARRAY[0..7] of HSINT;
    hObjNr   : HINT;
  END_VAR  
    
  _MemSet(#TxBuffer[0],0,sizeof(TxBuffer));
  
  TxBuffer[0] := 0;
  
  hObjNr := TPdo4.ObjNr$HINT;
  
  
  MasterDevice.CanTxObj((hObjNr+Place)$INT,
                         1,
                         #TxBuffer[0],
                         TRUE);
    

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _CanOpenBasicDS301::TransmitAdditionalPDO
	VAR_INPUT
		uiPDONrb 	: UINT;
		hiObjNbr 	: HINT;
		paCanData 	: ^t_a_CanData;(* := NIL *)
	END_VAR
	VAR_OUTPUT
		dRetcode 	: DINT;
	END_VAR
  VAR
    aCanData : t_a_CanData;
  END_VAR
  
  if paCanData = NIL then
  
    //reset memory for write data
    _memset(dest:=#aCanData[0], usByte:=0x00, cntr:=sizeof(t_a_CanData));
    
    //**************************************************************************
    //******* example for set additional Pdo write data ************************
    //******* for cyclic call                           ************************
    //**************************************************************************
    
    case uiPDONrb of
      //**************************************************
      //default Pdo transmit start (is not called cyclic)
      1://TPdo 1
      2://TPdo 2
      3://TPdo 3
      4://TPdo 4
      //default Pdo transmit end
      //**************************************************
      
      
      //**************************************************
      //additional transmit Pdo start (is called cyclic if SendData is 1 and additional TPDO is active)
      
      5://example for set write data of TPdo 5
        aCanData[0] := 5;  
        
      6://example for set write data of TPdo 6
        aCanData[0] := 6;
        
      7://example for set write data of TPdo 7
        aCanData[0] := 7;
        
      8://example for set write data of TPdo 8
        aCanData[0] := 8;
        
      9://example for set write data of TPdo 9
        aCanData[0] := 9;
      // ...
      
      //additional transmit Pdo end
      //**************************************************
    end_case;
  else  
    aCanData := paCanData^;
  end_if;  
  
  dRetcode := TxAdditionalPDO(uiPDONbr:=uiPDONrb, hiObjNbr:=hiObjNbr, paCanData:=#aCanData);

END_FUNCTION


// Overload this function to change Pdo settings
FUNCTION VIRTUAL GLOBAL _CanOpenBasicDS301::GetPdoSettings
  VAR
    sActPDOEntry : _PDOSETTINGS;
  END_VAR

  PDOIniSSW := 0; // DONT TOUCH

  // ----------------------------------------------------------------------------------------
  // -------   SET CONSTANT PARAMETER TO VARIABLES SO WE CAN EASY OVERLOAD ------------------
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------  
  
  
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------  
  // ------------------------             OBJECT NUMBERS            -------------------------
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  RSdoObjNr := CO_RSDO_OBJNR;
  TSdoObjNr := CO_TSDO_OBJNR;
  NgObjNr   := CO_NG_OBJNR;
  EmcyObjNr := CO_EMCY_OBJNR;
  
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------  
  // ------------------             SDO ERROR                             -------------------
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  SDO_RwError := CO_SDO_RW_ERROR;    
  
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------  
  // ------------------------             NODE GUARDING            --------------------------
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  GuardTime.Index         := 16#100C;
  GuardTime.SubIndex      := 16#00; 
  GuardTime.Data          := 100; // GuardTime
                       
  LifetimeFactor.Index    := 16#100D;
  LifetimeFactor.SubIndex := 16#00; 
  LifetimeFactor.Data     := 2; // Lifetimefactor 
  
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------  
  // ---------------------             PRODUCER HEARTBEAT            ------------------------
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  Heartbeat.Index    := 16#1017;
  Heartbeat.SubIndex := 16#00;
  Heartbeat.Data     := 1000; //heartbeat time  
  
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------  
  // ---------------------            PLC Consumer HEARTBEAT         ------------------------
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  PlcConsumerHeartBeat := to_udint(Heartbeat.Data*2);   
  
  // ----------------------------------------------------------------------------------------
  // ------  if a XDC file is connected the below settings are overwritten by it ------------
  // ----------------------------------------------------------------------------------------
  
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------  
  // --------------------             RECEIVE Pdo-SETTINGS               --------------------
  // ----------------------------------------------------------------------------------------
  // if a valid xdc file is connected the Pdo settings are taken from the file --------------
  // if this is the case they must be commented out here! -----------------------------------
  // ----------------------------------------------------------------------------------------
  // Receive Object Numbers -----------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  RPdo1.ObjNr := CO_RPDO1_OBJNR;
  RPdo2.ObjNr := CO_RPDO2_OBJNR;
  RPdo3.ObjNr := CO_RPDO3_OBJNR;
  RPdo4.ObjNr := CO_RPDO4_OBJNR;
  
  // ----------------------------------------------------------------------------------------
  // RPDO 1, Device --> PLC -----------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  //only needed if it is used, it is already deactivate at init
  DefaultPDOSetting(pPdoElement:=#RPdo1, iAddressSetting:=CO_INDEX_RPDO1_SETTING);
  
  // Pdo mapping parameter
  RPdo1.ActiveNbrOfMappings       := 1;   //-1; Deactivate that number of Mappings are send to the device
  
  RPdo1.MappingPara[0].Index      := CO_INDEX_RPDO1_MAPPING; // -1 = inactive
  RPdo1.MappingPara[0].Subindex   := 16#01; 
  RPdo1.MappingPara[0].Data       := 0;
  
//  RPdo1.MappingPara[1].Index      := CO_INDEX_RPDO1_MAPPING; // -1 = inactive
//  RPdo1.MappingPara[1].Subindex   := 16#02; 
//  RPdo1.MappingPara[1].Data       := 0;
  
  // ----------------------------------------------------------------------------------------
  // RPDO 2, Device --> PLC -----------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  //only needed if it is used, it is already deactivate at init
  DefaultPDOSetting(pPdoElement:=#RPdo2, iAddressSetting:=CO_INDEX_RPDO2_SETTING);
  
  // Pdo mapping parameter
  RPdo2.ActiveNbrOfMappings       := 1;   //-1; Deactivate that number of Mappings are send to the device
  
  RPdo2.MappingPara[0].Index      := CO_INDEX_RPDO2_MAPPING;
  RPdo2.MappingPara[0].Subindex   := 16#01; 
  RPdo2.MappingPara[0].Data       := 0;  
  
  // ----------------------------------------------------------------------------------------
  // RPDO 3, Device --> PLC -----------------------------------------------------------------
  // ---------------------------------------------------------------------------------------- 
  //only needed if it is used, it is already deactivate at init
  
  // ----------------------------------------------------------------------------------------
  // RPDO 4, Device --> PLC -----------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  //only needed if it is used, it is already deactivate at init
  
  
//  //********************************************************************************************************************************
//  //if additional RPdo's are needed they can added here
//  //********************************************************************************************************************************
//  // ----------------------------------------------------------------------------------------
//  // RPDO 5, Device --> PLC -----------------------------------------------------------------
//  // ----------------------------------------------------------------------------------------
//  //reset local structure 
  _memset(dest:=#sActPDOEntry, usByte:=0x00, cntr:=sizeof(_PDOSETTINGS));
//  
//  DefaultPDOSetting(pPdoElement:=#sActPDOEntry, iAddressSetting:=0x1804, iCobId:=0x490);  
//  
//  // Pdo mapping parameter
//  sActPDOEntry.ActiveNbrOfMappings       := 1;
//  
//  sActPDOEntry.MappingPara[0].Index      := 16#1A04; // -1 = inactive
//  sActPDOEntry.MappingPara[0].Subindex   := 16#01; 
//  sActPDOEntry.MappingPara[0].Data       := 0;
//  
//  //mapping entrys are by default deactivated
//  //sActPDOEntry.MappingPara[1].Index      := -1;// -1 = inactive
//
//  //add Pdo with data from sActPDOEntry
//  RPDOAdditionalObject(pPDOElement:=#sActPDOEntry);  
//  
//  // ----------------------------------------------------------------------------------------
//  // RPDO 6, Device --> PLC -----------------------------------------------------------------
//  // ----------------------------------------------------------------------------------------
//  //reset local structure 
//  _memset(dest:=#sActPDOEntry, usByte:=0x00, cntr:=sizeof(_PDOSETTINGS));
//  
//  DefaultPDOSetting(pPdoElement:=#sActPDOEntry, iAddressSetting:=0x1805, iCobId:=0x491);  
//  
//  // Pdo mapping parameter
//  sActPDOEntry.ActiveNbrOfMappings       := 1;
//  
//  sActPDOEntry.MappingPara[0].Index      := 16#1A05; // -1 = inactive
//  sActPDOEntry.MappingPara[0].Subindex   := 16#01; 
//  sActPDOEntry.MappingPara[0].Data       := 0;
//  
//  //add Pdo with data from sActPDOEntry
//  RPDOAdditionalObject(pPDOElement:=#sActPDOEntry);  
    
  
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------  
  // -------------------             TRANSMIT Pdo-SETTINGS               --------------------
  // ----------------------------------------------------------------------------------------
  // if a valid xdc file is connected the Pdo settings are taken from the file --------------
  // if this is the case they must be commented out here! -----------------------------------
  // ----------------------------------------------------------------------------------------
  // Transmit Object Numbers ----------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  TPdo1.ObjNr := CO_TPDO1_OBJNR;
  TPdo2.ObjNr := CO_TPDO2_OBJNR;
  TPdo3.ObjNr := CO_TPDO3_OBJNR;
  TPdo4.ObjNr := CO_TPDO4_OBJNR;
  
  // ----------------------------------------------------------------------------------------
  // TPDO 1, PLC --> Device -----------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  //only needed if it is used, it is already deactivate at init
  DefaultPDOSetting(pPdoElement:=#TPdo1, iAddressSetting:=CO_INDEX_TPDO1_SETTING);
  
  // Pdo mapping parameter
  TPdo1.ActiveNbrOfMappings       := 1;   //-1; Deactivate that number of Mappings are send to the device
  
  TPdo1.MappingPara[0].Index      := CO_INDEX_TPDO1_MAPPING; // -1 = inactive
  TPdo1.MappingPara[0].Subindex   := 16#01; 
  TPdo1.MappingPara[0].Data       := 0;
  
//  TPdo1.MappingPara[1].Index      := CO_INDEX_TPDO1_MAPPING; // -1 = inactive
//  TPdo1.MappingPara[1].Subindex   := 16#02; 
//  TPdo1.MappingPara[1].Data       := 0;  
  
  // ----------------------------------------------------------------------------------------
  // TPDO 2, PLC --> Device -----------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  //only needed if it is used, it is already deactivate at init
  DefaultPDOSetting(pPdoElement:=#TPdo2, iAddressSetting:=CO_INDEX_TPDO2_SETTING);
  
  // Pdo mapping parameter
  TPdo2.ActiveNbrOfMappings       := 1;   //-1; Deactivate that number of Mappings are send to the device
  
  TPdo2.MappingPara[0].Index      := CO_INDEX_TPDO2_MAPPING; // -1 = inactive
  TPdo2.MappingPara[0].Subindex   := 16#01; 
  TPdo2.MappingPara[0].Data       := 0;
  
  // ----------------------------------------------------------------------------------------
  // TPDO 3, PLC --> Device -----------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  //only needed if it is used, it is already deactivate at init
  
  
  // ----------------------------------------------------------------------------------------
  // TPDO 4, PLC --> Device -----------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  //only needed if it is used, it is already deactivate at init
    
    
//  //********************************************************************************************************************************
//  //if additional TPdo's are needed they can added here
//  //********************************************************************************************************************************
//  // ----------------------------------------------------------------------------------------
//  // TPDO 5, Device --> PLC -----------------------------------------------------------------
//  // ----------------------------------------------------------------------------------------
//  //reset local structure 
//  _memset(dest:=#sActPDOEntry, usByte:=0x00, cntr:=sizeof(_PDOSETTINGS));
//  
//  DefaultPDOSetting(pPdoElement:=#sActPDOEntry, iAddressSetting:=0x1404, iCobId:=0x510);  
//  
//  // Pdo mapping parameter
//  sActPDOEntry.ActiveNbrOfMappings       := 1;
//  
//  sActPDOEntry.MappingPara[0].Index      := 16#1604; // -1 = inactive
//  sActPDOEntry.MappingPara[0].Subindex   := 16#01; 
//  sActPDOEntry.MappingPara[0].Data       := 0;
//  
//  //mapping entrys are by default deactivated
//  //sActPDOEntry.MappingPara[1].Index      := -1;// -1 = inactive
//
//  //add Pdo with data from sActPDOEntry
//  TPDOAdditionalObject(pPDOElement:=#sActPDOEntry);  
//  
//  // ----------------------------------------------------------------------------------------
//  // TPDO 6, Device --> PLC -----------------------------------------------------------------
//  // ----------------------------------------------------------------------------------------
//  //reset local structure 
//  _memset(dest:=#sActPDOEntry, usByte:=0x00, cntr:=sizeof(_PDOSETTINGS));
//  
//  DefaultPDOSetting(pPdoElement:=#sActPDOEntry, iAddressSetting:=0x1405, iCobId:=0x511);  
//  
//  // Pdo mapping parameter
//  sActPDOEntry.ActiveNbrOfMappings       := 1;
//  
//  sActPDOEntry.MappingPara[0].Index      := 16#1605; // -1 = inactive
//  sActPDOEntry.MappingPara[0].Subindex   := 16#01; 
//  sActPDOEntry.MappingPara[0].Data       := 0;
//  
//  //add Pdo with data from sActPDOEntry
//  TPDOAdditionalObject(pPDOElement:=#sActPDOEntry); 
//  

END_FUNCTION

// Overload this function to set some application
// specific Parameter during initialization
FUNCTION VIRTUAL GLOBAL _CanOpenBasicDS301::UserSettings
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
    Hlpretcode  : iprStates;
    HlpIndex    : INT;
    HlpSubIndex : SINT;
    HlpData     : DINT; 
    HlpRW       : BOOL;
    HlpLen      : USINT;
    HlpRetData  : DINT;
  END_VAR; 
  
  retcode := 0;
  
  //**********************************************************************************************
  // USER SETTINGS HANDLING
  //**********************************************************************************************
  case PDOIniSSW of
  
    0:// USER SDO TABLE --------------------------------------------------------------------------
      if (IsClientConnected(#SDOTable) = 1) then
      
        pSDOTable$DINT := SDOTable.GetTabPtr(); // Get the pointer of table with user parameter
        if (pSDOTable <> NIL) then
          // dSDOTabCounter ... number of lines in the table
          // 1st 4 bytes in  table contain number of bytes in table (excluding 1st 4 bytes where the size in bytes is stored)
          dSDOTabCounter := pSDOTable^ / 8;       // Size of all values for on Parameter(One Line in Table)
                                                  // Sizeof(Index) + sizeof(SubIndex) + sizeof(Data) + sizeof(DataLength) = 8Byte;
          // move the pointer to the start of the table data
          pSDOTable += sizeof(DINT);
          PDOIniSSW := 1;
          return;
        
        else
          // FINISHED ------------------------------------------------------------------------------
          PDOIniSSW := 2;
          return;
          
        end_if;
        
      else
        // FINISHED ------------------------------------------------------------------------------
        PDOIniSSW := 2;
        return;
        
      end_if;
      
    1:// USER PARAMETER --------------------------------------------------------------------------   
      HlpIndex    := pSDOTable^$INT;
      HlpSubIndex := (pSDOTable + sizeof(INT))^$SINT;
      HlpData     := (pSDOTable + sizeof(INT) + sizeof(SINT))^;
      HlpRW       := 1;
      HlpLen      := (pSDOTable + sizeof(INT) + sizeof(SINT) + sizeof(DINT))^$USINT;
       
    2:// NODEGUARDING PARAMETER ------------------------------------------------------------------
      if (NodeGuardingSupported = 1) then
      
        HlpIndex    := GuardTime.Index;
        HlpSubIndex := GuardTime.SubIndex$SINT; 
        HlpData     := GuardTime.Data$DINT; 
        HlpRW       := 1; 
        HlpLen      := 2;
      
      // PRODUCER HEARTBEAT PARAMETER ------------------------------------------------------------
      elsif (ProducerHeartbeatSupported = 1) then
      
        HlpIndex    := Heartbeat.Index;
        HlpSubIndex := Heartbeat.SubIndex$SINT; 
        HlpData     := Heartbeat.Data$DINT; 
        HlpRW       := 1; 
        HlpLen      := 2;
        
        udTimeStampHB := ops.tAbsolute;
        
      else
        // FINISHED --------------------------------------------------------------------------------
        PDOIniSSW := 0;
        retcode   := 1;
        return;
      
      end_if;
      
    3:// NODEGUARDING PARAMETER ------------------------------------------------------------------
      if (NodeGuardingSupported = 1) then
      
        HlpIndex    := LifetimeFactor.Index;
        HlpSubIndex := LifetimeFactor.SubIndex$SINT; 
        HlpData     := LifetimeFactor.Data$DINT;
        HlpRW       := 1; 
        HlpLen      := 1;
        
      else
        // FINISHED --------------------------------------------------------------------------------
        PDOIniSSW := 0;
        retcode   := 1;
        return;
        
      end_if;
      
    4:// FINISHED --------------------------------------------------------------------------------
      PDOIniSSW := 0;
      retcode   := 1;
      return;
      
  END_CASE;
  //**********************************************************************************************
  // END USER SETTINGS HANDLING
  //**********************************************************************************************
  
  
  //**********************************************************************************************
  // ASYNC DATA HANDLING
  //**********************************************************************************************
  
  HlpRetcode := AsyncSDOHandling(pHandle  := #HlpHandleInit
                              , iIndex    := HlpIndex
                              , siSubIndex:= HlpSubIndex
                              , dData     := HlpData
                              , bRW       := HlpRW
                              , usLength  := HlpLen  
                              , pAsyncData:= #HlpRetData
                              );
                              
  // Send SDO --------------------------------------------------
  if HlpRetcode = READY then
  
  // Send SDO was not successful -------------------------------
  elsif HlpRetcode = ERROR then
    //set class to error if required or there is no communication to node 
    if Required | HlpRetData = CO_CAN_DEVICE_NOANSWER then
      OpMode      := _CAN_COMERROR;
      DeviceState := _CanOpenMng::_CAN_COMERROR;
      //init is aborted with com error to node
      InitSSW     := 200;
    else
      //error sending SDO table parameter
      if (PDOIniSSW <> 1) then
        PDOIniSSW += 1;
      else// Send user Parameter 
        dSDOTabCounter -= 1;
        if (dSDOTabCounter <= 0) then // this is the end of the table
          PDOIniSSW += 1;             // table data have been sent so go on with node guarding and heartbeat
        else                          // still at least 1 line in the table to send
          pSDOTable := pSDOTable + 8; // move pointer to next line of table
        end_if;
      end_if;
    end_if;  
  
  // Send SDO was successful ------------------------------------  
  elsif HlpRetcode = QUIT then
    if (PDOIniSSW <> 1) then
      PDOIniSSW += 1;
    else// Send user Parameter 
      dSDOTabCounter -= 1;
      if (dSDOTabCounter <= 0) then // this is the end of the table
        PDOIniSSW += 1;             // table data have been sent so go on with node guarding and heartbeat
      else                          // still at least 1 line in the table to send
        pSDOTable := pSDOTable + 8; // move pointer to next line of table
      end_if;
    end_if;
  end_if;    
  
  //****************************************************************************************************
  // END ASYNC DATA HANDLING
  //****************************************************************************************************    
  
END_FUNCTION

// Check Rx Timeout
FUNCTION VIRTUAL _CanOpenBasicDS301::CheckRxPdo
	VAR_OUTPUT
		dRetCode 	: DINT;
	END_VAR
  VAR
    tempTime  : UDINT;
    uiTmpCnt  : UINT;
    pActPDOEntry : ^_PDOSETTINGS;
  END_VAR

  // ------------------------------------------------------------
  // Monitoring if Pdo´s received cyclic ------------------------
  // ------------------------------------------------------------
  //reset output variable
  dRetCode := 0;
  
  if (ChkRxPdo = 1) & (OpMode = _CAN_SYNC) then
    if RPdo1.active = TRUE then                   // RPDO 1
      tempTime := TimeRPdo1;                      // we have to save the timestamp before the if, because TimeRPdo is set in interrupt, and this could lead to TimeRPdo be 1 bigger then ops.tabsolute.
      if ops.tAbsolute - tempTime > udRPdoTimeout & bRPdo1Rec = TRUE then // Timeout error
        dRetCode := -1;
      end_if;
    end_if;
    if RPdo2.active = TRUE then                   // RPDO 2
      tempTime := TimeRPdo2;                      // we have to save the timestamp before the if, because TimeRPdo is set in interrupt, and this could lead to TimeRPdo be 1 bigger then ops.tabsolute.
      if ops.tabsolute - tempTime > udRPdoTimeout & bRPdo2Rec = TRUE then // Timeout error
        dRetCode := -2;
      end_if;
    end_if;
    if RPdo3.active = TRUE then                   // RPDO 3
      tempTime := TimeRPdo3;                      // we have to save the timestamp before the if, because TimeRPdo is set in interrupt, and this could lead to TimeRPdo be 1 bigger then ops.tabsolute.
      if ops.tabsolute - tempTime > udRPdoTimeout & bRPdo3Rec = TRUE then // Timeout error
        dRetCode := -3;
      end_if;
    end_if;
    if RPdo4.active = TRUE then                   // RPDO 4
      tempTime := TimeRPdo4;                      // we have to save the timestamp before the if, because TimeRPdo is set in interrupt, and this could lead to TimeRPdo be 1 bigger then ops.tabsolute.
      if ops.tabsolute - tempTime > udRPdoTimeout & bRPdo4Rec = TRUE then // Timeout error
        dRetCode := -4;
      end_if;
    end_if;
    
    // check timeout of additional RPdo if some exists
    if sPDOAdditionalVars.bRxAdditionalUsed then
      //set pointer to first additional RPdo
      pActPDOEntry := #RPdoAdditional;
      for uiTmpCnt := 0 to sPDOAdditionalVars.uiRPDOUsed-1 do      
        if pActPDOEntry^.active = TRUE then                                   // additional RPDO
          tempTime := sPDOAdditionalVars.RxVars[uiTmpCnt+CO_NUMBER_DEFAULT_PDO].udTimeStamp;        // we have to save the timestamp before the if, because TimeRPdo is set in interrupt, and this could lead to TimeRPdo be 1 bigger then ops.tabsolute.
          if ops.tabsolute - tempTime > udRPdoTimeout & sPDOAdditionalVars.RxVars[uiTmpCnt+CO_NUMBER_DEFAULT_PDO].bRPdoRec = TRUE then // Timeout error
            dRetCode := -(uiTmpCnt+CO_NUMBER_DEFAULT_PDO+1);
          end_if;
        end_if;
        //set pointer to next additional Pdo and check for validity
        pActPDOEntry := pActPDOEntry^.pNextPDO;
        if pActPDOEntry = NIL then
          // pointer is not valid -> exit for loop
          exit;
        end_if;
      end_for;
    end_if;
    
    // if one of the RPdo's have a timeout set an error
    if dRetCode < 0 
    | ((ops.tAbsolute-udCheckRxPDOTimeout) >= CO_CANPDOTIMEOUT_FIRSTPDO & DataReady = FALSE) then
      CanDisabled := 1;
      OpMode      := _CAN_COMERROR;
      DeviceState := _CanOpenMng::_CAN_COMERROR;
    end_if;
  else
    //check of rx Pdo is deactivated or wrong OpMode
    dRetCode := 1;
  end_if;
  
END_FUNCTION

// Get State of asyncrounous communication
FUNCTION VIRTUAL _CanOpenBasicDS301::GetAsyncState
  VAR_INPUT
    Handle     : ^DINT;
  END_VAR
  VAR_OUTPUT
    retcode   : iprStates;
  END_VAR
  // -------------------------------------------------------------
  // Get SDO state -----------------------------------------------
  // -------------------------------------------------------------
  retcode := AsyncState;
  
  if ( AsyncState = READY ) | ( Handle^ = sDataSDO.SdoHandle ) then
    Handle^ := sDataSDO.SdoHandle;
  else 
    Handle^ := 0;
  end_if;

END_FUNCTION

//Do a asynconous command
FUNCTION VIRTUAL _CanOpenBasicDS301::AsyncCmd
  VAR_INPUT
    Index   : INT;
    SubIndex   : SINT;
    Data   : DINT;
    RW   : BOOL;
    Len   : USINT;
  END_VAR
  VAR_OUTPUT
    RetCode   : DINT;
  END_VAR
  // -------------------------------------------------------------
  // Send SDO ----------------------------------------------------
  // -------------------------------------------------------------
  // Check if can object is initialized
  
  //initialze return code with no sdo object to process
  RetCode := -100;
  
  if HandleRxObjSdo >= 0 then
  
    if AsyncState = READY then
      
      AsyncState    := BUSY;             // --> BUSY
      RequestTimeOut := ops.tAbsolute;

      RetCode :=SendSDO(Index    := Index$HINT, 
                        SubIndex := SubIndex$HSINT, 
                        Data     := Data$HDINT, 
                        Length   := Len,
                        RW       := RW);            // Read/Write Data 
                        
                       
      if RetCode = 4 & bResetCom then //try again if buffer was full!
        RetCode := SendSDO( Index     := Index$HINT, 
                            SubIndex  := SubIndex$HSINT, 
                            Data      := Data$HDINT, 
                            Length    := Len,
                            RW        := RW);            // Read/Write Data 
        
      end_if;
    else
      //Async State is not ready
      RetCode := -101;  
    end_if;    
  end_if;
    
END_FUNCTION

// Wait for incomming SDO
FUNCTION VIRTUAL _CanOpenBasicDS301::SdoProcess
  // -------------------------------------------------------------
  // Check SDO Timeout error -------------------------------------
  // -------------------------------------------------------------
  case AsyncState of 

    BUSY:// Wait for SDO 
    // ------------------------ TIMEOUT ERROR -----------------------
      if (OPS.tabsolute - RequestTimeOut > CO_CAN_DEVICE_TIMEOUT) then
        AsyncState := ERROR;
        sDataSDO.LastSdoData := CO_CAN_DEVICE_NOANSWER; 
      end_if;     

  END_CASE;

END_FUNCTION

// Check incomming SDO
FUNCTION VIRTUAL _CanOpenBasicDS301::SDOCheck
  VAR
    CANData     : _CAN_STRUCT;
  END_VAR
  
  //copy received sdo data to local buffer
  CANData := RxBufferSdo$_CAN_STRUCT;
  
  // -------------------------------------------------------------
  // Check received SDO ------------------------------------------
  // -------------------------------------------------------------  
  if AsyncState = BUSY then
  
    ComSDO.hsCMD := CANData.CMD ;
  
    if CANData.CMD <> SDO_RwError then // SDO error 16#80 
      // -----------------------------------------------------------------------------------------------------
      // --------------------------       Expedited Read                     ---------------------------------
      // -----------------------------------------------------------------------------------------------------
      //  CommandCode
      //  Bits       	Value 	Meaning
      //  7-5 	      010b    SCS  Server Command Specifier
      //  4 	        0 	    (Not Used) Segment toggle bit
      //  3-2 	      (n)     Data size	
      //                      n=3 (11b) 1 data bytes received
      //                      n=2 (10b) 2 data bytes received
      //                      n=1 (01b) 3 data byte received 
      //                      n=0 (00b) 4 data byte received 
      //  1 					1 	  	expedited transfer
      //  0 					1       data set size is indicated
  
                                // Command Code Meaning
      if CANData.CMD = 16#43 |         // 0x43 	Read Dictionary Object reply, expedited, 4 bytes received
         CANData.CMD = 16#47 |         // 0x47 	Read Dictionary Object reply, expedited, 3 bytes received
         CANData.CMD = 16#4B |         // 0x4B 	Read Dictionary Object reply, expedited, 2 bytes received
         CANData.CMD = 16#4F |         // 0x4F 	Read Dictionary Object reply, expedited, 1 bytes received
         CANData.CMD = 16#42 |         // Receive data successfully
         CANData.CMD = 16#60 then      // Send data successfully
    
        ComSDO.dRxCounter += 1;
        AsyncState       := QUIT;  // wait until retcode gets read from 
                                    // this class (method:GetAsyncData)
      end_if;
      
    else
    
      AsyncState        := ERROR;  // Received data not successful
      
    end_if;
    
  end_if;
  
  sDataSDO.LastSDOData := CANData.Data$DINT;
  
END_FUNCTION

// Get data of asynchronous command
FUNCTION VIRTUAL _CanOpenBasicDS301::GetAsyncData
  VAR_INPUT
    Handle     : DINT;
    pBuffer   : ^HSINT;
  END_VAR
  VAR_OUTPUT
    retcode   : DINT;
  END_VAR
  // -------------------------------------------------------------
  // Copy received SDO in the buffer
  // -------------------------------------------------------------
  // If last action was a read asynchron, we have to wait 
  // until the data gets read from this function
  if (( AsyncState = QUIT )|( AsyncState = ERROR )) & 
      ( Handle = sDataSDO.SdoHandle )                           then

    retcode   := sDataSDO.LastSdoData;
    sDataSDO.SdoHandle += 1;

    // Copy Last sendet sdo buffer
    if pBuffer <> NIL then
      _MemCpy(pBuffer, #RxBufferSdo[0], sizeof(RxBufferSdo));
    end_if;

    // Sdo Handle can not be 0
    if sDataSDO.SdoHandle = 0 then
      sDataSDO.SdoHandle := 100;
    end_if;

    AsyncState := READY;
  
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _CanOpenBasicDS301::AddCanObjects
  VAR
    iTempObjNumber      :INT;
    pActPDOEntry        : ^_PDOSETTINGS;
  END_VAR;
  // ---------------------------------------------------------------------------------------------
  // Initialization for all CanObjects -----------------------------------------------------------
  // ---------------------------------------------------------------------------------------------
  //**********************************************************************************************
  // INITIALIZATION CANOBJECTS HANDLING
  //**********************************************************************************************
  
  
  // add all Rx CanObjects ------------------------------------------------------------------
  // -----------------------------------------------------------------------------------------
  // ADD Can Objects -------------------------------------------------------------------------
  // -----------------------------------------------------------------------------------------  
  // NODE GUARDING ---------------------------------------------------------------------------
  if NodeGuardingSupported = 1 then
    HandleRxNG := MasterDevice.AddCanObjRx(ObjNr      :=NgObjNr + TO_INT(Place)       // Objectnumber
                                          ,Length     :=1                              // Byteanzahl  
                                          ,ActionPtr  := #ReceiveNG()                  // IRQ Routine 
                                          ,ThisPointer:=this
                                          ,UseIso     :=FALSE);                        // don´t Use CanLibIso if needed

  // HEARTBEAT -------------------------------------------------------------------------------
  elsif ProducerHeartbeatSupported = 1 | CheckNMTState = 1 then //add object for nmt message if activated
    HandleRxObjHB := MasterDevice.AddCanObjRx(ObjNr     := NgObjNr + TO_INT(Place)       // Objectnumber
                                            ,Length     :=1                              // Byteanzahl  
                                            ,ActionPtr  := #ReceiveHB()                  // IRQ Routine 
                                            ,ThisPointer:=this
                                            ,UseIso     :=FALSE);                        // don´t Use CanLibIso if needed

  end_if;

  // SDO CHANNEL -----------------------------------------------------------------------------
  HandleRxObjSdo := MasterDevice.AddCanObjRx(ObjNr      := RSdoObjNr + TO_INT(Place)      // Objectnumber
                                            ,Length     := 8                              // Byteanzahl  
                                            ,ActionPtr  := #ReceiveSDO()                  // IRQ Routine 
                                            ,ThisPointer:=this
                                            ,UseIso     :=FALSE);                        // don´t Use CanLibIso if needed
                                     

  HandleTxObjSdo := MasterDevice.AddCanObjTx(ObjNr  :=TSdoObjNr + TO_INT(Place)    // Objectnumber
                                            ,Length := 8);     
                                     
   
  // EMERGENCY CHANNEL -----------------------------------------------------------------------
  if DisableEmergencyObject = 0 then
    HandleRxObjEMCY := MasterDevice.AddCanObjRx(ObjNr     := EmcyObjNr + TO_INT(Place)      // Objectnumber
                                              ,Length     := 8                              // Byteanzahl  
                                              ,ActionPtr  := #ReceiveEMCY()                 // IRQ Routine 
                                              ,ThisPointer:=this
                                              ,UseIso     :=FALSE);                        // don´t Use CanLibIso if needed
                                                                           
  end_if;

   
  // -----------------------------------------------------------------------------------------
  // ADD RPDO Can Objects --------------------------------------------------------------------
  // -----------------------------------------------------------------------------------------  
  // RPDO1 -----------------------------------------------------------------------------------
  if RPdo1.active = TRUE then
  
    iTempObjNumber := RPdo1.ObjNr + TO_INT(Place);
    
    RPdo1.HandleObj := MasterDevice.AddCanObjRx(ObjNr     := iTempObjNumber         // Objectnumber
                                              ,Length     := 8                      // Byteanzahl  
                                              ,ActionPtr  := #ReceivePdo1()         // IRQ Routine 
                                              ,ThisPointer:=this
                                              ,UseIso     :=TRUE);                 // don´t Use CanLibIso if needed

        
  end_if;
  
  // RPDO2 -----------------------------------------------------------------------------------
  if RPdo2.active = TRUE then
  
    iTempObjNumber := RPdo2.ObjNr + TO_INT(Place);
    
    RPdo2.HandleObj := MasterDevice.AddCanObjRx(ObjNr     := iTempObjNumber         // Objectnumber
                                              ,Length     := 8                      // Byteanzahl  
                                              ,ActionPtr  := #ReceivePdo2()         // IRQ Routine 
                                              ,ThisPointer:=this
                                              ,UseIso     :=TRUE);                 // don´t Use CanLibIso if needed    
                  
  end_if;
  
  // RPDO3 -----------------------------------------------------------------------------------
  if RPdo3.active = TRUE then

    iTempObjNumber := RPdo3.ObjNr + TO_INT(Place);
    
    RPdo3.HandleObj := MasterDevice.AddCanObjRx(ObjNr     := iTempObjNumber         // Objectnumber
                                              ,Length     := 8                      // Byteanzahl  
                                              ,ActionPtr  := #ReceivePdo3()         // IRQ Routine 
                                              ,ThisPointer:=this
                                              ,UseIso     :=TRUE);                 // don´t Use CanLibIso if needed

                   
  end_if;
  
  // RPDO4 -----------------------------------------------------------------------------------
  if RPdo4.active = TRUE then
    
    iTempObjNumber := RPdo4.ObjNr + TO_INT(Place);
    
    RPdo4.HandleObj := MasterDevice.AddCanObjRx(ObjNr     := iTempObjNumber         // Objectnumber
                                              ,Length     := 8                      // Byteanzahl  
                                              ,ActionPtr  := #ReceivePdo4()         // IRQ Routine 
                                              ,ThisPointer:=this
                                              ,UseIso     :=TRUE);                 // don´t Use CanLibIso if needed
              
  end_if;  
  
  pActPdoEntry := #RPdo4;
  sPDOAdditionalVars.uiRPDOUsed := 0;
  
  //check for additional receive Pdo data
  while pActPdoEntry^.pNextPDO <> NIL do
    pActPdoEntry := pActPdoEntry^.pNextPDO;
    sPDOAdditionalVars.uiRPDOUsed += 1;
    
    if pActPdoEntry^.active = TRUE then
    
      //if a RPdo higher then default RPdo's (1-4) is used, it is an additional RPdo
      sPDOAdditionalVars.bRxAdditionalUsed := TRUE;
      
      iTempObjNumber    := pActPdoEntry^.ObjNr + TO_INT(Place);
      
      pActPdoEntry^.HandleObj := MasterDevice.AddCanObjRx(ObjNr     := iTempObjNumber        // Objectnumber
                                                        ,Length     := 8                     // Byteanzahl  
                                                        ,ActionPtr  := #RxAdditionalPDO()    // IRQ Routine 
                                                        ,ThisPointer:=this
                                                        ,UseIso     :=TRUE);                 // don´t Use CanLibIso if needed
                            
    end_if;
  
  end_while;
  


  // add Tx Pdo CanObjects if necessary
  // ---------------------------------------------------------------------------------------       
  // ---------------------------------------------------------------------------------------
  // ADD TPDO Can Objects ------------------------------------------------------------------
  // ---------------------------------------------------------------------------------------
  // TPDO1 ---------------------------------------------------------------------------------
  if TPdo1.active = TRUE then
  
    iTempObjNumber := TPdo1.ObjNr + TO_INT(Place);
    
    TPdo1.HandleObj := MasterDevice.AddCanObjTx(iTempObjNumber,              // Objectnumber
                                                   8);       
         
    
  end_if;    
  
  // TPDO2 ---------------------------------------------------------------------------------
  if TPdo2.active = TRUE then
    
    iTempObjNumber := TPdo2.ObjNr + TO_INT(Place);
    
    TPdo2.HandleObj := MasterDevice.AddCanObjTx(iTempObjNumber,              // Objectnumber
                                                   8);       
         
           
  end_if;
  
  // TPDO3 ---------------------------------------------------------------------------------
  if TPdo3.active = TRUE then
  
    iTempObjNumber := TPdo3.ObjNr + TO_INT(Place);
    
    TPdo3.HandleObj := MasterDevice.AddCanObjTx(iTempObjNumber,              // Objectnumber
                                                   8);       
         
  end_if;    
  
  // TPDO4 ---------------------------------------------------------------------------------
  if TPdo4.active = TRUE then
    
    iTempObjNumber := TPdo4.ObjNr + TO_INT(Place);
    
    TPdo4.HandleObj := MasterDevice.AddCanObjTx(iTempObjNumber,              // Objectnumber
                                                   8);       

  end_if;    
  
  pActPdoEntry := #TPdo4;
  sPDOAdditionalVars.uiTPDOUsed := 0;
  
  //check for additional transmit Pdo data
  while pActPdoEntry^.pNextPDO <> NIL do
    pActPdoEntry := pActPdoEntry^.pNextPDO;
    sPDOAdditionalVars.uiTPDOUsed += 1;
    
    if pActPdoEntry^.active = TRUE then
      sPDOAdditionalVars.TxVars[CO_NUMBER_DEFAULT_PDO+sPDOAdditionalVars.uiTPDOUsed].bSendFlag := TRUE;
      
      //if a TPdo higher then default TPdo's (1-4) is used, it is an additional TPdo
      sPDOAdditionalVars.bTxAdditionalUsed := TRUE;
    
      iTempObjNumber    := pActPdoEntry^.ObjNr + TO_INT(Place);
      
      pActPdoEntry^.HandleObj := MasterDevice.AddCanObjTx(iTempObjNumber,         // Objectnumber
                                                     8);         
    end_if;
  
  end_while;
  

  // Initialize can node -------------------------------------------------------------------------
  OpMode  := _CAN_INIT;
  if CheckNMTState = 1 then
    //reset communication for init of node
    SetNmt(Para:=CO_RESETCOMMUNICATION);
    udWaitInitNode := ops.tAbsolute;
  end_if;
  //reset initialization ssw
  InitSSW   := 0;
  PDOIniSSW := 0;
  
END_FUNCTION //AddCanObjects


FUNCTION GLOBAL _CanOpenBasicDS301::SetSDOobjData
  VAR_INPUT
    Active   : BOOL;
    Index   : INT;
    SubIndex   : SINT;
    Data   : DINT;
    RW   : BOOL;
    Len   : USINT;
    pThis   : ^void;
    pCallBack   : ^void;
  END_VAR
  VAR_OUTPUT
    Retcode   : INT;
  END_VAR
  VAR
    usTmpcnt  : USINT;
    bFoundEmptyPlace : bool;
  END_VAR
  // ----------------------------------------------------------------------
  // INITIALIZATION USER SDO OBJECTS --------------------------------------
  // ----------------------------------------------------------------------
  Retcode := -1;
  
  bFoundEmptyPlace := FALSE;
  if sDataSDO.pSdoData = NIL then
    bFoundEmptyPlace := TRUE;
    sDataSDO.pSdoData$pVoid := StdLib.Malloc(size:=sizeof(_DataSDO)); 
    sDataSDO.pActSdoEntry := sDataSDO.pSdoData;
  else  
    sDataSDO.pActSdoEntry := sDataSDO.pSdoData;
    // Check if enough memory allocated
    for usTmpcnt := 0 to 31 do
      if sDataSDO.pActSdoEntry^.pNextSDO = NIL then
        bFoundEmptyPlace := TRUE;
        sDataSDO.pActSdoEntry^.pNextSDO$pVoid := StdLib.Malloc(size:=sizeof(_DataSDO)); 
        sDataSDO.pActSdoEntry := sDataSDO.pActSdoEntry^.pNextSDO;       
        exit;      
      end_if;
      sDataSDO.pActSdoEntry := sDataSDO.pActSdoEntry^.pNextSDO;
    end_for;
  end_if;  
  
  if (sDataSDO.pActSdoEntry = NIL) | bFoundEmptyPlace = FALSE then  // Allocate error
    ErrorAlloc := 1;
  end_if;  

  // Write SDO object data into allocate memory
  if (ErrorAlloc = 0) then
   
    sDataSDO.usNoSDOobj += 1;
        
    sDataSDO.pActSdoEntry^.pThis     := pThis;
    sDataSDO.pActSdoEntry^.pCallBack := pCallBack;
    sDataSDO.pActSdoEntry^.Active    := Active;
    sDataSDO.pActSdoEntry^.Index     := Index;
    sDataSDO.pActSdoEntry^.SubIndex  := SubIndex;
    sDataSDO.pActSdoEntry^.Data      := Data;
    sDataSDO.pActSdoEntry^.RW        := RW;
    sDataSDO.pActSdoEntry^.Len       := Len;
    sDataSDO.pActSdoEntry^.pNextSDO  := NIL;
    
    sDataSDO.udBufferSizeSDO += sizeof(_DataSDO);
    Retcode := sDataSDO.usNoSDOobj;
    
  end_if;

END_FUNCTION


FUNCTION VIRTUAL _CanOpenBasicDS301::ReadWriteUserSDO
  VAR
    HlpRetcode : iprStates;
    HlpRetData : DINT;
  END_VAR
  // ----------------------------------------------------------------------
  // READ/WRITE HANDLING for USER SDO OBJECTS -----------------------------
  // ----------------------------------------------------------------------
  if (ErrorAlloc = 0) then
    // Check if there user SDO objets
    if (sDataSDO.usNoSDOobj > 0) then
    
      HlpRetcode := GetAsyncState(#HlpHandleRWSDO);                             // Get SDO state
      
      // If Canbus ready for send SDO, check if the next SDO is active
      if (HlpRetcode = READY) then
        // If the next SDO inactive, search the next active SDO
        // Search the next active SDO
        sDataSDO.pActSdoEntry    := sDataSDO.pActSdoEntry^.pNextSDO;          // Get the SDO data for sending SDO
        if sDataSDO.pActSdoEntry <> NIL then
          while (sDataSDO.pActSdoEntry^$_DataSDO.Active = 0) do
            sDataSDO.pActSdoEntry    := sDataSDO.pActSdoEntry^.pNextSDO;          // Get the SDO data for sending SDO
            sDataSDO.usCounterSDOobj += 1;
            if sDataSDO.pActSdoEntry = NIL then
              //go back to first entry
              sDataSDO.pActSdoEntry    := sDataSDO.pSdoData;               
              sDataSDO.usCounterSDOobj := 0;
              if (sDataSDO.pActSdoEntry^$_DataSDO.Active = 0) then
                return;
              else
                exit;                
              end_if;
            end_if;
          end_while; 
        else
          //go back to first entry
          sDataSDO.pActSdoEntry    := sDataSDO.pSdoData;    // No active SDO found
          sDataSDO.usCounterSDOobj := 0;
          if (sDataSDO.pActSdoEntry^$_DataSDO.Active = 0) then
            return;
          end_if;
        end_if;
      end_if;
      
      //**********************************************************************************************
      // ASYNC DATA HANDLING
      //**********************************************************************************************
      
      HlpRetcode := AsyncSDOHandling(pHandle  := #HlpHandleRWSDO
                                  , iIndex    := sDataSDO.pActSdoEntry^.Index
                                  , siSubIndex:= sDataSDO.pActSdoEntry^.SubIndex
                                  , dData     := sDataSDO.pActSdoEntry^.Data
                                  , bRW       := sDataSDO.pActSdoEntry^.RW
                                  , usLength  := sDataSDO.pActSdoEntry^.Len
                                  , pAsyncData:= #HlpRetData
                                  );
                                  
      // Send SDO --------------------------------------------------
      if HlpRetcode = READY then
        // Increase TxCounter from the SDO object        
        CallBack(udTxCount   := 1,
                udRxCount    := 0,
                udErrorCount := 0,
                dData        := 0);
                
      // Send SDO was not successful ------------------------------------ 
      elsif HlpRetcode = ERROR then 
        //don't stop the manager class - error is displayed on the sdo object
        //opMode      := _CAN_COMERROR;
        //DeviceState := _CanOpenMng::_CAN_COMERROR;    
        // Increase ErrorCounter from the SDO object
        // and send the errorcode        
        CallBack(udTxCount  := 0,
               udRxCount    := 0,
               udErrorCount := 1,
               dData        := HlpRetData);
               
        sDataSDO.usCounterSDOobj += 1;
        
      // Send SDO was successful ------------------------------------ 
      elsif HlpRetcode = QUIT then
        // Increase rxCounter from the SDO object
        // and send the data                  
        CallBack(udTxCount  := 0,
               udRxCount    := 1,
               udErrorCount := 0,
               dData        := HlpRetData);
        
        sDataSDO.usCounterSDOobj += 1;      
      end_if;      
    end_if;
    
  end_if;

END_FUNCTION


FUNCTION GLOBAL _CanOpenBasicDS301::ChangeSDOobjData
	VAR_INPUT
		NumberSDO 	: INT;
		Active 	: BOOL;
		Index 	: INT;
		SubIndex 	: SINT;
		Data 	: DINT;
		RW 	: BOOL;
		Len 	: USINT;
		bOnlyChangeActive 	: BOOL;(* := FALSE *)
	END_VAR
	VAR_OUTPUT
		Retcode 	: INT;
	END_VAR
  VAR
    pTempData : ^_DataSDO;
    usTmpcnt  : USINT;
    bFoundSDOEntry : BOOL;
  END_VAR
  // ----------------------------------------------------------------------
  // CHANGED DATA FROM A USER SDO OBJECT ----------------------------------
  // ----------------------------------------------------------------------
  Retcode := -1;
  // Check the number from SDO object
  if (NumberSDO > 0 & NumberSDO <= sDataSDO.usNoSDOobj) then
  
    // Write SDO object data into allocate memory
    if (ErrorAlloc = 0) then
      bFoundSDOEntry := TRUE;
      pTempData := sDataSDO.pSdoData;
      if NumberSDO > 1 then
        for usTmpcnt := 1 to NumberSDO-1 do
          if pTempData^.pNextSDO = NIL then
            bFoundSDOEntry := FALSE;
            exit;      
          end_if;
          pTempData := pTempData^.pNextSDO;
        end_for;      
      end_if;
      
      if bFoundSDOEntry then
        pTempData^.Active    := Active;
        
        if bOnlyChangeActive = FALSE then
          pTempData^.Index     := Index;
          pTempData^.SubIndex  := SubIndex;
          pTempData^.Data      := Data;
          pTempData^.RW        := RW;
          pTempData^.Len       := Len; 
        end_if;

        Retcode := 0; 
        
      end_if;      
    end_if;
    
  end_if;

END_FUNCTION



FUNCTION GLOBAL _CanOpenBasicDS301::GetComSDOData
  VAR_OUTPUT
    ComSDOData   : _ComSDO;
  END_VAR

  ComSDOData.hdTxRxResult   := ComSDO.hsCMD;
  ComSDOData.dTxCounter     := ComSDO.dTxCounter;
  ComSDOData.dRxCounter     := ComSDO.dRxCounter;
  ComSDOData.dErrCounter    := ComSDO.dErrorCounter;
  ComSDOData.hdLastErrCode  := ComSDO.hdErrorRetCode;
  ComSDOData.hdErrIndex     := ComSDO.hiIndex;
  ComSDOData.hdErrSubIndex  := ComSDO.hsSubIndex;
  ComSDOData.hdErrData      := ComSDO.hdData;
  ComSDOData.dErrRW         := ComSDO.bRW;
  ComSDOData.dErrLen        := ComSDO.usLen;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _CanOpenBasicDS301::CanControl
  VAR
    RetVal     : DINT;
    bTempDataReady : BOOL;
    uiTmpCnt : UINT;
  END_VAR
  
  //read Master status:
  MasterDevice := MasterDevice.Read();  
    
  if (MasterDevice = _CanOpenMng::_CAN_OPERATIONAL & CheckNMTState = 0)        // Master is ready
  | (DeviceState = _CanOpenMng::_CAN_OPERATIONAL  & CheckNMTState = 1) then   // Node is ready
    // Monitoring if Pdo´s received cyclic
    CheckRxPdo();
  else
    //Pdo is only at operational state enabled
    ResetReceiveFlag();
    //set timestamp for timeout check of Rx Pdo's
    udCheckRxPDOTimeout := ops.tAbsolute;
  end_if;  

  // -----------------------------------------------------------------------------------------------------
  // ----------------------           METHOD for ASYNCHRON DATA            -------------------------------
  // -----------------------------------------------------------------------------------------------------
  SdoProcess();  
    
  //******************************************************************************************************
  // DeviceState STATE MACHINE
  //******************************************************************************************************
  case CanDeviceState of
  
    //******************************************************************************************************
    _CAN_BOOT_UP:
      DeviceState := _CanOpenMng::_CAN_BOOT_UP;
      
    //******************************************************************************************************    
    _CAN_STOPPED:
      DeviceState := _CanOpenMng::_CAN_STOPPED;
    
    //******************************************************************************************************
    _CAN_OPERATIONAL:
      DeviceState := _CanOpenMng::_CAN_OPERATIONAL;
      
    //******************************************************************************************************
    _CAN_PRE_OPERATIONAL:
      DeviceState := _CanOpenMng::_CAN_PRE_OPERATIONAL;
      
  end_case;
  //******************************************************************************************************
  // END DeviceState STATE MACHINE
  //******************************************************************************************************
  
  
  //******************************************************************************************************
  // MAIN STATE MACHINE
  //******************************************************************************************************
  case OpMode of
  
    _CAN_IDLE:// Do Nothing ------------------------------------------------------------------------------
      NGErrorCounter := 0;      
    
    _CAN_INIT:// Initialize Device -----------------------------------------------------------------------
      InitSettingsAndPdos();
      
    _CAN_NGERROR:// -----------------------------------------------------------------------
      DeviceState := _CanOpenMng::_CAN_NGERROR;
      DataReady := 0;
    
    _CAN_COMERROR: // -----------------------------------------------------------------------
      DeviceState := _CanOpenMng::_CAN_COMERROR;
      DataReady := 0;
      
    _CAN_HBERROR: // -----------------------------------------------------------------------
      DeviceState := _CanOpenMng::_CAN_HBERROR;
      DataReady := 0;
      
    _CAN_NETENABLE:// Initialization successful ----------------------------------------------------------
    
      if MasterDevice = _CanOpenMng::_CAN_OPERATIONAL then            // Master is ready

        //during communication reset
        if bResetCom then
          RetVal := SetNmt(Para:= CO_STARTREMOTENODE);     // Start Remote Node(send operational)
          if RetVal = 4 then //if buffer is full, try one more time to send
            RetVal := SetNmt(Para:= CO_STARTREMOTENODE);
          end_if;
          bResetCom := False;
        end_if;
        
        OpMode       := _CAN_SYNC;         // Set State Machine to sync
        udTimeStampHB := ops.tAbsolute;

      end_if;        

      // SCHMAR2 301013 send first nodeguarding message to guarantee it's send when pdos start
      if OpMode = _CAN_SYNC
       & NodeGuardingSupported = 1 then 
       
        udTimestampNG := ops.tAbsolute;
        MasterDevice.SetFlagNG(handle:= HandleRxNG);         
      end_if;         
      
    _CAN_SYNC:// Run Communication -----------------------------------------------------------------------
      
      //only send Pdo data at operational state - or check nmt is not activated by class
      if ((NodeGuardingSupported | ProducerHeartbeatSupported) & DeviceState = _CanOpenMng::_CAN_OPERATIONAL)
      | (NodeGuardingSupported = 0 & ProducerHeartbeatSupported = 0) 
      | CheckNMTState = 0 then
        // if any Pdo data is received the data is ready
        bTempDataReady := bRPdo1Rec | bRPdo2Rec | bRPdo3Rec | bRPdo4Rec;
        //check for additional RPdo's
        if sPDOAdditionalVars.bRxAdditionalUsed then
          for uiTmpCnt := 0 to sPDOAdditionalVars.uiRPDOUsed-1 do
            bTempDataReady := bTempDataReady | sPDOAdditionalVars.RxVars[uiTmpCnt+CO_NUMBER_DEFAULT_PDO].bRPdoRec;
          end_for;
        end_if;
        
        DataReady := bTempDataReady;      
        
        // -------------------------------------------------------------------------------------------------
        // ----------------------             Send Pdo's           -----------------------------------------
        // -------------------------------------------------------------------------------------------------
        //sending of Pdo is only at operational device state allowed.
        SendAllPDOs();
      end_if;
      

      // -------------------------------------------------------------------------------------------------
      // -------------------------          NODEGUARDING        ------------------------------------------
      // -------------------------------------------------------------------------------------------------
      // SCHMAR2 30_10_2013 check if we got a nodeguard message -> errorcounter only increased after guardtime
      if NodeGuardingSupported = 1 then
        // send the NG request all defined ms.
        if (ops.tAbsolute - udTimestampNG >= GuardTime.Data$UDINT) then
          udTimestampNG := ops.tAbsolute;
          MasterDevice.SetFlagNG(handle:= HandleRxNG);
            // check if slave has send the NG-object
            if NGReceiveFlag = 1 then
              NGReceiveFlag   := 0;
              NGErrorCounter  := 0;
            else  
              NGErrorCounter += 1;
              if NGErrorCounter > Lifetimefactor.Data then
                DeviceState     := _CanOpenMng::_CAN_NGERROR;
                opmode          := _CAN_NGERROR;
                NGErrorCounter  := 0;
              end_if;
            end_if;      
        end_if;     
      // -------------------------------------------------------------------------------------------------
      // -------------------------         PRODUCER HEARTBEAT        -------------------------------------
      // -------------------------------------------------------------------------------------------------
      elsif (ProducerHeartbeatSupported = 1) then
        // Make slave send the object data
        if bHeartbeatRXFlag = TRUE then
          bHeartbeatRXFlag := FALSE;
        else
        
          if (ops.tAbsolute - udTimeStampHB) > PlcConsumerHeartBeat then  
          
            case (RxBufferHB[0]) of
            
              CO_HB_STOPPED, CO_HB_OPERATIONAL, CO_HB_PREOPERATIONAL:
                
                RxBufferHB[0] := 0;
                udTimeStampHB := ops.tAbsolute;
            
            else
              DeviceState := _CanOpenMng::_CAN_HBERROR;
              opMode      := _CAN_HBERROR;
            end_case;
           
          end_if;
        
        end_if;
      end_if;
    
    
    _CAN_NETDISABLE:// Disable Pdo receive on device ------------------------------------------------------
      
      SetNMT(Para:= CO_STOPREMOTENODE);// Stop Remote Node
      OpMode := _CAN_IDLE;
    
    _CAN_RESETNODE:// Reset device (RELOAD PARAMETER) -----------------------------------------------------
      
      SetNMT(Para:= CO_RESETNODE);// Reset Node
      OpMode := _CAN_IDLE;
    
    _CAN_RESETCOM:// Reset Communikation (RELOAD PARAMETER) ----------------------------------------------
      
      SetNMT(Para:= CO_RESETCOMMUNICATION);// Reset Communication
      OpMode := _CAN_IDLE;      
            
  END_CASE;
  
  //if activated set client NewNMTState if there is a new state and init is already started
  if bNewNMTState = TRUE & InitSSW > 0 then
    //set new nmt state at client
    NewNMTState.Write(input:=NewNMTState);
    
    //only reconnect node if it is not required and not at can stopped state
    if bQuitErrorNewNMT & (Required = 0 & QuitErrorNMTState <> _CAN_STOPPED) then
      ErrorQuit.Write(input:=0);
    end_if;
    bNewNMTState := FALSE;
  end_if;
    
  //******************************************************************************************************
  // END MAIN STATE MACHINE
  //******************************************************************************************************
  
  
  // SDO Handling for _CanOpenSDO Objects connected with the server DeviceState
  if (opmode = _CAN_SYNC) then
    ReadWriteUserSDO();
  end_if;
  
  _Segment_Up_Download();
    
END_FUNCTION


FUNCTION VIRTUAL GLOBAL _CanOpenBasicDS301::SetOpMode
  VAR_INPUT
    opModeSet   : _CAN_OPMODE_INT;
  END_VAR
  VAR_OUTPUT
    retCode     : DINT;
  END_VAR
  
  retcode := 0;
  
  // -----------------------------------------------------------------------------------------------------
  // ---------------------                  SetOpMode State-maschine           ---------------------------
  // -----------------------------------------------------------------------------------------------------
  case opModeSet of
    // -----------------------------------------------------------------------------------------------------
    _CAN_IDLE:
      OpMode := opModeSet;
        
    // -----------------------------------------------------------------------------------------------------
    _CAN_INIT:
      OpMode := opModeSet;
      
    // -----------------------------------------------------------------------------------------------------
    _CAN_NETENABLE:
      OpMode := opModeSet;      
      
    // -----------------------------------------------------------------------------------------------------
    _CAN_SYNC:
      OpMode := opModeSet;
      
    // -----------------------------------------------------------------------------------------------------
    _CAN_NETDISABLE:
      OpMode := opModeSet;
      
    // -----------------------------------------------------------------------------------------------------
    _CAN_RESETNODE:
      OpMode := opModeSet;
      
    // -----------------------------------------------------------------------------------------------------
    _CAN_RESETCOM:
      OpMode := opModeSet;
      
    else
    
      retcode := -1;
      
  end_case;
  
  // -----------------------------------------------------------------------------------------------------
  // ---------------------                 End SetOpMode State-maschine        ---------------------------
  // -----------------------------------------------------------------------------------------------------

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _CanOpenBasicDS301::ReInitObject

  SetOpMode(opModeSet:=_CAN_INIT);
  //reset initialization ssw
  InitSSW   := 0;
  PDOIniSSW := 0;
  bResetCom := TRUE; //to be sure that first can-object are being send if we get a Buffer Full the first time
  ResetReceiveFlag();
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL _CanOpenBasicDS301::ResetComm

  SetOpMode(opModeSet:=_CAN_NETENABLE);
  bResetCom := TRUE; //to be sure that first can-object are being send if we get a Buffer Full the first time
  
  ResetReceiveFlag();
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL _CanOpenBasicDS301::CheckInitDone
  VAR_OUTPUT
    RetValue   : BOOL;
  END_VAR
  
  if (OpMode = _CAN_NETENABLE) | (OpMode = _CAN_SYNC) then
    RetValue := TRUE;    
  else
    RetValue := FALSE;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _CanOpenBasicDS301::GetNGorHBtime
  VAR_OUTPUT
    udTime   : UDINT;
  END_VAR
  
  if NodeGuardingSupported = 1 then
    udTime := to_udint(GuardTime.Data) * to_udint(Lifetimefactor.Data);
  elsif ProducerHeartbeatSupported = 1 then
    udTime := to_UDINT(Heartbeat.Data);
  else
    udTime := 0;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL _CanOpenBasicDS301::SendAllPDOs
VAR
  uiTmpCnt : UINT;
  pActPDOEntry : ^_PDOSETTINGS;
  dRetCode : DINT;
END_VAR

  if TPdo1.active = TRUE & SendMarkTpdo1 = TRUE then
    TransmitPDO1();
    if SendMode = 1 then
      SendMarkTpdo1 := FALSE;
    end_if;
  end_if;
  
  if TPdo2.active = TRUE & SendMarkTpdo2 = TRUE then
    TransmitPDO2();
    if SendMode = 1 then
      SendMarkTpdo2 := FALSE;
    end_if;
  end_if;
  
  if TPdo3.active = TRUE & SendMarkTpdo3 = TRUE then
    TransmitPDO3();
    if SendMode = 1 then
      SendMarkTpdo3 := FALSE;
    end_if;
  end_if;
  
  if TPdo4.active = TRUE & SendMarkTpdo4 = TRUE then
    TransmitPDO4();
    if SendMode = 1 then
      SendMarkTpdo4 := FALSE;
    end_if;
  end_if;
  
  //check for additional TPdo's
  if sPDOAdditionalVars.bTxAdditionalUsed then
    pActPDOEntry := #TPdoAdditional;
    for uiTmpCnt := 0 to (sPDOAdditionalVars.uiTPDOUsed-1) do
      if pActPDOEntry^.active & sPDOAdditionalVars.TxVars[uiTmpCnt+CO_NUMBER_DEFAULT_PDO].bSendFlag = TRUE then
        //call methode to send TPdo data of additional Pdo
        dRetCode := TransmitAdditionalPDO(uiPDONrb:=uiTmpCnt+CO_NUMBER_DEFAULT_PDO+1, hiObjNbr:=0, paCanData:=NIL);
        //reset send flag if SendMode is 1
        if SendMode = 1 then
          sPDOAdditionalVars.TxVars[uiTmpCnt+CO_NUMBER_DEFAULT_PDO].bSendFlag := FALSE;
        end_if;
        if dRetCode <= 0 then
          //sending of Pdo object failed
          sPDOAdditionalVars.TxVars[uiTmpCnt+CO_NUMBER_DEFAULT_PDO].udErrorSendCnt += 1;
        end_if;        
      end_if;
      
      pActPDOEntry := pActPDOEntry^.pNextPDO;
      if pActPDOEntry = NIL then
        exit;
      end_if;
    end_for;    
  end_if;
  
END_FUNCTION


FUNCTION _CanOpenBasicDS301::CallBack
  VAR_INPUT
    udTxCount   : UDINT;
    udRxCount   : UDINT;
    udErrorCount   : UDINT;
    dData   : DINT;
  END_VAR
  VAR    
    pTempThis : ^void;
    pTempCallBack  : ^void;
  END_VAR
  
  //save act thispointer
  pTempThis     := this;
  pTempCallBack := sDataSDO.pActSdoEntry^.pCallBack;
  //and set this pointer to object of callback
  this$^void    := sDataSDO.pActSdoEntry^.pThis;
  
  // Increase TxCounter from the SDO object        
  pTempCallBack$CallBack(udTxCount    := udTxCount,
                         udRxCount    := udRxCount,
                         udErrorCount := udErrorCount,
                         dData        := dData);
                                           
  this$^void := pTempThis;

END_FUNCTION


FUNCTION _CanOpenBasicDS301::ConvertHexStringToHDINT
  VAR_INPUT
    pHexString   : ^CHAR;
  END_VAR
  VAR_OUTPUT
    hdOutputValue   : HDINT;
  END_VAR
  VAR
    pHelpChar : ^CHAR;
    usHelpShift : USINT;
    udStrLen   : UDINT;
  END_VAR
  
  hdOutputValue := 0;
  pHelpChar     := pHexString;
  usHelpShift   := 0;
  
  //search for 0x and remove it  
  
  udStrLen := _strlen(src:=pHelpChar);
  if udStrLen <= 10 then  
    while udStrLen do
      case (pHelpChar+udStrLen-1)^ of
        '0':
        '1':  hdOutputValue := hdOutputValue or (1 shl usHelpShift);
        '2':  hdOutputValue := hdOutputValue or (2 shl usHelpShift);
        '3':  hdOutputValue := hdOutputValue or (3 shl usHelpShift);
        '4':  hdOutputValue := hdOutputValue or (4 shl usHelpShift);
        '5':  hdOutputValue := hdOutputValue or (5 shl usHelpShift);
        '6':  hdOutputValue := hdOutputValue or (6 shl usHelpShift);
        '7':  hdOutputValue := hdOutputValue or (7 shl usHelpShift);
        '8':  hdOutputValue := hdOutputValue or (8 shl usHelpShift);
        '9':  hdOutputValue := hdOutputValue or (9 shl usHelpShift);
        'A','a':  hdOutputValue := hdOutputValue or (10 shl usHelpShift);
        'B','b':  hdOutputValue := hdOutputValue or (11 shl usHelpShift);
        'C','c':  hdOutputValue := hdOutputValue or (12 shl usHelpShift);
        'D','d':  hdOutputValue := hdOutputValue or (13 shl usHelpShift);
        'E','e':  hdOutputValue := hdOutputValue or (14 shl usHelpShift);
        'F','f':  hdOutputValue := hdOutputValue or (15 shl usHelpShift);
        'X','x':  exit; //we reached the '0x' passphrase of hex string -> exit                
      else
        exit;    
      end_case;
      usHelpShift += 4;
      udStrLen -= 1;
    end_while;
  else
    //Wrong formatted hex string
    hdOutputValue := CO_XDC_CONVERT_INVALIDVALUE;
  end_if;
    
END_FUNCTION


FUNCTION _CanOpenBasicDS301::XDCHandling
  VAR_INPUT
    pStringFile   : ^CHAR;
  END_VAR
  VAR_OUTPUT
    dRetCode   : DINT;
  END_VAR
  VAR
    dTempRetCode : DINT;
    fileLength : DINT;
    pFileBuffer : ^USINT;
    FileHandle : DINT;
  END_VAR
    
  dTempRetCode := _XMLReaderXDC.ReadFile(FileName:=pStringFile);
  
  if dTempRetCode = 1 then  
    FileHandle := FileSys.FileOpen_A(0, pStringFile, ATT_READ_ONLY);
    //check for a valid file handle 
    if ( FileHandle >= 0) then
      fileLength := FileSys.FileLength_A(0, FileHandle);
      //check for a valid file length
      if fileLength > 0 then      
        //allocate memory for the file data
        pFileBuffer$^void := StdLib.Malloc(fileLength$UDINT);

        if (pFileBuffer <> NIL) then
          _XMLReaderXDC.XmlState := _XMLReader::_READY;
          //read of file
          FileSys.FileRead_A(0, FileHandle, pFileBuffer, fileLength$UDINT);
          //close file after read is finished
          FileSys.FileClose_A(0, FileHandle);
          //set strukture of xdc file to _XMLReaderXDC object
          dTempRetCode := _XMLReaderXDC.ParseXML(pData:=pFileBuffer, length:=fileLength$UDINT);
          if dTempRetCode = 0 then
            //add file for parsing of xdc file failed
            MasterDevice.LogError("@0418 (_CanOpenBasicDS301::XDCHandling) Add file for parsing failed!");
            _XMLReaderXDC.XmlState := _XMLReader::_ERROR;
          end_if;
        else
          //allocate memory failed
          MasterDevice.LogError("@0419 (_CanOpenBasicDS301::XDCHandling) Allocate memory for file data failed!");
          _XMLReaderXDC.XmlState := _XMLReader::_ERROR;
        end_if;         
      else
        //read of file length failed
        MasterDevice.LogError("@041B (_CanOpenBasicDS301::XDCHandling) Read of file length failed!");
        _XMLReaderXDC.XmlState :=  _XMLReader::_ERROR;
      end_if;      
    else
      //file handle is not valid
      MasterDevice.LogError("@041C (_CanOpenBasicDS301::XDCHandling) File handle is not valid!");
      _XMLReaderXDC.XmlState :=  _XMLReader::_ERROR;
    end_if;        
    
    //reset memory
    if pFileBuffer then
      StdLib.Free(mptr:=pFileBuffer);
      pFileBuffer := NIL;
    end_if;    
  else
    //read of xdc file was not successful
    dTempRetCode := -1;    
    MasterDevice.LogError("@041D (_CanOpenBasicDS301::XDCHandling) Open of xdc file failed!");
  end_if;
  
  if _XMLReaderXDC.XmlState <> _XMLReader::_ERROR then
  
    while _XMLReaderXDC.XmlState <> _XMLReader::_STRUCT_CREATED & _XMLReaderXDC.XmlState <> _XMLReader::_ERROR do
      _XMLReaderXDC.Background(0);    
    end_while;
    
    if _XMLReaderXDC.XmlState = _XMLReader::_ERROR then
      //parsing of xdc data failed
      dTempRetCode := -2; 
      MasterDevice.LogValue("@041E (_CanOpenBasicDS301::XDCHandling) Error at parsing of xdc file. Errorstate 0x{0}, Line 0x{1}, Sign 0x{2}.", _XMLReaderXDC.ErrorState$UDINT, _XMLReaderXDC.ErrorLine$UDINT, _XMLReaderXDC.ErrorSign$UDINT);
    else
      dTempRetCode := 0;
      //call xdc handling to read out the Pdo info 
      sXDCVars.dRetcode := XDCGetPdoInfo();
      while sXDCVars.dRetcode = BUSY do
        sXDCVars.dRetcode := XDCGetPdoInfo();
      end_while; 
      if sXDCVars.dRetcode = ERROR then
        //problem occurred while get Pdo infos from xdc data - xdc data not valid
        dTempRetCode := -3;           
        MasterDevice.LogError("@041F (_CanOpenBasicDS301::XDCHandling) Reading of Pdo info data from xdc file failed!");
      end_if;
    end_if;
  else
    //failed to get xdc file
    dTempRetCode := -4;
  end_if;
  
  //release 
  _XMLReaderXDC.FreeReader();
  
  dRetCode := dTempRetCode;
  
END_FUNCTION


FUNCTION _CanOpenBasicDS301::XDCGetPdoInfo
  VAR_OUTPUT
    dRetCode   : iprStates;
  END_VAR
  VAR
    dTempRetCode : DINT;
  END_VAR
  
  dRetCode := BUSY;
  
  case sXDCVars.eXDCPDOInfos of
  
    //***********************************************************************************************************************    
    _GetCANOpenObjectList:
      XDCGetCANOpenObjectList();
      //get additional indexes
      sXDCVars.eXDCPDOInfos := _GetAdditionalIndexes;      
      
    //***********************************************************************************************************************    
    _GetAdditionalIndexes:
      XDCGetAdditionalIndexes();
      //get network info
      sXDCVars.eXDCPDOInfos := _GetNetworkInfo;   
    
    //***********************************************************************************************************************    
    _GetNetworkInfo:
      XDCGetNetworkManagementInfo();       
      
      //set first index for rpdo communication para
      sXDCVars.pRPDOData$^void := StdLib.Malloc(size:=sizeof(t_s_PDOStruct));
      _memset(dest:=sXDCVars.pRPDOData, usByte:=0x00, cntr:=sizeof(t_s_PDOStruct));
      //TPDO is a RPDO at CANOpen-Node
      sXDCVars.hdActSearchIndex  := CO_INDEX_TPDO1_SETTING;    
      sXDCVars.pActPDOEntry      := sXDCVars.pRPDOData;
      sXDCVars.bFirstAlloc       := FALSE;
      //get first rpdo communication para
      sXDCVars.eXDCPDOInfos := _GetRPDOCommPara;      
          
    //***********************************************************************************************************************
    _GetRPDOCommPara:    
      dTempRetCode := XDCGetPdoCanOpenElement(hdSearchIndex:=sXDCVars.hdActSearchIndex, pCanElement:=#sXDCVars.sActPDOData);
      if dTempRetCode = 0 then
        //data of act search index is complete
        if sXDCVars.bFirstAlloc = FALSE then
          sXDCVars.bFirstAlloc := TRUE;
        else          
          if sXDCVars.pActPDOEntry^.pNextPDOData = NIL then        
            sXDCVars.pActPDOEntry^.pNextPDOData$^void := StdLib.Malloc(size:=sizeof(t_s_PDOStruct));
            _memset(dest:=sXDCVars.pActPDOEntry^.pNextPDOData, usByte:=0x00, cntr:=sizeof(t_s_PDOStruct));
          end_if;        
          sXDCVars.pActPDOEntry := sXDCVars.pActPDOEntry^.pNextPDOData;           
        end_if;        
        _memcpy(ptr1:=#sXDCVars.pActPDOEntry^.PDOCommPara, ptr2:=#sXDCVars.sActPDOData, cntr:=sizeof(t_s_PDOCommPara)); 
        sXDCVars.uiRPDOEntries += 1;
      end_if;
      //set var to next search index
      sXDCVars.hdActSearchIndex += 1; 
      dTempRetCode := XDCCheckIndexExisting(phdActIndex:=#sXDCVars.hdActSearchIndex, hdMaxIndex:=CO_INDEX_TPDO1_MAPPING);
      // look for end of index to search
      if dTempRetCode then
        //TPDO is a RPDO at CANOpen-Node
        sXDCVars.hdActSearchIndex  := CO_INDEX_TPDO1_MAPPING;
        sXDCVars.pActPDOEntry      := sXDCVars.pRPDOData;
        //element is not found, stop searching here because last entry is reached.
        sXDCVars.eXDCPDOInfos := _GetRPDOMapping;
      end_if; 
    
    //***********************************************************************************************************************
    _GetRPDOMapping:  
      dTempRetCode := XDCGetPdoCanOpenElement(hdSearchIndex:=sXDCVars.pActPDOEntry^.PDOCommPara.Index+CO_PDO_MAPPING_OFFSET_TO_COBID, pCanElement:=#sXDCVars.sActPDOData);
      //set var to next search index
      sXDCVars.hdActSearchIndex += 1; 
      if dTempRetCode = 0 then
        //data of act search index is complete
        if sXDCVars.pActPDOEntry <> NIL then        
          _memcpy(ptr1:=#sXDCVars.pActPDOEntry^.PDOMapping, ptr2:=#sXDCVars.sActPDOData, cntr:=sizeof(t_s_PDOMapping));
        end_if;
      else
        //element is not found
      end_if;
      
      if sXDCVars.pActPDOEntry^.pNextPDOData <> NIL then
        sXDCVars.pActPDOEntry := sXDCVars.pActPDOEntry^.pNextPDOData;
      else
        //last Pdo entry is reached -> go to next step
        sXDCVars.pTPDOData$^void := StdLib.Malloc(size:=sizeof(t_s_PDOStruct));
        _memset(dest:=sXDCVars.pTPDOData, usByte:=0x00, cntr:=sizeof(t_s_PDOStruct));
        //RPDO is a TPDO at CANOpen-Node
        sXDCVars.hdActSearchIndex := CO_INDEX_RPDO1_SETTING;
        sXDCVars.pActPDOEntry     := sXDCVars.pTPDOData;
        sXDCVars.bFirstAlloc      := FALSE;
        sXDCVars.eXDCPDOInfos := _GetTPDOCommPara;        
      end_if;
    
    //***********************************************************************************************************************
    _GetTPDOCommPara: 
      dTempRetCode := XDCGetPdoCanOpenElement(hdSearchIndex:=sXDCVars.hdActSearchIndex, pCanElement:=#sXDCVars.sActPDOData);
      if dTempRetCode = 0 then
        //data of act search index is complete
        if sXDCVars.bFirstAlloc = FALSE then
          sXDCVars.bFirstAlloc := TRUE;
        else          
          if sXDCVars.pActPDOEntry^.pNextPDOData = NIL then        
            sXDCVars.pActPDOEntry^.pNextPDOData$^void := StdLib.Malloc(size:=sizeof(t_s_PDOStruct));
            _memset(dest:=sXDCVars.pActPDOEntry^.pNextPDOData, usByte:=0x00, cntr:=sizeof(t_s_PDOStruct));
          end_if;        
          sXDCVars.pActPDOEntry := sXDCVars.pActPDOEntry^.pNextPDOData;           
        end_if;        
        _memcpy(ptr1:=#sXDCVars.pActPDOEntry^.PDOCommPara, ptr2:=#sXDCVars.sActPDOData, cntr:=sizeof(t_s_PDOCommPara));
        sXDCVars.uiTPDOEntries += 1;    
      end_if;
        
      //set var to next search index
      sXDCVars.hdActSearchIndex += 1; 
      dTempRetCode := XDCCheckIndexExisting(phdActIndex:=#sXDCVars.hdActSearchIndex, hdMaxIndex:=CO_INDEX_RPDO1_MAPPING);
      // look for end of index to search
      if dTempRetCode then
        //RPDO is a TPDO at CANOpen-Node
        sXDCVars.hdActSearchIndex  := CO_INDEX_RPDO1_MAPPING;
        sXDCVars.pActPDOEntry      := sXDCVars.pTPDOData;
        //element is not found, stop searching here because last entry is reached.
        sXDCVars.eXDCPDOInfos := _GetTPDOMapping;
      end_if; 
    
    //***********************************************************************************************************************
    _GetTPDOMapping:       
      dTempRetCode := XDCGetPdoCanOpenElement(hdSearchIndex:=sXDCVars.pActPDOEntry^.PDOCommPara.Index+CO_PDO_MAPPING_OFFSET_TO_COBID, pCanElement:=#sXDCVars.sActPDOData);
      //set var to next search index
      sXDCVars.hdActSearchIndex += 1; 
      if dTempRetCode = 0 then
        //data of act search index is complete
        if sXDCVars.pActPDOEntry <> NIL then        
          _memcpy(ptr1:=#sXDCVars.pActPDOEntry^.PDOMapping, ptr2:=#sXDCVars.sActPDOData, cntr:=sizeof(t_s_PDOMapping));
        end_if;
      else
        //element is not found
      end_if;
      
      if sXDCVars.pActPDOEntry^.pNextPDOData <> NIL then
        sXDCVars.pActPDOEntry := sXDCVars.pActPDOEntry^.pNextPDOData;
      else
        //last Pdo entry is reached -> go to next step
        sXDCVars.eXDCPDOInfos := _GetInfoFinished;        
      end_if;
      
    //***********************************************************************************************************************
    _GetInfoFinished:
      dRetCode := READY;
    
    //***********************************************************************************************************************
    _GetInfoError:
        
  end_case;

    
END_FUNCTION


FUNCTION _CanOpenBasicDS301::XDCGetNameValue
  VAR_INPUT
    pStringName   : ^CHAR;
    pAttributeList   : ^_XML_ATTRIBUTE_LIST;
    pudValue   : ^UDINT;(* := NIL *)
    pStringValue   : ^CHAR;(* := NIL *)
    udStrLength   : UDINT;(* := CO_XDC_MAX_STRING_LENGTH *)
    dDataType   : DINT;(* := CO_XDC_VALUES_TYPE_UNKNOWN *)
  END_VAR
  VAR_OUTPUT
    dRetCode   : DINT;
  END_VAR
  VAR
    udTmpCnt : UDINT;
    pHelpXML : ^_XML_ATTRIBUTE;
    dTmpDataType : DINT;
  END_VAR
  
  //initialise the return value
  dRetCode := -1;
  
  if pAttributeList = NIL then
    return;
  end_if;
  
  if pAttributeList^.no < 1 then
    return;  
  end_if;
  
  //initialise the input variables
  if pudValue then
    pudValue^ := 0;
  end_if;
  if pStringValue then
    pStringValue^ := 0x00;
  end_if;
  
  pHelpXML := pAttributeList^.pList;   
  dTmpDataType := dDataType;
   
  //search for string at attributes
  for udTmpCnt := 0 to pAttributeList^.no-1 do
    if pHelpXML <> NIL
    & _strcmp(str1:=pHelpXML^.Name, str2:=pStringName) = 0 then
      //searched name is found
      if pudValue then
        //look for the 0x identifier of hex number
        if dTmpDataType = CO_XDC_VALUES_TYPE_HEX | 
         ( (pHelpXML^.Value+1)^ = 'x' | (pHelpXML^.Value+1)^ = 'X' ) then
          //convert hex string to value
          pudValue^ := ConvertHexStringToHDINT(pHexString:=pHelpXML^.Value);
          if pudValue^ = CO_XDC_CONVERT_INVALIDVALUE then
            // convert of hex string to value failed
            dRetCode := -2;
            exit;            
          end_if;

        //look for bool string true or false  
        elsif dTmpDataType = CO_XDC_VALUES_TYPE_STR_BOOL then
          if ( (pHelpXML^.Value)^ = 'f' | (pHelpXML^.Value)^ = 'F' ) then
            pudValue^ := 0;
          elsif ( (pHelpXML^.Value)^ = 't' | (pHelpXML^.Value)^ = 'T' ) then
            pudValue^ := 1;
          else
            // bool string true or false is not found
            dRetCode := -3;
            exit;  
          end_if;
        else //decimal or unknown data type -> convert to decimal
          //convert decimal string to value
          pudValue^ :=  (toSigCLib.AToI(ps1:=(pHelpXML^.Value)))$UDINT;
        end_if;
      end_if;
      
      //always write the string value to input string variable if it is valid
      if pStringValue then
        if _strlen(src:=pHelpXML^.Value) < udStrLength then
          _strcpy(dest:=pStringValue, src:=pHelpXML^.Value);
        else
          _memcpy(ptr1:=pStringValue, ptr2:=pHelpXML^.Value, cntr:=udStrLength-2);
          (pStringValue+udStrLength-1)^ := 0;
        end_if;

      end_if;
      //xml entry is found -> leave loop with ok
      dRetCode := 0;
      exit;
    end_if;
    pHelpXML += sizeof(_XML_ATTRIBUTE);
  end_for;  

END_FUNCTION


FUNCTION _CanOpenBasicDS301::XDCGetPdoCanOpenElement
	VAR_INPUT
		hdSearchIndex 	: HDINT;
		pCanElement 	: ^t_s_PDOElement;
	END_VAR
	VAR_OUTPUT
		dRetcode 	: DINT;
	END_VAR
  VAR
    dTempRetCode : DINT;
    aTempStr     : Array[0..CO_XDC_MAX_STRING_LENGTH-1] of CHAR;
    pHelpElement : ^_XML_ELEMENT;
    pHelpElement2 : ^_XML_ELEMENT;
    pHelpChildren : ^_XML_ELEMENT;
    uiTempNbrEntries : UINT;
    dTempDataType    : DINT;
  END_VAR
  
  //initialize return value with ok
  dRetcode := 0;   
 //**********************************************************************************************************************************
  toSigCLib.IToA(val:=hdSearchIndex$DINT, dst:=#aTempStr[0], base:=16);
  sXDCVars.pXDCElement := _XMLReaderXDC.GetElementByAttrib(pName:="index", pValue:=#aTempStr[0]);
  //try lower case if upper case doesnt find a result
  if sXDCVars.pXDCElement = NIL then
    sXDCVars.pXDCElement := _XMLReaderXDC.GetElementByAttrib(pName:="index", pValue:=toSigCLib.StrLwr(#aTempStr[0]));
  end_if;

  if sXDCVars.pXDCElement then
    _memset(dest:=#sXDCVars.sActPDOData, usByte:=0x00, cntr:=sizeof(sXDCVars.sActPDOData));
    pCanElement^.Index := hdSearchIndex$HDINT;
    
    //subnumber 00 Number of Entries
    //**********************************************************************************************************************************
    dTempRetCode := XDCGetNameValue(pStringName:="subNumber", pAttributeList:=#sXDCVars.pXDCElement^.Attributes,  pudValue:=#pCanElement^.SubNbrs, pStringValue:=NIL, dDataType:=CO_XDC_VALUES_TYPE_HEX);
      
    if pCanElement^.SubNbrs & dTempRetCode = 0  then  
    
      //set pointer to first child entry
      pHelpElement           := sXDCVars.pXDCElement^.pChildren;
      sXDCVars.udActSubIndex := 0;
      
      dTempRetCode := XDCGetNameValue(pStringName:="actualValue", pAttributeList:=#pHelpElement^.Attributes, pudValue:=#pCanElement^.LargestSubIndex, pStringValue:=NIL);
      
      if dTempRetCode = 0 then            
        uiTempNbrEntries := pCanElement^.LargestSubIndex$UINT; 
        pCanElement^.aMappingInfo[sXDCVars.udActSubIndex].Value := uiTempNbrEntries;
        //get read write flag of index
        dTempRetCode := XDCGetNameValue(pStringName:="accessType", pAttributeList:=#pHelpElement^.Attributes,  pudValue:=NIL, pStringValue:=#aTempStr[0], dDataType:=CO_XDC_VALUES_TYPE_UNKNOWN);
        if dTempRetCode = 0 then
          pCanElement^.aMappingInfo[sXDCVars.udActSubIndex].AccessType := XDCAccessTypeToDec(pstrAccessType:=#aTempStr[0]);
          if pCanElement^.aMappingInfo[sXDCVars.udActSubIndex].AccessType = _UnknownType then
            MasterDevice.LogValue("@04D5 (_CanOpenBasicDS301::XDCGetPdoCanOpenElement) Failed to fetch access type from XDC File of parameter with index 0x{0}, subindex 0x{1}.", pCanElement^.index$UDINT, sXDCVars.udActSubIndex$UDINT);
          end_if;
        else
          MasterDevice.LogValue("@04D5 (_CanOpenBasicDS301::XDCGetPdoCanOpenElement) Failed to fetch access type from XDC File of parameter with index 0x{0}, subindex 0x{1}.", pCanElement^.index$UDINT, sXDCVars.udActSubIndex$UDINT);
        end_if;
      else            
        uiTempNbrEntries := 0;
      end_if;
      
      //set pointer to next child entry
      pHelpElement := pHelpElement^.pNext;
      
      //index 1400 and 1800 subnumber 01 COB ID | 02 Transmission Type | 03 Inhibit Time | 04 reserved | 05 Event Timer | 06 Sync Start Value
      //index 1600 and 1A00 mapping parameter 1-8
      while uiTempNbrEntries do 
        //**********************************************************************************************************************************
        if pHelpElement then
        
          //get dataType
          dTempRetCode := XDCGetNameValue(pStringName:="dataType", pAttributeList:=#pHelpElement^.Attributes, pudValue:=#dTempDataType$UDINT, pStringValue:=NIL, dDataType:=CO_XDC_VALUES_TYPE_DEC);
          if dTempRetCode = 0 then      
            //get Subindex number
            dTempRetCode := XDCGetNameValue(pStringName:="subIndex", pAttributeList:=#pHelpElement^.Attributes, pudValue:=#sXDCVars.udActSubIndex, pStringValue:=NIL, dDataType:=CO_XDC_VALUES_TYPE_HEX);
            if dTempRetCode = 0 then
              //get unique ID
              dTempRetCode := XDCGetNameValue(pStringName:="uniqueIDRef", pAttributeList:=#pHelpElement^.Attributes, pudValue:=NIL, pStringValue:=#aTempStr[0]);
              if dTempRetCode = 0 then 
                //search the unique id at file
                pHelpElement2 := _XMLReaderXDC.GetElementByAttrib(pName:="uniqueID", pValue:=#aTempStr[0]);
                if pHelpElement2 then                
                  //get read write flag of index
                  dTempRetCode := XDCGetNameValue(pStringName:="access", pAttributeList:=#pHelpElement2^.Attributes,  pudValue:=NIL, pStringValue:=#aTempStr[0], dDataType:=CO_XDC_VALUES_TYPE_UNKNOWN);
                  if dTempRetCode = 0 then
                    pCanElement^.aMappingInfo[sXDCVars.udActSubIndex].AccessType := XDCAccessTypeToDec(pstrAccessType:=#aTempStr[0]);
                    if pCanElement^.aMappingInfo[sXDCVars.udActSubIndex].AccessType = _UnknownType then
                      MasterDevice.LogValue("@04D5 (_CanOpenBasicDS301::XDCGetPdoCanOpenElement) Failed to fetch access type from XDC File of parameter with index 0x{0}, subindex 0x{1}.", pCanElement^.index$UDINT, sXDCVars.udActSubIndex$UDINT);
                    end_if;
                  else
                    MasterDevice.LogValue("@04D5 (_CanOpenBasicDS301::XDCGetPdoCanOpenElement) Failed to fetch access type from XDC File of parameter with index 0x{0}, subindex 0x{1}.", pCanElement^.index$UDINT, sXDCVars.udActSubIndex$UDINT);
                  end_if;
                  
                  pHelpChildren := pHelpElement2^.pChildren;
                  //if unique id is found search for the value of this paramater
                  while pHelpChildren & _strcmp(str1:="actualValue", str2:=pHelpChildren^.Name) = 1 do   
                    //search entry
                    pHelpChildren := pHelpChildren^.pNext;
                  end_while;
                end_if;
                if pHelpChildren then
                  
                  //if all was ok we can get our value for this parameter
                  dTempRetCode := XDCGetNameValue(pStringName:="value", pAttributeList:=#pHelpChildren^.Attributes, pudValue:=#pCanElement^.aMappingInfo[sXDCVars.udActSubIndex].Value$UDINT, pStringValue:=NIL, dDataType:=dTempDataType);
                    
                  if dTempRetCode <> 0 then                    
                    //value was not found
                    MasterDevice.LogValue("@05AE (_CanOpenBasicDS301::XDCGetPdoCanOpenElement) Failed to get value from XDC File of parameter with index 0x{0}, subindex 0x{1}.", pCanElement^.index$UDINT, sXDCVars.udActSubIndex$UDINT);
                  end_if;
                else
                  //pointer to children is not valid
                  MasterDevice.LogValue("@05AE (_CanOpenBasicDS301::XDCGetPdoCanOpenElement) Failed to get value from XDC File of parameter with index 0x{0}, subindex 0x{1}.", pCanElement^.index$UDINT, sXDCVars.udActSubIndex$UDINT);
                  
                end_if;
              else
                //unique id is not found at xdc data
                MasterDevice.LogValue("@05AE (_CanOpenBasicDS301::XDCGetPdoCanOpenElement) Failed to get value from XDC File of parameter with index 0x{0}, subindex 0x{1}.", pCanElement^.index$UDINT, sXDCVars.udActSubIndex$UDINT);       
              end_if;
            else
              //error get sub index number
              MasterDevice.LogValue("@05AE (_CanOpenBasicDS301::XDCGetPdoCanOpenElement) Failed to get value from XDC File of parameter with index 0x{0}, subindex 0x{1}.", pCanElement^.index$UDINT, sXDCVars.udActSubIndex$UDINT);    
              exit;
            end_if;
          else
            //error get datatype
            MasterDevice.LogValue("@05AE (_CanOpenBasicDS301::XDCGetPdoCanOpenElement) Failed to get value from XDC File of parameter with index 0x{0}, subindex 0x{1}.", pCanElement^.index$UDINT, sXDCVars.udActSubIndex$UDINT);
          end_if;  
        else
          //error element is not existing or last element
          //MasterDevice.LogValue("@05AE (_CanOpenBasicDS301::XDCGetPdoCanOpenElement) Failed to get value from XDC File of parameter with index 0x{0}, subindex 0x{1}.", pCanElement^.index$UDINT, sXDCVars.udActSubIndex$UDINT);
          exit;
        end_if;           
        uiTempNbrEntries -= 1;
        //set pointer to next child entry
        pHelpElement := pHelpElement^.pNext;
      end_while;
    else
      //subnumber 00 Number of Entries
      //value is not found -> go to next step      
      MasterDevice.LogValue("@05AE (_CanOpenBasicDS301::XDCGetPdoCanOpenElement) Failed to get value from XDC File of parameter with index 0x{0}, subindex 0x{1}.", pCanElement^.index$UDINT, sXDCVars.udActSubIndex$UDINT);
      dRetcode := 1;   
    end_if;      
  else
    //element is not found, stop searching here because last entry is reached.
    MasterDevice.LogValue("@05AE (_CanOpenBasicDS301::XDCGetPdoCanOpenElement) Failed to get value from XDC File of parameter with index 0x{0}, subindex 0x{1}.", pCanElement^.index$UDINT, sXDCVars.udActSubIndex$UDINT);
    dRetcode := -1;
  end_if;
      
END_FUNCTION


FUNCTION _CanOpenBasicDS301::XDCSetPdoData

    // ----------------------------------------------------------------------------------------  
    // --------------------             RECEIVE Pdo-SETTINGS               --------------------
    // ----------------------------------------------------------------------------------------
    // Receive Object Numbers -----------------------------------------------------------------
    // RPDO   Device --> PLC ------------------------------------------------------------------
    // ----------------------------------------------------------------------------------------
    if XDCSetRPdoTPdoData(#RPdo1, sXDCVars.pTPDOData) <> 0 then    
      //max numbers of objects reached
      MasterDevice.LogError("@0421 (_CanOpenBasicDS301::XDCSetPdoData) Maximum number of receive Pdo's is reached!");
    end_if;
    
    // ----------------------------------------------------------------------------------------  
    // --------------------             TRANSMIT Pdo-SETTINGS               --------------------
    // ----------------------------------------------------------------------------------------
    // Transmit Object Numbers -----------------------------------------------------------------
    // TPDO   PLC --> Device ------------------------------------------------------------------
    // ----------------------------------------------------------------------------------------
    if XDCSetRPdoTPdoData(#TPdo1, sXDCVars.pRPDOData) <> 0 then
      //max numbers of objects reached
      MasterDevice.LogError("@0421 (_CanOpenBasicDS301::XDCSetPdoData) Maximum number of transmit Pdo's is reached!");
    end_if;
    
END_FUNCTION


FUNCTION _CanOpenBasicDS301::XDCSetRPdoTPdoData
	VAR_INPUT
		pActPdoEntry 	: ^_PDOSETTINGS;
		pXDCActPdoEntry 	: ^t_s_PDOStruct;
	END_VAR
	VAR_OUTPUT
		dRetCode 	: DINT;
	END_VAR
  VAR
    uiTmpCnt : UINT;  
    uiTmpPDOCnt : UINT;
    hsActUsedXDCSubIndex : HSINT;
  END_VAR
    
  sXDCVars.pActPDOEntry := pXDCActPdoEntry; 
  uiTmpPDOCnt := 0;  
  dRetCode    := 0;
  
  while pActPdoEntry <> NIL do
    if sXDCVars.pActPDOEntry & sXDCVars.uiTPDOEntries then    

      pActPdoEntry^.ObjNr  := sXDCVars.pActPDOEntry^.PDOCommPara.aMappingInfo[CO_SUBINDEX_COB_ID].Value$INT - Place$INT;  
      
      if (sXDCVars.pActPDOEntry^.PDOCommPara.aMappingInfo[CO_SUBINDEX_COB_ID].Value$HDINT and CO_MAP_PARA_PDO_VALID_FLAG) = 0 then
        // Pdo is marked as valid
        pActPdoEntry^.active   := TRUE; // TRUE = active, FALSE = inactive
        pActPdoEntry^.inactive := FALSE; // set to true if Pdo should be set to inactive on CanOpen node
        
        //set highest subindex number 
        if XDCCheckWriteable(eAccesMode:=sXDCVars.pActPDOEntry^.PDOCommPara.aMappingInfo[CO_SUBINDEX_HIGHEST_SUBNBR].AccessType) then          
          pActPdoEntry^.HighestSubNbr.Index := sXDCVars.pActPDOEntry^.PDOCommPara.Index$INT;
        else
          pActPdoEntry^.HighestSubNbr.Index := -1;
        end_if;
        pActPdoEntry^.HighestSubNbr.SubIndex := CO_SUBINDEX_HIGHEST_SUBNBR;
        pActPdoEntry^.HighestSubNbr.Data     := sXDCVars.pActPDOEntry^.PDOCommPara.aMappingInfo[CO_SUBINDEX_HIGHEST_SUBNBR].Value$DINT; 
        
        //activate Pdo after change Pdo mapping
        if XDCCheckWriteable(eAccesMode:=sXDCVars.pActPDOEntry^.PDOCommPara.aMappingInfo[CO_SUBINDEX_COB_ID].AccessType) then          
          pActPdoEntry^.Activate.Index := sXDCVars.pActPDOEntry^.PDOCommPara.Index$INT;
        else
          pActPdoEntry^.Activate.Index := -1;
        end_if;
        pActPdoEntry^.Activate.SubIndex := CO_SUBINDEX_COB_ID;
        pActPdoEntry^.Activate.Data     := sXDCVars.pActPDOEntry^.PDOCommPara.aMappingInfo[CO_SUBINDEX_COB_ID].Value$DINT; 
        
        //deactivate Pdo before change Pdo mapping
        if XDCCheckWriteable(eAccesMode:=sXDCVars.pActPDOEntry^.PDOCommPara.aMappingInfo[CO_SUBINDEX_COB_ID].AccessType) then          
          pActPdoEntry^.Deactivate.Index := sXDCVars.pActPDOEntry^.PDOCommPara.Index$INT;
        else
          pActPdoEntry^.Deactivate.Index := -1;
        end_if;        
        pActPdoEntry^.Deactivate.SubIndex := CO_SUBINDEX_COB_ID;
        pActPdoEntry^.Deactivate.Data     := (CO_MAP_PARA_PDO_VALID_FLAG$DINT + sXDCVars.pActPDOEntry^.PDOCommPara.aMappingInfo[CO_SUBINDEX_COB_ID].Value); 
        
        // Synchronous or Asynchronous Transmission
        if XDCCheckWriteable(eAccesMode:=sXDCVars.pActPDOEntry^.PDOCommPara.aMappingInfo[CO_SUBINDEX_TRANS_TYPE].AccessType) then          
          pActPdoEntry^.TransmissionType.Index := sXDCVars.pActPDOEntry^.PDOCommPara.Index$INT;
        else
          pActPdoEntry^.TransmissionType.Index := -1;
        end_if;        
        pActPdoEntry^.TransmissionType.SubIndex := CO_SUBINDEX_TRANS_TYPE;
        pActPdoEntry^.TransmissionType.Data     := sXDCVars.pActPDOEntry^.PDOCommPara.aMappingInfo[CO_SUBINDEX_TRANS_TYPE].Value$DINT; 
        
        // min time between Pdo retry
        if XDCCheckWriteable(eAccesMode:=sXDCVars.pActPDOEntry^.PDOCommPara.aMappingInfo[CO_SUBINDEX_INHIBIT_TIME].AccessType) then          
          pActPdoEntry^.InhibitTime.Index := sXDCVars.pActPDOEntry^.PDOCommPara.Index$INT;
        else
          pActPdoEntry^.InhibitTime.Index := -1;
        end_if;        
        pActPdoEntry^.InhibitTime.SubIndex      := CO_SUBINDEX_INHIBIT_TIME;
        pActPdoEntry^.InhibitTime.Data          := sXDCVars.pActPDOEntry^.PDOCommPara.aMappingInfo[CO_SUBINDEX_INHIBIT_TIME].Value$DINT; 
                
        // Event Timer
        if XDCCheckWriteable(eAccesMode:=sXDCVars.pActPDOEntry^.PDOCommPara.aMappingInfo[CO_SUBINDEX_EVENT_TIMER].AccessType) then          
          pActPdoEntry^.EventTimer.Index := sXDCVars.pActPDOEntry^.PDOCommPara.Index$INT;
        else
          pActPdoEntry^.EventTimer.Index := -1;
        end_if;        
        pActPdoEntry^.EventTimer.SubIndex := CO_SUBINDEX_EVENT_TIMER;
        pActPdoEntry^.EventTimer.Data     := sXDCVars.pActPDOEntry^.PDOCommPara.aMappingInfo[CO_SUBINDEX_EVENT_TIMER].Value$DINT; 
        
        // SYNC start value
        if XDCCheckWriteable(eAccesMode:=sXDCVars.pActPDOEntry^.PDOCommPara.aMappingInfo[CO_SUBINDEX_SYNC_START_VALUE].AccessType) then          
          pActPdoEntry^.SyncStartValue.Index := sXDCVars.pActPDOEntry^.PDOCommPara.Index$INT;
        else
          pActPdoEntry^.SyncStartValue.Index := -1;
        end_if;        
        pActPdoEntry^.SyncStartValue.SubIndex := CO_SUBINDEX_SYNC_START_VALUE;
        pActPdoEntry^.SyncStartValue.Data     := sXDCVars.pActPDOEntry^.PDOCommPara.aMappingInfo[CO_SUBINDEX_SYNC_START_VALUE].Value$DINT; 
        
        
        //not supported by xdc file
        //pActPdoEntry^.PdoChoice.Index  := -1;
        //pActPdoEntry^.PdoChoice.SubIndex
        //pActPdoEntry^.PdoChoice.Data

        // Pdo mapping parameter
        if XDCCheckWriteable(eAccesMode:=sXDCVars.pActPDOEntry^.PDOMapping.aMapEntry[CO_SUBINDEX_HIGHEST_SUBNBR].AccessType) then
          pActPdoEntry^.ActiveNbrOfMappings := sXDCVars.pActPDOEntry^.PDOMapping.aMapEntry[CO_SUBINDEX_HIGHEST_SUBNBR].Value;
        else          
          pActPdoEntry^.ActiveNbrOfMappings := -1;
        end_if;
        
        //we have 8 mapping parameters + amount of mapping entrys
        //the first array entry at xdc Pdo mapping is not used, due to this we have entries - 2
        for uiTmpCnt := 0 to (CO_MAX_PDO_MAPPING_ENTRIES-2)$USINT do
          //set act used xdec subindex number (the first entry is the amount of subindex entrys which is not used in the further mapping)
          hsActUsedXDCSubIndex := (uiTmpCnt+1)$HSINT;
          //check if act subindex entry of Pdo mapping is smaller then highest subnumber
          if hsActUsedXDCSubIndex <= sXDCVars.pActPDOEntry^.PDOMapping.aMapEntry[CO_SUBINDEX_HIGHEST_SUBNBR].Value then
            pActPdoEntry^.MappingPara[uiTmpCnt].SubIndex  := hsActUsedXDCSubIndex;
            pActPdoEntry^.MappingPara[uiTmpCnt].Data      := sXDCVars.pActPDOEntry^.PDOMapping.aMapEntry[hsActUsedXDCSubIndex].Value$DINT;            
            //check if parameter is writeable
            if XDCCheckWriteable(eAccesMode:=sXDCVars.pActPDOEntry^.PDOMapping.aMapEntry[hsActUsedXDCSubIndex].AccessType) then          
              pActPdoEntry^.MappingPara[uiTmpCnt].Index := sXDCVars.pActPDOEntry^.PDOMapping.index$INT;
            else
              pActPdoEntry^.MappingPara[uiTmpCnt].Index := -1;
            end_if;
          else
            //deactivate mapping parameter
            pActPdoEntry^.MappingPara[uiTmpCnt].Index := -1;
          end_if;
        end_for;
        
      //*****************************************************************************************************************************  
      else  //Pdo is marked as deactivated
        DeactivatePDO(pPdoElement:=pActPdoEntry);
        
        //check for valid value of Pdo cob id
        if sXDCVars.pActPDOEntry^.PDOCommPara.aMappingInfo[CO_SUBINDEX_COB_ID].Value$UDINT <> CO_XDC_CONVERT_INVALIDVALUE then
          pActPdoEntry^.inactive := TRUE; // set to true if Pdo should be set to inactive on CanOpen node
          //deactivate Pdo before change Pdo mapping
          pActPdoEntry^.Deactivate.Index    := sXDCVars.pActPDOEntry^.PDOCommPara.Index$INT;
          pActPdoEntry^.Deactivate.SubIndex := CO_SUBINDEX_COB_ID;
          pActPdoEntry^.Deactivate.Data     := to_dint(CO_MAP_PARA_PDO_VALID_FLAG + pActPdoEntry^.ObjNr$UINT + Place$UINT);        
        end_if;
      end_if;
      
      // check next entry
      sXDCVars.pActPDOEntry := sXDCVars.pActPDOEntry^.pNextPDOData;
      
      if sXDCVars.pActPDOEntry <> NIL & pActPdoEntry^.pNextPDO = NIL then
        pActPdoEntry^.pNextPDO$^void := StdLib.Malloc(size:=sizeof(_PDOSETTINGS));
        pActPdoEntry := pActPdoEntry^.pNextPDO;
        if pActPdoEntry = NIL then
          //error while allocate memory for RPDO
          ErrorAlloc := 1;
          return;
        end_if;
        _memset(dest:=pActPdoEntry, usByte:=0x00, cntr:=sizeof(_PDOSETTINGS));
      else  
        pActPdoEntry := pActPdoEntry^.pNextPDO;
      end_if;         
      
    //*****************************************************************************************************************************  
    else //no Pdo information -> deactivate settings
    
      DeactivatePDO(pPdoElement:=pActPdoEntry);
      
      pActPdoEntry := pActPdoEntry^.pNextPDO;
      
    end_if; 
    
    uiTmpPDOCnt += 1;
    if uiTmpPDOCnt > CO_MAX_PDO_OBJECTS then
      //error is logged later
      dRetCode := -1;
      exit;
    end_if;
    
  end_while;

END_FUNCTION


FUNCTION _CanOpenBasicDS301::RxAdditionalPDO
  VAR_INPUT
    piCanptr   : ^t_s_BasicCanObj;
    RxDataptr   : ^t_s_BasicCanObj;
    Thisptr   : DINT;
  END_VAR 
  VAR
    uiTmpCnt : UINT;
    pActPDOEntry : ^_PDOSETTINGS;
  END_VAR
  
  this := Thisptr$^_CanOpenBasicDS301;
  
  //check for additional RPdo's
  if sPDOAdditionalVars.bRxAdditionalUsed then
    //set pointer to first additional Pdo entry
    pActPDOEntry  := #RPdoAdditional;
    //set to last normal Pdo (0-3)
    uiTmpCnt      := 4;
    
    while (pActPDOEntry^.ObjNr <> (RxDataptr^.udObjNbr$INT-Place$INT)) do
      uiTmpCnt += 1;
      if pActPDOEntry^.pNextPDO <> NIL then
        pActPDOEntry := pActPDOEntry^.pNextPDO;
      else
        //found no valid receive Pdo
        return;
      end_if;      
    end_while;
    
    sPDOAdditionalVars.RxVars[uiTmpCnt].ReceiveCntPDO += 1;
    sPDOAdditionalVars.RxVars[uiTmpCnt].bRPdoRec      := TRUE;
    sPDOAdditionalVars.RxVars[uiTmpCnt].udTimeStamp   := ops.tAbsolute;
    
    ConvertAdditionalPDO(uiPDONrb:=uiTmpCnt+1, hiObjNbr:=RxDataptr^.udObjNbr$HINT, usLength:=RxDataptr^.usLength, aCanData:=RxDataptr^.CanData);
    
  end_if;  
  
END_FUNCTION


FUNCTION _CanOpenBasicDS301::TxAdditionalPDO
	VAR_INPUT
		uiPDONbr 	: UINT;(* := 0 *)
		hiObjNbr 	: HINT;(* := 0 *)
		paCanData 	: ^t_a_CanData;
	END_VAR
	VAR_OUTPUT
		dRetCode 	: DINT;
	END_VAR
  VAR
    uiTmpCnt : UINT;
    pActPDOEntry : ^_PDOSETTINGS;
  END_VAR
  
  dRetCode := 0;
  uiTmpCnt := 0;    
  
  //check for additional TPdo's
  if sPDOAdditionalVars.bTxAdditionalUsed = FALSE & uiPDONbr > CO_NUMBER_DEFAULT_PDO then
    //if Pdo number is higher then default Pdo's it must be an additional Pdo
    dRetCode := -1;
    return;
  end_if;
  
  //set pointer to first transmit Pdo entry
  pActPDOEntry  := #TPdo1;
  
  //search for Pdo number
  if uiPDONbr > 0 then
    uiTmpCnt += 1;
    while (uiTmpCnt < uiPDONbr)  do
      if pActPDOEntry^.pNextPDO <> NIL then
        uiTmpCnt += 1;
        pActPDOEntry := pActPDOEntry^.pNextPDO;
      else
        //no valid entry found
        return;
      end_if;    
    end_while;
    
    //save the actual Pdo data offset
    dRetCode := uiTmpCnt;
  //search for object number
  elsif hiObjNbr > 0 then    

    while (pActPDOEntry^.ObjNr <> (hiObjNbr$INT-Place$INT)) do
      if pActPDOEntry^.pNextPDO <> NIL then
        uiTmpCnt += 1;
        pActPDOEntry := pActPDOEntry^.pNextPDO;
      else
        //no valid entry found
        return;
      end_if;      
    end_while;
    //save the actual Pdo data offset
    dRetCode := uiTmpCnt;
  end_if;

  if dRetCode > 0 then
    //send Pdo
    MasterDevice.CanTxObj((pActPDOEntry^.ObjNr+Place)$INT,
                           8,
                           paCanData,
                           TRUE);
    if uiPDONbr = 1 then
      SendMarkTpdo1 := SendMode <> 1;
      TimeRPdo1     := ops.tAbsolute;
    elsif uiPDONbr = 2 then
      SendMarkTpdo2 := SendMode <> 1;
      TimeRPdo2     := ops.tAbsolute;
    elsif uiPDONbr = 3 then
      SendMarkTpdo3 := SendMode <> 1;
      TimeRPdo3     := ops.tAbsolute;
    elsif uiPDONbr = 4 then
      SendMarkTpdo4 := SendMode <> 1;
      TimeRPdo4     := ops.tAbsolute;
    else
      sPDOAdditionalVars.TxVars[dRetCode-1].bSendFlag   := SendMode <> 1;
      sPDOAdditionalVars.TxVars[dRetCode-1].udTimeStamp := ops.tAbsolute;
    end_if;
                       
  end_if;

END_FUNCTION


FUNCTION _CanOpenBasicDS301::RPDOAdditionalObject
	VAR_INPUT
		pPDOElement 	: ^_PDOSETTINGS;
	END_VAR
	VAR_OUTPUT
		dRetCode 	: DINT;
	END_VAR
  VAR
    uiTmpPDOCnt : UINT;
    pActPdoEntry : ^_PDOSETTINGS;
    bFoundEntry : BOOL;
  END_VAR
  
  dRetCode := 0;
  
  pActPdoEntry := #RPdoAdditional;
  uiTmpPDOCnt  := 0;
  bFoundEntry  := FALSE;
  sPDOAdditionalVars.uiRPDOUsed += 1;
  
  if sPDOAdditionalVars.uiRPDOUsed = 1 then
    pActPdoEntry^ := pPDOElement^;
    dRetCode      := uiTmpPDOCnt+CO_NUMBER_DEFAULT_PDO+1;
  else
    while uiTmpPDOCnt < CO_MAX_PDO_OBJECTS do
      if pActPdoEntry^.pNextPDO = NIL then    
        pActPdoEntry^.pNextPDO$^void := StdLib.Malloc(size:=sizeof(_PDOSETTINGS));
        pActPdoEntry := pActPdoEntry^.pNextPDO;
        if pActPdoEntry = NIL then
          //error while allocate memory for RPDO
          ErrorAlloc := 1;
          dRetCode   := -1;
          exit;
        end_if;      
        pActPdoEntry^          := pPDOElement^;
        pActPdoEntry^.pNextPDO := NIL;
        dRetCode               := uiTmpPDOCnt+CO_NUMBER_DEFAULT_PDO+1;
        bFoundEntry            := TRUE;
        exit;
      else    
        pActPdoEntry := pActPdoEntry^.pNextPDO;
      end_if;
      uiTmpPDOCnt += 1;
    end_while;
    if bFoundEntry = FALSE then
      //max numbers of objects reached
      MasterDevice.LogError("@0421 (_CanOpenBasicDS301::RPDOAdditionalObject) Maximum number of receive Pdo's is reached!");
    end_if;
  end_if;  
  
END_FUNCTION


FUNCTION _CanOpenBasicDS301::TPDOAdditionalObject
	VAR_INPUT
		pPDOElement 	: ^_PDOSETTINGS;
	END_VAR
	VAR_OUTPUT
		dRetCode 	: DINT;
	END_VAR
  VAR
    uiTmpPDOCnt : UINT;
    pActPdoEntry : ^_PDOSETTINGS;
    bFoundEntry : BOOL;
  END_VAR

  dRetCode := 0;
  
  pActPdoEntry := #TPdoAdditional;
  uiTmpPDOCnt  := 0;
  bFoundEntry  := FALSE;
  sPDOAdditionalVars.uiTPDOUsed += 1;
  
  if sPDOAdditionalVars.uiTPDOUsed = 1 then
    pActPdoEntry^ := pPDOElement^;
    dRetCode      := uiTmpPDOCnt+CO_NUMBER_DEFAULT_PDO+1;
  else
    while uiTmpPDOCnt < CO_MAX_PDO_OBJECTS do
      if pActPdoEntry^.pNextPDO = NIL then    
        pActPdoEntry^.pNextPDO$^void := StdLib.Malloc(size:=sizeof(_PDOSETTINGS));
        pActPdoEntry := pActPdoEntry^.pNextPDO;
        if pActPdoEntry = NIL then
          //error while allocate memory for RPDO
          ErrorAlloc := 1;
          dRetCode   := -1;
          exit;
        end_if;      
        pActPdoEntry^          := pPDOElement^;
        pActPdoEntry^.pNextPDO := NIL;
        dRetCode               := uiTmpPDOCnt+CO_NUMBER_DEFAULT_PDO+1;
        bFoundEntry            := TRUE;
        exit;
      else    
        pActPdoEntry := pActPdoEntry^.pNextPDO;
      end_if;
      uiTmpPDOCnt += 1;
    end_while;
    if bFoundEntry = FALSE then
      //max numbers of objects reached
      MasterDevice.LogError("@0422 (_CanOpenBasicDS301::TPDOAdditionalObject) Maximum number of transmit Pdo's is reached!");
    end_if;
  end_if;  
  
END_FUNCTION


FUNCTION _CanOpenBasicDS301::XDCGetNetworkManagementInfo
  VAR
    dTempRetCode : DINT;
    aTempStr     : Array[0..CO_XDC_MAX_STRING_LENGTH-1] of CHAR;
    pHelpElement : ^_XML_ELEMENT;
    udTempValue   : UDINT;
  END_VAR
  
  //initialize return value with ok
  dTempRetCode := 0;
  
  // get CANopenGeneralFeatures
  //**********************************************************************************************************************************
  pHelpElement :=  _XMLReaderXDC.GetElementByName(pName:="CANopenGeneralFeatures");
  
  if pHelpElement then
    //***************************************************************************************
    dTempRetCode := XDCGetNameValue(pStringName:="groupMessaging"
                                  , pAttributeList:=#pHelpElement^.Attributes
                                  , pudValue:=#udTempValue
                                  , pStringValue:=#aTempStr[0]
                                  , dDataType:=CO_XDC_VALUES_TYPE_STR_BOOL);
    if dTempRetCode = 0 then
      sXDCVars.sNetworkManagementInfo.GeneralFeatures.bgroupMessaging   := udTempValue$BOOL;
      sXDCVars.sNetworkManagementInfo.GeneralFeatures.biEntryValid.Bit1 := TRUE;
    end_if;
    
    //***************************************************************************************
    dTempRetCode := XDCGetNameValue(pStringName:="dynamicChannels"
                                  , pAttributeList:=#pHelpElement^.Attributes
                                  , pudValue:=#sXDCVars.sNetworkManagementInfo.GeneralFeatures.uddynamicChannels
                                  , pStringValue:=#aTempStr[0]);
                  
    if dTempRetCode = 0 then
      sXDCVars.sNetworkManagementInfo.GeneralFeatures.biEntryValid.Bit2 := TRUE;
    end_if;
    
    //***************************************************************************************
    dTempRetCode := XDCGetNameValue(pStringName:="selfStartingDevice"
                                  , pAttributeList:=#pHelpElement^.Attributes
                                  , pudValue:=#udTempValue
                                  , pStringValue:=#aTempStr[0]
                                  , dDataType:=CO_XDC_VALUES_TYPE_STR_BOOL);
    if dTempRetCode = 0 then
      sXDCVars.sNetworkManagementInfo.GeneralFeatures.bselfStartingDevice := udTempValue$BOOL;
      sXDCVars.sNetworkManagementInfo.GeneralFeatures.biEntryValid.Bit3   := TRUE;
    end_if;    
    
    //***************************************************************************************
    dTempRetCode := XDCGetNameValue(pStringName:="SDORequestingDevice"
                                  , pAttributeList:=#pHelpElement^.Attributes
                                  , pudValue:=#udTempValue
                                  , pStringValue:=#aTempStr[0]
                                  , dDataType:=CO_XDC_VALUES_TYPE_STR_BOOL);
    if dTempRetCode = 0 then
      sXDCVars.sNetworkManagementInfo.GeneralFeatures.bSDORequestingDevice := udTempValue$BOOL;
      sXDCVars.sNetworkManagementInfo.GeneralFeatures.biEntryValid.Bit4    := TRUE;
    end_if;
    
    //***************************************************************************************
    dTempRetCode := XDCGetNameValue(pStringName:="granularity"
                                  , pAttributeList:=#pHelpElement^.Attributes
                                  , pudValue:=#sXDCVars.sNetworkManagementInfo.GeneralFeatures.udgranularity
                                  , pStringValue:=#aTempStr[0]);
    
    if dTempRetCode = 0 then
      sXDCVars.sNetworkManagementInfo.GeneralFeatures.biEntryValid.Bit5 := TRUE;
    end_if;
    
    //***************************************************************************************
    dTempRetCode := XDCGetNameValue(pStringName:="nrOfRxPDO"
                                  , pAttributeList:=#pHelpElement^.Attributes
                                  , pudValue:=#sXDCVars.sNetworkManagementInfo.GeneralFeatures.udnrOfRxPDO
                                  , pStringValue:=#aTempStr[0]);
    if dTempRetCode = 0 then
      sXDCVars.sNetworkManagementInfo.GeneralFeatures.biEntryValid.Bit6 := TRUE;
    end_if;
    
    //***************************************************************************************
    dTempRetCode := XDCGetNameValue(pStringName:="nrOfTxPDO"
                                  , pAttributeList:=#pHelpElement^.Attributes
                                  , pudValue:=#sXDCVars.sNetworkManagementInfo.GeneralFeatures.udnrOfTxPDO
                                  , pStringValue:=#aTempStr[0]);
    if dTempRetCode = 0 then
      sXDCVars.sNetworkManagementInfo.GeneralFeatures.biEntryValid.Bit7 := TRUE;
    end_if;
        
    //***************************************************************************************
    dTempRetCode := XDCGetNameValue(pStringName:="bootUpSlave"
                                  , pAttributeList:=#pHelpElement^.Attributes
                                  , pudValue:=#udTempValue
                                  , pStringValue:=#aTempStr[0]
                                  , dDataType:=CO_XDC_VALUES_TYPE_STR_BOOL);
    if dTempRetCode = 0 then
      sXDCVars.sNetworkManagementInfo.GeneralFeatures.bbootUpSlave      := udTempValue$BOOL;
      sXDCVars.sNetworkManagementInfo.GeneralFeatures.biEntryValid.Bit8 := TRUE;
    end_if;    
    
    //***************************************************************************************
    dTempRetCode := XDCGetNameValue(pStringName:="layerSettingServiceSlave"
                                  , pAttributeList:=#pHelpElement^.Attributes
                                  , pudValue:=#udTempValue
                                  , pStringValue:=#aTempStr[0]
                                  , dDataType:=CO_XDC_VALUES_TYPE_STR_BOOL);
    if dTempRetCode = 0 then
      sXDCVars.sNetworkManagementInfo.GeneralFeatures.blayerSettingServiceSlave := udTempValue$BOOL;
      sXDCVars.sNetworkManagementInfo.GeneralFeatures.biEntryValid.Bit9         := TRUE;
    end_if;    
  end_if;
    
  // get CANopenMasterFeatures
  //**********************************************************************************************************************************
  pHelpElement :=  _XMLReaderXDC.GetElementByName(pName:="CANopenMasterFeatures");
  
  if pHelpElement then
    //***************************************************************************************
    dTempRetCode := XDCGetNameValue(pStringName:="bootUpMaster"
                                  , pAttributeList:=#pHelpElement^.Attributes
                                  , pudValue:=#udTempValue
                                  , pStringValue:=#aTempStr[0]
                                  , dDataType:=CO_XDC_VALUES_TYPE_STR_BOOL);
    if dTempRetCode = 0 then
      sXDCVars.sNetworkManagementInfo.MasterFeatures.bbootUpMaster     := udTempValue$BOOL;
      sXDCVars.sNetworkManagementInfo.MasterFeatures.biEntryValid.Bit1 := TRUE;
    end_if;
    
    //***************************************************************************************
    dTempRetCode := XDCGetNameValue(pStringName:="flyingMaster"
                                  , pAttributeList:=#pHelpElement^.Attributes
                                  , pudValue:=#udTempValue
                                  , pStringValue:=#aTempStr[0]
                                  , dDataType:=CO_XDC_VALUES_TYPE_STR_BOOL);
    if dTempRetCode = 0 then
      sXDCVars.sNetworkManagementInfo.MasterFeatures.bflyingMaster     := udTempValue$BOOL;
      sXDCVars.sNetworkManagementInfo.MasterFeatures.biEntryValid.Bit2 := TRUE;
    end_if;
    
    //***************************************************************************************
    dTempRetCode := XDCGetNameValue(pStringName:="SDOManager"
                                  , pAttributeList:=#pHelpElement^.Attributes
                                  , pudValue:=#udTempValue
                                  , pStringValue:=#aTempStr[0]
                                  , dDataType:=CO_XDC_VALUES_TYPE_STR_BOOL);
    if dTempRetCode = 0 then
      sXDCVars.sNetworkManagementInfo.MasterFeatures.bSDOManager       := udTempValue$BOOL;
      sXDCVars.sNetworkManagementInfo.MasterFeatures.biEntryValid.Bit3 := TRUE;
    end_if;

    //***************************************************************************************
    dTempRetCode := XDCGetNameValue(pStringName:="configurationManager"
                                  , pAttributeList:=#pHelpElement^.Attributes
                                  , pudValue:=#udTempValue
                                  , pStringValue:=#aTempStr[0]
                                  , dDataType:=CO_XDC_VALUES_TYPE_STR_BOOL);
    if dTempRetCode = 0 then
      sXDCVars.sNetworkManagementInfo.MasterFeatures.bconfigurationManager := udTempValue$BOOL;
      sXDCVars.sNetworkManagementInfo.MasterFeatures.biEntryValid.Bit4     := TRUE;
    end_if;
 
    //***************************************************************************************
    dTempRetCode := XDCGetNameValue(pStringName:="layerSettingServiceMaster"
                                  , pAttributeList:=#pHelpElement^.Attributes
                                  , pudValue:=#udTempValue
                                  , pStringValue:=#aTempStr[0]
                                  , dDataType:=CO_XDC_VALUES_TYPE_STR_BOOL);
    if dTempRetCode = 0 then
      sXDCVars.sNetworkManagementInfo.MasterFeatures.blayerSettingServiceMaster := udTempValue$BOOL;
      sXDCVars.sNetworkManagementInfo.MasterFeatures.biEntryValid.Bit5          := TRUE;
    end_if;    
  end_if;
  
  
  // get deviceCommissioning
  //**********************************************************************************************************************************
  pHelpElement :=  _XMLReaderXDC.GetElementByName(pName:="deviceCommissioning");
  
  if pHelpElement then  
    //***************************************************************************************
    dTempRetCode := XDCGetNameValue(pStringName:="nodeID"
                                  , pAttributeList:=#pHelpElement^.Attributes
                                  , pudValue:=#sXDCVars.sNetworkManagementInfo.DeviceCommissioning.udnodeID
                                  , pStringValue:=#aTempStr[0]);
                  
    if dTempRetCode = 0 then
      sXDCVars.sNetworkManagementInfo.DeviceCommissioning.biEntryValid.Bit1 := TRUE;
    end_if;
  
    //***************************************************************************************
    dTempRetCode := XDCGetNameValue(pStringName:="nodeName"
                                  , pAttributeList:=#pHelpElement^.Attributes
                                  , pudValue:=#udTempValue
                                  , pStringValue:=#sXDCVars.sNetworkManagementInfo.DeviceCommissioning.strnodeName[0]);
                  
    if dTempRetCode = 0 then
      sXDCVars.sNetworkManagementInfo.DeviceCommissioning.biEntryValid.Bit2 := TRUE;
    end_if;
  
    //***************************************************************************************
    dTempRetCode := XDCGetNameValue(pStringName:="actualBaudRate"
                                  , pAttributeList:=#pHelpElement^.Attributes
                                  , pudValue:=#sXDCVars.sNetworkManagementInfo.DeviceCommissioning.udactualBaudRate
                                  , pStringValue:=#aTempStr[0]);
                  
    if dTempRetCode = 0 then
      sXDCVars.sNetworkManagementInfo.DeviceCommissioning.biEntryValid.Bit3 := TRUE;
    end_if;
  
    //***************************************************************************************
    dTempRetCode := XDCGetNameValue(pStringName:="networkNumber"
                                  , pAttributeList:=#pHelpElement^.Attributes
                                  , pudValue:=#sXDCVars.sNetworkManagementInfo.DeviceCommissioning.udnetworkNumber
                                  , pStringValue:=#aTempStr[0]);
                  
    if dTempRetCode = 0 then
      sXDCVars.sNetworkManagementInfo.DeviceCommissioning.biEntryValid.Bit4 := TRUE;
    end_if;
  
    //***************************************************************************************
    dTempRetCode := XDCGetNameValue(pStringName:="networkName"
                                  , pAttributeList:=#pHelpElement^.Attributes
                                  , pudValue:=#udTempValue
                                  , pStringValue:=#sXDCVars.sNetworkManagementInfo.DeviceCommissioning.strnetworkName[0]);
                  
    if dTempRetCode = 0 then
      sXDCVars.sNetworkManagementInfo.DeviceCommissioning.biEntryValid.Bit5 := TRUE;
    end_if;
  
    //***************************************************************************************
    dTempRetCode := XDCGetNameValue(pStringName:="CANopenManager"
                                  , pAttributeList:=#pHelpElement^.Attributes
                                  , pudValue:=#udTempValue
                                  , pStringValue:=#aTempStr[0]
                                  , dDataType:=CO_XDC_VALUES_TYPE_STR_BOOL);
    if dTempRetCode = 0 then
      sXDCVars.sNetworkManagementInfo.DeviceCommissioning.bCANopenManager   := udTempValue$BOOL;
      sXDCVars.sNetworkManagementInfo.DeviceCommissioning.biEntryValid.Bit6 := TRUE;
    end_if;
  end_if;  
  
END_FUNCTION


FUNCTION _CanOpenBasicDS301::XDCGetCANOpenObjectList
  VAR
    dTempRetCode : DINT;
    aTempStr     : Array[0..CO_XDC_MAX_STRING_LENGTH-1] of CHAR;
    pHelpElement : ^_XML_ELEMENT;
    udTempValue  : UDINT;
  END_VAR
  
  //initialize return value with ok
  dTempRetCode := 0;
  sXDCVars.hdActSearchIndex := 0;
  // get all available indexes from xdc file
  //**********************************************************************************************************************************
//  pHelpElement := _XMLReaderXDC.GetElementByName(pName:="CANopenObject");
  pHelpElement := _XMLReaderXDC.GetFirstElement();
  
  while pHelpElement do
    //***************************************************************************************
    dTempRetCode := XDCGetNameValue(pStringName:="index"
                                  , pAttributeList:=#pHelpElement^.Attributes
                                  , pudValue:=#udTempValue
                                  , pStringValue:=#aTempStr[0]
                                  , dDataType:=CO_XDC_VALUES_TYPE_HEX);
    if dTempRetCode = 0 then
      sXDCVars.aObjectIndexes[sXDCVars.uiFoundObjectIndexes] := udTempValue$HINT;
      sXDCVars.uiFoundObjectIndexes += 1;
    end_if;
    if sXDCVars.uiFoundObjectIndexes >= CO_XDC_MAX_OBJECT_INDEXES then
      //maximum of array is reached
      exit;
    end_if;
    pHelpElement := _XMLReaderXDC.GetNextElement();
  end_while;
  
END_FUNCTION


FUNCTION _CanOpenBasicDS301::DeactivatePDO
  VAR_INPUT
    pPdoElement   : ^_PDOSETTINGS;
  END_VAR
  VAR
    usTmpCnt : USINT;
  END_VAR

    pPdoElement^.active   := FALSE; // TRUE = active, FALSE = inactive
    pPdoElement^.inactive := FALSE; // set to true if Pdo should be set to inactive on CanOpen node
        
    //highest subindex number
    pPdoElement^.HighestSubNbr.Index  := -1;
    //deactivate Pdo mapping
    pPdoElement^.Deactivate.Index  := -1;
    //activate Pdo mapping
    pPdoElement^.Activate.Index    := -1;      
    // Synchronous or Asynchronous Transmission
    pPdoElement^.TransmissionType.Index := -1;
    // Residence time, delivery period
    pPdoElement^.InhibitTime.Index      := -1;    
    // Pdo choice parameter
    pPdoElement^.PdoChoice.Index  := -1;
    // event timer
    pPdoElement^.EventTimer.Index := -1;    
    // SYNC start value
    pPdoElement^.SyncStartValue.Index := -1;

    pPdoElement^.ActiveNbrOfMappings := -1;
    // Pdo mapping parameter
    for usTmpCnt := 0 to (CO_MAX_PDO_MAPPING_ENTRIES-1)$USINT do
      //deactivate mapping parameter
      pPdoElement^.MappingPara[usTmpCnt].Index := -1;
    end_for;    
    
END_FUNCTION


FUNCTION VIRTUAL _CanOpenBasicDS301::DefaultPDOSetting
	VAR_INPUT
		pPdoElement 	: ^_PDOSETTINGS;
		iAddressSetting 	: INT;
		iCobId 	: INT;(* := 0x00 *)
	END_VAR  
  
  if iCobId = 0 then
    if pPdoElement^.ObjNr <> 0 then
      iCobId := pPdoElement^.ObjNr; 
    else  
      MasterDevice.LogError("@0420 (_CanOpenBasicDS301::DefaultPDOSetting) Initialize Pdo with default values failed because COB-ID is 0!");
      DeactivatePDO(pPdoElement:=pPdoElement);
    end_if;    
  else
    pPdoElement^.ObjNr := iCobId;
  end_if;  
    
  pPdoElement^.active   := TRUE; // TRUE = active, FALSE = inactive
  pPdoElement^.inactive := FALSE; // set to true if Pdo should be set to inactive on CanOpen node
    
  // highest subindex number
  pPdoElement^.HighestSubNbr.Index         := -1;// -1 = inactive
  pPdoElement^.HighestSubNbr.SubIndex      := CO_SUBINDEX_HIGHEST_SUBNBR;
  pPdoElement^.HighestSubNbr.Data          := 0;  
  
  // at first the Pdo must be deactivated on CanOpen node  
  pPdoElement^.Deactivate.Index          := iAddressSetting;
  pPdoElement^.Deactivate.SubIndex       := CO_SUBINDEX_COB_ID;
  pPdoElement^.Deactivate.Data           := to_dint(CO_MAP_PARA_PDO_VALID_FLAG + iCobId$UINT + Place$UINT);  
    
  // Synchronous or Asynchronous Transmission
  pPdoElement^.Transmissiontype.Index    := iAddressSetting;
  pPdoElement^.Transmissiontype.SubIndex := CO_SUBINDEX_TRANS_TYPE;
  pPdoElement^.Transmissiontype.Data     := CO_TRANSMISSION_TYPE_EVERYSYNC;
  
  // min time between Pdo retry
  pPdoElement^.InhibitTime.Index         := -1;// -1 = inactive
  pPdoElement^.InhibitTime.SubIndex      := CO_SUBINDEX_INHIBIT_TIME;
  pPdoElement^.InhibitTime.Data          := 0;
  
  //not used
  pPdoElement^.PdoChoice.Index           := -1; //CO_INDEX_RPDO1_CHOICE;
  
  //event timer
  pPdoElement^.EventTimer.Index         := -1;// -1 = inactive
  pPdoElement^.EventTimer.SubIndex      := CO_SUBINDEX_EVENT_TIMER;
  pPdoElement^.EventTimer.Data          := 0;
  
  //SYNC start value
  pPdoElement^.SyncStartValue.Index         := -1;// -1 = inactive
  pPdoElement^.SyncStartValue.SubIndex      := CO_SUBINDEX_SYNC_START_VALUE;
  pPdoElement^.SyncStartValue.Data          := 0;
  
  // Activate Pdo
  // at last the Pdo must be activated on CanOpen node  
  pPdoElement^.Activate.Index          := iAddressSetting;
  pPdoElement^.Activate.SubIndex       := 16#01;
  pPdoElement^.Activate.Data           := to_dint(iCobId + Place$UINT);  
  
END_FUNCTION


FUNCTION _CanOpenBasicDS301::AsyncSDOHandling
  VAR_INPUT
    pHandle   : ^DINT;
    iIndex   : INT;
    siSubIndex   : SINT;
    dData   : DINT;
    bRW   : BOOL;
    usLength   : USINT;
    pAsyncData   : ^DINT;
  END_VAR
  VAR_OUTPUT
    dRetCode   : iprStates;
  END_VAR
  

  dRetCode := GetAsyncState(pHandle);// Get SDO state  
    
  //**********************************************************************************************
  // ASYNC DATA HANDLING
  //**********************************************************************************************
  case dRetCode of 

    READY:// Send SDO --------------------------------------------------
      AsyncCmd(Index    := iIndex, 
               SubIndex := siSubIndex, 
               Data     := dData, 
               RW       := bRW, 
               Len      := usLength);

    ERROR:// Send SDO was not successful -------------------------------
      pAsyncData^           := GetAsyncData(pHandle^,NIL);
      ComSDO.bRW            := bRW;
      ComSDO.usLen          := usLength;
      ComSDO.hiIndex        := TO_UINT(iIndex);
      ComSDO.hsSubIndex     := TO_USINT(siSubIndex);
      ComSDO.hdData         := TO_UDINT(dData);
      ComSDO.hdErrorRetCode := TO_UDINT(pAsyncData^);
      ComSDO.dErrorCounter  += 1;
      ErrorSDO += 1;
      
      //Add Data to pipe (1 = successful)
      if cPipe_Add(sSDOErrorLogging.pSDOErrorPipe, #ComSDO, sizeof(t_s_ComSDOInfo)) = 1 then
        //one more sdo error info in buffer
        sSDOErrorLogging.usDataInBuffer += 1;
      end_if;
      
    QUIT:// Send SDO was successful ------------------------------------
      pAsyncData^ := GetAsyncData(pHandle^,NIL);
      
  end_case;    

END_FUNCTION


FUNCTION _CanOpenBasicDS301::ResetReceiveFlag
  VAR
    usTmpCnt : USINT;
  END_VAR
  
  bRPdo1Rec := FALSE;
  bRPdo2Rec := FALSE;
  bRPdo3Rec := FALSE;
  bRPdo4Rec := FALSE;
  
  //check for additional RPdo's
  if sPDOAdditionalVars.bRxAdditionalUsed then
    for usTmpCnt := 0 to sPDOAdditionalVars.uiRPDOUsed-1 do
      sPDOAdditionalVars.RxVars[usTmpCnt+CO_NUMBER_DEFAULT_PDO].bRPdoRec := FALSE;
    end_for;
  end_if;
  
END_FUNCTION


FUNCTION _CanOpenBasicDS301::XDCCheckIndexExisting
	VAR_INPUT
		phdActIndex 	: ^HDINT;
		hdMaxIndex 	: HDINT;(* := 0x0000 *)
	END_VAR
	VAR_OUTPUT
		dRetCode 	: DINT;
	END_VAR
  VAR
  	uiTmpCnt : UINT;
  END_VAR
  
  if hdMaxIndex = 0x0000 then
    hdMaxIndex := phdActIndex^;
  end_if;
  
  dRetCode := -1;
  
  while phdActIndex^ < hdMaxIndex do
    for uiTmpCnt := 0  to sXDCVars.uiFoundObjectIndexes-1 do
      if sXDCVars.aObjectIndexes[uiTmpCnt] = phdActIndex^$HINT then
        dRetCode := 0;
        return;
      end_if; 
    end_for;
    phdActIndex^ += 1;
  end_while;

END_FUNCTION


FUNCTION VIRTUAL _CanOpenBasicDS301::XDCGetAdditionalIndexes

END_FUNCTION


FUNCTION _CanOpenBasicDS301::XDCAccessTypeToDec
	VAR_INPUT
		pstrAccessType 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		eAccessType 	: t_e_AccessTypeXDC;
	END_VAR

  eAccessType := _UnknownType;
  toSigCLib.StrLwr(pstrAccessType);
  
  if _strcmp(str1:=pstrAccessType, str2:=CO_ACCESSTYPE_STR_CONST) = 0 then
    eAccessType := _Constant;
  elsif _strcmp(str1:=pstrAccessType, str2:=CO_ACCESSTYPE_STR_RO) = 0 
  | _strcmp(str1:=pstrAccessType, str2:=CO_ACCESSTYPE_STR_READ) = 0 then
    eAccessType := _ReadOnly;
  elsif _strcmp(str1:=pstrAccessType, str2:=CO_ACCESSTYPE_STR_WO) = 0 
  | _strcmp(str1:=pstrAccessType, str2:=CO_ACCESSTYPE_STR_WRITE) = 0 then
    eAccessType := _WriteOnly;
  elsif _strcmp(str1:=pstrAccessType, str2:=CO_ACCESSTYPE_STR_RW) = 0 
  | _strcmp(str1:=pstrAccessType, str2:=CO_ACCESSTYPE_STR_READWRITE) = 0 then
    eAccessType := _ReadWrite;
  elsif _strcmp(str1:=pstrAccessType, str2:=CO_ACCESSTYPE_STR_RWR) = 0 
  | _strcmp(str1:=pstrAccessType, str2:=CO_ACCESSTYPE_STR_READWRITEREAD) = 0 then
    eAccessType := _ReadWriteRead;
  elsif _strcmp(str1:=pstrAccessType, str2:=CO_ACCESSTYPE_STR_RWW) = 0 
  | _strcmp(str1:=pstrAccessType, str2:=CO_ACCESSTYPE_STR_READWRITEWRITE) = 0 then
    eAccessType := _ReadWriteWrite;
  end_if;
    
END_FUNCTION


FUNCTION _CanOpenBasicDS301::XDCCheckWriteable
	VAR_INPUT
		eAccesMode 	: t_e_AccessTypeXDC;
	END_VAR
	VAR_OUTPUT
		bWriteable 	: BOOL;
	END_VAR
  
  bWriteable := FALSE;
  
  case eAccesMode of
    //If the access type could not be read, the parameter will still be written to remain compatible with the previous version.
    _UnknownType,
    _WriteOnly,      
    _ReadWrite,       
    _ReadWriteRead,      
    _ReadWriteWrite:
      bWriteable := TRUE;
  end_case;

END_FUNCTION


FUNCTION VIRTUAL _CanOpenBasicDS301::StartSegmentUpload
	VAR_INPUT
		uiIndexSegmentUploadModule 	: UINT;
		usSubindexSegmentUploadModule 	: USINT;
		pUploadData 	: ^USINT;
		udUploadLength 	: UDINT;
	END_VAR

  
  if pUploadData <> NIL then

    // 'file' pointer for writing of uploaded data
    s_SegmentHandling.p_UploadData := pUploadData;
    // length of upload data
    s_SegmentHandling.ud_UploadLength                := udUploadLength;
    s_SegmentHandling.ui_IndexSegmentUploadModule    := uiIndexSegmentUploadModule;
    s_SegmentHandling.us_SubindexSegmentUploadModule := usSubindexSegmentUploadModule;

    // Check if it is OK to start a segment upload
    if s_SegmentHandling.us_SegmentTransferActive = CO_SEGMENT_INACTIVE then // no segment transfer active

      if StartSegUploadTransfer() <> 0 then
        // stop segment transfer
        Stop_SegmentTransfer();
        
        // log error: PrepareSDOUploadInitiate was NOK;
        // set error state
        s_SegmentHandling.en_SegmentTransferResult := SEGTR_ERROR_PrepSDOUpldInitNOK;
        
      else
        // status of segment transfer
        //s_SegmentHandling.en_SegmentTransferResult := SEGTR_UPLOAD;
      end_if;
      
    else
      // log error: upload could not be started - another segment transfer is active
      // set error state
      s_SegmentHandling.en_SegmentTransferResult := SEGTR_ERROR_UpldSegTransAkt;
    end_if;
  
  else
    // log error: new upload not started: invalid data pointer
    // set error state
    s_SegmentHandling.en_SegmentTransferResult := SEGTR_ERROR_InvalUpldPtr;
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL _CanOpenBasicDS301::StartSegUploadTransfer
	VAR_OUTPUT
		retVal 	: DINT;
	END_VAR

  retVal := InitiateSegmentUpload();
  
  if retVal = 0 then
  
    s_SegmentHandling.us_SegmentTransferActive := CO_UPLOAD_SEGMENT_ACTIVE;
    // now we wait for response
    s_SegmentHandling.b_Wait4ModuleResponse          := TRUE;
    // reset response timeout
    s_SegmentHandling.ud_SendTime     := ops.tAbsolute;

  end_if;
 
END_FUNCTION


FUNCTION VIRTUAL _CanOpenBasicDS301::Stop_SegmentTransfer

  s_SegmentHandling.us_SegmentTransferActive := CO_SEGMENT_INACTIVE;
  
END_FUNCTION


FUNCTION VIRTUAL _CanOpenBasicDS301::InitiateSegmentUpload
	VAR_OUTPUT
		retval 	: DINT;
	END_VAR  
  
  _memset(dest:=#TXCAN_Data_Seg[0], usByte:=0, cntr:=sizeof(TXCAN_Data_Seg));

  retval := PrepareSDOUploadInitiate(pSDOData:=#TXCAN_Data_Seg[0], Index:=s_SegmentHandling.ui_IndexSegmentUploadModule, SubIndex:=s_SegmentHandling.us_SubindexSegmentUploadModule);
  
  if retval = 0 then

    retval := SendDataViaCAN(pData:=#TXCAN_Data_Seg[0], Length:=sizeof(t_s_CanOpen_SDO_Upload_Initiate_Request), ObjNr:=(TSdoObjNr + TO_INT(Place))$INT);
    
  end_if;

END_FUNCTION


FUNCTION VIRTUAL _CanOpenBasicDS301::CANReceiveSegmentTransfer
  VAR
    TmpCommandSpecifier : BSINT;
    TmpUsedBytesInBuffer : USINT;
    bStopSegmentTransfer : BOOL;
  END_VAR
  
  // Byte 0..7  ... CAN Data
  // Byte 8     ... Data length
  // Byte 9..10 ... CAN-object Number

  bStopSegmentTransfer := FALSE;
   
  //Check which type of Transfer currently is active
  
  //Download Segment
  if s_SegmentHandling.us_SegmentTransferActive = CO_DOWNLOAD_SEGMENT_ACTIVE then
  //**************************************************************************************************

    //Check toggle bit in response
    if s_SegmentHandling.b_ToggleBit = RXCAN_Data$t_s_CanOpen_SDO_Dwnld_Segment_Request.Header.ToggleBit then
      _ToggleBitOKCnt += 1;
    else
      _ToggleBitNotOKCnt += 1;
    end_if;      
    
    //Save flag that we got response
    s_SegmentHandling.b_Wait4ModuleResponse := FALSE;
  
  //Upload Segment
  elsif s_SegmentHandling.us_SegmentTransferActive = CO_UPLOAD_SEGMENT_ACTIVE then
  //**************************************************************************************************

    TmpCommandSpecifier := ((RXCAN_Data$t_s_CanOpen_SDO_Upload_Segment_Response.Header AND CO_CO_COMMAND_SPECIFIER_MASK) shr 5);
    
    //Check for a valid command specifier for Upload Segment Transfer
    if TmpCommandSpecifier = CO_CO_CS_UPLOAD_SEGMENT_RESPONSE | TmpCommandSpecifier = CO_CO_CS_INITIATE_UPLOAD_RESPONSE then
      
      if TmpCommandSpecifier = CO_CO_CS_UPLOAD_SEGMENT_RESPONSE then
        
        TmpUsedBytesInBuffer := sizeof(t_s_CanOpen_SDO_Upload_Segment_Response.aData) - ((RXCAN_Data$t_s_CanOpen_SDO_Upload_Segment_Response.Header AND 16#0E) shr 1);

        //Copy data into receive buffer
        if s_SegmentHandling.ud_ReadActDataLen + TmpUsedBytesInBuffer < s_SegmentHandling.ud_UploadLength then
          _memcpy(ptr1:=s_SegmentHandling.p_UploadData + s_SegmentHandling.ud_ReadActDataLen , ptr2:=#RXCAN_Data[1], cntr:=TmpUsedBytesInBuffer);
          s_SegmentHandling.ud_ReadActDataLen += TmpUsedBytesInBuffer;        
        else // not all data of received CAN message shall be uploaded
          // error handling:  read to many bytes from module
          
          _memcpy(ptr1:=s_SegmentHandling.p_UploadData + s_SegmentHandling.ud_ReadActDataLen 
                 , ptr2:=#RXCAN_Data[1]
                 , cntr:=s_SegmentHandling.ud_UploadLength - s_SegmentHandling.ud_ReadActDataLen
                 );
          s_SegmentHandling.ud_ReadActDataLen += TmpUsedBytesInBuffer; 
          // stop the segment transfer
          bStopSegmentTransfer := TRUE;
        end_if;          
      end_if;
                
      //Check if more packets are left: C -> 1 .. no more segments to be uploaded
      if (RXCAN_Data$t_s_CanOpen_SDO_Upload_Segment_Response.Header.C <> 0) |
         (bStopSegmentTransfer = TRUE) then 
        
        //No More Segments to be uploaded
        s_SegmentHandling.us_SegmentTransferActive := CO_SEGMENT_INACTIVE;
        
        // segment upload was successful
        s_SegmentHandling.en_SegmentTransferResult := SEGTR_OK;
      
        // reset read buffer
        s_SegmentHandling.ud_ReadActDataLen := 0;
        
      else
        s_SegmentHandling.b_SendResponseToModule := TRUE;

      end_if;
      
      //Save flag that we got response
      s_SegmentHandling.b_Wait4ModuleResponse := FALSE;
      
    else //Invalid Command specifier for Upload Segment Transfer
      Stop_SegmentTransfer();
      // Errorlogging: Invalid Command specifier for Upload Segment Transfer
      // show error state on server
      s_SegmentHandling.en_SegmentTransferResult := SEGTR_ERROR_InvalCmdSpec;
    end_if;
  end_if;     
  
END_FUNCTION


FUNCTION VIRTUAL _CanOpenBasicDS301::HandleSegmentTransferCommunication
  VAR
    udTmpCopyLen : UDINT;
    retval : DINT;
    bIsLastPacket : BOOL;
  END_VAR
  
  // Check if we have to send Segment Data SDOs and check we if do not wait for an response for the segment
  //****************************************************************************************************************************************************************************    
  if s_SegmentHandling.us_SegmentTransferActive = CO_DOWNLOAD_SEGMENT_ACTIVE & s_SegmentHandling.b_Wait4ModuleResponse = FALSE then
  
    _memset(dest:=#TXCAN_Data_Seg[0], usByte:=0, cntr:=sizeof(TXCAN_Data_Seg)); 
          
    //Check if its first transfer -> we have to initiate the segment transfer
    if s_SegmentHandling.b_IsFirstPacket = TRUE then
    
      s_SegmentHandling.ud_ActWriteOffset := 0;
          
      retval := PrepareSDODownloadInitiate(pSDOData:=#TXCAN_Data_Seg[0]
                                          , pSendData:= (#(s_SegmentHandling.ud_DownloadLength))$^USINT
                                          , usDataLen:= 4
                                          , hIndex:= s_SegmentHandling.ui_IndexSegmentDownloadModule
                                          , hsSubIndex:= s_SegmentHandling.us_SubindexSegmentDownloadModule
                                          , ExpeditedTransfer:=0                                     
                                          );
                                          
      s_SegmentHandling.b_ToggleBit := CO_CO_CS_TOGGLEBIT_START_VALUE;
                                          
      udTmpCopyLen := 0;
      bIsLastPacket := FALSE;
      s_SegmentHandling.b_IsFirstPacket := FALSE;
    
    else
    
      // Limit length for segment transfer
      if s_SegmentHandling.ud_DataLeftToWrite > sizeof(t_s_CanOpen_SDO_Dwnld_Segment_Request.Data) then
        udTmpCopyLen := sizeof(t_s_CanOpen_SDO_Dwnld_Segment_Request.Data);
        bIsLastPacket := FALSE;
      else
        udTmpCopyLen := s_SegmentHandling.ud_DataLeftToWrite;
        bIsLastPacket := TRUE;
      end_if;     

      //Prepare Buffer for segmented transfer
      retval := PrepareSDODownloadSegmentTransfer( pSDOData:=#TXCAN_Data_Seg[0] 
                                                 , pSendData:=(s_SegmentHandling.p_WriteData + s_SegmentHandling.ud_ActWriteOffset)
                                                 , DataLen:=  udTmpCopyLen$USINT
                                                 , pToggleBit:= #s_SegmentHandling.b_ToggleBit
                                                 , LastPacket:= bIsLastPacket
                                                 );
    end_if;
                                       
    //Check for success of preparing SDO packet                 
    if retval = 0 then
      
      // Send Can object
      retval := SendDataViaCAN( pData:=#TXCAN_Data_Seg[0]
                                 , Length:= sizeof(t_s_CanOpen_SDO_Dwnld_Segment_Request)
                                 , ObjNr:=TO_INT(TSdoObjNr + TO_INT(Place))
                                 );    
      
      if retval = 0 then
        // Increment Write Offset
        s_SegmentHandling.ud_ActWriteOffset += udTmpCopyLen;
        
        //Reduce amount of Data which has to be write yet
        s_SegmentHandling.ud_DataLeftToWrite -= udTmpCopyLen;
        
        s_SegmentHandling.b_Wait4ModuleResponse := TRUE;
        // reset response timeout
        s_SegmentHandling.ud_SendTime     := ops.tAbsolute;
        // Check if we got data to transmit left or not       
        if bIsLastPacket then 
          
          // No more data left to send
          s_SegmentHandling.us_SegmentTransferActive := CO_SEGMENT_INACTIVE; // no segment transfer active at the moment
          
          // segment download was successful
          s_SegmentHandling.en_SegmentTransferResult := SEGTR_OK;
          
          s_SegmentHandling.b_ToggleBit := CO_CO_CS_TOGGLEBIT_START_VALUE;
            
        else // 

        end_if;
      else
        //Errorhandling
      end_if;
    else
      //Errorhandling
    end_if;
  
  // carry out upload segment transfer (PrepareSDOUploadInitiate is called in method StartSegmentUpload)
  //****************************************************************************************************************************************************************************    
  elsif s_SegmentHandling.us_SegmentTransferActive = CO_UPLOAD_SEGMENT_ACTIVE & s_SegmentHandling.b_SendResponseToModule = TRUE then
    
    _memset(dest:=#TXCAN_Data_Seg[0], usByte:=0, cntr:=sizeof(TXCAN_Data_Seg));
    retval := PrepareSDOUploadSegmentTransfer(pSDOData:=#TXCAN_Data_Seg[0], pToggleBit:=#s_SegmentHandling.b_ToggleBit);
    if retval = 0 then
    
      retval := SendDataViaCAN(pData:=#TXCAN_Data_Seg[0], Length:=8, ObjNr:= (TSdoObjNr + TO_INT(Place))$INT);
      if retval = 0 then
        s_SegmentHandling.b_SendResponseToModule := FALSE;
        
        // now we wait for response
        s_SegmentHandling.b_Wait4ModuleResponse := TRUE;
        // reset response timeout
        s_SegmentHandling.ud_SendTime     := ops.tAbsolute;
      end_if;        
    end_if;
  
  // check for response timeout
  //****************************************************************************************************************************************************************************    
  elsif s_SegmentHandling.b_Wait4ModuleResponse = TRUE then
  
    //Check for timeout
    if s_SegmentHandling.us_SegmentTransferActive = CO_UPLOAD_SEGMENT_ACTIVE then
      
      if ops.tAbsolute - s_SegmentHandling.ud_SendTime > CO_WAIT4RESP_UPLOAD_TIMEOUT then
        s_SegmentHandling.b_Wait4ModuleResponse := FALSE;
        
        Stop_SegmentTransfer();
        // error logging:  upload timeout surpassed
        // set error state
        s_SegmentHandling.en_SegmentTransferResult := SEGTR_ERROR_UpldTOPassed;
      end_if;
      
    elsif s_SegmentHandling.us_SegmentTransferActive = CO_DOWNLOAD_SEGMENT_ACTIVE then
    
      //Check for timeout
      if ops.tAbsolute - s_SegmentHandling.ud_SendTime > CO_WAIT4RESP_DOWNLOAD_TIMEOUT then
        s_SegmentHandling.b_Wait4ModuleResponse := FALSE;
        
        Stop_SegmentTransfer();
        // error logging:  download timeout surpassed
        // set error state
        s_SegmentHandling.en_SegmentTransferResult := SEGTR_ERROR_DldTOPassed;
      end_if;
    
    else
      // do nothing
    end_if;
  
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL _CanOpenBasicDS301::PrepareSDOUploadInitiate
	VAR_INPUT
		pSDOData 	: ^USINT;
		Index 	: HINT;
		SubIndex 	: HSINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  
  retcode := 0;
    
  //Check valid ptr
  if pSDOData = NIL then
    retcode := -2;
    return;
  end_if;
  
  //Reset Headerinformation
  pSDOData^$t_s_CanOpen_SDO_Upload_Initiate_Request.Header := 0;
  
  //Set correct Headerinformation for Expedited Transfer
  pSDOData^$t_s_CanOpen_SDO_Upload_Initiate_Request.Header := (CO_CO_CS_INITIATE_UPLOAD_REQUEST shl 5);     // Initiate upload Request
  
  //Set right indexes  
  pSDOData^$t_s_CanOpen_SDO_Upload_Initiate_Request.Index := Index;
  pSDOData^$t_s_CanOpen_SDO_Upload_Initiate_Request.SubIndex := SubIndex;
  
END_FUNCTION


FUNCTION VIRTUAL _CanOpenBasicDS301::PrepareSDODownloadInitiate
	VAR_INPUT
		pSDOData 	: ^USINT;
		pSendData 	: ^USINT;
		usDataLen 	: USINT;
		hIndex 	: HINT;
		hsSubIndex 	: HSINT;
		ExpeditedTransfer 	: BOOL;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
  	UnusedBytes : USINT;
  END_VAR
  
  retcode := 0;
  
  //Check for correct data length
  if usDataLen > sizeof(t_s_CanOpen_SDO_Dwnld_Initiate_Request.Data) then
    retcode := -1;
    return;
  end_if;
  
  //Check valid ptr
  if pSDOData = NIL | pSendData = NIL then
    retcode := -2;
    return;
  end_if;

  //Calculate data size  
  UnusedBytes := sizeof(t_s_CanOpen_SDO_Dwnld_Initiate_Request.Data) - usDataLen;
  
  //Reset Headerinformation
  pSDOData^$t_s_CanOpen_SDO_Dwnld_Initiate_Request.Header := 0;
  
  //Set correct Headerinformation for Expedited Transfer
  pSDOData^$t_s_CanOpen_SDO_Dwnld_Initiate_Request.Header._CCS1 := CO_CO_CS_INITIATE_DOWNLOAD_REQUEST;     // Initiate Download Request
  pSDOData^$t_s_CanOpen_SDO_Dwnld_Initiate_Request.Header._E    := ExpeditedTransfer;
  pSDOData^$t_s_CanOpen_SDO_Dwnld_Initiate_Request.Header._S    := 1;     // data set size is indicated

  //Set right amount of used data bytes 
  pSDOData^$t_s_CanOpen_SDO_Dwnld_Initiate_Request.Header._N1   := to_bool(UnusedBytes AND 16#01);
  pSDOData^$t_s_CanOpen_SDO_Dwnld_Initiate_Request.Header._N2   := to_bool(((UnusedBytes shr 1) AND 16#01));  
  
  //Set right indexes  
  pSDOData^$t_s_CanOpen_SDO_Dwnld_Initiate_Request.Index := hIndex;
  pSDOData^$t_s_CanOpen_SDO_Dwnld_Initiate_Request.SubIndex := hsSubIndex;
  
  //Copy data into Data section
  _memcpy(ptr1:= (pSDOData + t_s_CanOpen_SDO_Dwnld_Initiate_Request.Data)
        , ptr2:= pSendData
        , cntr:= usDataLen);
        
END_FUNCTION


FUNCTION VIRTUAL _CanOpenBasicDS301::PrepareSDOUploadSegmentTransfer
	VAR_INPUT
		pSDOData 	: ^USINT;
		pToggleBit 	: ^BOOL;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
    
  retcode := 0;
    
  //Check valid ptr
  if pSDOData = NIL then
    retcode := -2;
    return;
  end_if;
    
  //Set correct Headerinformation for abort transfer
  pSDOData^$t_s_CanOpen_SDO_Upload_Segment_Request.Header := (CO_CO_CS_UPLOAD_SEGMENT_REQUEST shl 5);
  
  pSDOData^$t_s_CanOpen_SDO_Upload_Segment_Request.Header.ToggleBit := pToggleBit^;   //Toggle bit, starts with zero   
  pToggleBit^ := pToggleBit^ xor 1;
  
END_FUNCTION


FUNCTION VIRTUAL _CanOpenBasicDS301::PrepareSDODownloadSegmentTransfer
	VAR_INPUT
		pSDOData 	: ^USINT;
		pSendData 	: ^USINT;
		DataLen 	: USINT;
		pToggleBit 	: ^BOOL;
		LastPacket 	: BOOL;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
  	UnusedBytes : USINT;
  END_VAR
 
  retcode := 0;
  
  //Check for correct data length
  if DataLen > sizeof(t_s_CanOpen_SDO_Dwnld_Segment_Request.Data) then
    retcode := -1;
    return;
  end_if;
  
  //Check valid ptr
  if pSDOData = NIL | pSendData = NIL | pToggleBit = NIL then
    retcode := -2;
    return;
  end_if;
  
  //Calculate data size  
  UnusedBytes := sizeof(t_s_CanOpen_SDO_Dwnld_Segment_Request.Data) - DataLen;  
  
  //Reset Headerinformation
  pSDOData^$t_s_CanOpen_SDO_Dwnld_Segment_Request.Header := 0;
  
  //Set correct Headerinformation for segment Transfer
  pSDOData^$t_s_CanOpen_SDO_Dwnld_Segment_Request.Header._CCS1     := CO_CO_CS_DOWNLOAD_SEGMENT_REQUEST;  //Command
  pSDOData^$t_s_CanOpen_SDO_Dwnld_Segment_Request.Header._C        := LastPacket <> 0;     //0 .. not last packet, 1.. last one 
  pSDOData^$t_s_CanOpen_SDO_Dwnld_Segment_Request.Header.ToggleBit := pToggleBit^;          //Toggle bit, starts with zero
  
  pToggleBit^ := pToggleBit^ xor 1; //Toggle it

  //Set right amount of used data bytes
  pSDOData^$t_s_CanOpen_SDO_Dwnld_Segment_Request.Header._N1   := to_bool(UnusedBytes AND 16#01);
  pSDOData^$t_s_CanOpen_SDO_Dwnld_Segment_Request.Header._N2   := to_bool(((UnusedBytes shr 1) AND 16#01));  
  pSDOData^$t_s_CanOpen_SDO_Dwnld_Segment_Request.Header._N3   := to_bool(((UnusedBytes shr 2) AND 16#01));  
      
  //Copy data to send into Data section
  _memcpy(ptr1:= (pSDOData + t_s_CanOpen_SDO_Dwnld_Segment_Request.Data)
        , ptr2:= pSendData
        , cntr:= DataLen);
        
END_FUNCTION


FUNCTION VIRTUAL _CanOpenBasicDS301::StartSegDownloadTransfer
	VAR_INPUT
		udLength 	: UDINT;
	END_VAR

    // start next segment transfer
    s_SegmentHandling.b_IsFirstPacket := TRUE;
    s_SegmentHandling.ud_DataLeftToWrite := udLength;
    
END_FUNCTION


FUNCTION GLOBAL _CanOpenBasicDS301::SendDataViaCAN
	VAR_INPUT
		pData 	: ^USINT;
		Length 	: USINT;
		ObjNr 	: INT;
	END_VAR
	VAR_OUTPUT
		retval 	: DINT;
	END_VAR
  
  //Check for pointer
  if pData = NIL then
    retval := -1;
    return;
  end_if;
  
  //Transmit CAN Data Object
  retval := MasterDevice.CanTxObj(ObjNr:=ObjNr, length:= Length, data:=pData, FALSE);
  
  // increase SDO send counters
  if retval = 0 then // --> SUCCESSFUL
    SendCounterSdo    += 1;
    ComSDO.dTxCounter += 1;
  end_if;  
  
END_FUNCTION


FUNCTION VIRTUAL _CanOpenBasicDS301::StartSegmentDownload
	VAR_INPUT
		uiIndexSegmentDownloadModule 	: UINT;
		usSubindexSegmentDownloadModule 	: USINT;
		pDownloadData 	: ^USINT;
		udDownloadLength 	: UDINT;
	END_VAR
  
  if pDownloadData <> NIL then

    s_SegmentHandling.p_WriteData                      := pDownloadData;
    
    s_SegmentHandling.ud_DownloadLength                := udDownloadLength;
    s_SegmentHandling.ui_IndexSegmentDownloadModule    := uiIndexSegmentDownloadModule;
    s_SegmentHandling.us_SubindexSegmentDownloadModule := usSubindexSegmentDownloadModule;
    
    
    
    if s_SegmentHandling.us_SegmentTransferActive = CO_SEGMENT_INACTIVE  then
    
      s_SegmentHandling.us_SegmentTransferActive := CO_DOWNLOAD_SEGMENT_ACTIVE;

      // start the download transfer
      StartSegDownloadTransfer(s_SegmentHandling.ud_DownloadLength);

    else

      // Errorlogging: new Download not started: segment up- or download running at the moment
      // set error state
      s_SegmentHandling.en_SegmentTransferResult := SEGTR_ERROR_DldSegTransfAkt;
    end_if;
  else
    // Errorlogging: new Download not started: invalid download pointer
    // set error state
    s_SegmentHandling.en_SegmentTransferResult := SEGTR_ERROR_InvalDldPtr;
  end_if;
  
END_FUNCTION


FUNCTION GLOBAL _CanOpenBasicDS301::StartSegmentTransfer
	VAR_INPUT
		uiIndex 	: UINT;
		usSubIndex 	: USINT;
		pData 	: ^USINT;
		udLength 	: UDINT;
		bRW 	: DINT;
	END_VAR

  if bRW = 0 then // upload (read) data
    StartSegmentUpload(uiIndexSegmentUploadModule:=uiIndex
                       , usSubindexSegmentUploadModule:=usSubIndex
                       , pUploadData:=pData
                       , udUploadLength:=udLength
                       );
  else // download (write) data
    StartSegmentDownload( uiIndexSegmentDownloadModule:=uiIndex
                        , usSubindexSegmentDownloadModule:=usSubIndex
                        , pDownloadData:=pData
                        , udDownloadLength:=udLength
                        );
  end_if;


END_FUNCTION


FUNCTION GLOBAL _CanOpenBasicDS301::CheckStatusSegmentTransfer
	VAR_OUTPUT
		retVal 	: USINT;
	END_VAR

  retVal := s_SegmentHandling.us_SegmentTransferActive;

END_FUNCTION


FUNCTION _CanOpenBasicDS301::_Segment_Up_Download

  if s_SegmentHandling.us_SegmentTransferActive <> CO_SEGMENT_INACTIVE then

    // carry out only if there are new data from CAN (ReceiveCounterSdo is increased only if a new CAN object is received))
    if ReceiveCounterSdo > s_SegmentHandling.ud_oldReceiveCounterSdo then
      // copy data in own buffer
      _memcpy(ptr1:=#(RXCAN_Data[0]), ptr2:=#(RxBufferSdo[0]), cntr:=8);
      // work out segment transfer CAN data from CAN module
      CANReceiveSegmentTransfer();
      // save old ReceiveCounterSdo
      s_SegmentHandling.ud_oldReceiveCounterSdo := ReceiveCounterSdo;
    end_if;
    // send CAN data for segment transfer to CAN module
    HandleSegmentTransferCommunication();
  
  end_if;

END_FUNCTION


FUNCTION GLOBAL _CanOpenBasicDS301::GetReceiveCounterSdo
	VAR_OUTPUT
		retVal 	: UDINT;
	END_VAR

  retVal := ReceiveCounterSdo;
  
END_FUNCTION


FUNCTION GLOBAL _CanOpenBasicDS301::GetRxBufferSdo
	VAR_OUTPUT
		retVal 	: ^HSINT;
	END_VAR
  
  retVal := #(RxBufferSdo[0]);

END_FUNCTION


FUNCTION GLOBAL _CanOpenBasicDS301::GetTSdoObjNr
	VAR_OUTPUT
		retVal 	: INT;
	END_VAR

  retVal := TSdoObjNr;

END_FUNCTION


FUNCTION GLOBAL _CanOpenBasicDS301::CheckResultSegmentTransfer
	VAR_OUTPUT
		retVal 	: t_SegmentTransferResult;
	END_VAR
  
  retVal := s_SegmentHandling.en_SegmentTransferResult;

END_FUNCTION


FUNCTION _CanOpenBasicDS301::NMTStateProcess

  //only set new nmt state from node if it is activated
  if CheckNMTState = 1 then
    if CanDeviceState = _CAN_BOOT_UP then
      //bootup message received
      bNewNMTState := TRUE;      
      //set quit error flag
      bQuitErrorNewNMT := TRUE;      
      
      //set error state for quit error and NewNMTState
      QuitErrorNMTState := NewNMTState := CanDeviceState;
      //set node to COM Error if Boot-Up Msg is received
      if Required & DeviceState = _CanOpenMng::_CAN_OPERATIONAL then
        OpMode      := _CAN_COMERROR;
        DeviceState := _CanOpenMng::_CAN_COMERROR;
      end_if;
      
    //set quit error if can node is in an error state   
    elsif (CanDeviceState = _CAN_OPERATIONAL | CanDeviceState = _CAN_PRE_OPERATIONAL  | CanDeviceState = _CAN_STOPPED)    
    & (DeviceState = _CanOpenMng::_CAN_COMERROR  | DeviceState = _CanOpenMng::_CAN_HBERROR 
      | DeviceState = _CanOpenMng::_CAN_NGERROR  | DeviceState = _CanOpenMng::_CAN_STOPPED) then
      //set new error quit nmt state if last state was not a boot up message
      if bQuitErrorNewNMT = FALSE | QuitErrorNMTState <> _CAN_BOOT_UP  then
        //set error state for quit error only if boot up or stopped is already acknowledged
        QuitErrorNMTState := CanDeviceState;
        //set quit error flag
        bQuitErrorNewNMT  := TRUE;
      end_if;
      
      //set client state
      bNewNMTState := TRUE;
      
      //set new received nmt state
      NewNMTState  := CanDeviceState;
      
    //check for state change and set it on client if last state change is already resetted  
    elsif bNewNMTState = FALSE & CanDeviceState <> NewNMTState then
      bNewNMTState := TRUE;
      NewNMTState  := CanDeviceState;      
    end_if;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _CanOpenBasicDS301::CanControlCy

END_FUNCTION

#pragma warning(disable:073);
FUNCTION VIRTUAL _CanOpenBasicDS301::GetProperty
	VAR_INPUT
		udPropertyID 	: UDINT;
		usDatalength 	: USINT;
		pPropertyValue 	: pVoid;
	END_VAR
	VAR_OUTPUT
		dRetCode 	: DINT;
	END_VAR
  
  //PropertyId not supported
  dRetCode := -1;

END_FUNCTION


FUNCTION VIRTUAL _CanOpenBasicDS301::SetProperty
	VAR_INPUT
		udPropertyID 	: UDINT;
		usDatalength 	: USINT;
		pPropertyValue 	: pVoid;
	END_VAR
	VAR_OUTPUT
		dRetCode 	: DINT;
	END_VAR
  //PropertyId not supported
  dRetCode := -1;
  
END_FUNCTION
#pragma warning(default:073);


FUNCTION GLOBAL _CanOpenBasicDS301::GetPlaceNbr
	VAR_OUTPUT
		dPlaceNbr 	: DINT;
	END_VAR

  //returns place number of node
  dPlaceNbr := Place;
  
END_FUNCTION
