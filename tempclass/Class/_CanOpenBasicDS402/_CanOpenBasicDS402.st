//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION
#include "..\..\Class\_CanOpenMng\_CanOpenMng.h"

(*!
<Class
	Name               = "_CanOpenBasicDS402"
	Revision           = "1.14"
	GUID               = "{3E10A88B-86EF-4C55-8C0E-A4275385E911}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(640,120)"
	Comment            = "Class can be used, to establish CANOpen Communication (DS402) to one Node">
	<Channels>
		<Server Name="ActDriveMode" GUID="{985D8633-C3E7-4778-80BB-5962D2FCA500}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Actual drive mode"/>
		<Server Name="ActPosition" GUID="{14B526EB-F3EB-4783-86CD-E925B0B2E834}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Actual position"/>
		<Server Name="ActSpeed" GUID="{A5232D9A-0E65-4961-9E54-A67437EA5C88}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Actual speed"/>
		<Server Name="ControlWord" GUID="{86AEB22D-02B7-4428-8E23-7EB21DFA53B5}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Controlword of the drive (DS402)"/>
		<Server Name="Current" GUID="{BC1BCB55-317C-4C33-9C52-EC2B6175356A}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Demand Current for Current Mode"/>
		<Server Name="DestAccel" GUID="{A5899783-7E7D-4BBE-81CF-C61B0A541106}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Destination Accel for pp Mode"/>
		<Server Name="DestDecel" GUID="{A622312F-E890-4151-BF2C-73FD6B8585D8}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Destination Decel for pp Mode"/>
		<Server Name="DestinationPos" GUID="{DE3384DD-939C-462E-8FDC-C17C5911B84E}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Destination Position for pp Mode"/>
		<Server Name="DestSpeed" GUID="{D85D9620-511E-4682-AB5B-19A540D96B2A}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Destination Speed for pp Mode"/>
		<Server Name="DriveError" GUID="{13127D7C-533A-4CA0-B52B-45731E22A7A7}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="General Error Information (0..no error, 1..error)"/>
		<Server Name="DriveErrorStatus" GUID="{1B7A4CEB-AFF3-41EF-9678-7A70A1B81C06}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Drive error code"/>
		<Server Name="DriveMode" GUID="{69B7FFA3-2EDB-4895-A449-04D2F774ED20}" Visualized="true" Initialize="true" DefValue="0" WriteProtected="false" Retentive="false" Comment="Drive Mode:(DS402)&#13;&#10;1..PP PROFILE POSITION MODE, &#13;&#10;3..PV PROFILE VELOCITY MODE, &#13;&#10;6..HM HOMING MODE,&#13;&#10;7..IP INTERPOLATED POSITION MODE.&#13;&#10;If a drive mode is changed twice by writing on this server the second value might not be set on this server and thereby not send to the drive if the processing of the first drive mode change hasn&apos;t finished."/>
		<Server Name="Enable" GUID="{51EDEBD4-ADEF-4512-BA8B-D3F5733E2E23}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Set Drive to enable&#13;&#10;0..Disable&#13;&#10;1..Enable"/>
		<Server Name="ErrorQuit" WriteProtected="false">
		</Server>
		<Server Name="Position" GUID="{BC80927C-0631-407B-A7F8-A07ABBBEFA4A}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Position for Interpolated Position Mode (DS402, IP-Mode)"/>
		<Server Name="Speed" GUID="{720FAFA4-8509-48DD-9957-1B9D03BF890C}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Demand Speed for Velocity Mode (DS402, PV-Mode)"/>
		<Server Name="StatusWord" GUID="{5BBAEB74-8667-43DF-B7C6-E6D298DFFCAC}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Status Word of Drive(DS402)"/>
		<Server Name="Stop" GUID="{DFDFE156-8D19-4B0F-93E5-76A5CF2F3F89}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Stop movement"/>
		<Client Name="ErrorSet" Required="false" Internal="false" Comment="General Error Information (0..no error, 1..error)"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\_CanOpenMng\_CanOpenMng.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="Roskri"/>
		<Dokumentation Revision="1.14" Date="25.06.2020" Author="PieSte" Company="Sigmatek" Description="Add LSS (Layer Setting Service) functions for internal use at baseclass.&#13;&#10;Add flag to reconize new drive error events.&#13;&#10;Add DIASMaster.h file at baseclass because of error at compiling without HwControl class in project (SA 57237)."/>
		<Dokumentation Revision="1.13" Date="09.03.2020" Author="PieSte" Company="Sigmatek" Description="Add &quot;CheckNMTState&quot; for reconnection of node if nmt boot up message is received.&#13;&#10;Add client &quot;NewNMTState&quot; to get new nmt states of node if &quot;CheckNMTState&quot; is enabled."/>
		<Dokumentation Revision="1.12" Date="17.02.2020" Author="HaeTho" Company="Sigmatek" Description="segment transfer added in _CanOpenBasicDS301"/>
		<Dokumentation Revision="1.11" Date="23.10.2019" Author="PieSte" Company="Sigmatek" Description="Corrected failure at writing of Pdo communication parameters from xdc file if they are not defined.&#13;&#10;Add deactivation of class if &quot;Place&quot; is set to &quot;DEACTIVATED_LSL&quot;. &#13;&#10;Add log messages if a parameter readout of xdc file failed.&#13;&#10;The initialization of device is stopped if there is no answer to sdo from node. &#13;&#10;The ErrorQuit server has been extended so that ResetComm() and ReInitObject() methods can also be triggered."/>
		<Dokumentation Revision="1.10" Date="04.06.2019" Author="PieSte" Company="Sigmatek" Description="It is now evaluated from the xdc file whether the mapping parameter is write-protected. If this is the case, this parameter is not transferred in the initialization.&#13;&#10;The transfer of the highest subindex number to subindex 0, the event timer to subindex 5 and the SYNC start value to subindex 6 at the communication parameters for node config was added."/>
		<Dokumentation Revision="1.9" Date="19.10.2018" Author="PieSte" Company="Sigmatek" Description="The conversion with &quot;to_udint&quot; and assignment to a smaller data type leads from compiler version C47 to an error. The conversion with &quot;to_uint&quot; and &quot;to_usint&quot; converts to the appropriate data types. The bug was fixed in the base class _CanOpenBasicDS301."/>
		<Dokumentation Revision="1.8" Date="11.09.2018" Author="PieSte" Company="Sigmatek" Description="Add support for xdc files. The rpdo and tpdo data structure has been extended to support more than the 4 default Pdo&apos;s. The Pdo mapping has been extended from 5 to 8 entries.&#13;&#10;Do not cause a communication error with connection abort, if a sdo transmission fails.&#13;&#10;Add logging for errors at initialisation and sdo communication.&#13;&#10;Add waiting time for change of drivemode.&#13;&#10;The read of error object in case of an error can be deactivate by setting variable IndexErrorStat to -1."/>
		<Dokumentation Revision="1.7" Date="16.04.2018" Author="RamAnd" Company="Sigmatek" Description="Added enable sequence instead of instantaneously setting all the bits in the control word.&#13;&#10;Reset the ResetFault bit in case of a non-quitable error."/>
		<Dokumentation Revision="1.6" Date="05.09.2017" Author="RamAnd" Company="Sigmatek" Description="New method SendAllPDOs() for easier overloading if there are new PDOs to send."/>
		<Dokumentation Revision="1.5" Date="07.02.2017" Author="EisMic" Company="Sigmatek" Description="ErrorQuit will now be send in CanControl method and not directly in write method."/>
		<Dokumentation Revision="1.4" Date="2016-10-11" Author="Roskri" Company="Sigmatek" Description="Changing drivemode twice before actual drive mode was read could cause that the second drivemode-change wasn&apos;t send to the drive. Changing drive mode directly after an driveerror occured could cause that the drivemode wasn&apos;t changed.&#13;&#10;PDOChoice-mapping parameter is by default deactivated.&#13;&#10;The accel parameter in method Moveref had no effect and the value 0 was always send to the drive independent of this parameter. &#13;&#10;The reference mode parameter was always send to the drive with the wrong length which led to an CAN_COMERROR&#13;&#10;Changing drive mode twice, by calling drivemode write-method before the class has finished processing the first drive mode change, is not allowed and server-value will in this case not change&#13;&#10;Servers DestSpeed,DestAccel,DestDecel are not write protected anymore.&#13;&#10;Examples corrected for reading position and speed with Rpdo2&#13;&#10;It now also possible in PP-Mode to read and write SDOs with _CanOpenSDOBase"/>
		<Dokumentation Revision="1.3" Date="07.09.2016" Author="EisMic" Company="Sigmatek" Description="Reworked definitions to avoid identical redefinitions."/>
		<Dokumentation Revision="1.2" Date="2016-06-30" Author="Roskri" Company="Sigmatek" Description="Changes in baseclass: GetNGorHBtime-method"/>
		<Dokumentation Revision="1.1" Date="2016-06-22" Author="Roskri" Company="Sigmatek" Description="Changes in base-Class"/>
		<Dokumentation Revision="1.0" Date="2016-06-20" Author="Roskri" Company="Sigmatek" Description="Class created"/>
	</RevDoku>
	<Network Name="_CanOpenBasicDS402">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{A7C1CD43-4DB4-4932-89F4-2926312D653A}"
				Class      = "_CanOpenBasicDS301"
				Position   = "(218,120)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="AsyncState"/>
					<Server Name="CanDisabled"/>
					<Server Name="DataReady"/>
					<Server Name="DeviceState"/>
					<Server Name="EmcyStatusByte0_3"/>
					<Server Name="EmcyStatusByte4_7"/>
					<Server Name="ErrorAlloc"/>
					<Server Name="ErrorQuit"/>
					<Server Name="ErrorSDO"/>
					<Client Name="CheckNMTState"/>
					<Client Name="ChkRxPdo"/>
					<Client Name="DisableEmergencyObject"/>
					<Client Name="FileSys"/>
					<Client Name="Index"/>
					<Client Name="MasterDevice"/>
					<Client Name="NewNMTState"/>
					<Client Name="NodeGuardingSupported"/>
					<Client Name="Place"/>
					<Client Name="ProducerHeartbeatSupported"/>
					<Client Name="Required"/>
					<Client Name="SDOTable"/>
					<Client Name="SendMode"/>
					<Client Name="StdLib"/>
					<Client Name="toSigCLib"/>
					<Client Name="toXDCFile"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.DeviceState" Destination="_base.DeviceState" Vertices="(1278,210),(1106,210),"/>
			<Connection Source="this.ErrorQuit" Destination="_base.ErrorQuit" Vertices="(1278,270),(1106,270),"/>
			<Connection Source="_base.Index" Destination="this.Index" Vertices="(218,330),(38,330),"/>
			<Connection Source="_base.Required" Destination="this.Required" Vertices="(218,390),(38,390),"/>
			<Connection Source="this.CanDisabled" Destination="_base.CanDisabled" Vertices="(1278,330),(1106,330),"/>
			<Connection Source="this.AsyncState" Destination="_base.AsyncState" Vertices="(1278,450),(1106,450),"/>
			<Connection Source="this.ErrorAlloc" Destination="_base.ErrorAlloc" Vertices="(1278,570),(1106,570),"/>
			<Connection Source="this.EmcyStatusByte0_3" Destination="_base.EmcyStatusByte0_3" Vertices="(1278,630),(1106,630),"/>
			<Connection Source="this.EmcyStatusByte4_7" Destination="_base.EmcyStatusByte4_7" Vertices="(1278,690),(1106,690),"/>
			<Connection Source="_base.MasterDevice" Destination="this.MasterDevice" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.Place" Destination="this.Place" Vertices="(218,270),(38,270),"/>
			<Connection Source="_base.ChkRxPdo" Destination="this.ChkRxPdo" Vertices="(218,450),(38,450),"/>
			<Connection Source="_base.NodeGuardingSupported" Destination="this.NodeGuardingSupported" Vertices="(218,510),(38,510),"/>
			<Connection Source="_base.SendMode" Destination="this.SendMode" Vertices="(218,630),(38,630),"/>
			<Connection Source="_base.ProducerHeartbeatSupported" Destination="this.ProducerHeartbeatSupported" Vertices="(218,570),(38,570),"/>
			<Connection Source="_base.DisableEmergencyObject" Destination="this.DisableEmergencyObject" Vertices="(218,690),(38,690),"/>
			<Connection Source="_base.SDOTable" Destination="this.SDOTable" Vertices="(218,870),(38,870),"/>
			<Connection Source="this.ErrorSDO" Destination="_base.ErrorSDO" Vertices="(1278,510),(1106,510),"/>
			<Connection Source="this.DataReady" Destination="_base.DataReady" Vertices="(1278,390),(1106,390),"/>
			<Connection Source="_base.toXDCFile" Destination="this.toXDCFile" Vertices="(218,930),(38,930),"/>
			<Connection Source="_base.CheckNMTState" Destination="this.CheckNMTState" Vertices="(218,750),(38,750),"/>
			<Connection Source="_base.NewNMTState" Destination="this.NewNMTState" Vertices="(218,810),(38,810),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using _CanOpenBasicDS301

_CanOpenBasicDS402 : CLASS
: _CanOpenBasicDS301
	TYPE
	  _EnableSequenceSSW :
	  (
	    _Disabled,
	    _DisableOperation,
	    _StartEnable,
	    _SwitchOn,
	    _EnableOperation,
	    _CheckOperationEnabled,
	    _Enabled
	  )$UDINT;
	  _HomingSSW :
	  (
	    REF_W4_START,
	    REF_SET_PARA,
	    REF_START,
	    REF_W4_END
	  )$UDINT;
	  _PPSSW :
	  (
	    _PP_W4_START,
	    _PP_START,
	    _W4_SETPOINT
	  )$UDINT;
#pragma pack(push, 1)
	  _RefPara : STRUCT
	    RefOffset : DINT;
	    RefMode : DINT;
	    Speed1 : DINT;
	    Speed2 : DINT;
	    Accel : DINT;
	  END_STRUCT;
#pragma pack(pop)
	  _SubOpMode :
	  (
	    _SUB_IDLE,
	    _SUB_SETOPMODE,
	    _SUB_HOMING,
	    _SUB_PROFILE_POSITION
	  )$UDINT;
	END_TYPE
  //Servers:
	DriveMode 	: SvrCh_DINT;
	ActDriveMode 	: SvrCh_DINT;
	StatusWord 	: SvrCh_DS402_State;
	ControlWord 	: SvrCh_DS402_Control;
	DriveError 	: SvrCh_DINT;
	DriveErrorStatus 	: SvrCh_HDINT;
	Enable 	: SvrCh_DINT;
	Position 	: SvrCh_DINT;
	Speed 	: SvrCh_DINT;
	Current 	: SvrCh_DINT;
	ActPosition 	: SvrCh_DINT;
	ActSpeed 	: SvrCh_DINT;
	DestinationPos 	: SvrCh_DINT;
	DestSpeed 	: SvrCh_DINT;
	DestAccel 	: SvrCh_DINT;
	DestDecel 	: SvrCh_DINT;
	Stop 	: SvrCh_DINT;
  //Clients:
	ErrorSet 	: CltCh_DINT;
  //Variables:
		SubOpMode 	: _SubOpMode;
		HlpHandleDrvMode_w 	: DINT;			//! <Variable Comment="Handle for asynchronous data transfer" Name="HlpHandleDrvMode_w"/>
		HlpHandleDrvMode_r 	: DINT;			//! <Variable Comment="Handle for asynchronous data transfer" Name="HlpHandleDrvMode_r"/>
		HlpHandleRefPara 	: DINT;			//! <Variable Comment="Handle for asynchronous data transfer" Name="HlpHandleRefPara"/>
		DriveModeChanged 	: BOOL;
		HomingRefOffset 	: _CAN_SDO_OBJECT;
		HomingRefMode 	: _CAN_SDO_OBJECT;
		HomingSpeed1 	: _CAN_SDO_OBJECT;
		HomingSpeed2 	: _CAN_SDO_OBJECT;
		HomingAccel 	: _CAN_SDO_OBJECT;
		RefPara 	: _RefPara;
		oldError 	: DINT;			//! <Variable Comment="Old error status" Name="oldError"/>
		IndexDriveMode_r 	: DINT;			//! <Variable Comment="Index for read drive mode Object (DS402 16#6061)" Name="IndexDriveMode_r"/>
		IndexDriveMode_w 	: DINT;			//! <Variable Comment="Index for write drive mode Object (DS402 16#6060)" Name="IndexDriveMode_w"/>
		SpecControlword : BDINT
		[
		  1 Bit1,
		  2 Bit2,
		  3 Bit3,
		  4 Bit4,
		  5 Bit5,
		  6 Bit6,
		  7 Bit7,
		  8 Bit8,
		  9 Bit9,
		  10 Bit10,
		  11 Bit11,
		  12 Bit12,
		  13 Bit13,
		  14 Bit14,
		  15 Bit15,
		  16 Bit16,
		  17 Bit17,
		  18 Bit18,
		  19 Bit19,
		  20 Bit20,
		  21 Bit21,
		  22 Bit22,
		  23 Bit23,
		  24 Bit24,
		  25 Bit25,
		  26 Bit26,
		  27 Bit27,
		  28 Bit28,
		  29 Bit29,
		  30 Bit30,
		  31 Bit31,
		  32 Bit32,
		];

		OldControlWord : BDINT
		[
		  1 Bit1,
		  2 Bit2,
		  3 Bit3,
		  4 Bit4,
		  5 Bit5,
		  6 Bit6,
		  7 Bit7,
		  8 Bit8,
		  9 Bit9,
		  10 Bit10,
		  11 Bit11,
		  12 Bit12,
		  13 Bit13,
		  14 Bit14,
		  15 Bit15,
		  16 Bit16,
		  17 Bit17,
		  18 Bit18,
		  19 Bit19,
		  20 Bit20,
		  21 Bit21,
		  22 Bit22,
		  23 Bit23,
		  24 Bit24,
		  25 Bit25,
		  26 Bit26,
		  27 Bit27,
		  28 Bit28,
		  29 Bit29,
		  30 Bit30,
		  31 Bit31,
		  32 Bit32,
		];

		PPModeSSW 	: _PPSSW;
		HomingSSW 	: _HomingSSW;
		HomingParaSSW 	: DINT;
		InitFinished 	: BOOL;
		ErrorOccured 	: DINT;
		TimeStampResetFault 	: UDINT;
		IndexErrorStat 	: DINT;			//! <Variable Comment="Index for error status" Name="IndexErrorStat"/>
		HlpHandleErrStat 	: DINT;			//! <Variable Comment="Handle for asynchronous data transfer" Name="HlpHandleErrStat"/>
		SubIndexDriveMode_r 	: DINT;
		SubIndexErrorStat 	: DINT;
		EnableSequenceSSW 	: _EnableSequenceSSW;
		EnableStartTime 	: UDINT;
		udTimeStampMChng 	: UDINT;
  //Functions:
				//! <Function Comment="Initialize drive&#13;&#10;" Name="InitSettingsAndPdos"/>
	FUNCTION VIRTUAL InitSettingsAndPdos;
				//! <Function Comment="Convert received Pdo to internal&#13;&#10;data structure (for example server)&#13;&#10;" Name="ConvertPdo1"/>
	FUNCTION VIRTUAL GLOBAL ConvertPdo1;
				//! <Function Comment="Convert received Pdo to internal&#13;&#10;data structure (for example server)&#13;&#10;" Name="ConvertPdo2"/>
	FUNCTION VIRTUAL GLOBAL ConvertPdo2;
				//! <Function Comment="Send Pdo to drive&#13;&#10;" Name="TransmitPdo1"/>
	FUNCTION VIRTUAL GLOBAL TransmitPdo1;
				//! <Function Comment="Send Pdo to drive&#13;&#10;" Name="TransmitPdo2"/>
	FUNCTION VIRTUAL GLOBAL TransmitPdo2;
				//! <Function Comment="Send Pdo to drive&#13;&#10;" Name="TransmitPdo3"/>
	FUNCTION VIRTUAL GLOBAL TransmitPdo3;
				//! <Function Comment="Send Pdo to drive&#13;&#10;" Name="TransmitPdo4"/>
	FUNCTION VIRTUAL GLOBAL TransmitPdo4;
				//! <Function Comment="Overload this function to change Pdo settings&#13;&#10;transmission time, inhibit time etc;&#13;&#10;" Name="GetPdoSettings"/>
	FUNCTION VIRTUAL GLOBAL GetPdoSettings;
				//! <Function Comment="Handles CAN-Communication" Name="CanControl"/>
	FUNCTION VIRTUAL GLOBAL CanControl;
				//! <Function Comment="Convert Manufacturer&#13;&#10;specific Controlword&#13;&#10;to DS 402 Standard Controlword" Name="ControlwordSwitching"/>
	FUNCTION VIRTUAL GLOBAL ControlwordSwitching;
				//! <Function Comment="Convert Manufacturer&#13;&#10;specific Statusword&#13;&#10;to DS 402 Standard Statusword&#13;&#10;" Name="StatusWordSwitching"/>
	FUNCTION VIRTUAL GLOBAL StatusWordSwitching
		VAR_INPUT
			Spec_Statusword 	: BDINT;
		END_VAR;
				//! <Function Comment="Start Profile Positionmode" Name="PPMode"/>
	FUNCTION PPMode;
				//! <Function Comment="Starting a reference movement (Homing mode)" Name="MoveRef"/>
	FUNCTION VIRTUAL GLOBAL MoveRef
		VAR_INPUT
			RefOffset 	: DINT;			//! <Variable Comment="Reference offset" Name="MoveRef.RefOffset"/>
			RefMode 	: DINT;			//! <Variable Comment="Reference mode" Name="MoveRef.RefMode"/>
			Speed1 	: DINT;			//! <Variable Comment="Reference speed 1" Name="MoveRef.Speed1"/>
			Speed2 	: DINT;			//! <Variable Comment="Reference speed 2" Name="MoveRef.Speed2"/>
			Accel 	: DINT;			//! <Variable Comment="Reference acceleration" Name="MoveRef.Accel"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="1 ... Referencing was successfully started&#13;&#10;0 ... Referencing couldn&apos;t be started since cyclic communication isn&apos;t active." Name="MoveRef.retcode"/>
		END_VAR;
				//! <Function Comment="Start homing mode" Name="HomingMode"/>
	FUNCTION HomingMode;
				//! <Function Comment="Writes the parameters for move reference.&#13;&#10;Is called by HomingMode." Name="SetRefPara"/>
	FUNCTION SetRefPara
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="timeout for the enable sequence [ms]&#13;&#10;default = 1000&#13;&#10;overwrite in derivation to get customized time" Name="GetEnableTimeout"/>
	FUNCTION VIRTUAL GetEnableTimeout
		VAR_OUTPUT
			EnableTimeout 	: UDINT;
		END_VAR;
				//! <Function Comment="handles the enable sequence" Name="EnableSequence"/>
	FUNCTION VIRTUAL EnableSequence;
	
	FUNCTION VIRTUAL GLOBAL ErrorQuit::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL DriveMode::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Enable::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Position::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Speed::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Stop::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _CanOpenBasicDS402::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__CANOPENBASICDS402
1$UINT, 14$UINT, (SIZEOF(::_CanOpenBasicDS402))$UINT, 
17$UINT, 1$UINT, 0$UINT, 
TO_UDINT(238678879), "_CanOpenBasicDS402", //Class
TO_UDINT(2457842784), "_CanOpenBasicDS301", 1$UINT, 15$UINT, //Baseclass
//Servers:
(::_CanOpenBasicDS402.DriveMode.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1765329764), "DriveMode", 
(::_CanOpenBasicDS402.ActDriveMode.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2692201446), "ActDriveMode", 
(::_CanOpenBasicDS402.StatusWord.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1533682038), "StatusWord", 
(::_CanOpenBasicDS402.ControlWord.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2412184912), "ControlWord", 
(::_CanOpenBasicDS402.DriveError.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1838592276), "DriveError", 
(::_CanOpenBasicDS402.DriveErrorStatus.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3862701496), "DriveErrorStatus", 
(::_CanOpenBasicDS402.Enable.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(56102836), "Enable", 
(::_CanOpenBasicDS402.Position.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2149546169), "Position", 
(::_CanOpenBasicDS402.Speed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4168236102), "Speed", 
(::_CanOpenBasicDS402.Current.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3820407313), "Current", 
(::_CanOpenBasicDS402.ActPosition.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3276766410), "ActPosition", 
(::_CanOpenBasicDS402.ActSpeed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1555690308), "ActSpeed", 
(::_CanOpenBasicDS402.DestinationPos.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2363242721), "DestinationPos", 
(::_CanOpenBasicDS402.DestSpeed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3212376252), "DestSpeed", 
(::_CanOpenBasicDS402.DestAccel.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3986829487), "DestAccel", 
(::_CanOpenBasicDS402.DestDecel.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2744323), "DestDecel", 
(::_CanOpenBasicDS402.Stop.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2411985666), "Stop", 
//Clients:
(::_CanOpenBasicDS402.ErrorSet.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3305567351), "ErrorSet", 
END_FUNCTION


#define USER_CNT__CanOpenBasicDS402 55

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__CanOpenBasicDS402] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _CanOpenBasicDS402::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= _CanOpenBasicDS301::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= _CanOpenBasicDS301::DeviceState.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, _CanOpenBasicDS301::DeviceState.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT__CanOpenBasicDS402;
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #InitSettingsAndPdos();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #ConvertPdo1();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #ConvertPdo2();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #TransmitPdo1();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #TransmitPdo2();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #TransmitPdo3();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[15]		:= #TransmitPdo4();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[17]		:= #GetPdoSettings();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[26]		:= #CanControl();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[50]		:= #ControlwordSwitching();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[51]		:= #StatusWordSwitching();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[52]		:= #MoveRef();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[53]		:= #GetEnableTimeout();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[54]		:= #EnableSequence();

#pragma warning (default : 74)
	_CanOpenBasicDS301::DeviceState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF _CanOpenBasicDS301::DeviceState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ErrorQuit.pMeth			:= StoreMethod( #M_RD_DIRECT(), #ErrorQuit::Write() );
	IF ErrorQuit.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	DriveMode.pMeth			:= StoreMethod( #M_RD_DIRECT(), #DriveMode::Write() );
	IF DriveMode.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ControlWord.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF ControlWord.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Enable.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Enable::Write() );
	IF Enable.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Position.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Position::Write() );
	IF Position.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Speed.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Speed::Write() );
	IF Speed.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Current.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF Current.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	DestinationPos.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF DestinationPos.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	DestSpeed.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF DestSpeed.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	DestAccel.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF DestAccel.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	DestDecel.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF DestDecel.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Stop.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Stop::Write() );
	IF Stop.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
FUNCTION VIRTUAL _CanOpenBasicDS402::InitSettingsAndPdos

  _CanOpenBasicDS301::InitSettingsAndPdos();

  //Init finished
  if InitSSW = 100 then
    if DriveMode <> 0 then
      SubOpMode := _SUB_SETOPMODE;
    end_if;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _CanOpenBasicDS402::Enable::Write
  VAR_INPUT
    input (EAX)   : DINT;
  END_VAR
  VAR_OUTPUT
    result (EAX)   : DINT;
  END_VAR

  if input then  
    result := 1;

    if EnableSequenceSSW = _Disabled then
      if StatusWord.VoltageEnabled   &
         StatusWord.QuickStop        &
         StatusWord.ReadyToSwitchOn  &
         StatusWord.SwitchedOn then
        
        // quick enable after disable
        EnableSequenceSSW := _EnableOperation;     
      else
        // enable from scratch
        EnableSequenceSSW := _StartEnable;     
      end_if;
    end_if;
  else
    // disable: clear only operation and opmode specific bits
    ControlWord.EnableOperation     := FALSE;
    ControlWord.OperationModeSpec1  := FALSE;

    result := 0;  
    EnableSequenceSSW := _DisableOperation;
  end_if;

END_FUNCTION //Enable


FUNCTION VIRTUAL GLOBAL _CanOpenBasicDS402::ErrorQuit::Write
  VAR_INPUT
    input (EAX)   : DINT;
  END_VAR
  VAR_OUTPUT
    result (EAX)   : DINT;
  END_VAR
    
  //call error quit of baseclass
  ErrorQuit := _CanOpenBasicDS301::ErrorQuit.Write(input);
  
  if (StatusWord.ReadyToSwitchOn = 1 ) & (StatusWord.SwitchedOn = 1) THEN  
    ControlWord.SwitchOn      := 1;
    ControlWord.EnableVoltage := 1;
    ControlWord.QuickStop     := 1;
  end_if;    
  
  // Reset Error 
  DriveError              := 0;
  DriveErrorStatus        := 0;
    
  ControlWord.ResetFault  := 1;
  // Set timestamp after a defined time again when the DriveError set if the error remains
  TimeStampResetFault     := ops.tabsolute;

  result                  := ErrorQuit;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _CanOpenBasicDS402::ConvertPdo1
  VAR
    HlpStatusWord : BDINT;
  END_VAR

  HlpStatusWord := RxBufferPdo1[0]$BINT;
  
  StatusWordSwitching(Spec_Statusword:=HlpStatusWord);
  
  ActPosition   := RxBufferPdo1[2]$DINT;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL _CanOpenBasicDS402::ConvertPdo2
  VAR
    tmpSpeed  :DINT;
  END_VAR

  ActPosition := RxBufferPdo2[0]$DINT; 
  tmpSpeed    := (RxBufferPdo2[4]$DINT and 0x00FFFFFF);
  ActSpeed    := tmpSpeed;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL _CanOpenBasicDS402::TransmitPdo1
  VAR
    TxBuffer : ARRAY[0..7] of HSINT;
    hObjNr   : HINT;
  END_VAR  
    
  _MemSet(#TxBuffer[0],0,sizeof(TxBuffer));
  
  // CONTROLWORD -------------------------------------------------------------------------------
  TxBuffer[0]$HINT := SpecControlWord$HINT;
  
  hObjNr := TPdo1.ObjNr$HINT;
  
  MasterDevice.CanTxObj((hObjNr+Place)$INT,
                         2,
                         #TxBuffer[0],
                         TRUE);
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL _CanOpenBasicDS402::TransmitPdo2
  VAR
    TxBuffer : ARRAY[0..7] of HSINT;
    hObjNr   : HINT;
  END_VAR  
    
  _MemSet(#TxBuffer[0],0,sizeof(TxBuffer));
  
  // TARGETPOS FOR PP MODE -------------------------------------------------------------------------------
  TxBuffer[0]$DINT := DestinationPos;
    
  TxBuffer[4]$DINT := DestSpeed;
  
  hObjNr := TPdo2.ObjNr$HINT;
  
  MasterDevice.CanTxObj((hObjNr+Place)$INT,
                         8,
                         #TxBuffer[0],
                         TRUE);
    
END_FUNCTION


FUNCTION VIRTUAL GLOBAL _CanOpenBasicDS402::TransmitPdo3
  VAR
    TxBuffer : ARRAY[0..7] of HSINT;
    hObjNr   : HINT;
  END_VAR  
    
  _MemSet(#TxBuffer[0],0,sizeof(TxBuffer));
  
  // SPEED FOR PV MODE -------------------------------------------------------------------------------
  TxBuffer[0]$DINT := Speed;
  
  hObjNr := TPdo3.ObjNr$HINT;
  
  MasterDevice.CanTxObj((hObjNr+Place)$INT,
                         8,
                         #TxBuffer[0],
                         TRUE);
    
END_FUNCTION


FUNCTION VIRTUAL GLOBAL _CanOpenBasicDS402::TransmitPdo4
   VAR
    TxBuffer : ARRAY[0..7] of HSINT;
    hObjNr   : HINT;
  END_VAR  
    
  _MemSet(#TxBuffer[0],0,sizeof(TxBuffer));
  
  // ACCEL FOR PP MODE -------------------------------------------------------------------------------
  TxBuffer[0]$DINT := DestAccel;
  
  TxBuffer[4]$DINT := DestDecel;
  
  hObjNr      := TPdo4.ObjNr$HINT;
  
  MasterDevice.CanTxObj((hObjNr+Place)$INT,
                         8,
                         #TxBuffer[0],
                         TRUE);
    
END_FUNCTION


FUNCTION VIRTUAL GLOBAL _CanOpenBasicDS402::ControlwordSwitching

  // CONTROLWORD IDENT TO STANDARD
  SpecControlWord$DS402_Control := ControlWord;
  
  if ControlWord <> OldControlword THEN
    SendMarkTpdo1 := TRUE;
  end_if;
  
  OldControlword$DS402_Control := ControlWord;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL _CanOpenBasicDS402::StatusWordSwitching
  VAR_INPUT
    Spec_Statusword   : BDINT;
  END_VAR

  // STATUSWORD IDENT TO STANDARD
  StatusWord := Spec_Statusword;
  DataReady := 1;
  
END_FUNCTION


FUNCTION _CanOpenBasicDS402::PPMode
//**************************************************************************************************
  // PROFILE POSITIONMODE (PP MODE)
  //**************************************************************************************************  
  case PPModeSSW of
    
    _PP_W4_START:// Do Nothing -----------------------------------------------------------------------
    
    _PP_START:// Start -------------------------------------------------------------------------------
      
      ControlWord.OperationModeSpec1 := TRUE;
      PPModeSSW := _W4_SETPOINT;
    
    _W4_SETPOINT:// Wait for setpoint ----------------------------------------------------------------
      
      if StatusWord.OperationModeSpec1 = TRUE THEN
        PPModeSSW := _PP_W4_START;
        ControlWord.OperationModeSpec1 := FALSE;
        ControlWord.OperationModeSpec2 := FALSE;
      end_if;
      
  end_case;
  //**************************************************************************************************
  // END PROFILE POSITIONMODE (PP MODE)
  //**************************************************************************************************  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL _CanOpenBasicDS402::MoveRef
  VAR_INPUT
    RefOffset : DINT;
    RefMode   : DINT;
    Speed1    : DINT;
    Speed2    : DINT;
    Accel     : DINT;
  END_VAR
  VAR_OUTPUT
    retcode   : DINT;
  END_VAR
  
  retcode := 0;
  
  if ( OpMode = _CAN_SYNC ) THEN 
            
    RefPara.RefOffset := RefOffset;
    RefPara.RefMode   := RefMode;
    RefPara.Speed1    := Speed1;
    RefPara.Speed2    := Speed2;
    RefPara.Accel     := Accel;
    
    DriveMode         := 6;
    SubopMode         := _SUB_SETOPMODE;
    HomingSSW         := REF_SET_PARA;
    HomingParaSSW     := 0;
    retcode           := 1;
    
  end_if;

END_FUNCTION


FUNCTION _CanOpenBasicDS402::HomingMode
  //**********************************************************************************************
  // MOVE Reference (HOMING MODE)
  //**********************************************************************************************
  case HomingSSW of
    
    REF_W4_START:// Do nothing just wait for start -----------------------------------------------
    
    REF_SET_PARA:// Set parameter for reference --------------------------------------------------
    
      ControlWord.OperationModeSpec1 := FALSE;
      
      if SetRefPara() = TRUE THEN
        HomingSSW := REF_START;
      end_if;
    
    REF_START:// Start move reference ------------------------------------------------------------
      
      ControlWord.OperationModeSpec1 := TRUE; // START REFERENCE
      HomingSSW := REF_W4_END;
      
    REF_W4_END:// Wait for moveend reference -----------------------------------------------------
      
      if (( StatusWord.OperationModeSpec1 = TRUE )  & ( StatusWord.OperationModeSpec2 = FALSE )) |   //-->SUCCESSFUL
         (( StatusWord.OperationModeSpec1 = FALSE ) & ( StatusWord.OperationModeSpec2 = TRUE  )) THEN//-->ERROR
        
        ControlWord.OperationModeSpec1 := FALSE;
        HomingSSW := REF_W4_START;
        SubOpMode := _SUB_IDLE;
        
      end_if; 
      
  end_case;
  //**********************************************************************************************
  // END MOVE Reference (HOMING MODE)
  //**********************************************************************************************
END_FUNCTION


FUNCTION _CanOpenBasicDS402::SetRefPara
  VAR_OUTPUT
    retcode     : BOOL;
  END_VAR
  VAR
    HlpRetcode  : iprStates;
    HlpIndex    : INT;
    HlpSubIndex : SINT;
    HlpData     : DINT;
    HlpRW       : BOOL;
    HlpLen      : UINT;
    HlpRetData  : DINT;
  END_VAR;
  // ---------------------------------------------------------------------------------------------
  // ----------------        SET PARAMETER FOR MOVE Reference (HOMING MODE)       ----------------
  // ---------------------------------------------------------------------------------------------
          
  retcode := FALSE;
  
  //**********************************************************************************************
  // SEND PARAMETER FOR MOVE Reference (HOMING MODE)
  //**********************************************************************************************
  case HomingParaSSW of
        
    0:// REFMODE ---------------------------------------------------------------------------------
      HlpIndex    := HomingRefMode.Index$INT;
      HlpSubIndex := HomingRefMode.SubIndex$SINT;
      HlpData     := RefPara.RefMode$DINT;
      HlpRW       := TRUE;
      HlpLen      := 1;
    
    1:// SPEED1 ----------------------------------------------------------------------------------
      HlpIndex    := HomingSpeed1.Index$INT;
      HlpSubIndex := HomingSpeed1.SubIndex$SINT;
      HlpData     := RefPara.Speed1;
      HlpRW       := TRUE;
      HlpLen      := 4;
   
    2:// SPEED2 ----------------------------------------------------------------------------------
      HlpIndex    := HomingSpeed2.Index$INT;
      HlpSubIndex := HomingSpeed2.SubIndex$SINT;
      HlpData     := RefPara.Speed2;
      HlpRW       := TRUE;
      HlpLen      := 4;

    3:// REFOFFSET -------------------------------------------------------------------------------
      HlpIndex    := HomingRefOffset.Index$INT;
      HlpSubIndex := HomingRefOffset.SubIndex$SINT;
      HlpData     := RefPara.RefOffset;
      HlpRW       := TRUE;
      HlpLen      := 4;
    
    4:// ACCEL -----------------------------------------------------------------------------------
      HlpIndex    := HomingAccel.Index$INT;
      HlpSubIndex := HomingAccel.SubIndex$SINT;
      HlpData     := RefPara.Accel;
      HlpRW       := TRUE;
      HlpLen      := 4;
  
    5:// FINISHED---------------------------------------------------------------------------------
      retcode := TRUE;
      RETURN;
      
  end_case;

  //**********************************************************************************************
  // ASYNC DATA HANDLING
  //**********************************************************************************************
  
  HlpRetcode := AsyncSDOHandling(pHandle  := #HlpHandleRefPara
                              , iIndex    := HlpIndex
                              , siSubIndex:= HlpSubIndex
                              , dData     := HlpData
                              , bRW       := TRUE
                              , usLength  := HlpLen$USINT
                              , pAsyncData:= #HlpRetData
                              );
                              
  // Send SDO --------------------------------------------------
  if HlpRetcode = READY then
  
  // Send SDO was not successful -------------------------------
  elsif HlpRetcode = ERROR then
    //don't set class to error if not required because then the communication to node is stopped  
    if Required then
      OpMode      := _CAN_COMERROR;
      DeviceState := _CanOpenMng::_CAN_COMERROR;
    end_if;
  
  // Send SDO was successful ------------------------------------  
  elsif HlpRetcode = QUIT then
    HomingParaSSW += 1; 
  end_if;    
  
  //****************************************************************************************************
  // END ASYNC DATA HANDLING
  //****************************************************************************************************
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL _CanOpenBasicDS402::DriveMode::Write
  VAR_INPUT
    input (EAX)   : DINT;
  END_VAR
  VAR_OUTPUT
    result (EAX)   : DINT;
  END_VAR

  if subOpmode <> _SUB_SETOPMODE then
    DriveMode := input;     
    SubOPMode := _SUB_SETOPMODE; 
    result    := DriveMode;        
  else
    result    := ACCESS_DENIED;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _CanOpenBasicDS402::Speed::Write
  VAR_INPUT
    input (EAX)   : DINT;
  END_VAR
  VAR_OUTPUT
    result (EAX)   : DINT;
  END_VAR

  Speed         := input;
  
  SendMarkTpdo1 := TRUE;
    
  result        := Speed;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _CanOpenBasicDS402::GetPdoSettings
  VAR
    sActPDOEntry : _PDOSETTINGS;
  END_VAR

  PDOIniSSW := 0; // DONT TOUCH

  // ----------------------------------------------------------------------------------------
  // -------   SET CONSTANT PARAMETER TO VARIABLES SO WE CAN EASY OVERLOAD ------------------
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  
  
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------  
  // ------------------                  INDEX DRIVEMODE                  -------------------
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  
  IndexDriveMode_w      := CO_INDEX_DRIVEMODE_W;
  IndexDriveMode_r      := CO_INDEX_DRIVEMODE_R;
  SubIndexDriveMode_r   := CO_DEFAULT_SUBINDEX;    
    
  IndexErrorStat        := -1;                     // -1 = read of error index is disabled
  SubIndexErrorStat     := CO_DEFAULT_SUBINDEX;    
  
  // ----------------------------------------------------------------------------------------  
  // ------------------------             HOMING-SETTINGS            ------------------------
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  // REF OFFSET
  HomingRefOffset.Index     := CO_INDEX_REFOFFSET;
  HomingRefOffset.SubIndex  := 16#00;
  
  // REF MODE
  HomingRefMode.Index       := CO_INDEX_REFMODE;
  HomingRefMode.SubIndex    := 16#00;
  
  // SPEED1
  HomingSpeed1.Index        := CO_INDEX_REFSPEED;
  HomingSpeed1.SubIndex     := 16#01;
  
  // SPEED2
  HomingSpeed2.Index        := CO_INDEX_REFSPEED;
  HomingSpeed2.SubIndex     := 16#02;
  
  // ACCEL
  HomingAccel.Index         := CO_INDEX_REFACCEL;
  HomingAccel.SubIndex      := 16#00;
  
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------  
  // ------------------------             OBJECT NUMBERS            -------------------------
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  RSdoObjNr := CO_RSDO_OBJNR;
  TSdoObjNr := CO_TSDO_OBJNR;
  NgObjNr   := CO_NG_OBJNR;
  EmcyObjNr := CO_EMCY_OBJNR;
  
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------  
  // ------------------                     SDO ERROR                     -------------------
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  SDO_RwError := CO_SDO_RW_ERROR;  
  
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------  
  // ------------------------             NODE GUARDING            --------------------------
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  GuardTime.Index    := 16#100C;
  GuardTime.SubIndex := 16#00; 
  GuardTime.Data     := 100; // GuardTime
                       
  LifetimeFactor.Index    := 16#100D;
  LifetimeFactor.SubIndex := 16#00; 
  LifetimeFactor.Data     := 2; // Lifetimefactor 
  
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------  
  // ---------------------             PRODUCER HEARTBEAT            ------------------------
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  Heartbeat.Index    := 16#1017;
  Heartbeat.SubIndex := 16#00;
  Heartbeat.Data     := 1000;
  
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------  
  // ---------------------            PLC Consumer HEARTBEAT         ------------------------
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  PlcConsumerHeartBeat := to_udint(Heartbeat.Data*2); 


  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------  
  // --------------------             RECEIVE Pdo-SETTINGS               --------------------
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  // if a valid xdc file is connected the Pdo settings are taken from the file --------------
  // ----------------------------------------------------------------------------------------
  // Receive Object Numbers -----------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  RPdo1.ObjNr := CO_RPDO1_OBJNR;
  RPdo2.ObjNr := CO_RPDO2_OBJNR;
  RPdo3.ObjNr := CO_RPDO3_OBJNR;
  RPdo4.ObjNr := CO_RPDO4_OBJNR;
  
  // ----------------------------------------------------------------------------------------
  // RPDO 1, DRIVE --> PLC -----------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  //only needed if it is used, it is already deactivate at init
  DefaultPDOSetting(pPdoElement:=#RPdo1, iAddressSetting:=CO_INDEX_RPDO1_SETTING);
  
  // Pdo mapping parameter
  RPdo1.ActiveNbrOfMappings       := 1;  //-1; Deactivate that number of Mappings are send to the device
  
  RPdo1.MappingPara[0].Index      := CO_INDEX_RPDO1_MAPPING; // -1 = inactive
  RPdo1.MappingPara[0].Subindex   := 16#01; 
  RPdo1.MappingPara[0].Data       := CO_MAP_PARA_RPDO1_1;    
  
  // ----------------------------------------------------------------------------------------
  // RPDO 2, DRIVE --> PLC ------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  //only needed if it is used, it is already deactivate at init
  DefaultPDOSetting(pPdoElement:=#RPdo2, iAddressSetting:=CO_INDEX_RPDO2_SETTING);
  
  // Pdo mapping parameter
  RPdo2.ActiveNbrOfMappings       := 2; //-1; Deactivate that number of Mappings are send to the device
  
  RPdo2.MappingPara[0].Index      := CO_INDEX_RPDO2_MAPPING;
  RPdo2.MappingPara[0].Subindex   := 16#01; 
  RPdo2.MappingPara[0].Data       := CO_MAP_PARA_RPDO2_1;  
  
  RPdo2.MappingPara[1].Index      := CO_INDEX_RPDO2_MAPPING;
  RPdo2.MappingPara[1].Subindex   := 16#02; 
  RPdo2.MappingPara[1].Data       := CO_MAP_PARA_RPDO2_2;
    
  // ----------------------------------------------------------------------------------------
  // RPDO 3, DRIVE --> PLC ------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  //only needed if it is used, it is already deactivate at init
  
  
  // ----------------------------------------------------------------------------------------
  // RPDO 4, DRIVE --> PLC ------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  //only needed if it is used, it is already deactivate at init
  
  
  //********************************************************************************************************************************
  //if additional RPdo's are needed they can added here
  //********************************************************************************************************************************
  // ----------------------------------------------------------------------------------------
  // RPDO 5, DRIVE --> PLC -----------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  //reset local structure to deactivated value
  _memset(dest:=#sActPDOEntry, usByte:=0x00, cntr:=sizeof(_PDOSETTINGS));
//  
//  DefaultPDOSetting(pPdoElement:=#sActPDOEntry, iAddressSetting:=0x1804, iCobId:=0x490);  
//  
//  // Pdo mapping parameter
//  sActPDOEntry.ActiveNbrOfMappings       := 1;
//  
//  sActPDOEntry.MappingPara[0].Index      := 1A04; // -1 = inactive
//  sActPDOEntry.MappingPara[0].Subindex   := 16#01; 
//  sActPDOEntry.MappingPara[0].Data       := 0;
//  
//  //mapping entrys are by default deactivated
//  //sActPDOEntry.MappingPara[1].Index      := -1;// -1 = inactive
//  
//  RPDOAdditionalObject(pPDOData:=#sActPDOEntry);  
//  
//  // ----------------------------------------------------------------------------------------
//  // RPDO 6, DRIVE --> PLC -----------------------------------------------------------------
//  // ----------------------------------------------------------------------------------------
//  //reset local structure to deactivated value
//  DeactivatePDO(pPdoElement:=#sActPDOEntry);
//  
//  DefaultPDOSetting(pPdoElement:=#sActPDOEntry, iAddressSetting:=0x1805, iCobId:=0x491);  
//  
//  // Pdo mapping parameter
//  sActPDOEntry.ActiveNbrOfMappings       := 1;
//  
//  sActPDOEntry.MappingPara[0].Index      := 1A05; // -1 = inactive
//  sActPDOEntry.MappingPara[0].Subindex   := 16#01; 
//  sActPDOEntry.MappingPara[0].Data       := 0;
//  
//  //mapping entrys are by default deactivated
//  //sActPDOEntry.MappingPara[1].Index      := -1;// -1 = inactive
//  
//  RPDOAdditionalObject(pPDOData:=#sActPDOEntry);  
  
  
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------  
  // -------------------             TRANSMIT Pdo-SETTINGS               --------------------
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  // if a valid xdc file is connected the Pdo settings are taken from the file --------------
  // ----------------------------------------------------------------------------------------
  // Transmit Object Numbers ----------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  TPdo1.ObjNr := CO_TPDO1_OBJNR;
  TPdo2.ObjNr := CO_TPDO2_OBJNR;
  TPdo3.ObjNr := CO_TPDO3_OBJNR;
  TPdo4.ObjNr := CO_TPDO4_OBJNR;
  
  // ----------------------------------------------------------------------------------------
  // TPDO 1, PLC --> DRIVE ------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  //only needed if it is used, it is already deactivate at init
  DefaultPDOSetting(pPdoElement:=#TPdo1, iAddressSetting:=CO_INDEX_TPDO1_SETTING);
  
  // Pdo mapping parameter
  TPdo1.ActiveNbrOfMappings       := 1;   //-1; Deactivate that number of Mappings are send to the device
  
  TPdo1.MappingPara[0].Index      := CO_INDEX_TPDO1_MAPPING; // -1 = inactive
  TPdo1.MappingPara[0].Subindex   := 16#01; 
  TPdo1.MappingPara[0].Data       := CO_MAP_PARA_TPDO1_1;
  
  // ----------------------------------------------------------------------------------------
  // TPDO 2, PLC --> DRIVE ------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  //only needed if it is used, it is already deactivate at init
  DefaultPDOSetting(pPdoElement:=#TPdo2, iAddressSetting:=CO_INDEX_TPDO2_SETTING);
  
  // Pdo mapping parameter
  TPdo2.ActiveNbrOfMappings       := 2;   //-1; Deactivate that number of Mappings are send to the device
  
  TPdo2.MappingPara[0].Index      := CO_INDEX_TPDO2_MAPPING; // -1 = inactive
  TPdo2.MappingPara[0].Subindex   := 16#01; 
  TPdo2.MappingPara[0].Data       := CO_MAP_PARA_TPDO2_1;
    
  TPdo2.MappingPara[1].Index      := CO_INDEX_TPDO2_MAPPING;
  TPdo2.MappingPara[1].Subindex   := 16#02; 
  TPdo2.MappingPara[1].Data       := CO_MAP_PARA_TPDO2_2;
  
  // ----------------------------------------------------------------------------------------
  // TPDO 3, PLC --> DRIVE ------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  //only needed if it is used, it is already deactivate at init
  DefaultPDOSetting(pPdoElement:=#TPdo3, iAddressSetting:=CO_INDEX_TPDO3_SETTING);
  
  // Pdo mapping parameter
  TPdo3.ActiveNbrOfMappings       := 1;   //-1; Deactivate that number of Mappings are send to the device
  
  TPdo3.MappingPara[0].Index      := CO_INDEX_TPDO3_MAPPING; // -1 = inactive
  TPdo3.MappingPara[0].Subindex   := 16#01; 
  TPdo3.MappingPara[0].Data       := CO_MAP_PARA_TPDO3_1;
    
  // ----------------------------------------------------------------------------------------
  // TPDO 4, PLC --> DRIVE ------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  //only needed if it is used, it is already deactivate at init
  DefaultPDOSetting(pPdoElement:=#TPdo4, iAddressSetting:=CO_INDEX_TPDO4_SETTING);
  
  // Pdo mapping parameter
  TPdo4.ActiveNbrOfMappings       := 2;   //-1; Deactivate that number of Mappings are send to the device

  TPdo4.MappingPara[0].Index      := CO_INDEX_TPDO4_MAPPING;
  TPdo4.MappingPara[0].Subindex   := 16#01; 
  TPdo4.MappingPara[0].Data       := CO_MAP_PARA_TPDO4_1;
  
  TPdo4.MappingPara[1].Index      := CO_INDEX_TPDO4_MAPPING;
  TPdo4.MappingPara[1].Subindex   := 16#02; 
  TPdo4.MappingPara[1].Data       := CO_MAP_PARA_TPDO4_2;  
    
  //********************************************************************************************************************************
  //if additional TPdo's are needed they can added here
  //********************************************************************************************************************************
  // ----------------------------------------------------------------------------------------
  // TPDO 5, DRIVE --> PLC -----------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
//  //reset local structure to deactivated value
//  _memset(dest:=#sActPDOEntry, usByte:=0x00, cntr:=sizeof(_PDOSETTINGS));
//  
//  DefaultPDOSetting(pPdoElement:=#sActPDOEntry, iAddressSetting:=0x1404, iCobId:=0x510);  
//  
//  // Pdo mapping parameter
//  sActPDOEntry.ActiveNbrOfMappings       := 1;
//  
//  sActPDOEntry.MappingPara[0].Index      := 1604; // -1 = inactive
//  sActPDOEntry.MappingPara[0].Subindex   := 16#01; 
//  sActPDOEntry.MappingPara[0].Data       := 0;
//  
//  //mapping entrys are by default deactivated
//  //sActPDOEntry.MappingPara[1].Index      := -1;// -1 = inactive
//  
//  TPDOAdditionalObject(pPDOData:=#sActPDOEntry);  
//  
//  // ----------------------------------------------------------------------------------------
//  // TPDO 6, DRIVE --> PLC -----------------------------------------------------------------
//  // ----------------------------------------------------------------------------------------
//  //reset local structure to deactivated value
//  DeactivatePDO(pPdoElement:=#sActPDOEntry);
//  


END_FUNCTION


FUNCTION VIRTUAL GLOBAL _CanOpenBasicDS402::Stop::Write
  VAR_INPUT
    input (EAX)   : DINT;
  END_VAR
  VAR_OUTPUT
    result (EAX)   : DINT;
  END_VAR

  // -------------------------------------
  // Set Stop Axis -----------------------
  // -------------------------------------
  Stop := input;
  
  if input = 1 THEN
    ControlWord.Halt := TRUE;
    Speed.write(0);
  else
     ControlWord.Halt := FALSE;
  end_if;
  
   result := Stop;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _CanOpenBasicDS402::Position::Write
  VAR_INPUT
    input (EAX)   : DINT;
  END_VAR
  VAR_OUTPUT
    result (EAX)   : DINT;
  END_VAR

  Position      := input;
  SendMarkTpdo1 := TRUE;
  result        := Position;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _CanOpenBasicDS402::CanControl
  VAR
    HlpRetcode :  iprStates;
    HlpRetData :  DINT;
    RetVal     :  DINT;
  END_VAR
  
  //get master state:
  MasterDevice := MasterDevice.Read();
  
  // ------------------------------------------------------------
  // Monitoring if Pdos received cyclic ------------------------
  // ------------------------------------------------------------ 
  if (MasterDevice = _CanOpenMng::_CAN_OPERATIONAL & CheckNMTState = 0)        // Master is ready
  | (DeviceState = _CanOpenMng::_CAN_OPERATIONAL  & CheckNMTState = 1) then   // Node is ready  
    // call base class for checking rx Pdo's
    RetVal := _CanOpenBasicDS301::CheckRxPdo();
    // if one of the RPdo's have a timeout set an error
    if RetVal < 0 then
      Statusword.Fault := TRUE;
    end_if;
  else
    //Pdo is only at operational state enabled
    ResetReceiveFlag();
    //set timestamp for timeout check of Rx Pdo's
    udCheckRxPDOTimeout := ops.tAbsolute;
  end_if;  

  // -----------------------------------------------------------------------------------------------------
  // ----------------------           METHOD FOR ASYNCHRON DATA            -------------------------------
  // -----------------------------------------------------------------------------------------------------
  SdoProcess();

  // -----------------------------------------------------------------------------------------------------
  // ----------------------          SET DriveError Server        ----------------------------------------
  // ----------------------------------------------------------------------------------------------------- 
  if ( StatusWord.Fault = FALSE ) THEN
    if DriveError = 1 THEN
      DriveError := 0;
      DriveErrorStatus := 0;       
    end_if;  
    if ControlWord.ResetFault = TRUE then
      ControlWord.ResetFault := FALSE;
    end_if;
  else
    // Don't set DriveError Server during Error Quit 
    if (DriveError = 0) & (ControlWord.ResetFault = FALSE) then
      DriveError := 1;
    elsif (ops.tabsolute - TimeStampResetFault) >= CO_CANRESETFAULTTIMEOUT then
      DriveError := 1;
      ControlWord.ResetFault := FALSE; //HasHan 12.06.2018:
    end_if;
    ControlWord.EnableOperation := FALSE;
  end_if;
  
  
  
  //******************************************************************************************************
  // DeviceState STATE MACHINE
  //******************************************************************************************************
  case CanDeviceState of
  
    //******************************************************************************************************
    _CAN_BOOT_UP:
      DeviceState := _CanOpenMng::_CAN_BOOT_UP;
      
    //******************************************************************************************************    
    _CAN_STOPPED:
      DeviceState := _CanOpenMng::_CAN_STOPPED;
    
    //******************************************************************************************************
    _CAN_OPERATIONAL:
      DeviceState := _CanOpenMng::_CAN_OPERATIONAL;
      
    //******************************************************************************************************
    _CAN_PRE_OPERATIONAL:
      DeviceState := _CanOpenMng::_CAN_PRE_OPERATIONAL;
      
  end_case;
  //******************************************************************************************************
  // END DeviceState STATE MACHINE
  //******************************************************************************************************
  
    

  //******************************************************************************************************
  // MAIN STATE MACHINE
  //******************************************************************************************************
  case OpMode of
  
    _CAN_IDLE:// Do Nothing ------------------------------------------------------------------------------
      NGErrorCounter := 0;
    
    _CAN_INIT:// Initialize Drive -------------------------------------------------------------------------
      InitSettingsAndPdos();
      if InitSSW = 100 then
        InitFinished := TRUE;      
      end_if;
      
    _CAN_NGERROR://---------------------------------------------------------------------------
      DeviceState := _CanOpenMng::_CAN_NGERROR;
      DataReady := 0;
      if subopmode = _SUB_SETOPMODE then
        SubOpMode := _SUB_IDLE;
      end_if;
      
    _CAN_COMERROR: //-------------------------------------------------------------------------
      DeviceState := _CanOpenMng::_CAN_COMERROR;
      DataReady := 0;
      if subopmode = _SUB_SETOPMODE then
        SubOpMode := _SUB_IDLE;
      end_if;
      
    _CAN_HBERROR: // -------------------------------------------------------------------------
      DeviceState := _CanOpenMng::_CAN_HBERROR;
      DataReady := 0;
      if subopmode = _SUB_SETOPMODE then
        SubOpMode := _SUB_IDLE;
      end_if;
      
      
    _CAN_NETENABLE:// Initialization successful ----------------------------------------------------------
    
      if MasterDevice = _CanOpenMng::_CAN_OPERATIONAL then            // Master is ready
      
        //when reset communication
        if bResetCom then
          RetVal := SetNmt(Para:= CO_STARTREMOTENODE);     // Start Remote Node(send operational)
          if RetVal = 4 then //if buffer is full, try one more time to send
            RetVal := SetNmt(Para:= CO_STARTREMOTENODE);
          end_if;
          bResetCom := False;
        end_if;

        OpMode       := _CAN_SYNC;         // Set State Machine to sync
        udTimeStampHB := ops.tAbsolute;

      end_if;
      
      // SCHMAR2 301013 send first nodeguarding message to guarantee it's send when pdos start
      if OpMode = _CAN_SYNC
       & NodeGuardingSupported = 1 then 
       
        udTimestampNG := ops.tAbsolute;
        MasterDevice.SetFlagNG(handle:= HandleRxNG); 
        
      end_if;         
      
    _CAN_SYNC:// Run Communication -----------------------------------------------------------------------
      
      //**************************************************************************************************
      // ENABLE/DISABLE SEQUENCE
      //**************************************************************************************************
      EnableSequence();
      
      //**************************************************************************************************
      // CHANGE DRIVE MODE
      //**************************************************************************************************
      case SubOpMode of
        
        _SUB_IDLE:// Do Nothing --------------------------------------------------------------------------
        
        _SUB_SETOPMODE:// Change Drive Mode --------------------------------------------------------------
        
          //**********************************************************************************************
          // ASYNC DATA HANDLING
          //**********************************************************************************************        
          HlpRetcode := AsyncSDOHandling(pHandle  := #HlpHandleDrvMode_w
                                      , iIndex    := IndexDriveMode_w$INT
                                      , siSubIndex:= 16#00
                                      , dData     := DriveMode
                                      , bRW       := TRUE
                                      , usLength  := 1
                                      , pAsyncData:= #HlpRetData
                                      );
              
          // Send SDO --------------------------------------------------
          if HlpRetcode = READY then  
            DriveModeChanged := TRUE; 
            udTimeStampMChng := ops.tAbsolute;
            
          // Send SDO was not successful -------------------------------
          elsif HlpRetcode = ERROR then
            OpMode      := _CAN_COMERROR;
            DeviceState := _CanOpenMng::_CAN_COMERROR; 
            
          // Send SDO was successful -------------------------------
          elsif HlpRetcode = QUIT then
            if HlpHandleDrvMode_w <> 0 then  //only change subopmode if HlpHandlDrvMode_w - Handle currently active is
          
              //******************************************************************************************
              // SET DRIVE MODE
              //******************************************************************************************
              case DriveMode of
              
                6: SubOpMode := _SUB_HOMING;
              
                1: SubOpMode := _SUB_PROFILE_POSITION;
              
              else
                SubOpMode := _SUB_IDLE;
              end_case;
              //******************************************************************************************
              // END SET DRIVE MODE
              //******************************************************************************************
              
            end_if;          
          end_if;
          
          //**********************************************************************************************
          // END ASYNC DATA HANDLING
          //**********************************************************************************************

          
        _SUB_HOMING:// Start Homing Mode -----------------------------------------------------------------
          // ---------------------------------------------------------------------------------------------
          // ----------------------          MOVE Reference (HOMING MODE)       --------------------------
          // ---------------------------------------------------------------------------------------------
          if ActDriveMode = 6 THEN
            HomingMode();
          end_if;
                    
        _SUB_PROFILE_POSITION:// Start Profile Postionmode -----------------------------------------------
          // ---------------------------------------------------------------------------------------------
          // ----------------------          PROFILE POSITIONMODE (PP MODE)       ------------------------
          // ---------------------------------------------------------------------------------------------          
          if ActDriveMode = 1 THEN
            PPMode();
          end_if;
          
      end_case;  
      //**************************************************************************************************
      // END CHANGE DRIVE MODE
      //**************************************************************************************************
      
      // -------------------------------------------------------------------------------------------------
      // ------------       ERROR RESET AFTER START (so we don't get an error after starting)      -------
      // -------------------------------------------------------------------------------------------------
       if InitFinished = TRUE & DataReady = 1 then
        InitFinished := FALSE;
        if DriveError = 1 THEN
          ErrorQuit.write(1);
        end_if;
      end_if;

      ControlWordSwitching(); // Check Controlword is changed            
      
      
      //only send Pdo data at operational state - or check nmt is not activated by class
      if ((NodeGuardingSupported | ProducerHeartbeatSupported) & DeviceState = _CanOpenMng::_CAN_OPERATIONAL)
      | (NodeGuardingSupported = 0 & ProducerHeartbeatSupported = 0) 
      | CheckNMTState = 0 then
        // -------------------------------------------------------------------------------------------------
        // ----------------------             Send Pdo's           -----------------------------------------
        // -------------------------------------------------------------------------------------------------
        //sending of Pdo is only at operational devicestate allowed.
        SendAllPDOs();
      end_if;
      
      // -------------------------------------------------------------------------------------------------
      // -------------------------          NODEGUARDING        ------------------------------------------
      // -------------------------------------------------------------------------------------------------
      // SCHMAR2 30_10_2013 check if we got a nodeguard message -> errorcounter only increased after guardtime
      if NodeGuardingSupported = 1 THEN
        // send the NG request all defined ms.
        if (ops.tAbsolute - udTimestampNG >= GuardTime.Data$UDINT) then
          udTimestampNG := ops.tAbsolute;
          MasterDevice.SetFlagNG(handle:= HandleRxNG);
            // check if slave has send the NG-object
            if NGReceiveFlag = 1 THEN
              NGReceiveFlag   := 0;
              NGErrorCounter  := 0;
            else  
              NGErrorCounter  += 1;
              if NGErrorCounter > Lifetimefactor.Data THEN
                DeviceState   := _CanOpenMng::_CAN_NGERROR;
                OpMode        := _CAN_NGERROR;
              end_if;
            end_if;      
        end_if;   
        
      // -------------------------------------------------------------------------------------------------
      // -------------------------         PRODUCER HEARTBEAT        -------------------------------------
      // -------------------------------------------------------------------------------------------------
      elsif (ProducerHeartbeatSupported = 1) THEN
        // Make slave send the object data
        if bHeartbeatRXFlag = 1 THEN
          bHeartbeatRXFlag := 0;
        else
        
          if (ops.tAbsolute - udTimeStampHB) > PlcConsumerHeartBeat then          
          
            case (RxBufferHB[0]) of
            
              CO_HB_STOPPED, CO_HB_OPERATIONAL, CO_HB_PREOPERATIONAL:
                
                RxBufferHB[0] := 0;
                udTimeStampHB := ops.tAbsolute;
            
            else
              DeviceState  := _CanOpenMng::_CAN_HBERROR;
              OpMode       := _CAN_HBERROR;
            end_case;
           
          end_if;        
        end_if;
      end_if;    
    
    _CAN_NETDISABLE:// Disable Pdo receive on drive ------------------------------------------------------
      
      SetNMT(Para:= CO_STOPREMOTENODE);// Stop Remote Node
      OpMode := _CAN_IDLE;
    
    _CAN_RESETNODE:// Reset Drive (RELOAD PARAMETER) -----------------------------------------------------
      
      SetNMT(Para:= CO_RESETNODE);// Reset Node
      OpMode := _CAN_IDLE;
    
    _CAN_RESETCOM:// Reset Communikation (RELOAD PARAMETER) ----------------------------------------------
      
      SetNMT(Para:= CO_RESETCOMMUNICATION);// Reset Communication
      OpMode := _CAN_IDLE;
      
  end_case;
  
  //if activated set client NewNMTState if there is a new state and init is already started
  if bNewNMTState = TRUE & InitSSW > 0 then
    //set new nmt state at client
    NewNMTState.Write(input:=NewNMTState);
    
    //only reconnect node if it is not required and not at can stopped state
    if bQuitErrorNewNMT & (Required = 0 & QuitErrorNMTState <> _CAN_STOPPED) then
      ErrorQuit.Write(input:=0);
    end_if;
    bNewNMTState := FALSE;
  end_if;
    
  //******************************************************************************************************
  // END MAIN STATE MACHINE
  //******************************************************************************************************
  
  // -----------------------------------------------------------------------------------------------------
  // ---------------------               GET ACTUAL DRIVE MODE                 ---------------------------
  // -----------------------------------------------------------------------------------------------------
  if ( DriveModeChanged = TRUE ) THEN    
    
    //**********************************************************************************************
    // ASYNC DATA HANDLING
    //**********************************************************************************************
    
    HlpRetcode := AsyncSDOHandling(pHandle  := #HlpHandleDrvMode_r
                                , iIndex    := IndexDriveMode_r$INT
                                , siSubIndex:= SubIndexDriveMode_r$SINT
                                , dData     := 0
                                , bRW       := FALSE
                                , usLength  := 1  
                                , pAsyncData:= #HlpRetData
                                );
                                
    // Send SDO --------------------------------------------------
    if HlpRetcode = READY then
      
    // Send SDO was not successful -------------------------------
    elsif HlpRetcode = ERROR then
      OpMode      := _CAN_COMERROR;
      DeviceState := _CanOpenMng::_CAN_COMERROR;   
      DriveModeChanged := FALSE;
      
    // Send SDO was successful ------------------------------------  
    elsif HlpRetcode = QUIT then
      ActDriveMode := HlpRetData;
      //check for correct drive mode change
      if ActDriveMode = DriveMode then
        DriveModeChanged := FALSE;
      elsif (ops.tAbsolute - udTimeStampMChng) > CO_DS402_TIMEOUT_DRIVEMODECHANGE then
        DriveModeChanged  := FALSE;
        //don't set class to error if not required because then the communication to node is stopped        
        if Required then
          OpMode            := _CAN_COMERROR;
          DeviceState       := _CanOpenMng::_CAN_COMERROR;
        end_if;
      end_if;
    end_if;    
  
    //****************************************************************************************************
    // END ASYNC DATA HANDLING
    //****************************************************************************************************
    
  // -----------------------------------------------------------------------------------------------------
  // ---------------------                  GET ACT ERROR CODE                 ---------------------------
  // -----------------------------------------------------------------------------------------------------
  elsif ErrorOccured = TRUE THEN// Get ERROR Code
    //only read from error index if it is valid
    if IndexErrorStat <> -1 & IndexErrorStat <> 0 then    
      //**********************************************************************************************
      // ASYNC DATA HANDLING
      //**********************************************************************************************
      
      HlpRetcode := AsyncSDOHandling(pHandle  := #HlpHandleErrStat
                                  , iIndex    := IndexErrorStat$INT
                                  , siSubIndex:= SubIndexErrorStat$SINT
                                  , dData     := 0
                                  , bRW       := FALSE
                                  , usLength  := 2
                                  , pAsyncData:= #HlpRetData
                                  );
                                  
      // Send SDO --------------------------------------------------
      if HlpRetcode = READY then
      
      // Send SDO was not successful -------------------------------
      elsif HlpRetcode = ERROR then
        OpMode      := _CAN_COMERROR;
        DeviceState := _CanOpenMng::_CAN_COMERROR;   
        ErrorOccured := 0;
        
      // Send SDO was successful ------------------------------------  
      elsif HlpRetcode = QUIT then
        DriveErrorStatus     := HlpRetData$HDINT;
        bdLogDataFlags.bNewDriveError := TRUE;
        ErrorOccured := 0;
      end_if;    
      
      //****************************************************************************************************
      // END ASYNC DATA HANDLING
      //****************************************************************************************************
    else
      //read of error index is deactivate, reset error flag
      ErrorOccured := 0;
    end_if;
    
  else
    // SDO Handling for _CanOpenSDO Objects connected with the OpMode
    if (OpMode = _CAN_SYNC & (SubOpMode = _SUB_IDLE | SubOpmode = _SUB_PROFILE_POSITION)) then  
      ReadWriteUserSDO();
    end_if;
    
  end_if;
  
  // Only if the state of the canbus is ok
  if OpMode <> _CAN_COMERROR then
    // Check if we have to read the error state via SDO
    if DriveError <> OldError THEN
      ErrorOccured := TRUE;
    end_if;
      
    if (DriveError = 0) & (DriveErrorStatus <> 0) then
      DriveErrorStatus := 0;
    end_if;
    // Remember old error status
    OldError := DriveError;

  end_if;
  
  // Write DriveError state to ErrorSet for the alarmsystem
  if (ErrorSet <> DriveError) then
    if (ErrorOccured = false) then
      ErrorSet := DriveError;
      ErrorSet.Write(ErrorSet);
    end_if;
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL _CanOpenBasicDS402::GetEnableTimeout
  VAR_OUTPUT
    EnableTimeout   : UDINT;
  END_VAR
  
  // overwrite in derivation to get customized time
  EnableTimeout := 1000;

END_FUNCTION


FUNCTION VIRTUAL _CanOpenBasicDS402::EnableSequence

  //**************************************************************************************************
  // ENABLE/DISABLE SEQUENCE
  //**************************************************************************************************
  case EnableSequenceSSW of
  //**************************************************************************************************
    _EnableSequenceSSW::_Disabled: // do nothing special, we're enabled now
    _EnableSequenceSSW::_Enabled:  // do nothing special, we're disabled now

  //**************************************************************************************************
    _EnableSequenceSSW::_StartEnable:
      ControlWord.SwitchOn      := FALSE;
      ControlWord.EnableVoltage := TRUE;
      ControlWord.QuickStop     := TRUE;

      EnableStartTime := ops.tAbsolute;
      EnableSequenceSSW := _SwitchOn;

  //**************************************************************************************************
    _EnableSequenceSSW::_SwitchOn:
      if StatusWord.VoltageEnabled &
         StatusWord.QuickStop      &
         StatusWord.ReadyToSwitchOn then
        
        ControlWord.SwitchOn      := TRUE;

        EnableStartTime := ops.tAbsolute;
        EnableSequenceSSW := _EnableOperation;
        
      elsif (ops.tAbsolute - EnableStartTime) > GetEnableTimeout() then
        // after 1 sec we stop trying => disable
        Enable.Write(0);
      end_if;

  //**************************************************************************************************
    _EnableSequenceSSW::_EnableOperation:
      if StatusWord.VoltageEnabled   &
         StatusWord.QuickStop        &
         StatusWord.ReadyToSwitchOn  &
         StatusWord.SwitchedOn 
      then
      
        ControlWord.EnableOperation := TRUE;

        if (DriveMode = 7) then
          ControlWord.OperationModeSpec1 := TRUE; // at interpolated position mode (to activate interpolation)
        else
          ControlWord.OperationModeSpec1 := FALSE;
        end_if;

        EnableStartTime := ops.tAbsolute;
        EnableSequenceSSW := _CheckOperationEnabled;
        
      elsif (ops.tAbsolute - EnableStartTime) > GetEnableTimeout() then
        // after 1 sec we stop trying => disable
        Enable.Write(0);
      end_if;

  //**************************************************************************************************
    _EnableSequenceSSW::_CheckOperationEnabled:
      if StatusWord.VoltageEnabled   &
         StatusWord.QuickStop        &
         StatusWord.ReadyToSwitchOn  &
         StatusWord.SwitchedOn       &
         StatusWord.OperationEnabled then
         
        Enable := 1;
        EnableSequenceSSW := _Enabled;
        
      elsif (ops.tAbsolute - EnableStartTime) > GetEnableTimeout() then
        // after 1 sec we stop trying => disable
        Enable.Write(0);
      end_if;

  //**************************************************************************************************
    _EnableSequenceSSW::_DisableOperation:

      if StatusWord.OperationEnabled = 0 then
        Enable := 0;
        EnableSequenceSSW := _Disabled;
      end_if;

  //**************************************************************************************************
  end_case;
  
      
END_FUNCTION