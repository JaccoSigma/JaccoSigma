//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES


//profile velocity mode
//******************************************************************************
#define FDD3000_CANOPEN_RPDOA_MAPPINGPARA_1       16#60410010   //statusword            
#define FDD3000_CANOPEN_RPDOA_MAPPINGPARA_2       16#60440010   //vl velocity actual value
#define FDD3000_CANOPEN_RPDOA_MAPPINGPARA_3       16#20081410   //DigIO Read word
//#define FDD3000_CANOPEN_RPDOA_MAPPINGPARA_3       16#20082701   //STO input 1 - 1 byte data
//#define FDD3000_CANOPEN_RPDOA_MAPPINGPARA_4       16#20082801   //STO input 2 - 1 byte data

#define FDD3000_CANOPEN_TPDOA_MAPPINGPARA_1       16#60400010   //Controlword
#define FDD3000_CANOPEN_TPDOA_MAPPINGPARA_2       16#60420010   //vl target velocity


//******************************************************************************
#define FDD3000_CANOPEN_PARA_GUARDTIME                16#100C   //parameter for Guard Time
#define FDD3000_CANOPEN_PARA_GUARDTIME_DATA               100   //setting for Guard Time 
#define FDD3000_CANOPEN_PARA_LIFETIMEFACTOR           16#100D   //parameter for Life Time Factor
#define FDD3000_CANOPEN_PARA_LIFETIMEFACTOR_DATA            2   //setting for Life Time Factor 
#define FDD3000_CANOPEN_PARA_HEARTBEAT                16#1017   //parameter for Heartbeat
#define FDD3000_CANOPEN_PARA_HEARTBEAT_DATA               100   //setting for Life Time Factor 

#define FDD3000_CANOPEN_STOREPARAS_INDEX          16#1010       //Index to set command for store drive data
#define FDD3000_CANOPEN_STOREPARAS_SUBINDEX       16#1          //Subindex to set command for store drive data
#define FDD3000_CANOPEN_STOREPARASMAGICNRB        16#65766173   //Magic number to store data on drive

#define FDD3000_CANOPEN_MAXBUFFER_CYCLICSDO                20   //size of internal sdo buffer
#define FDD3000_CANOPEN_READINTERVALL_CYCLICSDO           200   //interval time in which sdo's are read
  
      
//defines Init Node        
//******************************************************************************
#define FDD3000_CANOPEN_WAIT4CONFIGURENODE             (FDD3000_CANOPEN_PARA_HEARTBEAT_DATA/2)  // Waittime for drive to be in configuration mode
#define FDD3000_CANOPEN_RETRIES_CONFIGURENODE            6  // retries for waiting of drive to be in configuration mode
 
//defines LSS        
//******************************************************************************
#define FDD3000_CANOPEN_WAIT4STORENODECONFIG          2000  // Time to wait for store of node config
#define FDD3000_CANOPEN_WAIT4RESTARTNODE              5000  // Time to wait for restart node
      
//defines Autotune        
//******************************************************************************
#define FDD3000_CANOPEN_WAIT4DRIVERESTART            15000  // Waittime for restart of drive
#define FDD3000_CANOPEN_DRIVERESTART_CHECKOP         10000  // Waittime for check if drive is at operational state
#define FDD3000_CANOPEN_DRIVERESTART_CHECKPREOP      14000  // Waittime for check if drive stuck at pre operational state
#define FDD3000_CANOPEN_TIMEOUTDRIVERESTART          10000  // Timeout for restart of drive
#define FDD3000_CANOPEN_DISPLAY_AUTOTUNESTART         5000  // Time to display warning that autotune is starting
#define FDD3000_CANOPEN_WAIT4QUITERROR                2000  // Waitime to quit error
#define FDD3000_CANOPEN_TIMEOUT_AUTOTUNE             90000  // Timeout for autotune processing
//}}LSL_DEFINES

//{{LSL_DECLARATION
#include "..\..\Class\FDD3000_Parameters\FDD3000_ParameterDef.h"
#include "..\..\Class\FDD3000_Parameters\FDD3000_NewInstIF.h"

(*!
<Class
	Name               = "FDD3000_CanOpenInt"
	Revision           = "1.0"
	GUID               = "{870E9017-57AE-4CFA-B09E-C4ADBC1E87FC}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	DefCyclictime      = "1 ms"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(750,1500)">
	<Channels>
		<Server Name="AccRate" GUID="{C6868504-715B-4E40-8C33-A24055564958}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Parameter 02.011  Acceleration Rate 1 &#13;&#10;Short description: Defines the acceleration rate present in acceleration rate 1 as [0.0 s].&#13;&#10;Value Range: 0.0 to 32000.0 s&#13;&#10;"/>
		<Server Name="ActDriveMode" Comment="Actual drive mode (DS402)&#13;&#10;2..VELOCITY MODE">
		</Server>
		<Server Name="ActSpeed" Comment="Shows Actual Speed as [rpm].&#13;&#10;Parameter Index 16#6044, Subindex 0">
		</Server>
		<Server Name="ControllerIF" GUID="{2185FEFF-ED32-422E-8950-B3FC4383CEBF}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Connect drive controller class here."/>
		<Server Name="CurrentAtMaximumDeadTime" GUID="{46F04AF2-F2DD-4A67-B49D-F1C22A7BA3E9}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="OpenLoop Current At Maximum Deadtime Compensation (05.060)&#13;&#10;Short description Current at which maximum deadtime compensation is applied as [0.00 %]&#13;&#10;Read Only"/>
		<Server Name="CurrentLoopKiGain" GUID="{5CA735B9-0C22-4C82-8418-D9C560944A07}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="RFC-A Current Loop Ki Gain 04.014&#13;&#10;Short description: Defines the current loop controller integral gain as [0.000]&#13;&#10;Value Range: 0.000 to 600.000"/>
		<Server Name="CurrentLoopKPGain" GUID="{533D4382-C08B-4B5C-8801-8E781A5FB5F5}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="RFC-A Current Loop Kp Gain 04.013&#13;&#10;Short description: Defines the current loop controller proportional gain as [0.00].&#13;&#10;Value Range: 0.00 to 4000.00"/>
		<Server Name="DecRate" GUID="{4A7DBB6C-0444-46EC-87E7-71B857F194FE}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Parameter 02.021  Deceleration Rate 1 &#13;&#10;Short description: Defines the deceleration rate present in deceleration rate 1 as [0.0 s].&#13;&#10;Value Range: 0.0 to 32000.0 s&#13;&#10;"/>
		<Server Name="DeviceState">
		</Server>
		<Server Name="DriveMode" Comment="Drive Mode:(DS402)&#13;&#10;2..VELOCITY MODE&#13;&#10;Only Velocity mode is supported.">
		</Server>
		<Server Name="FwVersionComm" GUID="{786BEAE7-944D-4358-995C-0C98769278F4}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Parameter 15.002  Firmware Version &#13;&#10;Short description: The Firmware Version of the communication module.&#13;&#10;Module firmware version in the format major.minor.version.build (ww.xx.yy.zz)."/>
		<Server Name="FwVersionDrive" GUID="{4DE98FC5-A91C-49D7-819D-F307D1D89740}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Parameter 11.029  Firmware Version &#13;&#10;Short description: Displays the fimware version in the drive .&#13;&#10;Displays the drive control board firmware version in the format major.minor.version.build (ww.xx.yy.zz)."/>
		<Server Name="HwVersionComm" GUID="{BC54473C-85A4-4110-B3C2-505FB3DEBA31}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Parameter 15.003  Hardware Version &#13;&#10;Short description: Displays the Hardware Version of the communication module &#13;&#10;Module hardware version in the format major.minor (xx.yy)."/>
		<Server Name="InputWord" GUID="{A6F16367-FB06-43FC-856F-9AC8B1A7498E}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="LowFrequencyVoltageBoost" GUID="{A09D19BE-965B-4EF0-9108-85564056C62E}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Parameter 05.015  Low Frequency Voltage Boost &#13;&#10;Short description: Defines the level of voltage boost &#13;&#10;at 0Hz when using a fixed V to F relationship as [0.0 %].  &#13;&#10;Value Range: 0.0 to 25.0 %&#13;&#10;"/>
		<Server Name="MaximumDeadTimeComp" GUID="{9EA6C8AA-9E5A-41FE-9908-3018617360DB}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="OpenLoop Maximum Deadtime compensation 05.059&#13;&#10;Short description: Maximum Deadtime Compensation  as [0.000 µs]&#13;&#10;Read Only"/>
		<Server Name="MaxRefClamp" GUID="{C0EFD3FA-6E66-4A8E-BFEC-CEEF289F4A1C}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Parameter 01.006  Maximum Reference Clamp &#13;&#10;Short description: Defines the maximum value for the reference as [0.00 Hz].&#13;&#10;Value Range: 0.00 to 550.00 Hz"/>
		<Server Name="MinRefClamp" GUID="{68B80F80-77E6-42AF-A67B-84CACF133658}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Parameter 01.007  Minimum Reference Clamp &#13;&#10;Short description: Defines the minimum value for the reference  as [0.00 Hz].&#13;&#10;Value Range: 0.00 to Maximum Reference Clamp&#13;&#10;"/>
		<Server Name="MotorRatedCurrent" GUID="{4BCDB4A7-2121-4AD8-91CA-ED154BF12268}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Parameter 05.007  Motor Rated Current &#13;&#10;Short description: Set to the rated current rated of the motor as [0.00 A].&#13;&#10;Value Range: 0.00 to Drive Rating A"/>
		<Server Name="MotorRatedFrequency" GUID="{D662FB50-D3D5-460E-861D-F0E23004C554}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Parameter 05.006  Motor Rated Frequency &#13;&#10;Short description: Set to the rated frequency of the motor as [0.00 Hz]. &#13;&#10;Value Range: 0.00 to 550.00 Hz&#13;&#10;"/>
		<Server Name="MotorRatedPowerFactor" GUID="{59ED88DC-4E9B-488F-8C78-E407F94AEF6C}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Parameter 05.010  Motor Rated Power Factor &#13;&#10;Short description: Set to the rated power factor of the motor as [0.00].  &#13;&#10;This value can be measured by the drive during a rotating autotune.&#13;&#10;If Stator Inductance is &lt;&gt; 0 this value is calculated internal by the drive and can&apos;t be written.&#13;&#10;Value Range: 0.00 to 1.00&#13;&#10;"/>
		<Server Name="MotorRatedSpeed" GUID="{0B0C295D-2E89-451B-A478-2F95D4AB55F2}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Parameter 05.008  Motor Rated Speed &#13;&#10;Short description: Set to the rated speed of the motor as [0.0 rpm]. &#13;&#10;Value Range: 0.0 to 33000.0 rpm&#13;&#10;"/>
		<Server Name="MotorRatedVoltage" GUID="{0AA51321-20B7-4269-A08E-07BB7359E7AB}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Parameter 05.009  Motor Rated Voltage &#13;&#10;Short description: Set to the rated voltage of the motor as [V]. &#13;&#10;Value Range: 0 to 765 V"/>
		<Server Name="Online" GUID="{EC0B46DB-37CB-47B4-A86F-0B1E5DC24AEC}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows whether the drive is ready for operation.&#13;&#10;0 .. not Online&#13;&#10;1 .. Online"/>
		<Server Name="OPModeDrive" GUID="{CDC456AC-D426-4AF8-AE11-50AEB2E44335}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Parameter 11.084  Operation Mode of Drive&#13;&#10;Short description: Defines and displays the current drive mode &#13;&#10;_ModeUnknown .. 0&#13;&#10;_OpenLoop .. 1&#13;&#10;_RFC-A .. 2&#13;&#10;"/>
		<Server Name="ProductCodeDrive" GUID="{A4332E93-FCC8-4AD0-B664-4BAE0AE22221}" Class="String" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="Shows the Productcode of drive as string."/>
		<Server Name="SaturationBreakpoint1" GUID="{0025E740-651F-4149-B457-3FA445FE2179}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="RFC-A motor saturation breakpoints Pr 05.029 &#13;&#10;Short description: Defines Saturation Breakpoint 1 within &#13;&#10;the saturation characteristic as [0.0 %]. &#13;&#10;Value Range: 0.0 to 100.0 %&#13;&#10;"/>
		<Server Name="SaturationBreakpoint2" GUID="{157083CB-50F2-4E78-ABF2-4C23FA10504B}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="RFC-A motor saturation breakpoints Pr 05.062&#13;&#10;Short description: Defines Saturation Breakpoint 2 within &#13;&#10;the saturation characteristic as [0.0 %]. &#13;&#10;Value Range: 0.0 to 100.0 %"/>
		<Server Name="SaturationBreakpoint3" GUID="{61FC5A5A-7056-49E5-AD34-52C41BDF8074}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="RFC-A motor saturation breakpoints Pr 05.030&#13;&#10;Short description: Defines Saturation Breakpoint 3 within &#13;&#10;the saturation characteristic as [0.0 %]. &#13;&#10;Value Range: 0.0 to 100.0 %"/>
		<Server Name="SaturationBreakpoint4" GUID="{26988D3C-4372-4683-A1BC-93E0694DEB7E}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="RFC-A motor saturation breakpoints Pr 05.063&#13;&#10;Short description: Defines Saturation Breakpoint 4 within &#13;&#10;the saturation characteristic as [0.0 %]. &#13;&#10;Value Range: 0.0 to 100.0 %"/>
		<Server Name="SerialNoDrive" GUID="{DFEC76B8-90B9-47C0-A7E7-98EB73A60B06}" Class="String" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="Shows the Serialnumber of drive as string."/>
		<Server Name="Speed" Comment="Set Speed (Velocity Mode DS402) as [rpm].&#13;&#10;Parameter Index 16#6042, Subindex 0">
		</Server>
		<Server Name="StatorInductance" GUID="{3C60AD1B-3BB8-4E9C-8366-62BC7ACEFDDD}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="OpenLoop / RFC-A Stator Inductance 05.025&#13;&#10;Short description: Defines the inductance of the motor stator as [0.00 mH].&#13;&#10;Value Range: 0.00 to 5000.00 mH"/>
		<Server Name="StatorResistance" GUID="{51E37318-7EA3-4C33-8857-CF4DC2533FAD}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="OpenLoop / RFC-A Stator Resistance 05.017&#13;&#10;Short description: Defines the resistance of the motor stator as [0.0000 ohm]&#13;&#10;Value Range: 0.0000 to 99.9999 ohm"/>
		<Server Name="STOInput" GUID="{051A0DBF-118D-4DE7-84F9-CD33242B8E1C}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Displays the combined state of safe torque off channel 1&amp;2"/>
		<Server Name="TransientInductance" GUID="{B3652858-A1B5-4403-8FF0-6737E602951A}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="OpenLoop / RFC-A Transient Inductance 05.024&#13;&#10;Short description: Defines the inducatance of the transient &#13;&#10;components in the motor stator as [0.000 mH] &#13;&#10;Value Range: 0.000 to 500.000 mH"/>
		<Client Name="FDD3000_ActDriveParas" Required="true" Internal="true"/>
		<Client Name="FDD3000_HWKDriveParas" Required="true" Internal="true"/>
		<Client Name="FDD3000_OldDriveParas" Required="true" Internal="true"/>
		<Client Name="FDD3000_VOVControl1" Required="true" Internal="true"/>
		<Client Name="StrProductCode" Required="true" Internal="true"/>
		<Client Name="StrSerialNo" Required="true" Internal="true"/>
		<Client Name="toFDD3000FileHandling" Required="true" Internal="false"/>
	</Channels>
	<Separators>
		<Servers>
			<SepChn Position="2"/>
			<SepChn Position="9"/>
			<SepChn Position="22"/>
			<SepChn Position="26"/>
			<SepChn Position="29"/>
		</Servers>
	</Separators>
	<Dependencies>
		<Files>
			<File Path=".\Class\FDD3000_Parameters\FDD3000_ParameterDef.h" Include="true"/>
			<File Path=".\Class\FDD3000_Parameters\FDD3000_NewInstIF.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="PieSte"/>
		<Dokumentation Revision="1.0" Date="02.02.2021" Author="ZoePat" Company="Sigmatek" Description="first library version"/>
	</RevDoku>
	<Network Name="FDD3000_CanOpenInt">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{F2C621EB-54E4-4425-9289-73008D7765BC}"
				Class      = "_CanOpenBasicDS402"
				Position   = "(218,120)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="ActDriveMode"/>
					<Server Name="ActPosition"/>
					<Server Name="ActSpeed"/>
					<Server Name="AsyncState"/>
					<Server Name="CanDisabled"/>
					<Server Name="ControlWord"/>
					<Server Name="Current"/>
					<Server Name="DataReady"/>
					<Server Name="DestAccel"/>
					<Server Name="DestDecel"/>
					<Server Name="DestinationPos"/>
					<Server Name="DestSpeed"/>
					<Server Name="DeviceState"/>
					<Server Name="DriveError"/>
					<Server Name="DriveErrorStatus"/>
					<Server Name="DriveMode" Value="0"/>
					<Server Name="EmcyStatusByte0_3"/>
					<Server Name="EmcyStatusByte4_7"/>
					<Server Name="Enable"/>
					<Server Name="ErrorAlloc"/>
					<Server Name="ErrorQuit"/>
					<Server Name="ErrorSDO"/>
					<Server Name="Position"/>
					<Server Name="Speed"/>
					<Server Name="StatusWord"/>
					<Server Name="Stop"/>
					<Client Name="CheckNMTState" Value="1"/>
					<Client Name="ChkRxPdo" Value="1"/>
					<Client Name="DisableEmergencyObject"/>
					<Client Name="ErrorSet"/>
					<Client Name="Index" Value="-1"/>
					<Client Name="MasterDevice"/>
					<Client Name="NewNMTState"/>
					<Client Name="NodeGuardingSupported"/>
					<Client Name="Place" Value="0"/>
					<Client Name="ProducerHeartbeatSupported" Value="1"/>
					<Client Name="Required" Value="1"/>
					<Client Name="SDOTable"/>
					<Client Name="SendMode"/>
					<Client Name="toXDCFile"/>
				</Channels>
			</Object>
			<Object
				Name       = "FDD3000_ActDriveParas"
				GUID       = "{334DB8D7-C6CC-448A-B692-CC011457191A}"
				Class      = "FDD3000_Parameters"
				Position   = "(150,2130)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="AccRate"/>
					<Server Name="ClassSvr"/>
					<Server Name="CurrentAtMaximumDeadTime"/>
					<Server Name="CurrentLoopKiGain"/>
					<Server Name="CurrentLoopKPGain"/>
					<Server Name="DecRate"/>
					<Server Name="LowFrequencyVoltageBoost"/>
					<Server Name="MaximumDeadTimeComp"/>
					<Server Name="MaxRefClamp"/>
					<Server Name="MinRefClamp"/>
					<Server Name="MotorRatedCurrent"/>
					<Server Name="MotorRatedFrequency"/>
					<Server Name="MotorRatedPowerFactor"/>
					<Server Name="MotorRatedSpeed"/>
					<Server Name="MotorRatedVoltage"/>
					<Server Name="SaturationBreakpoint1"/>
					<Server Name="SaturationBreakpoint2"/>
					<Server Name="SaturationBreakpoint3"/>
					<Server Name="SaturationBreakpoint4"/>
					<Server Name="StatorInductance"/>
					<Server Name="StatorResistance"/>
					<Server Name="TransientInductance"/>
				</Channels>
			</Object>
			<Object
				Name       = "FDD3000_HWKDriveParas"
				GUID       = "{1214C375-43CD-4C66-BA56-EAD0E3F986EB}"
				Class      = "FDD3000_ParametersFileRam"
				Position   = "(2160,2130)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="AccRate"/>
					<Server Name="ClassSvr"/>
					<Server Name="CurrentAtMaximumDeadTime"/>
					<Server Name="CurrentLoopKiGain"/>
					<Server Name="CurrentLoopKPGain"/>
					<Server Name="DecRate"/>
					<Server Name="LowFrequencyVoltageBoost"/>
					<Server Name="MaximumDeadTimeComp"/>
					<Server Name="MaxRefClamp"/>
					<Server Name="MinRefClamp"/>
					<Server Name="MotorRatedCurrent"/>
					<Server Name="MotorRatedFrequency"/>
					<Server Name="MotorRatedPowerFactor"/>
					<Server Name="MotorRatedSpeed"/>
					<Server Name="MotorRatedVoltage"/>
					<Server Name="SaturationBreakpoint1"/>
					<Server Name="SaturationBreakpoint2"/>
					<Server Name="SaturationBreakpoint3"/>
					<Server Name="SaturationBreakpoint4"/>
					<Server Name="StatorInductance"/>
					<Server Name="StatorResistance"/>
					<Server Name="TransientInductance"/>
				</Channels>
			</Object>
			<Object
				Name       = "FDD3000_OldDriveParas"
				GUID       = "{2B8AC3BF-4814-475F-BD3F-62514B87EB96}"
				Class      = "FDD3000_Parameters"
				Position   = "(1170,2130)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="AccRate"/>
					<Server Name="ClassSvr"/>
					<Server Name="CurrentAtMaximumDeadTime"/>
					<Server Name="CurrentLoopKiGain"/>
					<Server Name="CurrentLoopKPGain"/>
					<Server Name="DecRate"/>
					<Server Name="LowFrequencyVoltageBoost"/>
					<Server Name="MaximumDeadTimeComp"/>
					<Server Name="MaxRefClamp"/>
					<Server Name="MinRefClamp"/>
					<Server Name="MotorRatedCurrent"/>
					<Server Name="MotorRatedFrequency"/>
					<Server Name="MotorRatedPowerFactor"/>
					<Server Name="MotorRatedSpeed"/>
					<Server Name="MotorRatedVoltage"/>
					<Server Name="SaturationBreakpoint1"/>
					<Server Name="SaturationBreakpoint2"/>
					<Server Name="SaturationBreakpoint3"/>
					<Server Name="SaturationBreakpoint4"/>
					<Server Name="StatorInductance"/>
					<Server Name="StatorResistance"/>
					<Server Name="TransientInductance"/>
				</Channels>
			</Object>
			<Object
				Name       = "FDD3000_VOVControl1"
				GUID       = "{A4DACFBF-EDA5-4F2E-8C9D-DDCCFF87C3FC}"
				Class      = "FDD3000_VOVControl"
				Position   = "(3180,3030)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="ActAutotuneStep"/>
					<Server Name="ActCyclicStep"/>
					<Server Name="ActLogData"/>
					<Server Name="ActLSSStep"/>
					<Server Name="ActSearchBitrate"/>
					<Server Name="ClassSvr"/>
					<Server Name="DataSource"/>
					<Server Name="FileSelect"/>
					<Server Name="MaxSpeed"/>
					<Server Name="MinSpeed"/>
					<Server Name="SetBitrate"/>
					<Server Name="SetDriveMode"/>
					<Server Name="SetNodeID"/>
					<Server Name="SetUserMotorParas"/>
					<Server Name="StartAutotune"/>
					<Server Name="StartLSS"/>
					<Server Name="VOV_Active"/>
				</Channels>
			</Object>
			<Object
				Name       = "StrProductCode"
				GUID       = "{953AFBB3-95E2-44B1-A7AC-6E0C2F04593A}"
				Class      = "String"
				Position   = "(210,1770)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "StrSerialNo"
				GUID       = "{D7FAABD9-08E4-4B64-8CA8-504D5FF9D937}"
				Class      = "String"
				Position   = "(210,1920)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.DeviceState" Destination="_base.DeviceState" Vertices="(4178,210),(874,210),"/>
			<Connection Source="this.ErrorQuit" Destination="_base.ErrorQuit" Vertices="(4178,270),(874,270),"/>
			<Connection Source="this.CanDisabled" Destination="_base.CanDisabled" Vertices="(4178,330),(874,330),"/>
			<Connection Source="this.DataReady" Destination="_base.DataReady" Vertices="(4178,390),(874,390),"/>
			<Connection Source="this.AsyncState" Destination="_base.AsyncState" Vertices="(4178,450),(874,450),"/>
			<Connection Source="this.ErrorSDO" Destination="_base.ErrorSDO" Vertices="(4178,510),(874,510),"/>
			<Connection Source="this.ErrorAlloc" Destination="_base.ErrorAlloc" Vertices="(4178,570),(874,570),"/>
			<Connection Source="this.EmcyStatusByte0_3" Destination="_base.EmcyStatusByte0_3" Vertices="(4178,630),(874,630),"/>
			<Connection Source="this.EmcyStatusByte4_7" Destination="_base.EmcyStatusByte4_7" Vertices="(4178,690),(874,690),"/>
			<Connection Source="this.DriveMode" Destination="_base.DriveMode" Vertices="(4178,750),(874,750),"/>
			<Connection Source="this.ActDriveMode" Destination="_base.ActDriveMode" Vertices="(4178,810),(874,810),"/>
			<Connection Source="this.StatusWord" Destination="_base.StatusWord" Vertices="(4178,870),(874,870),"/>
			<Connection Source="this.ControlWord" Destination="_base.ControlWord" Vertices="(4178,930),(874,930),"/>
			<Connection Source="this.DriveError" Destination="_base.DriveError" Vertices="(4178,990),(874,990),"/>
			<Connection Source="this.DriveErrorStatus" Destination="_base.DriveErrorStatus" Vertices="(4178,1050),(874,1050),"/>
			<Connection Source="this.Enable" Destination="_base.Enable" Vertices="(4178,1110),(874,1110),"/>
			<Connection Source="this.Speed" Destination="_base.Speed" Vertices="(4178,1170),(874,1230),"/>
			<Connection Source="this.ActSpeed" Destination="_base.ActSpeed" Vertices="(4178,1230),(874,1410),"/>
			<Connection Source="this.Stop" Destination="_base.Stop" Vertices="(4178,1290),(874,1710),"/>
			<Connection Source="_base.MasterDevice" Destination="this.MasterDevice" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.Place" Destination="this.Place" Vertices="(218,270),(38,270),"/>
			<Connection Source="_base.Index" Destination="this.Index" Vertices="(218,330),(38,330),"/>
			<Connection Source="_base.Required" Destination="this.Required" Vertices="(218,390),(38,390),"/>
			<Connection Source="_base.SDOTable" Destination="this.SDOTable" Vertices="(218,870),(38,510),"/>
			<Connection Source="_base.ErrorSet" Destination="this.ErrorSet" Vertices="(218,990),(38,570),"/>
			<Connection Source="this.StrProductCode" Destination="StrProductCode.Data"/>
			<Connection Source="this.ProductCodeDrive" Destination="StrProductCode.Data" Vertices="(4178,1530),(526,1860),"/>
			<Connection Source="this.StrSerialNo" Destination="StrSerialNo.Data"/>
			<Connection Source="this.SerialNoDrive" Destination="StrSerialNo.Data" Vertices="(4178,1590),(526,2010),"/>
			<Connection Source="this.FDD3000_ActDriveParas" Destination="FDD3000_ActDriveParas.ClassSvr"/>
			<Connection Source="this.FDD3000_VOVControl1" Destination="FDD3000_VOVControl1.ClassSvr"/>
			<Connection Source="this.FDD3000_OldDriveParas" Destination="FDD3000_OldDriveParas.ClassSvr"/>
			<Connection Source="this.FDD3000_HWKDriveParas" Destination="FDD3000_HWKDriveParas.ClassSvr"/>
			<Connection Source="_base.NewNMTState" Destination="this.NewNMTState" Vertices="(218,810),(38,450),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using _CanOpenBasicDS402

FDD3000_CanOpenInt : CLASS
: _CanOpenBasicDS402
	TYPE
	  eCyclicSSW :  //! <Type Public="true" Name="eCyclicSSW"/>
	  (
	    _SDOCyclic,
	    _NodeSettings,
	    _AutoTune,
	    _SaveMotorParas
	  )$UDINT;
	  eLSSNodeSSW :  //! <Type Public="true" Name="eLSSNodeSSW"/>
	  (
	    _IdleLSS,
	    _DeactivateMng,
	    _SetLSSInfos,
	    _Wait4SetLSSInfos,
	    _WriteSDOCiA,
	    _StoreNodeConfig,
	    _Wait4StoreNodeConfig,
	    _ResetNode,
	    _Wait4ResetNode,
	    _ActivateMng,
	    _QuitErrorNode,
	    _FinishedLSS,
	    _ErrorLSS
	  )$UDINT;
	  eSaveActValuesOnDrive :
	  (
	    _IdleSaveParas,
	    _UserGetParas,
	    _SendParasToDrive,
	    _SendSaveCMDDrive,
	    _FinishedSaveParas,
	    _ErrorSaveParas
	  )$UDINT;
	  eSDOCyclicSSW :
	  (
	    _IdleCyclicSDO,
	    _SetSDORequest,
	    _NextCyclicSDO,
	    _FinishedCyclicSDO,
	    _ErrorCyclicSDO
	  )$UDINT;
	  eXMLFileHandling :
	  (
	    _IdleFileHandling,
	    _GetWriteData,
	    _WriteFile,
	    _Wait4WriteFile,
	    _ReadFile,
	    _Wait4ReadFile,
	    _SetReadDataOnServer,
	    _FinishedFileHandling,
	    _ErrorFileHandling
	  )$UDINT;
#pragma pack(push, 1)
	  tsAutoTuneVars : STRUCT
	    SSWAutoTune : FDD3000_VOVControl::eAutoTuneSSW;
	    SSWAutoTuneErrorStep : FDD3000_VOVControl::eAutoTuneSSW;
	    udStartTime : UDINT;
	    hdSDORetCode : HDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  tsLSSNodeSetting : STRUCT
	    SSWNodeSetting : FDD3000_VOVControl::eLSSNodeSSW;
	    SSWNodeSettingErrorStep : FDD3000_VOVControl::eLSSNodeSSW;
	    usNodeId : USINT;
	    usBaudrate : USINT;
	    uiBitrate : UINT;
	    udStartTime : UDINT;
	    hdSDORetCode : HDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  tsSaveParas : STRUCT
	    SSWSaveParas : eSaveActValuesOnDrive;
	    SSWSaveParasError : eSaveActValuesOnDrive;
	    SSWFileHandling : eXMLFileHandling;
	    SSWFileHandlingError : eXMLFileHandling;
	    sParaFile : FDD3000_FileHandling::ts_ParaFile;
	    hdSDORetCode : HDINT;
	    udStartTime : UDINT;
	    bWriteDiffParas : BOOL;
	    bWriteValueAnyway : BOOL;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  tsSDOCyclicRead : STRUCT
	    udSDOAddLock : UDINT;
	    SSWCyclicSDO : eSDOCyclicSSW;
	    SSWCyclicSDOErrorStep : eSDOCyclicSSW;
	    aSDOCyclicData : ARRAY [0..FDD3000_CANOPEN_MAXBUFFER_CYCLICSDO-1] OF t_s_ComSDOCyclic;
	    iSDOHandle : INT;
	    bSDORespRdy : BOOL;
	    bRespError : BOOL;
	    dActSDORespData : DINT;
	    usSDOsInBuffer : USINT;
	    usActiveSDOsInBuffer : USINT;
	    usActSDOEntry : USINT;
	    udStartTime : UDINT;
	    udTxCount : UDINT;
	    udRxCount : UDINT;
	    udErrorCnt : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  tsSDOInit : STRUCT
	    SDOData : t_s_ComSDOCyclic;
	    OldPdoInitSSW : DINT;
	    pActDriveData : ^DINT;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	STOInput 	: SvrCh_DINT;
	InputWord 	: SvrCh_BDINT;
	Online 	: SvrCh_DINT;
	ProductCodeDrive 	: SvrChCmd_UDINT;
	SerialNoDrive 	: SvrChCmd_UDINT;
	FwVersionDrive 	: SvrCh_UDINT;
	FwVersionComm 	: SvrCh_UDINT;
	HwVersionComm 	: SvrCh_UDINT;
	ControllerIF 	: SvrChCmd_DINT;
	OPModeDrive 	: SvrCh_eUserDriveMode_PTofCls_FDD3000_VOVControl;
	MaxRefClamp 	: SvrCh_DINT;
	MinRefClamp 	: SvrCh_DINT;
	AccRate 	: SvrCh_DINT;
	DecRate 	: SvrCh_DINT;
	MotorRatedCurrent 	: SvrCh_DINT;
	MotorRatedSpeed 	: SvrCh_DINT;
	MotorRatedVoltage 	: SvrCh_DINT;
	MotorRatedPowerFactor 	: SvrCh_DINT;
	MotorRatedFrequency 	: SvrCh_DINT;
	LowFrequencyVoltageBoost 	: SvrCh_DINT;
	StatorResistance 	: SvrCh_DINT;
	TransientInductance 	: SvrCh_DINT;
	StatorInductance 	: SvrCh_DINT;
	MaximumDeadTimeComp 	: SvrCh_DINT;
	CurrentAtMaximumDeadTime 	: SvrCh_DINT;
	CurrentLoopKPGain 	: SvrCh_DINT;
	CurrentLoopKiGain 	: SvrCh_DINT;
	SaturationBreakpoint1 	: SvrCh_DINT;
	SaturationBreakpoint3 	: SvrCh_DINT;
	SaturationBreakpoint2 	: SvrCh_DINT;
	SaturationBreakpoint4 	: SvrCh_DINT;
  //Clients:
	StrProductCode 	: CltChCmd_String;
	StrSerialNo 	: CltChCmd_String;
	FDD3000_ActDriveParas 	: CltChCmd_FDD3000_Parameters;
	FDD3000_VOVControl1 	: CltChCmd_FDD3000_VOVControl;
	FDD3000_OldDriveParas 	: CltChCmd_FDD3000_Parameters;
	FDD3000_HWKDriveParas 	: CltChCmd_FDD3000_ParametersFileRam;
	toFDD3000FileHandling 	: CltChCmd_FDD3000_FileHandling;
  //Variables:
		sLSSNodeSetting 	: tsLSSNodeSetting;
		sAutoTuneVars 	: tsAutoTuneVars;
		sSaveParasVars 	: tsSaveParas;
		sCyclicSDORW 	: tsSDOCyclicRead;
		usActStrOffset 	: USINT;
		aStrBuffer : ARRAY [0..63] OF CHAR;

		bDeviceIsOK 	: BOOL;
		sInitSDO 	: tsSDOInit;
		dRetCodeResp 	: DINT;
		sLogFile 	: FDD3000AxisVis::_LogFile;
		oldErrorSDO 	: DINT;
		udWait4ConfigureNode 	: UDINT;
		usRetriesWait4Config 	: USINT;
  //Functions:
				//! <Function Comment="Initialization" Name="Init"/>
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="Initialize drive&#13;&#10;" Name="InitSettingsAndPdos"/>
	FUNCTION VIRTUAL InitSettingsAndPdos;
				//! <Function Comment="Convert received Pdo to internal&#13;&#10;data structure (for example server)&#13;&#10;" Name="ConvertPdo1"/>
	FUNCTION VIRTUAL GLOBAL ConvertPdo1;
				//! <Function Comment="Send Pdo to drive&#13;&#10;" Name="TransmitPdo1"/>
	FUNCTION VIRTUAL GLOBAL TransmitPdo1;
				//! <Function Comment="Overload this function to change Pdo settings&#13;&#10;transmission time, inhibit time etc;&#13;&#10;" Name="GetPdoSettings"/>
	FUNCTION VIRTUAL GLOBAL GetPdoSettings;
				//! <Function Comment="Overload this function to set some application&#13;&#10;specific parameter during initialization&#13;&#10;" Name="UserSettings"/>
	FUNCTION VIRTUAL GLOBAL UserSettings
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="return code of function&#13;&#10;0 .. UserSettings busy&#13;&#10;1 .. UserSettings ready" Name="UserSettings.retcode"/>
		END_VAR;
				//! <Function Comment="Handles CAN-Communication" Name="CanControl"/>
	FUNCTION VIRTUAL GLOBAL CanControl;
				//! <Function Comment="Is called via NewInst command _FDD3000_IF_GET_PROPERTY.&#13;&#10;Possible properties are defined in FDD3000_NewInstIF.h." Name="GetProperty"/>
	FUNCTION VIRTUAL GetProperty
		VAR_INPUT
			udPropertyID 	: UDINT;			//! <Variable Comment="Property ID" Name="GetProperty.udPropertyID"/>
			usDatalength 	: USINT;			//! <Variable Comment="Datalength of property data as byte.&#13;&#10;Minimum value is 4 Byte." Name="GetProperty.usDatalength"/>
			pPropertyValue 	: pVoid;			//! <Variable Comment="Pointer to which the value from the Property ID is written." Name="GetProperty.pPropertyValue"/>
		END_VAR
		VAR_OUTPUT
			dRetCode 	: DINT;			//! <Variable Comment="return code of methode.&#13;&#10; 0 .. ok&#13;&#10;-1 .. property id is not available&#13;&#10;-2 .. property id is not readable&#13;&#10;-3 .. pointer is not valid&#13;&#10;-4 .. datalength is smaller then 4 byte&#13;&#10;-6 .. datalength is to small for available data" Name="GetProperty.dRetCode"/>
		END_VAR;
				//! <Function Comment="Is called via NewInst command _FDD3000_IF_SET_PROPERTY.&#13;&#10;Possible properties are defined in FDD3000_NewInstIF.h." Name="SetProperty"/>
	FUNCTION VIRTUAL SetProperty
		VAR_INPUT
			udPropertyID 	: UDINT;			//! <Variable Comment="Property ID" Name="SetProperty.udPropertyID"/>
			usDatalength 	: USINT;			//! <Variable Comment="Datalength of property data as byte.&#13;&#10;Minimum value is 4 Byte." Name="SetProperty.usDatalength"/>
			pPropertyValue 	: pVoid;			//! <Variable Comment="Pointer from which the value of Property ID is written." Name="SetProperty.pPropertyValue"/>
		END_VAR
		VAR_OUTPUT
			dRetCode 	: DINT;			//! <Variable Comment="return code of methode.&#13;&#10; 0 .. ok&#13;&#10;-1 .. property id is not available&#13;&#10;-2 .. property id is not writeable&#13;&#10;-3 .. pointer is not valid&#13;&#10;-4 .. datalength is smaller then 4 byte&#13;&#10;-5 .. VOV is active - write of property is not possible&#13;&#10; " Name="SetProperty.dRetCode"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL CanControlCy;
				//! <Function Comment="Convert Manufacturer&#13;&#10;specific Statusword&#13;&#10;to DS 402 Standard Statusword&#13;&#10;" Name="StatusWordSwitching"/>
	FUNCTION VIRTUAL GLOBAL StatusWordSwitching
		VAR_INPUT
			Spec_Statusword 	: BDINT;
		END_VAR;
				//! <Function Comment="handles the enable sequence" Name="EnableSequence"/>
	FUNCTION VIRTUAL EnableSequence;
				//! <Function Comment="Configures the CanOpen device via LSS protocol.&#13;&#10;Only 1 unconfigured device must be present.&#13;&#10;The NodeID is set to &quot;Place&quot;, and the baudrate of the CanOpenManager is set.&#13;&#10;Also the DS402 Mode is activated, and the device gets restarted." Name="LSSNodeSetting"/>
	FUNCTION LSSNodeSetting
		VAR_OUTPUT
			dRetCode 	: iprStates;
		END_VAR;
				//! <Function Comment="wrapper for sending sdo requests" Name="SDOInternal"/>
	FUNCTION SDOInternal
		VAR_INPUT
			hiIndex 	: HINT;
			usSubIndex 	: USINT;
			usLength 	: USINT;
			bRW 	: BOOL;
			dDataWr 	: DINT := 0;
			pRetData 	: ^DINT := NIL;
		END_VAR
		VAR_OUTPUT
			dRetCode 	: iprStates;
		END_VAR;
				//! <Function Comment="handles the cyclic sdo buffer" Name="SDOCyclicWork"/>
	FUNCTION SDOCyclicWork
		VAR_OUTPUT
			dRetCode 	: iprStates;
		END_VAR;
	
	FUNCTION TAB FDD3000InternalFileHandlingTab;
				//! <Function Comment="checks for the correct device." Name="CheckDeviceID"/>
	FUNCTION VIRTUAL CheckDeviceID
		VAR_INPUT
			pStrProductCode 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			bIsOK 	: BOOL;
		END_VAR;
				//! <Function Comment="internal callback function" Name="SDOInternalCallback"/>
	FUNCTION SDOInternalCallback
		VAR_INPUT
			udTxCount 	: UDINT;
			udRxCount 	: UDINT;
			udErrorCount 	: UDINT;
			dData 	: DINT;
		END_VAR;
				//! <Function Comment="adds a sdo request to the buffer. (threadsafe)" Name="SDOCyclicAdd"/>
	FUNCTION SDOCyclicAdd
		VAR_INPUT
			bRW 	: BOOL;
			usLen 	: USINT;
			hiIndex 	: HINT;
			usSubIndex 	: USINT;
			dData 	: DINT;
			eSendMode 	: e_SendModeSDO;
		END_VAR
		VAR_OUTPUT
			dRetCode 	: DINT;
		END_VAR;
				//! <Function Comment="handles the autotune, and is controlled by the VOV." Name="AutoTuneHandling"/>
	FUNCTION AutoTuneHandling
		VAR_OUTPUT
			dRetCode 	: iprStates;
		END_VAR;
				//! <Function Comment="used by the VOV. Stores the selected parameters on the drive." Name="SaveParasOnDrive"/>
	FUNCTION SaveParasOnDrive
		VAR_OUTPUT
			dRetCode 	: iprStates;
		END_VAR;
				//! <Function Comment="Used by the VOV, to load and stor the parameters to a file." Name="XMLFileHandling"/>
	FUNCTION XMLFileHandling
		VAR_OUTPUT
			dRetCode 	: iprStates;
		END_VAR;
				//! <Function Comment="get pointer to Logdata" Name="GetLogFile"/>
	FUNCTION VIRTUAL GetLogFile
		VAR_OUTPUT
			ptrLogFile 	: ^FDD3000AxisVis::_LogFile;
		END_VAR;
				//! <Function Comment="adds an alarm from the drive to the list for the LogViewer of the VOV." Name="AlarmListLogger"/>
	FUNCTION AlarmListLogger
		VAR_INPUT
			Command 	: FDD3000AxisVis::_CommandList;
			TripCode 	: FDD3000AxisVis::_LogData_TripCode;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ControllerIF::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL MaxRefClamp::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL MaxRefClamp::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL MinRefClamp::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL MinRefClamp::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AccRate::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AccRate::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL DecRate::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL DecRate::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL MotorRatedCurrent::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL MotorRatedCurrent::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL MotorRatedSpeed::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL MotorRatedSpeed::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL MotorRatedVoltage::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL MotorRatedVoltage::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL MotorRatedPowerFactor::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL MotorRatedPowerFactor::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL MotorRatedFrequency::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL MotorRatedFrequency::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL LowFrequencyVoltageBoost::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL LowFrequencyVoltageBoost::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL StatorResistance::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL StatorResistance::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL TransientInductance::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL TransientInductance::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL StatorInductance::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL StatorInductance::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL MaximumDeadTimeComp::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL CurrentAtMaximumDeadTime::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL CurrentLoopKPGain::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL CurrentLoopKPGain::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL CurrentLoopKiGain::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL CurrentLoopKiGain::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SaturationBreakpoint1::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SaturationBreakpoint1::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SaturationBreakpoint3::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SaturationBreakpoint3::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SaturationBreakpoint2::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SaturationBreakpoint2::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SaturationBreakpoint4::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SaturationBreakpoint4::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using FDD3000_Parameters
#pragma using FDD3000_ParametersFileRam
#pragma using FDD3000_VOVControl
#pragma using String
#pragma usingLtd FDD3000_FileHandling


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB FDD3000_CanOpenInt::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_FDD3000_CANOPENINT
1$UINT, 0$UINT, (SIZEOF(::FDD3000_CanOpenInt))$UINT, 
31$UINT, 7$UINT, 0$UINT, 
TO_UDINT(555764090), "FDD3000_CanOpenInt", //Class
TO_UDINT(238678879), "_CanOpenBasicDS402", 1$UINT, 14$UINT, //Baseclass
//Servers:
(::FDD3000_CanOpenInt.STOInput.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2118211883), "STOInput", 
(::FDD3000_CanOpenInt.InputWord.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3456773996), "InputWord", 
(::FDD3000_CanOpenInt.Online.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1858763116), "Online", 
(::FDD3000_CanOpenInt.ProductCodeDrive.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(2456944508), "ProductCodeDrive", 
(::FDD3000_CanOpenInt.SerialNoDrive.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(1426268939), "SerialNoDrive", 
(::FDD3000_CanOpenInt.FwVersionDrive.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1995891270), "FwVersionDrive", 
(::FDD3000_CanOpenInt.FwVersionComm.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1122607697), "FwVersionComm", 
(::FDD3000_CanOpenInt.HwVersionComm.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3088035553), "HwVersionComm", 
(::FDD3000_CanOpenInt.ControllerIF.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(3950683491), "ControllerIF", 
(::FDD3000_CanOpenInt.OPModeDrive.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4277789707), "OPModeDrive", 
(::FDD3000_CanOpenInt.MaxRefClamp.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2280484791), "MaxRefClamp", 
(::FDD3000_CanOpenInt.MinRefClamp.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1272976568), "MinRefClamp", 
(::FDD3000_CanOpenInt.AccRate.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(565376633), "AccRate", 
(::FDD3000_CanOpenInt.DecRate.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2782083779), "DecRate", 
(::FDD3000_CanOpenInt.MotorRatedCurrent.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1827429705), "MotorRatedCurrent", 
(::FDD3000_CanOpenInt.MotorRatedSpeed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1154694624), "MotorRatedSpeed", 
(::FDD3000_CanOpenInt.MotorRatedVoltage.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3179776645), "MotorRatedVoltage", 
(::FDD3000_CanOpenInt.MotorRatedPowerFactor.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3627548735), "MotorRatedPowerFactor", 
(::FDD3000_CanOpenInt.MotorRatedFrequency.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2125789213), "MotorRatedFrequency", 
(::FDD3000_CanOpenInt.LowFrequencyVoltageBoost.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1097702356), "LowFrequencyVoltageBoost", 
(::FDD3000_CanOpenInt.StatorResistance.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2658549821), "StatorResistance", 
(::FDD3000_CanOpenInt.TransientInductance.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2172931522), "TransientInductance", 
(::FDD3000_CanOpenInt.StatorInductance.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(381380844), "StatorInductance", 
(::FDD3000_CanOpenInt.MaximumDeadTimeComp.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1552366758), "MaximumDeadTimeComp", 
(::FDD3000_CanOpenInt.CurrentAtMaximumDeadTime.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(425687078), "CurrentAtMaximumDeadTime", 
(::FDD3000_CanOpenInt.CurrentLoopKPGain.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3906162718), "CurrentLoopKPGain", 
(::FDD3000_CanOpenInt.CurrentLoopKiGain.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2233705965), "CurrentLoopKiGain", 
(::FDD3000_CanOpenInt.SaturationBreakpoint1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1697189204), "SaturationBreakpoint1", 
(::FDD3000_CanOpenInt.SaturationBreakpoint3.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2334616696), "SaturationBreakpoint3", 
(::FDD3000_CanOpenInt.SaturationBreakpoint2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4229979374), "SaturationBreakpoint2", 
(::FDD3000_CanOpenInt.SaturationBreakpoint4.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(356776411), "SaturationBreakpoint4", 
//Clients:
(::FDD3000_CanOpenInt.StrProductCode.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2943832204), "StrProductCode", TO_UDINT(1850111279), "String", 1$UINT, 11$UINT, 
(::FDD3000_CanOpenInt.StrSerialNo.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1829637442), "StrSerialNo", TO_UDINT(1850111279), "String", 1$UINT, 11$UINT, 
(::FDD3000_CanOpenInt.FDD3000_ActDriveParas.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(313100764), "FDD3000_ActDriveParas", TO_UDINT(1735900044), "FDD3000_Parameters", 1$UINT, 0$UINT, 
(::FDD3000_CanOpenInt.FDD3000_VOVControl1.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1731349495), "FDD3000_VOVControl1", TO_UDINT(3765128076), "FDD3000_VOVControl", 1$UINT, 0$UINT, 
(::FDD3000_CanOpenInt.FDD3000_OldDriveParas.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(875421398), "FDD3000_OldDriveParas", TO_UDINT(1735900044), "FDD3000_Parameters", 1$UINT, 0$UINT, 
(::FDD3000_CanOpenInt.FDD3000_HWKDriveParas.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2804704698), "FDD3000_HWKDriveParas", TO_UDINT(4289130556), "FDD3000_ParametersFileRam", 1$UINT, 0$UINT, 
(::FDD3000_CanOpenInt.toFDD3000FileHandling.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2563699785), "toFDD3000FileHandling", TO_UDINT(3011908429), "FDD3000_FileHandling", 1$UINT, 0$UINT, 
END_FUNCTION


#define USER_CNT_FDD3000_CanOpenInt 57

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_FDD3000_CanOpenInt] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION FDD3000_CanOpenInt::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= _CanOpenBasicDS402::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= _CanOpenBasicDS301::DeviceState.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, _CanOpenBasicDS301::DeviceState.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_FDD3000_CanOpenInt;
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #InitSettingsAndPdos();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #ConvertPdo1();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #TransmitPdo1();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[17]		:= #GetPdoSettings();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[18]		:= #UserSettings();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[26]		:= #CanControl();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[46]		:= #GetProperty();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[47]		:= #SetProperty();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[49]		:= #CanControlCy();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[51]		:= #StatusWordSwitching();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[54]		:= #EnableSequence();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[55]		:= #CheckDeviceID();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[56]		:= #GetLogFile();

#pragma warning (default : 74)
	_CanOpenBasicDS301::DeviceState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF _CanOpenBasicDS301::DeviceState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, ProductCodeDrive.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Write		:= #ProductCodeDrive::M_WR_DIRECT();
	ProductCodeDrive.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ProductCodeDrive.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, SerialNoDrive.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Write		:= #SerialNoDrive::M_WR_DIRECT();
	SerialNoDrive.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF SerialNoDrive.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, ControllerIF.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.NewInstr		:= #ControllerIF::NewInst();
	ControllerIF.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ControllerIF.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	MaxRefClamp.pMeth			:= StoreMethod( #MaxRefClamp::Read(), #MaxRefClamp::Write() );
	IF MaxRefClamp.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	MinRefClamp.pMeth			:= StoreMethod( #MinRefClamp::Read(), #MinRefClamp::Write() );
	IF MinRefClamp.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AccRate.pMeth			:= StoreMethod( #AccRate::Read(), #AccRate::Write() );
	IF AccRate.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	DecRate.pMeth			:= StoreMethod( #DecRate::Read(), #DecRate::Write() );
	IF DecRate.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	MotorRatedCurrent.pMeth			:= StoreMethod( #MotorRatedCurrent::Read(), #MotorRatedCurrent::Write() );
	IF MotorRatedCurrent.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	MotorRatedSpeed.pMeth			:= StoreMethod( #MotorRatedSpeed::Read(), #MotorRatedSpeed::Write() );
	IF MotorRatedSpeed.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	MotorRatedVoltage.pMeth			:= StoreMethod( #MotorRatedVoltage::Read(), #MotorRatedVoltage::Write() );
	IF MotorRatedVoltage.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	MotorRatedPowerFactor.pMeth			:= StoreMethod( #MotorRatedPowerFactor::Read(), #MotorRatedPowerFactor::Write() );
	IF MotorRatedPowerFactor.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	MotorRatedFrequency.pMeth			:= StoreMethod( #MotorRatedFrequency::Read(), #MotorRatedFrequency::Write() );
	IF MotorRatedFrequency.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	LowFrequencyVoltageBoost.pMeth			:= StoreMethod( #LowFrequencyVoltageBoost::Read(), #LowFrequencyVoltageBoost::Write() );
	IF LowFrequencyVoltageBoost.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	StatorResistance.pMeth			:= StoreMethod( #StatorResistance::Read(), #StatorResistance::Write() );
	IF StatorResistance.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	TransientInductance.pMeth			:= StoreMethod( #TransientInductance::Read(), #TransientInductance::Write() );
	IF TransientInductance.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	StatorInductance.pMeth			:= StoreMethod( #StatorInductance::Read(), #StatorInductance::Write() );
	IF StatorInductance.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	MaximumDeadTimeComp.pMeth			:= StoreMethod( #MaximumDeadTimeComp::Read(), #M_NO_F() );
	IF MaximumDeadTimeComp.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	CurrentAtMaximumDeadTime.pMeth			:= StoreMethod( #CurrentAtMaximumDeadTime::Read(), #M_NO_F() );
	IF CurrentAtMaximumDeadTime.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	CurrentLoopKPGain.pMeth			:= StoreMethod( #CurrentLoopKPGain::Read(), #CurrentLoopKPGain::Write() );
	IF CurrentLoopKPGain.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	CurrentLoopKiGain.pMeth			:= StoreMethod( #CurrentLoopKiGain::Read(), #CurrentLoopKiGain::Write() );
	IF CurrentLoopKiGain.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SaturationBreakpoint1.pMeth			:= StoreMethod( #SaturationBreakpoint1::Read(), #SaturationBreakpoint1::Write() );
	IF SaturationBreakpoint1.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SaturationBreakpoint3.pMeth			:= StoreMethod( #SaturationBreakpoint3::Read(), #SaturationBreakpoint3::Write() );
	IF SaturationBreakpoint3.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SaturationBreakpoint2.pMeth			:= StoreMethod( #SaturationBreakpoint2::Read(), #SaturationBreakpoint2::Write() );
	IF SaturationBreakpoint2.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SaturationBreakpoint4.pMeth			:= StoreMethod( #SaturationBreakpoint4::Read(), #SaturationBreakpoint4::Write() );
	IF SaturationBreakpoint4.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::Init
VAR
  dRetCode : DINT;
END_VAR
  
  _CanOpenBasicDS301::Init();
  
  if usInitCnt = 10 then
    // Initialize the SDO object and get the number
    // If number -1 initialize unsuccessful
    dRetCode := SetSDOobjData(0, 0, 0, 0, 0, 0, this, #SDOInternalCallback());
    //write parameters which are different to stored on hwk
    sSaveParasVars.bWriteDiffParas  := TRUE;
    
    if dRetCode >= 0 then
      sCyclicSDORW.iSDOHandle := dRetCode$int;      
    else  
      MasterDevice.LogError("@0700 (FDD3000_CanOpenInt::Init) Adding of internal SDO Channel failed!");
    end_if;
    
    //Get act Bitrate and node number for visu class    
    sLSSNodeSetting.usNodeId   := Place$USINT;
    sLSSNodeSetting.usBaudrate := MasterDevice.IFGetActBaudrate();
    sLSSNodeSetting.uiBitrate  := _CanOpenLSSControl1.SigmatekIndex2Baudrate(sLSSNodeSetting.usBaudrate);
    FDD3000_VOVControl1.SetNodeID  := sLSSNodeSetting.usNodeId;
    FDD3000_VOVControl1.SetBitrate := sLSSNodeSetting.uiBitrate;
    
    //initialize time stamps
    udWait4ConfigureNode := ops.tAbsolute;
    
  end_if;

END_FUNCTION


FUNCTION VIRTUAL FDD3000_CanOpenInt::InitSettingsAndPdos

  case InitSSW of  
    0: //save different parameters from hwk on drive  
      sSaveParasVars.bWriteDiffParas := TRUE;
  end_case;  
    
   _CanOpenBasicDS402::InitSettingsAndPdos();  
        
END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::GetPdoSettings
  
  PDOIniSSW := 0; // DONT TOUCH

  // ----------------------------------------------------------------------------------------
  // -------   SET CONSTANT PARAMETER TO VARIABLES SO WE CAN EASY OVERLOAD ------------------
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  
  
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------  
  // ------------------                  INDEX DRIVEMODE                  -------------------
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  
  IndexDriveMode_w      := CO_INDEX_DRIVEMODE_W;
  IndexDriveMode_r      := CO_INDEX_DRIVEMODE_R;
  SubIndexDriveMode_r   := CO_DEFAULT_SUBINDEX;    
    
  // Parameter 10.020  Trip 0
  IndexErrorStat        := FDD3000_MENU_10_STATUS_TRIPS; 
  SubIndexErrorStat     := FDD3000_10_PARA_TRIP_0;    
  
  // ----------------------------------------------------------------------------------------  
  // ------------------------             HOMING-SETTINGS            ------------------------
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  // REF OFFSET
  HomingRefOffset.Index     := -1;    // -1 = index is disabled
  HomingRefOffset.SubIndex  := 16#00;
  
  // REF MODE
  HomingRefMode.Index       := -1;    // -1 = index is disabled
  HomingRefMode.SubIndex    := 16#00;
  
  // SPEED1
  HomingSpeed1.Index        := -1;    // -1 = index is disabled
  HomingSpeed1.SubIndex     := 16#01;
  
  // SPEED2
  HomingSpeed2.Index        := -1;    // -1 = index is disabled
  HomingSpeed2.SubIndex     := 16#02;
  
  // ACCEL
  HomingAccel.Index         := -1;    // -1 = index is disabled
  HomingAccel.SubIndex      := 16#00;
  
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------  
  // ------------------------             OBJECT NUMBERS            -------------------------
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  RSdoObjNr := CO_RSDO_OBJNR;
  TSdoObjNr := CO_TSDO_OBJNR;
  NgObjNr   := CO_NG_OBJNR;
  EmcyObjNr := CO_EMCY_OBJNR;
  
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------  
  // ------------------                     SDO ERROR                     -------------------
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  SDO_RwError := CO_SDO_RW_ERROR;  
  
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------  
  // ------------------------             NODE GUARDING            --------------------------
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  GuardTime.Index         := FDD3000_CANOPEN_PARA_GUARDTIME;
  GuardTime.SubIndex      := 16#00; 
  GuardTime.Data          := FDD3000_CANOPEN_PARA_GUARDTIME_DATA; // GuardTime
                       
  LifetimeFactor.Index    := FDD3000_CANOPEN_PARA_LIFETIMEFACTOR;
  LifetimeFactor.SubIndex := 16#00; 
  LifetimeFactor.Data     := FDD3000_CANOPEN_PARA_LIFETIMEFACTOR_DATA; // Lifetimefactor 
  
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------  
  // ---------------------             PRODUCER HEARTBEAT            ------------------------
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  Heartbeat.Index         := FDD3000_CANOPEN_PARA_HEARTBEAT;
  Heartbeat.SubIndex      := 16#00;
  Heartbeat.Data          := FDD3000_CANOPEN_PARA_HEARTBEAT_DATA;
  
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------  
  // ---------------------            PLC Consumer HEARTBEAT         ------------------------
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  PlcConsumerHeartBeat := to_udint(Heartbeat.Data*2);
  
  //set drive mode 2 = velocity mode
  DriveMode.Write(input:=2);

  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------  
  // --------------------             RECEIVE PDO-SETTINGS               --------------------
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  // if a valid xdc file is connected the PDO settings are taken from the file --------------
  // ----------------------------------------------------------------------------------------
  // Receive Object Numbers -----------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  RPdo1.ObjNr := CO_RPDO1_OBJNR;
  
  // ----------------------------------------------------------------------------------------
  // RPDO 1, DRIVE --> PLC -----------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  //only needed if it is used, it is already deactivate at init  
  DefaultPDOSetting(pPdoElement:=#RPdo1, iAddressSetting:=CO_INDEX_RPDO1_SETTING);
  
//  RPdo1.TransmissionType.Data     := 0;
  
  // PDO mapping parameter
  RPdo1.ActiveNbrOfMappings       := 3; //-1; Deactivate that number of Mappings are send to the device
  
  RPdo1.MappingPara[0].Index      := CO_INDEX_RPDO1_MAPPING; //CO_INDEX_RPDO1_MAPPING; // -1 = inactive
  RPdo1.MappingPara[0].Subindex   := 16#01; 
  RPdo1.MappingPara[0].Data       := FDD3000_CANOPEN_RPDOA_MAPPINGPARA_1;    
  
  RPdo1.MappingPara[1].Index      := CO_INDEX_RPDO1_MAPPING;
  RPdo1.MappingPara[1].Subindex   := 16#02; 
  RPdo1.MappingPara[1].Data       := FDD3000_CANOPEN_RPDOA_MAPPINGPARA_2;
  
  RPdo1.MappingPara[2].Index      := CO_INDEX_RPDO1_MAPPING;
  RPdo1.MappingPara[2].Subindex   := 16#03; 
  RPdo1.MappingPara[2].Data       := FDD3000_CANOPEN_RPDOA_MAPPINGPARA_3;
  
//  RPdo1.MappingPara[3].Index      := CO_INDEX_RPDO1_MAPPING;
//  RPdo1.MappingPara[3].Subindex   := 16#04; 
//  RPdo1.MappingPara[3].Data       := FDD3000_CANOPEN_RPDOA_MAPPINGPARA_4;//STO input 2 - 1 byte data
    
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------  
  // -------------------             TRANSMIT PDO-SETTINGS               --------------------
  // ----------------------------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  // if a valid xdc file is connected the PDO settings are taken from the file --------------
  // ----------------------------------------------------------------------------------------
  // Transmit Object Numbers ----------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  TPdo1.ObjNr := CO_TPDO1_OBJNR;
  
  // ----------------------------------------------------------------------------------------
  // TPDO 1, PLC --> DRIVE ------------------------------------------------------------------
  // ----------------------------------------------------------------------------------------
  //only needed if it is used, it is already deactivate at init
  DefaultPDOSetting(pPdoElement:=#TPdo1, iAddressSetting:=CO_INDEX_TPDO1_SETTING);
  
  // PDO mapping parameter
  TPdo1.ActiveNbrOfMappings       := 2;   //-1; Deactivate that number of Mappings are send to the device
  
  TPdo1.MappingPara[0].Index      := CO_INDEX_TPDO1_MAPPING; //CO_INDEX_TPDO1_MAPPING; // -1 = inactive
  TPdo1.MappingPara[0].Subindex   := 16#01; 
  TPdo1.MappingPara[0].Data       := FDD3000_CANOPEN_TPDOA_MAPPINGPARA_1;
  
  TPdo1.MappingPara[1].Index      := CO_INDEX_TPDO1_MAPPING; // -1 = inactive
  TPdo1.MappingPara[1].Subindex   := 16#02; 
  TPdo1.MappingPara[1].Data       := FDD3000_CANOPEN_TPDOA_MAPPINGPARA_2;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::TransmitPdo1
  VAR
    TxBuffer : ARRAY[0..7] of HSINT;
    hObjNr   : HINT;
  END_VAR  
  
  _MemSet(#TxBuffer[0],0,sizeof(TxBuffer));
  
  // CONTROLWORD -------------------------------------------------------------------------------
  TxBuffer[0]$HINT := ControlWord$HINT;
    
  // CONTROLWORD -------------------------------------------------------------------------------
  TxBuffer[2]$INT := Speed$INT; //abs(SetFreqOut$INT);  
  
  hObjNr := TPdo1.ObjNr$HINT;  
  
  MasterDevice.CanTxObj((hObjNr+Place)$INT,
                         8,
                         #TxBuffer[0],
                         TRUE);
   
END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::ConvertPdo1
  VAR
    HlpStatusWord : BDINT;
  END_VAR

  HlpStatusWord  := RxBufferPdo1[0]$BINT;
  
  StatusWordSwitching(Spec_Statusword:=HlpStatusWord);
  
  if Enable = 1 & StatusWord.SwitchedOn = FALSE then
    //drive is disabled (by STO ..) switch off enable signal
    if EnableSequenceSSW <> _DisableOperation then    
      Enable.Write(input:=0);
    end_if;
  end_if;
    
  ActSpeed  := RxBufferPdo1[2]$INT;
  
  InputWord := RxBufferPdo1[4]$BINT;
  STOInput := InputWord.8 AND InputWord.9;
    
END_FUNCTION


FUNCTION VIRTUAL FDD3000_CanOpenInt::EnableSequence

  //**************************************************************************************************
  // ENABLE/DISABLE SEQUENCE
  _CanOpenBasicDS402::EnableSequence();  
   ControlWord.ManufactureSpec1 := TRUE; //remote control
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::StatusWordSwitching
	VAR_INPUT
		Spec_Statusword 	: BDINT;
	END_VAR
  
  // STATUSWORD IDENT TO STANDARD
  Spec_Statusword.5 := Spec_Statusword.5 xor 1;
  StatusWord := Spec_Statusword;
  DataReady := 1;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::UserSettings
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
    Hlpretcode  : iprStates;
    HlpIndex    : INT;
    HlpSubIndex : SINT;
    HlpData     : DINT; 
    HlpRW       : BOOL;
    HlpLen      : USINT;
    HlpRetData  : DINT;
    usActStrLength : USINT;
    aTmpStrBuffer  : Array [0..15] of CHAR;
  END_VAR; 
  
  //initialize retcode with busy
  retcode := 0;
  //check drive if it is ready for configuration - HB Time must be send first to get nmt state of drive
  if CanDeviceStateInternal <> _CAN_PRE_OPERATIONAL & PDOIniSSW = 1 then
    if (ops.tAbsolute-udWait4ConfigureNode) >= FDD3000_CANOPEN_WAIT4CONFIGURENODE then
      //set node to preop for configuration
      SetNmt(Para:=CO_SETPREOPERATIONAL);
      udWait4ConfigureNode := ops.tAbsolute;
      usRetriesWait4Config += 1;
      if usRetriesWait4Config >= FDD3000_CANOPEN_RETRIES_CONFIGURENODE then
        //reset variables        
        usRetriesWait4Config := 0;        
        //node doesn't change nmt state -> not available
        OpMode      := _CAN_COMERROR;
        DeviceState := _CanOpenMng::_CAN_COMERROR;
        //init is aborted with com error to node
        InitSSW     := 200;        
      end_if;
    end_if;
    return;
  end_if;
  
  //**********************************************************************************************
  // USER SETTINGS HANDLING
  //**********************************************************************************************
  case PDOIniSSW of
  
    //HB Time must be send first to get nmt state of drive
    0:// PRODUCER HEARTBEAT PARAMETER ------------------------------------------------------------
      HlpIndex    := Heartbeat.Index;
      HlpSubIndex := Heartbeat.SubIndex$SINT; 
      HlpData     := Heartbeat.Data$DINT; 
      HlpRW       := 1; 
      HlpLen      := 2;      
      udTimeStampHB := ops.tAbsolute;   
  
    1:// USER SDO TABLE --------------------------------------------------------------------------
            
      if (IsClientConnected(#SDOTable) = 1) then
      
        pSDOTable$DINT := SDOTable.GetTabPtr(); // Get the pointer of table with user parameter
        if (pSDOTable <> NIL) then
          // dSDOTabCounter ... number of lines in the table
          // 1st 4 bytes in  table contain number of bytes in table (excluding 1st 4 bytes where the size in bytes is stored)
          dSDOTabCounter := pSDOTable^ / 8;       // Size of all values for on Parameter(One Line in Table)
                                                  // Sizeof(Index) + sizeof(SubIndex) + sizeof(ProductCodeDrive) + sizeof(DataLength) = 8Byte;
          // move the pointer to the start of the table data
          pSDOTable += sizeof(DINT);
          PDOIniSSW := 2;
          return;
        
        else
          // FINISHED User table -----------------------------------------------------------------
          PDOIniSSW := 3;
          return;
          
        end_if;
        
      else
        // FINISHED User table -----------------------------------------------------------------
        PDOIniSSW := 3;
        return;
        
      end_if;    
      
    2:// USER PARAMETER --------------------------------------------------------------------------   
      HlpIndex    := pSDOTable^$INT;
      HlpSubIndex := (pSDOTable + sizeof(INT))^$SINT;
      HlpData     := (pSDOTable + sizeof(INT) + sizeof(SINT))^;
      HlpRW       := 1;
      HlpLen      := (pSDOTable + sizeof(INT) + sizeof(SINT) + sizeof(DINT))^$USINT;
                
    3:// 01.01.020  CiA402 profiles Enable ------------------------------------------------------------------      
        HlpIndex    := FDD3000_SI_MENU_01;
        HlpSubIndex := FDD3000_101_PARA_CIAPROFILE_ENABLE;
        HlpData     := 1;
        HlpRW       := 1; 
        HlpLen      := 1;

    4:// 01.01.010  Timeout delay ------------------------------------------------------------------      
        HlpIndex    := FDD3000_SI_MENU_01;
        HlpSubIndex := FDD3000_101_PARA_TIMEOUT_DELAY;
        HlpData     := FDD3000_CANOPEN_PARA_HEARTBEAT_DATA;
        HlpRW       := 1; 
        HlpLen      := 2;

    5:// 01.01.011  Timeout action ------------------------------------------------------------------      
        HlpIndex    := FDD3000_SI_MENU_01;
        HlpSubIndex := FDD3000_101_PARA_TIMEOUT_ACTION;
        HlpData     := 0;
        HlpRW       := 1; 
        HlpLen      := 1;
      
    6:// 06.043  Control Word Enable [0] ------------------------------------------------------------------      
        HlpIndex    := FDD3000_MENU_06_SEQUENCER_CLOCK;
        HlpSubIndex := FDD3000_06_CONTROLWORD_ENABLE;
        HlpData     := 1;
        HlpRW       := 1; 
        HlpLen      := 1;
           
    7:// 10.036  Auto-reset Hold Drive Healthy ------------------------------------------------------------      
        HlpIndex    := FDD3000_MENU_10_STATUS_TRIPS;
        HlpSubIndex := FDD3000_10_PARA_AUTO_RESET;
        HlpData     := 1;
        HlpRW       := 1; 
        HlpLen      := 1;
        
    8://  ------------------------------------------------------------------ 
        PDOIniSSW := 10;
        return;   
      
    10: //AAAA Product Identifier Characters (11.064)  ------------------------------------------------------------------  
        HlpIndex    := FDD3000_MENU_11_MISCELLANEOUS;
        HlpSubIndex := FDD3000_11_PARA_PRODUCT_IDENTIFIER;
        HlpData     := 0;
        HlpRW       := 0; 
        HlpLen      := 4;
      
    11: //nnn Frame size and voltage code (11.065)   ------------------------------------------------------------------  
        HlpIndex    := FDD3000_MENU_11_MISCELLANEOUS;
        HlpSubIndex := FDD3000_11_PARA_FRAME_SIZE_VOLTAGE;
        HlpData     := 0;
        HlpRW       := 0; 
        HlpLen      := 4;
        
    12: //ppppp Drive current rating (11.068)  ------------------------------------------------------------------  
        HlpIndex    := FDD3000_MENU_11_MISCELLANEOUS;
        HlpSubIndex := FDD3000_11_PARA_DRIVE_CURRENT;
        HlpData     := 0;
        HlpRW       := 0; 
        HlpLen      := 4;
        
    13: //CCCC Additional Identifier Characters 1 (11.091)  ------------------------------------------------------------------  
        HlpIndex    := FDD3000_MENU_11_MISCELLANEOUS;
        HlpSubIndex := FDD3000_11_PARA_ADD_IDENTIFIER1;
        HlpData     := 0;
        HlpRW       := 0; 
        HlpLen      := 4;
      
    14: //DDEE Additional Identifier Characters 2 (11.092)  ------------------------------------------------------------------  
        HlpIndex    := FDD3000_MENU_11_MISCELLANEOUS;
        HlpSubIndex := FDD3000_11_PARA_ADD_IDENTIFIER2;
        HlpData     := 0;
        HlpRW       := 0; 
        HlpLen      := 4;
      
    15: //FFFB Additional Identifier Characters 3 (11.093)  ------------------------------------------------------------------  
        HlpIndex    := FDD3000_MENU_11_MISCELLANEOUS;
        HlpSubIndex := FDD3000_11_PARA_ADD_IDENTIFIER3;
        HlpData     := 0;
        HlpRW       := 0; 
        HlpLen      := 4;      
      
    16:// 11.053 Serial Number MS ------------------------------------------------------------------  
        HlpIndex    := FDD3000_MENU_11_MISCELLANEOUS;
        HlpSubIndex := FDD3000_11_PARA_SERIALNR_MS;
        HlpData     := 0;
        HlpRW       := 0; 
        HlpLen      := 4;            
    
    17:// 11.052 Serial Number LS ------------------------------------------------------------------  
        HlpIndex    := FDD3000_MENU_11_MISCELLANEOUS;
        HlpSubIndex := FDD3000_11_PARA_SERIALNR_LS;
        HlpData     := 0;
        HlpRW       := 0; 
        HlpLen      := 4;
        
    18:// 11.029  Firmware Version Drive ww.xx.yy.zz  ------------------------------------------------------------------  
        HlpIndex    := FDD3000_MENU_11_MISCELLANEOUS;
        HlpSubIndex := FDD3000_11_PARA_FW_VERSION;
        HlpData     := 0;
        HlpRW       := 0; 
        HlpLen      := 4;
          
    19:// 15.002  Firmware Version Comm Module ww.xx.yy.zz
        HlpIndex    := FDD3000_MENU_15_SI_MODULE;
        HlpSubIndex := FDD3000_15_PARA_FW_VERSION;
        HlpData     := 0;
        HlpRW       := 0; 
        HlpLen      := 4;
      
    20:// 15.003  Hardware Version Comm Module ww.xx
        HlpIndex    := FDD3000_MENU_15_SI_MODULE;
        HlpSubIndex := FDD3000_15_PARA_HW_VERSION;
        HlpData     := 0;
        HlpRW       := 0; 
        HlpLen      := 2;
    
    21:// ------------------------------------------------------------------ 
        PDOIniSSW := 30;
        return;
        
    //*****************************************************************************************************
    //read act parameter from drive    
    30:// 01.006 Maximum Reference clamp ------------------------------------------------------------------  
        HlpIndex    := FDD3000_MENU_01_FREQ_REFERENCE;
        HlpSubIndex := FDD3000_01_PARA_MAX_REF_CLAMP;
        HlpData     := 0;
        HlpRW       := 0; 
        HlpLen      := 4;        
    
    31:// 01.007 Minimum Reference clamp ------------------------------------------------------------------  
        HlpIndex    := FDD3000_MENU_01_FREQ_REFERENCE;
        HlpSubIndex := FDD3000_01_PARA_MIN_REF_CLAMP;
        HlpData     := 0;
        HlpRW       := 0; 
        HlpLen      := 4;    
    
    32:// 02.011 Acceleration Rate 1 ------------------------------------------------------------------  
        HlpIndex    := FDD3000_MENU_02_FREQ_RAMPS;
        HlpSubIndex := FDD3000_02_PARA_ACCRATE;
        HlpData     := 0;
        HlpRW       := 0; 
        HlpLen      := 4;
        
    33:// 02.021 Deceleration Rate 1 ------------------------------------------------------------------  
        HlpIndex    := FDD3000_MENU_02_FREQ_RAMPS;
        HlpSubIndex := FDD3000_02_PARA_DEC_RATE;
        HlpData     := 0;
        HlpRW       := 0;
        HlpLen      := 4;
        
    34:// 05.007 Motor Rated Current ------------------------------------------------------------------  
        HlpIndex    := FDD3000_MENU_05_MOTOR_CONTROL;
        HlpSubIndex := FDD3000_05_PARA_MOTOR_CURR;
        HlpData     := 0;
        HlpRW       := 0;
        HlpLen      := 4;
        
    35:// 05.008 Motor Rated Speed ------------------------------------------------------------------  
        HlpIndex    := FDD3000_MENU_05_MOTOR_CONTROL;
        HlpSubIndex := FDD3000_05_PARA_MOTOR_SPEED;
        HlpData     := 0;
        HlpRW       := 0;
        HlpLen      := 4;
        
    36:// 05.009 Motor Rated Voltage ------------------------------------------------------------------  
        HlpIndex    := FDD3000_MENU_05_MOTOR_CONTROL;
        HlpSubIndex := FDD3000_05_PARA_MOTOR_VOLTAGE;
        HlpData     := 0;
        HlpRW       := 0;
        HlpLen      := 2;        
        
    37:// ------------------------------------------------------------------ 
        PDOIniSSW += 1; //05.010 Motor Rated Power Factor is read after stator inductance
        return;
        
    38:// 05.006 Motor Rated Frequency ------------------------------------------------------------------  
        HlpIndex    := FDD3000_MENU_05_MOTOR_CONTROL;
        HlpSubIndex := FDD3000_05_PARA_MOTOR_FREQ;
        HlpData     := 0;
        HlpRW       := 0;
        HlpLen      := 4;
        
    39:// 05.015 Low Frequency Voltage Boost ------------------------------------------------------------------  
        HlpIndex    := FDD3000_MENU_05_MOTOR_CONTROL;
        HlpSubIndex := FDD3000_05_PARA_LOWFREQVOLBOOST;
        HlpData     := 0;
        HlpRW       := 0;
        HlpLen      := 2;        
        
    40:// 11.084  Drive Mode
        HlpIndex    := FDD3000_MENU_11_MISCELLANEOUS;
        HlpSubIndex := FDD3000_11_PARA_DRIVE_OP_MODE;
        HlpData     := 0;
        HlpRW       := 0;
        HlpLen      := 1;        
            
    41:// ------------------------------------------------------------------ 
        PDOIniSSW := 50;
        return;
        
    // stationary   
    50:// OpenLoop / RFC-A Stator Resistance 05.017
        HlpIndex    := FDD3000_MENU_05_MOTOR_CONTROL;
        HlpSubIndex := FDD3000_05_PARA_STATOR_RESISTANCE;
        HlpData     := 0;
        HlpRW       := 0;
        HlpLen      := 4;        
        
    51:// OpenLoop / RFC-A Transient Inductance 05.024
        HlpIndex    := FDD3000_MENU_05_MOTOR_CONTROL;
        HlpSubIndex := FDD3000_05_PARA_TRANSIENT_INDUCTANCE;
        HlpData     := 0;
        HlpRW       := 0;
        HlpLen      := 4; 
        
    // rotating    
    52:// OpenLoop / RFC-A Stator Inductance 05.025 
        HlpIndex    := FDD3000_MENU_05_MOTOR_CONTROL;
        HlpSubIndex := FDD3000_05_PARA_STATOR_INDUCTANCE;
        HlpData     := 0;
        HlpRW       := 0;
        HlpLen      := 4;         
        
    53:// 05.010 Motor Rated Power Factor ------------------------------------------------------------------  
        HlpIndex    := FDD3000_MENU_05_MOTOR_CONTROL;
        HlpSubIndex := FDD3000_05_PARA_MOTOR_POWERFACTOR;
        HlpData     := 0;
        HlpRW       := 0;
        HlpLen      := 2;
        
    54:// ------------------------------------------------------------------ 
        if OPModeDrive = FDD3000_VOVControl::_OpenLoop then
          PDOIniSSW := 60;
        elsif OPModeDrive = FDD3000_VOVControl::_RFC_A then
          PDOIniSSW := 70;
        else
          //finished init
          PDOIniSSW := 100;
        end_if;
        return;
      
    // stationary 
    60://OpenLoop Maximum Deadtime compensation 05.059
        HlpIndex    := FDD3000_MENU_05_MOTOR_CONTROL;
        HlpSubIndex := FDD3000_05_PARA_MAX_DEADTIME_COMP;
        HlpData     := 0;
        HlpRW       := 0;
        HlpLen      := 4; 
        
    61://OpenLoop Current At Maximum Deadtime Compensation 05.060
        HlpIndex    := FDD3000_MENU_05_MOTOR_CONTROL;
        HlpSubIndex := FDD3000_05_PARA_CURRENT_MAX_DEADTIME;
        HlpData     := 0;
        HlpRW       := 0;
        HlpLen      := 4; 
          
    62:// ------------------------------------------------------------------ 
        PDOIniSSW := 100;
        return;
        
    // stationary 
    70://RFC-A Current Loop Gains 04.013
        HlpIndex    := FDD3000_MENU_04_TOURQUE_CURRENT;
        HlpSubIndex := FDD3000_04_PARA_CURRLOOP_KPGAIN;
        HlpData     := 0;
        HlpRW       := 0;
        HlpLen      := 4; 
        
    71://RFC-A Current Loop Gains 04.014
        HlpIndex    := FDD3000_MENU_04_TOURQUE_CURRENT;
        HlpSubIndex := FDD3000_04_PARA_CURRLOOP_KIGAIN;
        HlpData     := 0;
        HlpRW       := 0;
        HlpLen      := 4;
        
    // rotating 
    72://RFC-A motor saturation breakpoints 1 Pr 05.029
        HlpIndex    := FDD3000_MENU_05_MOTOR_CONTROL;
        HlpSubIndex := FDD3000_05_PARA_SAT_BREAKPOINT1;
        HlpData     := 0;
        HlpRW       := 0;
        HlpLen      := 2; 
        
    73://RFC-A motor saturation breakpoints 3 Pr 05.030
        HlpIndex    := FDD3000_MENU_05_MOTOR_CONTROL;
        HlpSubIndex := FDD3000_05_PARA_SAT_BREAKPOINT3;
        HlpData     := 0;
        HlpRW       := 0;
        HlpLen      := 2; 
        
    74://RFC-A motor saturation breakpoints 2 Pr 05.062
        HlpIndex    := FDD3000_MENU_05_MOTOR_CONTROL;
        HlpSubIndex := FDD3000_05_PARA_SAT_BREAKPOINT2;
        HlpData     := 0;
        HlpRW       := 0;
        HlpLen      := 2; 
        
    75://RFC-A motor saturation breakpoints 4 Pr 05.063
        HlpIndex    := FDD3000_MENU_05_MOTOR_CONTROL;
        HlpSubIndex := FDD3000_05_PARA_SAT_BREAKPOINT4;
        HlpData     := 0;
        HlpRW       := 0;
        HlpLen      := 2; 
      
    76:// ------------------------------------------------------------------ 
        PDOIniSSW := 100;
        return;        
        
    //*****************************************************************************************************
    //write different parameter to drive   
    90:
        //store data for write access
       HlpRW       :=   sInitSDO.SDOData.bRW;
       HlpLen      :=   sInitSDO.SDOData.usLen;
       HlpIndex    :=   sInitSDO.SDOData.hiIndex$INT;
       HlpSubIndex :=   sInitSDO.SDOData.usSubIndex$SINT;
       HlpData     :=   sInitSDO.SDOData.dData;
   
    91:// ------------------------------------------------------------------   
       PDOIniSSW := sInitSDO.OldPdoInitSSW;
       return;
        
    100:// FINISHED --------------------------------------------------------------------------------
      PDOIniSSW := 0;
      retcode   := 1;  
      return;
      
  END_CASE;
  //**********************************************************************************************
  // END USER SETTINGS HANDLING
  //**********************************************************************************************
  
  
  //**********************************************************************************************
  // ASYNC DATA HANDLING
  //**********************************************************************************************
  
  HlpRetcode := AsyncSDOHandling(pHandle  := #HlpHandleInit
                              , iIndex    := HlpIndex
                              , siSubIndex:= HlpSubIndex
                              , dData     := HlpData
                              , bRW       := HlpRW
                              , usLength  := HlpLen  
                              , pAsyncData:= #HlpRetData
                              );
                              
  // Send SDO --------------------------------------------------
  if HlpRetcode = READY then
  
  // Send SDO was not successful -------------------------------
  elsif HlpRetcode = ERROR then
    //set class to error if required or there is no communication to node 
    if Required | HlpRetData = CO_CAN_DEVICE_NOANSWER then
      OpMode      := _CAN_COMERROR;
      DeviceState := _CanOpenMng::_CAN_COMERROR;
      //init is aborted with com error to node
      InitSSW     := 200;
    else
      //error sending SDO table parameter
      if (PDOIniSSW <> 2) then
        PDOIniSSW += 1;
        
      else// Send user Parameter 
        dSDOTabCounter -= 1;
        if (dSDOTabCounter <= 0) then // this is the end of the table
          PDOIniSSW += 1;             // table data have been sent so go on with node guarding and heartbeat
        else                          // still at least 1 line in the table to send
          pSDOTable := pSDOTable + 8; // move pointer to next line of table
        end_if;
      end_if;
    end_if;  
  
  // Send SDO was successful ------------------------------------  
  elsif HlpRetcode = QUIT then  
    if (PDOIniSSW <> 2) then
      //process response data
      case PDOIniSSW of        
        //Section of identifier Parameter 
        //AAAA Product Identifier Characters (11.064)
        10:
          usActStrOffset := 0;
          aTmpStrBuffer[0]$DINT := HlpRetData;
          sigclib_sprintfST(pd:=#aStrBuffer[0], format:="%c%c%c%c-" 
                          , p0:=#aTmpStrBuffer[3]
                          , p1:=#aTmpStrBuffer[2]
                          , p2:=#aTmpStrBuffer[1]
                          , p3:=#aTmpStrBuffer[0]);
          usActStrLength := 5;
          usActStrOffset += usActStrLength; 
          
        //nnn Frame size and voltage code (11.065) 000-999
        11:
          sigclib_sprintfST(pd:=#aStrBuffer[usActStrOffset], format:="%03d-" , p0:=#HlpRetData);
          usActStrLength := 4;
          usActStrOffset += usActStrLength; 
          
        //ppppp Drive current rating (11.068) 00000 32767
        12:
          sigclib_sprintfST(pd:=#aStrBuffer[usActStrOffset], format:="%05d-" , p0:=#HlpRetData);
          usActStrLength := 6;
          usActStrOffset += usActStrLength;
                    
        //CCCC Additional Identifier Characters 1 (11.091)
        13:
          aTmpStrBuffer[0]$DINT := HlpRetData;
          sigclib_sprintfST(pd:=#aStrBuffer[usActStrOffset], format:="%c%c%c%c-" 
                          , p0:=#aTmpStrBuffer[3]
                          , p1:=#aTmpStrBuffer[2]
                          , p2:=#aTmpStrBuffer[1]
                          , p3:=#aTmpStrBuffer[0]);
          usActStrLength := 5;
          usActStrOffset += usActStrLength; 
                    
        //DDEE Additional Identifier Characters 2 (11.092)
        14:
          aTmpStrBuffer[0]$DINT := HlpRetData;
          sigclib_sprintfST(pd:=#aStrBuffer[usActStrOffset], format:="%c%c%c%c-" 
                          , p0:=#aTmpStrBuffer[3]
                          , p1:=#aTmpStrBuffer[2]
                          , p2:=#aTmpStrBuffer[1]
                          , p3:=#aTmpStrBuffer[0]);
          usActStrLength := 5;
          usActStrOffset += usActStrLength; 
          
        //FFFB Additional Identifier Characters 3 (11.093)
        15:
          //last string part of product code
          aTmpStrBuffer[0]$DINT := HlpRetData;
          sigclib_sprintfST(pd:=#aStrBuffer[usActStrOffset], format:="%c%c%c%c" 
                          , p0:=#aTmpStrBuffer[3]
                          , p1:=#aTmpStrBuffer[2]
                          , p2:=#aTmpStrBuffer[1]
                          , p3:=#aTmpStrBuffer[0]);
          usActStrLength := 4;
          usActStrOffset += usActStrLength;
          
          //check for sigmatek device
          bDeviceIsOK := CheckDeviceID(#aStrBuffer[0]);
          
          
          if bDeviceIsOK = FALSE then  
            //set string on server
            StrProductCode.WriteDataOff(udLen:=sigclib_strlen(str:=#aStrBuffer[0]), udOff:=0, pData:=#aStrBuffer[0]);
            
            //init is aborted with com error to node
            InitSSW     := 200;
            OpMode      := _CanOpenBasicDS301::_CAN_IDLE;
            DeviceState := _CanOpenMng::_CAN_NODE_WRONG_HW;
            return;
          else
            aStrBuffer[1] := 70;
            aStrBuffer[2] := 68;
            aStrBuffer[3] := 68;
            aStrBuffer[4] := 51;
            aStrBuffer[14] := 0;
            StrProductCode.WriteDataOff(udLen:=sigclib_strlen(str:=#aStrBuffer[1]), udOff:=0, pData:=#aStrBuffer[1]);
          end_if;

        // 11.053 Serial Number MS
        16:
          usActStrOffset := 0;
          sigclib_sprintfST(pd:=#aStrBuffer[usActStrOffset], format:="%d" , p0:=#HlpRetData);
          usActStrLength := sigclib_strlen(str:=#aStrBuffer[0])$USINT;
          usActStrOffset += usActStrLength;
          
        // 11.052 Serial Number LS
        17:
          sigclib_sprintfST(pd:=#aStrBuffer[usActStrOffset], format:="%06d" , p0:=#HlpRetData);
          usActStrLength := sigclib_strlen(str:=#aStrBuffer[0])$USINT;
          usActStrOffset += usActStrLength;
          StrSerialNo.WriteDataOff(udLen:=usActStrOffset, udOff:=0, pData:=#aStrBuffer[0]);
                   
        18:// 11.029  Firmware Version Drive ww.xx.yy.zz
          FwVersionDrive := HlpRetData$UDINT;
                  
        19:// 15.002  Firmware Version Comm Module ww.xx.yy.zz
          FwVersionComm := HlpRetData$UDINT;
                  
        20:// 15.003  Hardware Version Comm Module ww.xx
          HwVersionComm := HlpRetData$UDINT;
            
        30:// 01.006 Maximum Reference clamp ------------------------------------------------------------------ 
          FDD3000_ActDriveParas.MaxRefClamp.Write(input:=HlpRetData);
          MaxRefClamp :=  MaxRefClamp.Read();
          if MaxRefClamp <> HlpRetData then
            //value is not set -> take value from drive
            if MaxRefClamp = 0 & sSaveParasVars.bWriteValueAnyway = FALSE then
              MaxRefClamp.Write(input:=HlpRetData);
            else
              sInitSDO.pActDriveData := #FDD3000_ActDriveParas.MaxRefClamp.dData;
              sInitSDO.OldPdoInitSSW := PDOIniSSW;
              //value is different to value on drive -> write class value to drive
              HlpData       := MaxRefClamp;
              PDOIniSSW     := 90;
            end_if;
          else
            //value is the same as value on drive
            MaxRefClamp.Write(input:=HlpRetData);
          end_if;
        
        31:// 01.007 Minimum Reference clamp ------------------------------------------------------------------
          FDD3000_ActDriveParas.MinRefClamp.Write(input:=HlpRetData);
          MinRefClamp :=  MinRefClamp.Read();
          if MinRefClamp <> HlpRetData then
            //value is not set -> take value from drive
            if MinRefClamp = 0 & sSaveParasVars.bWriteValueAnyway = FALSE then
              MinRefClamp.Write(input:=HlpRetData);
            else
              sInitSDO.pActDriveData := #FDD3000_ActDriveParas.MinRefClamp.dData;
              sInitSDO.OldPdoInitSSW := PDOIniSSW;
              //value is different to value on drive -> write class value to drive
              HlpData       := MinRefClamp;
              PDOIniSSW     := 90;
            end_if;
          else
            //value is the same as value on drive
            MinRefClamp.Write(input:=HlpRetData);
          end_if;
        
        32:// 02.011 Acceleration Rate 1 ------------------------------------------------------------------
          FDD3000_ActDriveParas.AccRate.Write(input:=HlpRetData); 
          AccRate :=  AccRate.Read(); 
          if AccRate <> HlpRetData then
            //value is not set -> take value from drive
            if AccRate = 0 & sSaveParasVars.bWriteValueAnyway = FALSE then
              AccRate.Write(input:=HlpRetData);
            else
              sInitSDO.pActDriveData := #FDD3000_ActDriveParas.AccRate.dData;
              sInitSDO.OldPdoInitSSW := PDOIniSSW;
              //value is different to value on drive -> write class value to drive
              HlpData       := AccRate;
              PDOIniSSW     := 90;
            end_if;
          else
            //value is the same as value on drive
            AccRate.Write(input:=HlpRetData);
          end_if;
            
        33:// 02.021 Deceleration Rate 1 ------------------------------------------------------------------ 
          FDD3000_ActDriveParas.DecRate.Write(input:=HlpRetData);
          DecRate :=  DecRate.Read(); 
          if DecRate <> HlpRetData then
            //value is not set -> take value from drive
            if DecRate = 0 & sSaveParasVars.bWriteValueAnyway = FALSE then
              DecRate.Write(input:=HlpRetData);
            else
              sInitSDO.pActDriveData := #FDD3000_ActDriveParas.DecRate.dData;
              sInitSDO.OldPdoInitSSW := PDOIniSSW;
              //value is different to value on drive -> write class value to drive
              HlpData       := DecRate;
              PDOIniSSW     := 90;
            end_if;
          else
            //value is the same as value on drive
            DecRate.Write(input:=HlpRetData);
          end_if;      
           
             
        34:// 05.007 Motor Rated Current ------------------------------------------------------------------ 
          FDD3000_ActDriveParas.MotorRatedCurrent.Write(input:=HlpRetData); 
          MotorRatedCurrent :=  MotorRatedCurrent.Read();
          if MotorRatedCurrent <> HlpRetData then
            //value is not set -> take value from drive
            if MotorRatedCurrent = 0 & sSaveParasVars.bWriteValueAnyway = FALSE then
              MotorRatedCurrent.Write(input:=HlpRetData);
            else
              sInitSDO.pActDriveData := #FDD3000_ActDriveParas.MotorRatedCurrent.dData;
              sInitSDO.OldPdoInitSSW := PDOIniSSW;
              //value is different to value on drive -> write class value to drive
              HlpData       := MotorRatedCurrent;
              PDOIniSSW     := 90;
            end_if;
          else
            //value is the same as value on drive
            MotorRatedCurrent.Write(input:=HlpRetData);
          end_if;
            
        35:// 05.008 Motor Rated Speed ------------------------------------------------------------------ 
          FDD3000_ActDriveParas.MotorRatedSpeed.Write(input:=HlpRetData);
          MotorRatedSpeed :=  MotorRatedSpeed.Read();
          if MotorRatedSpeed <> HlpRetData then
            //value is not set -> take value from drive
            if MotorRatedSpeed = 0 & sSaveParasVars.bWriteValueAnyway = FALSE then
              MotorRatedSpeed.Write(input:=HlpRetData);
            else
              sInitSDO.pActDriveData := #FDD3000_ActDriveParas.MotorRatedSpeed.dData;
              sInitSDO.OldPdoInitSSW := PDOIniSSW;
              //value is different to value on drive -> write class value to drive
              HlpData       := MotorRatedSpeed;
              PDOIniSSW     := 90;
            end_if;
          else
            //value is the same as value on drive
            MotorRatedSpeed.Write(input:=HlpRetData);
          end_if;
          FDD3000_VOVControl1.MaxSpeed := MotorRatedSpeed/10;
          FDD3000_VOVControl1.MinSpeed := -MotorRatedSpeed/10;
            
        36:// 05.009 Motor Rated Voltage ------------------------------------------------------------------  
          FDD3000_ActDriveParas.MotorRatedVoltage.Write(input:=HlpRetData);
          MotorRatedVoltage :=  MotorRatedVoltage.Read();
          if MotorRatedVoltage <> HlpRetData then
            //value is not set -> take value from drive
            if MotorRatedVoltage = 0 & sSaveParasVars.bWriteValueAnyway = FALSE then
              MotorRatedVoltage.Write(input:=HlpRetData);
            else
              sInitSDO.pActDriveData := #FDD3000_ActDriveParas.MotorRatedVoltage.dData;
              sInitSDO.OldPdoInitSSW := PDOIniSSW;
              //value is different to value on drive -> write class value to drive
              HlpData       := MotorRatedVoltage;
              PDOIniSSW     := 90;
            end_if;
          else
            //value is the same as value on drive
            MotorRatedVoltage.Write(input:=HlpRetData);
          end_if;
          
        37:// 05.006 Motor Rated Power Factor ------------------------------------------------------------------ 
              
        38:// 05.006 Motor Rated Frequency ------------------------------------------------------------------ 
          FDD3000_ActDriveParas.MotorRatedFrequency.Write(input:=HlpRetData);
          MotorRatedFrequency :=  MotorRatedFrequency.Read();
          if MotorRatedFrequency <> HlpRetData then
            //value is not set -> take value from drive
            if MotorRatedFrequency = 0 & sSaveParasVars.bWriteValueAnyway = FALSE then
              MotorRatedFrequency.Write(input:=HlpRetData);
            else
              sInitSDO.pActDriveData := #FDD3000_ActDriveParas.MotorRatedFrequency.dData;
              sInitSDO.OldPdoInitSSW := PDOIniSSW;
              //value is different to value on drive -> write class value to drive
              HlpData       := MotorRatedFrequency;
              PDOIniSSW     := 90;
            end_if; 
          else
            //value is the same as value on drive
            MotorRatedFrequency.Write(input:=HlpRetData);
          end_if;
          
        39:// 05.015 Low Frequency Voltage Boost ------------------------------------------------------------------          
          FDD3000_ActDriveParas.LowFrequencyVoltageBoost.Write(input:=HlpRetData);
          LowFrequencyVoltageBoost :=  LowFrequencyVoltageBoost.Read();
          if LowFrequencyVoltageBoost <> HlpRetData then
            //value is not set -> take value from drive
            if LowFrequencyVoltageBoost = 0 & sSaveParasVars.bWriteValueAnyway = FALSE then
              LowFrequencyVoltageBoost.Write(input:=HlpRetData);
            else
              sInitSDO.pActDriveData := #FDD3000_ActDriveParas.LowFrequencyVoltageBoost.dData;
              sInitSDO.OldPdoInitSSW := PDOIniSSW;
              //value is different to value on drive -> write class value to drive
              HlpData       := LowFrequencyVoltageBoost;
              PDOIniSSW     := 90;
            end_if;
          else
            //value is the same as value on drive
            LowFrequencyVoltageBoost.Write(input:=HlpRetData);
          end_if;
          
        40:// Parameter 11.084  Drive Mode (OpenLoop or RFC-A)
          OPModeDrive := HlpRetData$FDD3000_VOVControl::eUserDriveMode;          
              
        // stationary   
        50:// OpenLoop / RFC-A Stator Resistance 05.017
          FDD3000_ActDriveParas.StatorResistance.Write(input:=HlpRetData);
          StatorResistance :=  StatorResistance.Read();  
          if StatorResistance <> HlpRetData then
            //value is not set -> take value from drive
            if StatorResistance = 0 & sSaveParasVars.bWriteValueAnyway = FALSE then
              StatorResistance.Write(input:=HlpRetData);
            else
              sInitSDO.pActDriveData := #FDD3000_ActDriveParas.StatorResistance.dData;
              sInitSDO.OldPdoInitSSW := PDOIniSSW;
              //value is different to value on drive -> write class value to drive
              HlpData       := StatorResistance;
              PDOIniSSW     := 90;
            end_if;
          else
            //value is the same as value on drive
            StatorResistance.Write(input:=HlpRetData);            
          end_if;          
            
        51:// OpenLoop / RFC-A Transient Inductance 05.024
          FDD3000_ActDriveParas.TransientInductance.Write(input:=HlpRetData);
          TransientInductance :=  TransientInductance.Read(); 
          if TransientInductance <> HlpRetData then
            //value is not set -> take value from drive
            if TransientInductance = 0 & sSaveParasVars.bWriteValueAnyway = FALSE then
              TransientInductance.Write(input:=HlpRetData);
            else
              sInitSDO.pActDriveData := #FDD3000_ActDriveParas.TransientInductance.dData;
              sInitSDO.OldPdoInitSSW := PDOIniSSW;
              //value is different to value on drive -> write class value to drive
              HlpData       := TransientInductance;
              PDOIniSSW     := 90;
            end_if;
          else
            //value is the same as value on drive
            TransientInductance.Write(input:=HlpRetData);
          end_if;
                 
        // rotating
        //must be written before motor rated power factor because it is used internal at drive
        52:// OpenLoop / RFC-A Stator Inductance 05.025
          FDD3000_ActDriveParas.StatorInductance.Write(input:=HlpRetData);
          StatorInductance :=  StatorInductance.Read(); 
          if StatorInductance <> HlpRetData then
            //value is not set -> take value from drive
            if StatorInductance = 0 & sSaveParasVars.bWriteValueAnyway = FALSE then
              StatorInductance.Write(input:=HlpRetData);
            else
              sInitSDO.pActDriveData := #FDD3000_ActDriveParas.StatorInductance.dData;
              sInitSDO.OldPdoInitSSW := PDOIniSSW;
              //value is different to value on drive -> write class value to drive
              HlpData       := StatorInductance;
              PDOIniSSW     := 90;
            end_if;
          else
            //value is the same as value on drive
            StatorInductance.Write(input:=HlpRetData);
          end_if;
          
        53:// 05.010 Motor Rated Power Factor ------------------------------------------------------------------ 
          FDD3000_ActDriveParas.MotorRatedPowerFactor.Write(input:=HlpRetData);
          MotorRatedPowerFactor :=  MotorRatedPowerFactor.Read();
          if MotorRatedPowerFactor <> HlpRetData then
            //value is not set -> take value from drive
            if (MotorRatedPowerFactor = 0 & sSaveParasVars.bWriteValueAnyway = FALSE) 
            | StatorInductance <> 0 then
              MotorRatedPowerFactor.Write(input:=HlpRetData);
            else
              sInitSDO.pActDriveData := #FDD3000_ActDriveParas.MotorRatedPowerFactor.dData;
              sInitSDO.OldPdoInitSSW := PDOIniSSW;
              //value is different to value on drive -> write class value to drive
              HlpData       := MotorRatedPowerFactor;
              PDOIniSSW     := 90;
            end_if; 
          else
            //value is the same as value on drive
            MotorRatedPowerFactor.Write(input:=HlpRetData);
          end_if;
                 
        // stationary 
        60://OpenLoop Maximum Deadtime compensation 05.059 Read only
          FDD3000_ActDriveParas.MaximumDeadTimeComp.Write(input:=HlpRetData);
          //value is the same as value on drive
          MaximumDeadTimeComp :=HlpRetData;
          //value showed on HWK paras class
          FDD3000_HWKDriveParas.MaximumDeadTimeComp.Write(input:=HlpRetData);
            
        61://OpenLoop Current At Maximum Deadtime Compensation (05.060) Read only
          FDD3000_ActDriveParas.CurrentAtMaximumDeadTime.Write(input:=HlpRetData); 
          //value is the same as value on drive
          CurrentAtMaximumDeadTime:=HlpRetData;
          //value showed on HWK paras class
          FDD3000_HWKDriveParas.CurrentAtMaximumDeadTime.Write(input:=HlpRetData);
            
        // stationary 
        70://RFC-A Current Loop Gains KP 04.013
          FDD3000_ActDriveParas.CurrentLoopKPGain.Write(input:=HlpRetData);
          CurrentLoopKPGain :=  CurrentLoopKPGain.Read(); 
          if CurrentLoopKPGain <> HlpRetData then
            //value is not set -> take value from drive
            if CurrentLoopKPGain = 0 & sSaveParasVars.bWriteValueAnyway = FALSE then
              CurrentLoopKPGain.Write(input:=HlpRetData);
            else
              sInitSDO.pActDriveData := #FDD3000_ActDriveParas.CurrentLoopKPGain.dData;
              sInitSDO.OldPdoInitSSW := PDOIniSSW;
              //value is different to value on drive -> write class value to drive
              HlpData       := CurrentLoopKPGain;
              PDOIniSSW     := 90;
            end_if;
          else
            //value is the same as value on drive
            CurrentLoopKPGain.Write(input:=HlpRetData);
          end_if;
            
        71://RFC-A Current Loop Gains Ki 04.014
          FDD3000_ActDriveParas.CurrentLoopKiGain.Write(input:=HlpRetData);
          CurrentLoopKiGain :=  CurrentLoopKiGain.Read();
          if CurrentLoopKiGain <> HlpRetData then
            //value is not set -> take value from drive
            if CurrentLoopKiGain = 0 & sSaveParasVars.bWriteValueAnyway = FALSE then
              CurrentLoopKiGain.Write(input:=HlpRetData);
            else
              sInitSDO.pActDriveData := #FDD3000_ActDriveParas.CurrentLoopKiGain.dData;
              sInitSDO.OldPdoInitSSW := PDOIniSSW;
              //value is different to value on drive -> write class value to drive
              HlpData       := CurrentLoopKiGain;
              PDOIniSSW     := 90;
            end_if;
          else
            //value is the same as value on drive
            CurrentLoopKiGain.Write(input:=HlpRetData);
          end_if;
            
        // rotating 
        72://RFC-A motor saturation breakpoints 1 Pr 05.029
          FDD3000_ActDriveParas.SaturationBreakpoint1.Write(input:=HlpRetData);
          SaturationBreakpoint1 :=  SaturationBreakpoint1.Read(); 
          if SaturationBreakpoint1 <> HlpRetData then
            //value is not set -> take value from drive
            if SaturationBreakpoint1 = 0 & sSaveParasVars.bWriteValueAnyway = FALSE then
              SaturationBreakpoint1.Write(input:=HlpRetData);
            else
              sInitSDO.pActDriveData := #FDD3000_ActDriveParas.SaturationBreakpoint1.dData;
              sInitSDO.OldPdoInitSSW := PDOIniSSW;
              //value is different to value on drive -> write class value to drive
              HlpData       := SaturationBreakpoint1;
              PDOIniSSW     := 90;
            end_if;
          else
            //value is the same as value on drive
            SaturationBreakpoint1.Write(input:=HlpRetData);
          end_if;
            
        73://RFC-A motor saturation breakpoints 3 Pr 05.030
          FDD3000_ActDriveParas.SaturationBreakpoint3.Write(input:=HlpRetData);
          SaturationBreakpoint3 :=  SaturationBreakpoint3.Read(); 
          if SaturationBreakpoint3 <> HlpRetData then
            //value is not set -> take value from drive
            if SaturationBreakpoint3 = 0 & sSaveParasVars.bWriteValueAnyway = FALSE then
              SaturationBreakpoint3.Write(input:=HlpRetData);
            else
              sInitSDO.pActDriveData := #FDD3000_ActDriveParas.SaturationBreakpoint3.dData;
              sInitSDO.OldPdoInitSSW := PDOIniSSW;
              //value is different to value on drive -> write class value to drive
              HlpData       := SaturationBreakpoint3;
              PDOIniSSW     := 90;
            end_if;
          else
            //value is the same as value on drive
            SaturationBreakpoint3.Write(input:=HlpRetData);
          end_if;
            
        74://RFC-A motor saturation breakpoints 2 Pr 05.062
          FDD3000_ActDriveParas.SaturationBreakpoint2.Write(input:=HlpRetData);
          SaturationBreakpoint2 :=  SaturationBreakpoint2.Read(); 
          if SaturationBreakpoint2 <> HlpRetData then
            //value is not set -> take value from drive
            if SaturationBreakpoint2 = 0 & sSaveParasVars.bWriteValueAnyway = FALSE then
              SaturationBreakpoint2.Write(input:=HlpRetData);
            else
              sInitSDO.pActDriveData := #FDD3000_ActDriveParas.SaturationBreakpoint2.dData;
              sInitSDO.OldPdoInitSSW := PDOIniSSW;
              //value is different to value on drive -> write class value to drive
              HlpData       := SaturationBreakpoint2;
              PDOIniSSW     := 90;
            end_if;
          else
            //value is the same as value on drive
            SaturationBreakpoint2.Write(input:=HlpRetData);
          end_if;
            
        75://RFC-A motor saturation breakpoints 4 Pr 05.063
          FDD3000_ActDriveParas.SaturationBreakpoint4.Write(input:=HlpRetData);
          SaturationBreakpoint4 :=  SaturationBreakpoint4.Read(); 
          if SaturationBreakpoint4 <> HlpRetData then
            //value is not set -> take value from drive
            if SaturationBreakpoint4 = 0 & sSaveParasVars.bWriteValueAnyway = FALSE then
              SaturationBreakpoint4.Write(input:=HlpRetData);
            else
              sInitSDO.pActDriveData := #FDD3000_ActDriveParas.SaturationBreakpoint4.dData;
              sInitSDO.OldPdoInitSSW := PDOIniSSW;
              //value is different to value on drive -> write class value to drive
              HlpData       := SaturationBreakpoint4;
              PDOIniSSW     := 90;
            end_if;
          else
            //value is the same as value on drive
            SaturationBreakpoint4.Write(input:=HlpRetData);
          end_if;
          
          
        //**************************************************************************************  
        90://write access was ok - go to next parameter
          PDOIniSSW := sInitSDO.OldPdoInitSSW;
          //set data on ActDriveParas
          sInitSDO.pActDriveData^ := sInitSDO.SDOData.dData;
          
      end_case;
      
      //step to write changed data
      if PDOIniSSW <> 90 | sSaveParasVars.bWriteDiffParas = FALSE then
        if PDOIniSSW = 90 then
          PDOIniSSW := sInitSDO.OldPdoInitSSW;
        end_if;
        PDOIniSSW += 1;
      else
        //store data for write access
        sInitSDO.SDOData.bRW        := TRUE;
        sInitSDO.SDOData.usLen      := HlpLen;
        sInitSDO.SDOData.hiIndex    := HlpIndex$HINT;
        sInitSDO.SDOData.usSubIndex := HlpSubIndex$USINT;
        sInitSDO.SDOData.dData      := HlpData;
      end_if;
  
    else// Send user Parameter 
      dSDOTabCounter -= 1;
      if (dSDOTabCounter <= 0) then // this is the end of the table
        PDOIniSSW += 1;             // table data have been sent so go on with node guarding and heartbeat
      else                          // still at least 1 line in the table to send
        pSDOTable := pSDOTable + 8; // move pointer to next line of table
      end_if;
    end_if;
  end_if;
  
  //****************************************************************************************************
  // END ASYNC DATA HANDLING
  //****************************************************************************************************    
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::CanControl
  
  if DeviceState = _CanOpenMng::_CAN_NODE_WRONG_HW then
    Online := 0; // should be 0 already, set to be sure
    return;
  end_if;

  _CanOpenBasicDS402::CanControl();
  
  if DeviceState = _CanOpenMng::_CAN_OPERATIONAL then
    Online := 1;
  else
    if PDOIniSSW <> 100 then      
      // Reset drive error at init 
      bdLogDataFlags.bNewDriveError := FALSE;
      ErrorOccured := 0;
    end_if;

    //device state has changed
    if Online = 1 then
      if DeviceState = _CanOpenMng::_CAN_HBERROR then
        bdLogDataFlags.bNewHBError := TRUE;
      elsif DeviceState = _CanOpenMng::_CAN_COMERROR then
        bdLogDataFlags.bNewComError := TRUE;
      end_if;
    end_if;
    Online := 0;    
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::CanControlCy
  VAR
  	dTmpRetCode : iprStates;
  END_VAR

  case FDD3000_VOVControl1.ActCyclicStep of
    //*******************************************************
  	FDD3000_VOVControl::_SDOCyclic:
      dTmpRetCode := READY;
      if Online = 1 then  
        dTmpRetCode := SDOCyclicWork();
        if dTmpRetCode <> BUSY then
          dTmpRetCode := READY;
        end_if;        
      end_if;
      
      if dTmpRetCode = READY then
        //start configure of node over Layer Setting Service
        if FDD3000_VOVControl1.StartLSS = 1 then
          FDD3000_VOVControl1.ActCyclicStep := FDD3000_VOVControl::_NodeSettings;
        //start static or dynamic autotune  
        elsif FDD3000_VOVControl1.StartAutotune = 1
         | FDD3000_VOVControl1.StartAutotune = 2 then
          FDD3000_VOVControl1.ActCyclicStep := FDD3000_VOVControl::_AutoTune;
        //start change of operation mode of drive (openloop/ RFC-A)  
        elsif FDD3000_VOVControl1.StartAutotune = 10 then 
          FDD3000_VOVControl1.ActCyclicStep := FDD3000_VOVControl::_AutoTune;          
        // check if para data must be saved  
        elsif FDD3000_VOVControl1.SetUserMotorParas = 11 then
          FDD3000_VOVControl1.ActCyclicStep := FDD3000_VOVControl::_SaveMotorParas;
        //load/store data from/in file  
        elsif FDD3000_VOVControl1.SetUserMotorParas = 21 
        | FDD3000_VOVControl1.SetUserMotorParas = 22 then
          FDD3000_VOVControl1.ActCyclicStep := FDD3000_VOVControl::_FileHandling;
        end_if;
      end_if;
    
    //*******************************************************
  	FDD3000_VOVControl::_NodeSettings:
      dTmpRetCode := LSSNodeSetting();
      if dTmpRetCode = READY then
        FDD3000_VOVControl1.ActCyclicStep := FDD3000_VOVControl::_SDOCyclic;
        FDD3000_VOVControl1.StartLSS      := 0;
      elsif dTmpRetCode <> BUSY then
        FDD3000_VOVControl1.ActCyclicStep := FDD3000_VOVControl::_SDOCyclic;
        FDD3000_VOVControl1.StartLSS      := -1;
        MasterDevice.LogError("@0701 (FDD3000_CanOpenInt::CanControlCy) Configure Node over LSS failed!");
      end_if;    
    
    //*******************************************************
  	FDD3000_VOVControl::_AutoTune:
      dTmpRetCode := AutoTuneHandling();
      if dTmpRetCode = READY then
        FDD3000_VOVControl1.ActCyclicStep := FDD3000_VOVControl::_SDOCyclic;
        FDD3000_VOVControl1.StartAutotune := 0;
      elsif dTmpRetCode <> BUSY then
        FDD3000_VOVControl1.ActCyclicStep := FDD3000_VOVControl::_SDOCyclic;
        if FDD3000_VOVControl1.StartAutotune = 10 then
          //change Openloop / RFC-A mode failed
          FDD3000_VOVControl1.StartAutotune := -2;
          MasterDevice.LogError("@0702 (FDD3000_CanOpenInt::CanControlCy) Switch of Operation Mode of Drive failed!");
        else
          //Autotune failed
          FDD3000_VOVControl1.StartAutotune := -1;
          MasterDevice.LogError("@0703 (FDD3000_CanOpenInt::CanControlCy) Autotune of motor failed!");
        end_if;       
      end_if;
    
    //*******************************************************
  	FDD3000_VOVControl::_SaveMotorParas:
      //set motor paras on hwk and drive handling
      dTmpRetCode := SaveParasOnDrive();
      if dTmpRetCode = READY then
        FDD3000_VOVControl1.ActCyclicStep     := FDD3000_VOVControl::_SDOCyclic;
        FDD3000_VOVControl1.SetUserMotorParas := 0;
      elsif dTmpRetCode <> BUSY then
        //error at set motor paras at drive and hwk
        FDD3000_VOVControl1.ActCyclicStep     := FDD3000_VOVControl::_SDOCyclic;
        FDD3000_VOVControl1.SetUserMotorParas := -1;
        MasterDevice.LogError("@0704 (FDD3000_CanOpenInt::CanControlCy) Set Source Data on HWK failed!");
      end_if;
      
    //*******************************************************
  	FDD3000_VOVControl::_FileHandling:
      dTmpRetCode := XMLFileHandling();
      if dTmpRetCode = READY then
        FDD3000_VOVControl1.ActCyclicStep     := FDD3000_VOVControl::_SDOCyclic;
        FDD3000_VOVControl1.SetUserMotorParas := 0;
      elsif dTmpRetCode <> BUSY then
        //error at load data from file
        if FDD3000_VOVControl1.SetUserMotorParas = 21 then
          FDD3000_VOVControl1.SetUserMotorParas := -2;
          MasterDevice.LogError("@0705 (FDD3000_CanOpenInt::CanControlCy) Failed to load data from file!");
        //error at store data in file
        elsif FDD3000_VOVControl1.SetUserMotorParas = 22 then
          FDD3000_VOVControl1.SetUserMotorParas := -3;
          MasterDevice.LogError("@0706 (FDD3000_CanOpenInt::CanControlCy) Failed to store data in file!");
        end_if;
        FDD3000_VOVControl1.ActCyclicStep     := FDD3000_VOVControl::_SDOCyclic;
      end_if;
      
  end_case;
  
  //check for new Alarmlist data
  if bdLogDataFlags.bNewEmcyMsg then
    if EmcyStatusByte0_3 then
      sLogFile.Logmode := 1;
      AlarmListLogger(Command:=FDD3000AxisVis::_Emcy_Msg, TripCode:=((EmcyStatusByte0_3 shr 24) and 0xFF)$FDD3000AxisVis::_LogData_TripCode);
    end_if;
    bdLogDataFlags.bNewEmcyMsg := FALSE;
  end_if;
  if bdLogDataFlags.bNewDriveError then
    sLogFile.Logmode := 1;
    AlarmListLogger(Command:=FDD3000AxisVis::_Drive_Error, TripCode:=(DriveErrorStatus and 0xFF)$FDD3000AxisVis::_LogData_TripCode);  
    bdLogDataFlags.bNewDriveError := FALSE;  
  end_if;
  if bdLogDataFlags.bNewHBError then
    sLogFile.Logmode := 1;
    AlarmListLogger(Command:=FDD3000AxisVis::_HB_Error, TripCode:=0$FDD3000AxisVis::_LogData_TripCode);  
    bdLogDataFlags.bNewHBError := FALSE;  
  end_if;
  if bdLogDataFlags.bNewComError then
    sLogFile.Logmode := 1;
    AlarmListLogger(Command:=FDD3000AxisVis::_Comm_Error, TripCode:=0$FDD3000AxisVis::_LogData_TripCode);  
    bdLogDataFlags.bNewComError := FALSE;  
  end_if;
  //check for new sdo error
  if ErrorSDO & ErrorSDO <> oldErrorSDO then    
    sLogFile.Logmode := 1;
    AlarmListLogger(Command:=FDD3000AxisVis::_SDO_Error, TripCode:=ComSDO.hdErrorRetCode$FDD3000AxisVis::_LogData_TripCode);  
    oldErrorSDO := ErrorSDO;  
  end_if;
    
END_FUNCTION


FUNCTION FDD3000_CanOpenInt::LSSNodeSetting
	VAR_OUTPUT
		dRetCode 	: iprStates;
	END_VAR
  VAR
    dTmpRetCode : iprStates;
    RetCode     : DINT;
  END_VAR;
  
  dRetCode := BUSY;

  case sLSSNodeSetting.SSWNodeSetting of
    //*********************************************************
    FDD3000_VOVControl::_IdleLSS:
      sLSSNodeSetting.usNodeId   := Place$USINT;
      sLSSNodeSetting.usBaudrate := MasterDevice.IFGetActBaudrate();
      sLSSNodeSetting.SSWNodeSettingErrorStep := FDD3000_VOVControl::_IdleLSS;
      sLSSNodeSetting.SSWNodeSetting          := FDD3000_VOVControl::_DeactivateMng;
    
    //*********************************************************
    FDD3000_VOVControl::_DeactivateMng:
      MasterDevice.StopStartMng(bStopStart:=TRUE);
      sLSSNodeSetting.SSWNodeSetting := FDD3000_VOVControl::_SetLSSInfos;
    
    //*********************************************************
    FDD3000_VOVControl::_SetLSSInfos:
      dTmpRetCode := _CanOpenLSSControl1.LSSNodeConfig(sLSSNodeSetting.usNodeId, sLSSNodeSetting.usBaudrate);
      if dTmpRetCode = READY then
        sLSSNodeSetting.SSWNodeSetting := FDD3000_VOVControl::_Wait4SetLSSInfos;
        
      elsif dTmpRetCode <> BUSY then
        //error occurred
        sLSSNodeSetting.SSWNodeSettingErrorStep := sLSSNodeSetting.SSWNodeSetting;
        sLSSNodeSetting.SSWNodeSetting := FDD3000_VOVControl::_ErrorLSS;      
      end_if;    
    
    //*********************************************************
    FDD3000_VOVControl::_Wait4SetLSSInfos:    
      //reset async state if it has one
      if AsyncState = ERROR then
        AsyncState := READY;
      end_if; 
      sLSSNodeSetting.SSWNodeSetting := FDD3000_VOVControl::_WriteSDOCiA;    
    
    //*********************************************************
    FDD3000_VOVControl::_WriteSDOCiA:
      // 01.01.020  CiA402 profiles Enable
      dTmpRetCode := SDOInternal(hiIndex:=FDD3000_SI_MENU_01
                                , usSubIndex:=FDD3000_101_PARA_CIAPROFILE_ENABLE
                                , usLength:=1
                                , bRW:=TRUE
                                , dDataWr:=1
                                , pRetData:= #sLSSNodeSetting.hdSDORetCode$DINT);
                                
      if dTmpRetCode = READY then
        sLSSNodeSetting.udStartTime    := ops.tAbsolute;
        sLSSNodeSetting.SSWNodeSetting := FDD3000_VOVControl::_StoreNodeConfig;
        
      elsif dTmpRetCode <> BUSY then
        //error occurred
        sLSSNodeSetting.SSWNodeSettingErrorStep := sLSSNodeSetting.SSWNodeSetting;
        sLSSNodeSetting.SSWNodeSetting := FDD3000_VOVControl::_ErrorLSS;      
      end_if;
    
    //*********************************************************
    FDD3000_VOVControl::_StoreNodeConfig:
      // Store Parameters on drive
      dTmpRetCode := SDOInternal( hiIndex:=FDD3000_CANOPEN_STOREPARAS_INDEX
                                , usSubIndex:=FDD3000_CANOPEN_STOREPARAS_SUBINDEX
                                , usLength:=4
                                , bRW:=TRUE
                                , dDataWr:=FDD3000_CANOPEN_STOREPARASMAGICNRB
                                , pRetData:= #sLSSNodeSetting.hdSDORetCode$DINT);
                                
      if dTmpRetCode = READY then
        sLSSNodeSetting.udStartTime    := ops.tAbsolute;
        sLSSNodeSetting.SSWNodeSetting := FDD3000_VOVControl::_Wait4StoreNodeConfig;
        
      elsif dTmpRetCode <> BUSY then
        //error occurred
        sLSSNodeSetting.SSWNodeSettingErrorStep := sLSSNodeSetting.SSWNodeSetting;
        sLSSNodeSetting.SSWNodeSetting := FDD3000_VOVControl::_ErrorLSS;      
      end_if;
      
    //*********************************************************
    FDD3000_VOVControl::_Wait4StoreNodeConfig:
      if (ops.tAbsolute-sLSSNodeSetting.udStartTime) >= FDD3000_CANOPEN_WAIT4STORENODECONFIG then
        sLSSNodeSetting.SSWNodeSetting := FDD3000_VOVControl::_ResetNode;
      end_if;

    //*********************************************************
    FDD3000_VOVControl::_ResetNode:
      RetCode := MasterDevice.SetNmt(Para:=CO_RESETNODE, ID:=sLSSNodeSetting.usNodeId);
      if RetCode = 0 then
        bQuitErrorNewNMT := FALSE;
        sLSSNodeSetting.udStartTime    := ops.tAbsolute;
        sLSSNodeSetting.SSWNodeSetting := FDD3000_VOVControl::_Wait4ResetNode;
      else  
        sLSSNodeSetting.SSWNodeSettingErrorStep := sLSSNodeSetting.SSWNodeSetting;
        sLSSNodeSetting.SSWNodeSetting := FDD3000_VOVControl::_ErrorLSS;
      end_if;    
    
    //*********************************************************
    FDD3000_VOVControl::_Wait4ResetNode:
      if (ops.tAbsolute-sLSSNodeSetting.udStartTime) >= FDD3000_CANOPEN_WAIT4RESTARTNODE then
        sLSSNodeSetting.udStartTime    := ops.tAbsolute;
        sLSSNodeSetting.SSWNodeSetting := FDD3000_VOVControl::_ActivateMng;      
      end_if;

    //*********************************************************
    FDD3000_VOVControl::_ActivateMng:
      MasterDevice.StopStartMng(bStopStart:=FALSE);
      sLSSNodeSetting.SSWNodeSetting := FDD3000_VOVControl::_QuitErrorNode;
      
    //*********************************************************
    FDD3000_VOVControl::_QuitErrorNode:
      if bQuitErrorNewNMT = TRUE then
        ErrorQuit.Write(input:=0);
        sLSSNodeSetting.SSWNodeSetting := FDD3000_VOVControl::_FinishedLSS;
      elsif DeviceState = _CanOpenMng::_CAN_OPERATIONAL then
        sLSSNodeSetting.SSWNodeSetting := FDD3000_VOVControl::_FinishedLSS;        
      end_if;    
        
    //*********************************************************
    FDD3000_VOVControl::_FinishedLSS:
      sLSSNodeSetting.SSWNodeSetting := FDD3000_VOVControl::_IdleLSS;      
      dRetCode := READY;    
    
    //*********************************************************
    FDD3000_VOVControl::_ErrorLSS: 
      sLSSNodeSetting.SSWNodeSetting := FDD3000_VOVControl::_IdleLSS;
      //unlock manager if an error occurred
      MasterDevice.StopStartMng(bStopStart:=FALSE);
      dRetCode := ERROR;
      
  end_case;

  FDD3000_VOVControl1.ActLSSStep       := sLSSNodeSetting.SSWNodeSetting;
  FDD3000_VOVControl1.ActSearchBitrate := _CanOpenLSSControl1.ActSearchBitrate;
  
END_FUNCTION


FUNCTION FDD3000_CanOpenInt::AutoTuneHandling
	VAR_OUTPUT
		dRetCode 	: iprStates;
	END_VAR
  VAR
    dTmpRetCode : iprStates;
    RetCode     : DINT;
    pTempServerOut : ^DINT;
    pTempServerIn  : ^DINT;
    ustmpCnt       : USINT;
  END_VAR;
  
  dRetCode := BUSY;
  
  case sAutoTuneVars.SSWAutoTune of
    
    //*********************************************************
  	eAutoTuneSSW::_IdleAutoTune:
      //disable drive if enabled
      if Enable then
        Enable.Write(input:=0);
      end_if;
      
      //start stationary or rotating autotune
      if FDD3000_VOVControl1.StartAutotune = 1 
      | FDD3000_VOVControl1.StartAutotune = 2 then
        //reset stator inductance if stationary mode is selected
        if FDD3000_VOVControl1.StartAutotune = 1 then
          StatorInductance.Write(input:=0);
        end_if;
        //reset SetUserMotorParas input
        FDD3000_VOVControl1.SetUserMotorParas := 0;
        sAutoTuneVars.SSWAutoTune             := _StoreOldParas;
      //start switch Operation Mode of Drive  
      elsif FDD3000_VOVControl1.StartAutotune = 10 then
        FDD3000_VOVControl1.SetDriveMode := _ModeUnknown;
        sAutoTuneVars.SSWAutoTune        := _ReadActDriveMode; 
      end_if;

    //*********************************************************
    //Start switch of Operation Mode (Openloop / RFC-A)
    //*********************************************************
  	eAutoTuneSSW::_ReadActDriveMode:
      // 11.084  User Drive Mode                          
      dTmpRetCode := SDOInternal(hiIndex:=FDD3000_MENU_11_MISCELLANEOUS
                                , usSubIndex:=FDD3000_11_PARA_DRIVE_OP_MODE
                                , usLength:=1
                                , bRW:=FALSE
                                , dDataWr:=0
                                , pRetData:= #sAutoTuneVars.hdSDORetCode$DINT);
                                
      if dTmpRetCode = READY then
        OPModeDrive := sAutoTuneVars.hdSDORetCode$FDD3000_VOVControl::eUserDriveMode;
        sAutoTuneVars.udStartTime := ops.tAbsolute;
        sAutoTuneVars.SSWAutoTune := _Wait4InputDriveMode;
        
      elsif dTmpRetCode <> BUSY then
        //error occurred
        sAutoTuneVars.SSWAutoTuneErrorStep := sAutoTuneVars.SSWAutoTune;
        sAutoTuneVars.SSWAutoTune := _ErrorAutoTune;      
      end_if;
    
    //*********************************************************
  	eAutoTuneSSW::_Wait4InputDriveMode:
      if FDD3000_VOVControl1.SetDriveMode <> _ModeUnknown then
        if FDD3000_VOVControl1.SetDriveMode <> OPModeDrive then
          sAutoTuneVars.SSWAutoTune := _SetDriveMode;
        else
          //if drive mode is not changed go to next step (OpenLoop - RFC-A)
          sAutoTuneVars.SSWAutoTune := _FinishedAutoTune;
        end_if;
      //check for stop autotune command  
      elsif FDD3000_VOVControl1.SetUserMotorParas = -1 then
        //stop autotune test
        sAutoTuneVars.udStartTime := ops.tAbsolute;
        sAutoTuneVars.SSWAutoTune := _QuitErrorStopped; 
      end_if;
      
    //*********************************************************
  	eAutoTuneSSW::_SetDriveMode:
      // 11.031  User Drive Mode                          
      dTmpRetCode := SDOInternal(hiIndex:=FDD3000_MENU_11_MISCELLANEOUS
                                , usSubIndex:=FDD3000_11_PARA_SETDRIVE_OP_MODE
                                , usLength:=1
                                , bRW:=TRUE
                                , dDataWr:=FDD3000_VOVControl1.SetDriveMode$DINT
                                , pRetData:= #sAutoTuneVars.hdSDORetCode$DINT);
                                
      if dTmpRetCode = READY then
        sAutoTuneVars.udStartTime := ops.tAbsolute;
        sAutoTuneVars.SSWAutoTune := _StoreAndResetDrive;
        
      elsif dTmpRetCode <> BUSY then
        //error occurred
        sAutoTuneVars.SSWAutoTuneErrorStep := sAutoTuneVars.SSWAutoTune;
        sAutoTuneVars.SSWAutoTune := _ErrorAutoTune;      
      end_if;
      
    //*********************************************************
  	eAutoTuneSSW::_StoreAndResetDrive:
      if (ops.tAbsolute-sAutoTuneVars.udStartTime) >= FDD3000_CANOPEN_WAIT4STORENODECONFIG then
        // 10.038 Reset Drive                          
        dTmpRetCode := SDOInternal(hiIndex:=FDD3000_MENU_10_STATUS_TRIPS
                                  , usSubIndex:=FDD3000_10_PARA_RESET_DRIVE
                                  , usLength:=1
                                  , bRW:=TRUE
                                  , dDataWr:=FDD3000_10_PARA_RESET_DRIVE_DATA
                                  , pRetData:= #sAutoTuneVars.hdSDORetCode$DINT);
                                  
        if dTmpRetCode = READY then
          sAutoTuneVars.udStartTime := ops.tAbsolute;
          sAutoTuneVars.SSWAutoTune := _NMTResetDrive;
          
        elsif dTmpRetCode <> BUSY then
          //error occurred
          sAutoTuneVars.SSWAutoTuneErrorStep := sAutoTuneVars.SSWAutoTune;
          sAutoTuneVars.SSWAutoTune := _ErrorAutoTune;      
        end_if;      
      end_if;
      
    //*********************************************************
  	eAutoTuneSSW::_NMTResetDrive:
      RetCode := MasterDevice.SetNmt(Para:=CO_RESETNODE, ID:=Place);
      if RetCode = 0 then
        sSaveParasVars.bWriteDiffParas   := FALSE;
        sSaveParasVars.bWriteValueAnyway := FALSE;
        bQuitErrorNewNMT          := FALSE;
        sAutoTuneVars.udStartTime := ops.tAbsolute;
        sAutoTuneVars.SSWAutoTune := _Wait4NMTResetDrive;
      else  
        //error occurred
        sAutoTuneVars.SSWAutoTuneErrorStep := sAutoTuneVars.SSWAutoTune;
        sAutoTuneVars.SSWAutoTune := _ErrorAutoTune; 
      end_if;      
      
    //*********************************************************
  	eAutoTuneSSW::_Wait4NMTResetDrive:
      //got to next step after timeout or when node is operational again
      if (ops.tAbsolute-sAutoTuneVars.udStartTime) >= FDD3000_CANOPEN_WAIT4DRIVERESTART then
        sAutoTuneVars.udStartTime := ops.tAbsolute;
        sAutoTuneVars.SSWAutoTune := _Wait4ResetDrive;
      //check for new drive state  
      elsif (ops.tAbsolute-sAutoTuneVars.udStartTime) >= FDD3000_CANOPEN_DRIVERESTART_CHECKOP then
        if DeviceState = _CanOpenMng::_CAN_OPERATIONAL  then
          sAutoTuneVars.SSWAutoTune := _Wait4ResetDrive;
        elsif DeviceState = _CanOpenMng::_CAN_PRE_OPERATIONAL
        & (ops.tAbsolute-sAutoTuneVars.udStartTime) >= FDD3000_CANOPEN_DRIVERESTART_CHECKPREOP then
          //drive stuck at preop - restart it
          if ErrorQuit <> 5 then
            ErrorQuit.Write(input:=5);          
          end_if;
        end_if;
      end_if;
      
    //*********************************************************
  	eAutoTuneSSW::_Wait4ResetDrive:
      if DeviceState = _CanOpenMng::_CAN_OPERATIONAL  then
        //finished change of drive mode (OpenLoop - RFC-A)
        ErrorQuit := 0;
        sAutoTuneVars.SSWAutoTune := _FinishedAutoTune;
      elsif bQuitErrorNewNMT = TRUE then
        ErrorQuit.Write(input:=0);        
      elsif (ops.tAbsolute-sAutoTuneVars.udStartTime) >= FDD3000_CANOPEN_TIMEOUTDRIVERESTART then
        //timeout of drive
        //error occurred
        sAutoTuneVars.SSWAutoTuneErrorStep := sAutoTuneVars.SSWAutoTune;
        sAutoTuneVars.SSWAutoTune := _ErrorAutoTune; 
      end_if;
    //*********************************************************
    //End switch of Operation Mode (Openloop / RFC-A)
    //*********************************************************
    
    //*********************************************************
    //Start Autotune (stationary / rotating) 
    //*********************************************************
  	eAutoTuneSSW::_StoreOldParas:
      if Online = 1 then
        pTempServerIn  := #FDD3000_ActDriveParas.MaxRefClamp.dData;
        pTempServerOut := #FDD3000_OldDriveParas.MaxRefClamp.dData;
        for usTmpCnt := 0 to FDD3000_PARAMETERSFILERAM_AMOUNT_SERVERS-1 do
          pTempServerOut^ := pTempServerIn^;
          pTempServerIn  += sizeof(SvrCh);
          pTempServerOut += sizeof(SvrCh);
        end_for;
        sAutoTuneVars.SSWAutoTune := _GetUserMotorParas;
      elsif (ops.tAbsolute-sAutoTuneVars.udStartTime) >= FDD3000_CANOPEN_TIMEOUTDRIVERESTART then
        //timeout of drive
        //error occurred
        sAutoTuneVars.SSWAutoTuneErrorStep := sAutoTuneVars.SSWAutoTune;
        sAutoTuneVars.SSWAutoTune := _ErrorAutoTune; 
      end_if;

    //*********************************************************
  	eAutoTuneSSW::_GetUserMotorParas:
      if FDD3000_VOVControl1.SetUserMotorParas > 0 then
        //get act values 
        MaxRefClamp.Write(input:=MaxRefClamp);
        MinRefClamp.Write(input:=MinRefClamp);
        AccRate.Write(input:=AccRate);
        DecRate.Write(input:=DecRate);
        MotorRatedCurrent.Write(input:=MotorRatedCurrent);
        MotorRatedSpeed.Write(input:=MotorRatedSpeed);
        MotorRatedVoltage.Write(input:=MotorRatedVoltage);
        MotorRatedPowerFactor.Write(input:=MotorRatedPowerFactor);
        MotorRatedFrequency.Write(input:=MotorRatedFrequency);
        LowFrequencyVoltageBoost.Write(input:=LowFrequencyVoltageBoost);
        
        sAutoTuneVars.udStartTime := ops.tAbsolute;
        sAutoTuneVars.SSWAutoTune := _SetUserMotorParas;
      //check for stop autotune command  
      elsif FDD3000_VOVControl1.SetUserMotorParas = -1 then
        //stop autotune test
        sAutoTuneVars.udStartTime := ops.tAbsolute;
        sAutoTuneVars.SSWAutoTune := _QuitErrorStopped;        
      end_if;
      
    //*********************************************************
  	eAutoTuneSSW::_SetUserMotorParas:
      dTmpRetCode := SDOCyclicWork();
      if dTmpRetCode = READY then
        //next step if all data is written to drive
        if sCyclicSDORW.usActiveSDOsInBuffer = 0 then
          sAutoTuneVars.udStartTime := ops.tAbsolute;
          sAutoTuneVars.SSWAutoTune := _GetSTOState;
        end_if;  
      elsif dTmpRetCode <> BUSY then
        //timeout of drive
        //error occurred
        sAutoTuneVars.SSWAutoTuneErrorStep := sAutoTuneVars.SSWAutoTune;
        sAutoTuneVars.SSWAutoTune := _ErrorAutoTune; 
      end_if;
      
    //*********************************************************
  	eAutoTuneSSW::_GetSTOState:      
      if STOInput then
        //sto enabled = ready 4 next step
        sAutoTuneVars.SSWAutoTune := _SetAutoTuneDrive;
      else
        sAutoTuneVars.SSWAutoTune := _InfoSTOEnable;        
      end_if;      
    
    //*********************************************************
  	eAutoTuneSSW::_InfoSTOEnable:
      //wait 4 STO enable
      if STOInput then
        //sto enabled = ready 4 next step
        sAutoTuneVars.SSWAutoTune := _SetAutoTuneDrive;
//      else
//        sAutoTuneVars.SSWAutoTune := _InfoSTOEnable; 
      //check for stop autotune command   
      elsif FDD3000_VOVControl1.SetUserMotorParas = -1 then
        //stop autotune test
        sAutoTuneVars.udStartTime := ops.tAbsolute;
        sAutoTuneVars.SSWAutoTune := _QuitErrorStopped; 
      end_if;
    
    //*********************************************************
  	eAutoTuneSSW::_SetAutoTuneDrive:
      //check for abort of auto tune
      if FDD3000_VOVControl1.SetUserMotorParas <> -1 then
        // 05.012  Autotune
        dTmpRetCode := SDOInternal(hiIndex:=FDD3000_MENU_05_MOTOR_CONTROL
                                  , usSubIndex:=FDD3000_05_PARA_AUTOTUNE
                                  , usLength:=1
                                  , bRW:=TRUE
                                  , dDataWr:=FDD3000_VOVControl1.StartAutotune
                                  , pRetData:= #sAutoTuneVars.hdSDORetCode$DINT);
                                  
        if dTmpRetCode = READY then
          sAutoTuneVars.udStartTime := ops.tAbsolute;
          sAutoTuneVars.SSWAutoTune := _WarningAutoTuneStart;
          
        elsif dTmpRetCode <> BUSY then
          //error occurred
          sAutoTuneVars.SSWAutoTuneErrorStep := sAutoTuneVars.SSWAutoTune;
          sAutoTuneVars.SSWAutoTune := _ErrorAutoTune;      
        end_if;
      else
        //stop autotune test
        sAutoTuneVars.udStartTime := ops.tAbsolute;
        sAutoTuneVars.SSWAutoTune := _QuitErrorStopped;     
      end_if;
    
    //*********************************************************
  	eAutoTuneSSW::_WarningAutoTuneStart:
      if (ops.tAbsolute-sAutoTuneVars.udStartTime) >= FDD3000_CANOPEN_DISPLAY_AUTOTUNESTART then
        sAutoTuneVars.SSWAutoTune := _EnableAutoTune;
      //check for stop autotune command  
      elsif FDD3000_VOVControl1.SetUserMotorParas = -1 then
        //stop autotune test
        sAutoTuneVars.udStartTime := ops.tAbsolute;
        sAutoTuneVars.SSWAutoTune := _DisableAutoTune; 
      end_if;
    
    //*********************************************************
  	eAutoTuneSSW::_EnableAutoTune:
      //start autotune
      Enable.Write(input:=1);
      sAutoTuneVars.SSWAutoTune := _Wait4AutoTuneFinished;      
    
    //*********************************************************
  	eAutoTuneSSW::_Wait4AutoTuneFinished:
      // 05.012  Autotune
      dTmpRetCode := SDOInternal(hiIndex:=FDD3000_MENU_05_MOTOR_CONTROL
                                , usSubIndex:=FDD3000_05_PARA_AUTOTUNE
                                , usLength:=1
                                , bRW:=FALSE
                                , dDataWr:=0
                                , pRetData:= #sAutoTuneVars.hdSDORetCode$DINT);
                                
      if dTmpRetCode = READY then
        if sAutoTuneVars.hdSDORetCode = 0 then
          sAutoTuneVars.udStartTime := ops.tAbsolute;
          //read act drive values
          PDOIniSSW                 := 20;
          //don't write different paras
          sSaveParasVars.bWriteDiffParas := FALSE;
          sAutoTuneVars.SSWAutoTune      := _GetAutoTuneParas;        
//        else
//          sAutoTuneVars.SSWAutoTune := _Wait4AutoTuneFinished;        
        end_if;      
      //check for stop autotune command    
      elsif FDD3000_VOVControl1.SetUserMotorParas = -1 then
        //stop autotune test
        sAutoTuneVars.udStartTime := ops.tAbsolute;
        sAutoTuneVars.SSWAutoTune := _DisableAutoTune;
      elsif dTmpRetCode <> BUSY then
        //error occurred
        sAutoTuneVars.SSWAutoTuneErrorStep := sAutoTuneVars.SSWAutoTune;
        sAutoTuneVars.SSWAutoTune          := _ErrorAutoTune;
      //check for timeout of autotune test  
      elsif  (ops.tAbsolute-sAutoTuneVars.udStartTime) >= FDD3000_CANOPEN_TIMEOUT_AUTOTUNE then
        //stop autotune test
        sAutoTuneVars.SSWAutoTuneErrorStep := sAutoTuneVars.SSWAutoTune;
        sAutoTuneVars.udStartTime          := ops.tAbsolute;
        sAutoTuneVars.SSWAutoTune          := _DisableAutoTune; 
      end_if;      
    
    //*********************************************************
  	eAutoTuneSSW::_GetAutoTuneParas:
      RetCode := UserSettings();
      //read of drive paras is finished
      if RetCode = 1 then
        //if rotating autotune was selected the motor rated power factor is calculated from drive
        sAutoTuneVars.SSWAutoTune := _InfoSTODisable;
      end_if;
    
    //*********************************************************
  	eAutoTuneSSW::_InfoSTODisable:
      //wait 4 STO enable
      if STOInput = 0 then
        //sto disabled = ready 4 next step
        sAutoTuneVars.SSWAutoTune := _FinishedAutoTune;
      //check for stop autotune command    
      elsif FDD3000_VOVControl1.SetUserMotorParas = -1 then
        //stop autotune test
        sAutoTuneVars.udStartTime := ops.tAbsolute;
        sAutoTuneVars.SSWAutoTune := _DisableAutoTune;
//      else
//        sAutoTuneVars.SSWAutoTune := _InfoSTOEnable;        
      end_if;    
    
    //*********************************************************
  	eAutoTuneSSW::_DisableAutoTune:
      //remove enable
      Enable.Write(input:=0);
      sAutoTuneVars.SSWAutoTune := _AutoTuneStopped;
      
    //*********************************************************
  	eAutoTuneSSW::_AutoTuneStopped:    
        // 05.012  Autotune
        dTmpRetCode := SDOInternal(hiIndex:=FDD3000_MENU_05_MOTOR_CONTROL
                                  , usSubIndex:=FDD3000_05_PARA_AUTOTUNE
                                  , usLength:=1
                                  , bRW:=TRUE
                                  , dDataWr:=0
                                  , pRetData:= #sAutoTuneVars.hdSDORetCode$DINT);
                                  
        if dTmpRetCode = READY then
          sAutoTuneVars.udStartTime := ops.tAbsolute;
          sAutoTuneVars.SSWAutoTune := _QuitErrorStopped;
          
        elsif dTmpRetCode <> BUSY then
          //error occurred
          sAutoTuneVars.SSWAutoTuneErrorStep := sAutoTuneVars.SSWAutoTune;
          sAutoTuneVars.SSWAutoTune := _ErrorAutoTune;      
        end_if;
        
    //*********************************************************
  	eAutoTuneSSW::_QuitErrorStopped:
      if (ops.tAbsolute-sAutoTuneVars.udStartTime) >= FDD3000_CANOPEN_WAIT4QUITERROR then
        if DriveError then
          ErrorQuit.Write(input:=0);      
        end_if;
        sAutoTuneVars.SSWAutoTune := _FinishedAutoTune;
      end_if;
    //*********************************************************
    //End Autotune (stationary / rotating) 
    //*********************************************************
    
    //*********************************************************
  	eAutoTuneSSW::_FinishedAutoTune:
      //reset server
      FDD3000_VOVControl1.SetUserMotorParas := 0;
      FDD3000_VOVControl1.SetDriveMode      := _ModeUnknown;
      sAutoTuneVars.SSWAutoTune := _IdleAutoTune;
      dRetCode := READY;
      
    
    //*********************************************************
  	eAutoTuneSSW::_ErrorAutoTune:
      dRetCode := ERROR;
      sAutoTuneVars.SSWAutoTune := _IdleAutoTune;    
    
  end_case;

  FDD3000_VOVControl1.ActAutotuneStep := sAutoTuneVars.SSWAutoTune;
  
END_FUNCTION


FUNCTION FDD3000_CanOpenInt::SaveParasOnDrive
	VAR_OUTPUT
		dRetCode 	: iprStates;
	END_VAR
  VAR
    dTmpRetCode : iprStates;
    RetCode     : DINT;
    pTempServerOut : ^DINT;
    pTempServerIn  : ^DINT;
    ustmpCnt       : USINT;
  END_VAR

  dRetCode := BUSY;
  
  case sSaveParasVars.SSWSaveParas of
    //*********************************************************
  	eSaveActValuesOnDrive::_IdleSaveParas:
      sSaveParasVars.SSWSaveParas := _UserGetParas;
    
    //*********************************************************
  	eSaveActValuesOnDrive::_UserGetParas:
      //data source hwk
      if FDD3000_VOVControl1.DataSource = 1 then
        pTempServerIn  := #MaxRefClamp.dData;
        pTempServerOut := #MaxRefClamp.dData;
      //data source actual drive parameter
      elsif FDD3000_VOVControl1.DataSource = 2 then
        pTempServerIn  := #FDD3000_ActDriveParas.MaxRefClamp.dData;
        pTempServerOut := #MaxRefClamp.dData;
      //data source old parameter
      elsif FDD3000_VOVControl1.DataSource = 3 then
        pTempServerIn  := #FDD3000_OldDriveParas.MaxRefClamp.dData;
        pTempServerOut := #MaxRefClamp.dData;
      else
        //wait 4 input
        return;
      end_if;
      
      //copy selected data to hwk server
      for usTmpCnt := 0 to FDD3000_PARAMETERSFILERAM_AMOUNT_SERVERS-1 do
        pTempServerOut^ := pTempServerIn^;
        pTempServerIn  += sizeof(SvrCh);
        pTempServerOut += sizeof(SvrCh);
      end_for;
      
      //disable write of sdo data to drive
      PDOIniSSW := 20;
      
      //set act values on hwk servers 
      MaxRefClamp.Write(input:=MaxRefClamp);
      MinRefClamp.Write(input:=MinRefClamp);
      AccRate.Write(input:=AccRate);
      DecRate.Write(input:=DecRate);
      MotorRatedCurrent.Write(input:=MotorRatedCurrent);
      MotorRatedSpeed.Write(input:=MotorRatedSpeed);
      MotorRatedVoltage.Write(input:=MotorRatedVoltage);
      //only write motor rated power factor if it is not calculated by drive
      MotorRatedPowerFactor.Write(input:=MotorRatedPowerFactor);
      MotorRatedFrequency.Write(input:=MotorRatedFrequency);
      LowFrequencyVoltageBoost.Write(input:=LowFrequencyVoltageBoost);
      //Openloop / RFC-A
      StatorResistance.Write(input:=StatorResistance);
      TransientInductance.Write(input:=TransientInductance);
      StatorInductance.Write(input:=StatorInductance);
      //OpenLoop mode
      if OPModeDrive = FDD3000_VOVControl::_OpenLoop then
        FDD3000_HWKDriveParas.MaximumDeadTimeComp      := MaximumDeadTimeComp;
        FDD3000_HWKDriveParas.CurrentAtMaximumDeadTime := CurrentAtMaximumDeadTime;
      end_if;
      //RFC-A mode
      if OPModeDrive = FDD3000_VOVControl::_RFC_A then
        CurrentLoopKPGain.Write(input:=CurrentLoopKPGain);
        CurrentLoopKiGain.Write(input:=CurrentLoopKiGain);
        SaturationBreakpoint1.Write(input:=SaturationBreakpoint1);
        SaturationBreakpoint3.Write(input:=SaturationBreakpoint3);
        SaturationBreakpoint2.Write(input:=SaturationBreakpoint2);
        SaturationBreakpoint4.Write(input:=SaturationBreakpoint4);
      end_if;
        
      //write different paras
      sSaveParasVars.bWriteDiffParas   := TRUE;
      sSaveParasVars.bWriteValueAnyway := TRUE;
      sSaveParasVars.SSWSaveParas    := _SendParasToDrive;        
    
    //*********************************************************
  	eSaveActValuesOnDrive::_SendParasToDrive:
      RetCode := UserSettings();
      //write of drive paras is finished
      if RetCode = 1 then
        //reset write different paras
        sSaveParasVars.bWriteDiffParas   := FALSE;
        sSaveParasVars.bWriteValueAnyway := FALSE;
        sSaveParasVars.udStartTime  := ops.tAbsolute;
        sSaveParasVars.SSWSaveParas := _SendSaveCMDDrive;
      end_if;
    
    //*********************************************************
  	eSaveActValuesOnDrive::_SendSaveCMDDrive:
      // 0x1010 1 Save Parameter data: 0x65766173
      dTmpRetCode := SDOInternal(hiIndex    :=FDD3000_CANOPEN_STOREPARAS_INDEX
                                , usSubIndex:=FDD3000_CANOPEN_STOREPARAS_SUBINDEX
                                , usLength  :=4
                                , bRW       :=TRUE
                                , dDataWr   :=FDD3000_CANOPEN_STOREPARASMAGICNRB
                                , pRetData  := #sSaveParasVars.hdSDORetCode$DINT);
                                
      if dTmpRetCode = READY then
        sSaveParasVars.udStartTime  := ops.tAbsolute;
        sSaveParasVars.SSWSaveParas := _FinishedSaveParas;      
      elsif dTmpRetCode <> BUSY then
        //error occurred
        sSaveParasVars.SSWSaveParasError := sSaveParasVars.SSWSaveParas;
        sSaveParasVars.SSWSaveParas := _ErrorSaveParas;
      end_if;      
    
    //*********************************************************
  	eSaveActValuesOnDrive::_FinishedSaveParas:
      dRetCode := READY;
      sSaveParasVars.SSWSaveParas := _IdleSaveParas;
    
    //*********************************************************
  	eSaveActValuesOnDrive::_ErrorSaveParas:
      dRetCode := ERROR;
      sSaveParasVars.SSWSaveParas := _IdleSaveParas;
      
  end_case;

END_FUNCTION


FUNCTION FDD3000_CanOpenInt::XMLFileHandling
	VAR_OUTPUT
		dRetCode 	: iprStates;
	END_VAR
  VAR
    dTmpRetCode : iprStates;
    pTempServerOut : ^DINT;
    pTempServerIn  : ^DINT;
    ustmpCnt       : USINT;
    UserCmdStruct  : CmdStruct;
    UserResults    : Results;
    pTable         : ^DINT;
    pOnePara       : ^FDD3000_FileHandling::ts_OneParameter;
    udTableLength  : UDINT;
    udTableEntries : UDINT;
    udTmpLen       : UDINT;
  END_VAR

  dRetCode := BUSY;
    
  case sSaveParasVars.SSWFileHandling of
    //*********************************************************
  	eXMLFileHandling::_IdleFileHandling:
      if FDD3000_VOVControl1.SetUserMotorParas = 21 then
        sSaveParasVars.SSWFileHandling := _ReadFile;
      else
        FDD3000_VOVControl1.FileSelect.Write(input:=FDD3000_VOVControl1.FileSelect);
        sSaveParasVars.SSWFileHandling := _GetWriteData;
        sSaveParasVars.udStartTime     := ops.tAbsolute;
      end_if;
      
    //*********************************************************
    //Write File
    //*********************************************************
  	eXMLFileHandling::_GetWriteData:
      //workaround for VOV Visu - if write is to fast it is wrong displayed at VOV
      if (ops.tAbsolute-sSaveParasVars.udStartTime) <= FDD3000_CANOPEN_WAIT4STORENODECONFIG then
        return;
      end_if;
    
      //data source hwk
      if FDD3000_VOVControl1.DataSource = 1 then
        pTempServerIn := #FDD3000_HWKDriveParas.MaxRefClamp.dData;
      //data source actual drive parameter
      elsif FDD3000_VOVControl1.DataSource = 2 then
        pTempServerIn := #FDD3000_ActDriveParas.MaxRefClamp.dData;
      //data source old parameter
      elsif FDD3000_VOVControl1.DataSource = 3 then
        pTempServerIn := #FDD3000_OldDriveParas.MaxRefClamp.dData;
      else
        //wait 4 input
        return;
      end_if;
      
      //get table pointer and set header information
      pTable := (#FDD3000InternalFileHandlingTab())$^DINT;
      udTableLength  := pTable^$UDINT;
      udTableEntries := udTableLength/sizeof(FDD3000_FileHandling::ts_OneParameter);
      sSaveParasVars.sParaFile.sHeader.udCRC32 := 0;
      sSaveParasVars.sParaFile.sHeader.udLen   := udTableLength;
      sSaveParasVars.sParaFile.sHeader.udVersion := 1;
      sSaveParasVars.sParaFile.sHeader.DriveType := e_DriveType::_FDD3000_CAN;
      sSaveParasVars.sParaFile.sHeader.AxOffset  := sizeof(FDD3000_FileHandling::ts_ParaFileHeader);
      sSaveParasVars.sParaFile.sHeader.AxLength  := udTableEntries;
      sSaveParasVars.sParaFile.sHeader.bsFileSelect := FDD3000_VOVControl1.FileSelect$BSINT;
      //get serial number for file name
      udTmpLen := StrSerialNo.GetLength();
      //reset AxName buffer
      _memset(dest:=#sSaveParasVars.sParaFile.sHeader.AxName[0], usByte:=0x00, cntr:=sizeof(sSaveParasVars.sParaFile.sHeader.AxName));
      //set serial number string in buffer
      StrSerialNo.GetDataAt(pData:=#sSaveParasVars.sParaFile.sHeader.AxName[0], udSize:=udTmpLen, udAt:=0);
         
      pOnePara      := pTable+sizeof(UDINT);
      
      //copy data for parameter file from datasource and table
      for ustmpCnt := 0 to udTableEntries-1 do
        sSaveParasVars.sParaFile.aParaData[ustmpCnt]       := pOnePara^;
        sSaveParasVars.sParaFile.aParaData[ustmpCnt].dData := pTempServerIn^;
        pOnePara       += sizeof(FDD3000_FileHandling::ts_OneParameter);
        pTempServerIn  += sizeof(SvrCh);
      end_for;     
      sSaveParasVars.SSWFileHandling := _WriteFile;
    
    
    //*********************************************************
  	eXMLFileHandling::_WriteFile:
      // Set the user command to the file handler
      UserCmdStruct.uiCmd          := 4;
      UserCmdStruct.aPara[0]       := _SDDUSERCMD::_SDDEXDATAXML$DINT;
      UserCmdStruct.aPara[1]$^DINT := #sSaveParasVars.sParaFile$DINT;
      
      dTmpRetCode := toFDD3000FileHandling.NewInst(#UserCmdStruct, #UserResults);
      
      if dTmpRetCode = READY then
        sSaveParasVars.udStartTime     := ops.tAbsolute;
        sSaveParasVars.SSWFileHandling := _Wait4WriteFile;      
      elsif dTmpRetCode <> BUSY then
        //error occurred
        sSaveParasVars.SSWFileHandlingError := sSaveParasVars.SSWFileHandling;
        sSaveParasVars.SSWFileHandling      := _ErrorFileHandling;
      end_if;
    
    //*********************************************************
  	eXMLFileHandling::_Wait4WriteFile:
      //set command for newinst to get act state
      UserCmdStruct.uiCmd := 5;
      
      dTmpRetCode := toFDD3000FileHandling.NewInst(#UserCmdStruct, #UserResults);
      
      if dTmpRetCode = READY then
        if UserResults.aData[0]$_SDDUSERCMD = _SDDIDLE then
          sSaveParasVars.udStartTime     := ops.tAbsolute;
          sSaveParasVars.SSWFileHandling := _FinishedFileHandling;
        elsif UserResults.aData[0]$_SDDUSERCMD = _SDDERROR then
          //error occurred
          sSaveParasVars.SSWFileHandlingError := sSaveParasVars.SSWFileHandling;
          sSaveParasVars.SSWFileHandling      := _ErrorFileHandling;
        end_if;      
      elsif dTmpRetCode <> BUSY then
        //error occurred
        sSaveParasVars.SSWFileHandlingError := sSaveParasVars.SSWFileHandling;
        sSaveParasVars.SSWFileHandling      := _ErrorFileHandling;
      end_if;
      
    
    //*********************************************************
    //Read File
    //*********************************************************
  	eXMLFileHandling::_ReadFile://
      //get serial number for axname to opening of file
      udTmpLen := StrSerialNo.GetLength();
      //reset AxName buffer
      _memset(dest:=#sSaveParasVars.sParaFile.sHeader.AxName[0], usByte:=0x00, cntr:=sizeof(sSaveParasVars.sParaFile.sHeader.AxName));
      //set serial number string in buffer
      StrSerialNo.GetDataAt(pData:=#sSaveParasVars.sParaFile.sHeader.AxName[0], udSize:=udTmpLen, udAt:=0);
      //select file to read from (with serial number or general tag)
      sSaveParasVars.sParaFile.sHeader.bsFileSelect := FDD3000_VOVControl1.FileSelect$BSINT;
      // Set the user command to the file handler
      UserCmdStruct.uiCmd          := 4;
      UserCmdStruct.aPara[0]       := _SDDUSERCMD::_SDDIMDATAXML$DINT;
      UserCmdStruct.aPara[1]$^DINT := #sSaveParasVars.sParaFile$DINT;
      
      //start reading of file
      dTmpRetCode := toFDD3000FileHandling.NewInst(#UserCmdStruct, #UserResults);
      
      if dTmpRetCode = READY then
        sSaveParasVars.udStartTime     := ops.tAbsolute;
        sSaveParasVars.SSWFileHandling := _Wait4ReadFile;      
      elsif dTmpRetCode <> BUSY then
        //error occurred
        sSaveParasVars.SSWFileHandlingError := sSaveParasVars.SSWFileHandling;
        sSaveParasVars.SSWFileHandling      := _ErrorFileHandling;
      end_if;
      
      
    //*********************************************************
  	eXMLFileHandling::_Wait4ReadFile:
      //set command for newinst to get act state
      UserCmdStruct.uiCmd := 5;
      //read act state from filehandling class
      dTmpRetCode := toFDD3000FileHandling.NewInst(#UserCmdStruct, #UserResults);
      
      if dTmpRetCode = READY then
        if UserResults.aData[0]$_SDDUSERCMD = _SDDIDLE then
          sSaveParasVars.udStartTime  := ops.tAbsolute;
          sSaveParasVars.SSWFileHandling := _SetReadDataOnServer;
        elsif UserResults.aData[0]$_SDDUSERCMD = _SDDERROR then
          //error occurred
          sSaveParasVars.SSWFileHandlingError := sSaveParasVars.SSWFileHandling;
          sSaveParasVars.SSWFileHandling      := _ErrorFileHandling;
        end_if;      
      elsif dTmpRetCode <> BUSY then
        //error occurred
        sSaveParasVars.SSWFileHandlingError := sSaveParasVars.SSWFileHandling;
        sSaveParasVars.SSWFileHandling      := _ErrorFileHandling;
      end_if;
    
    
    //*********************************************************
  	eXMLFileHandling::_SetReadDataOnServer:
    
      //set pointer to hwk servers to show data from file on it
      pTempServerOut := #MaxRefClamp.dData;
      //copy data from file to server
      for ustmpCnt := 0 to sSaveParasVars.sParaFile.sHeader.AxLength-1 do
        pTempServerOut^ := sSaveParasVars.sParaFile.aParaData[ustmpCnt].dData;
        pTempServerOut  += sizeof(SvrCh);
      end_for;
      
      //disable write of sdo data to drive
      PDOIniSSW := 20;
      
      //get act values 
      MaxRefClamp.Write(input:=MaxRefClamp);
      MinRefClamp.Write(input:=MinRefClamp);
      AccRate.Write(input:=AccRate);
      DecRate.Write(input:=DecRate);
      MotorRatedCurrent.Write(input:=MotorRatedCurrent);
      MotorRatedSpeed.Write(input:=MotorRatedSpeed);
      MotorRatedVoltage.Write(input:=MotorRatedVoltage);
      MotorRatedPowerFactor.Write(input:=MotorRatedPowerFactor);
      MotorRatedFrequency.Write(input:=MotorRatedFrequency);
      LowFrequencyVoltageBoost.Write(input:=LowFrequencyVoltageBoost);
      //Openloop / RFC-A
      StatorResistance.Write(input:=StatorResistance);
      TransientInductance.Write(input:=TransientInductance);
      StatorInductance.Write(input:=StatorInductance);
      //OpenLoop mode
      MaximumDeadTimeComp := MaximumDeadTimeComp;
      CurrentAtMaximumDeadTime := CurrentAtMaximumDeadTime;
      //RFC-A mode
      CurrentLoopKPGain.Write(input:=CurrentLoopKPGain);
      CurrentLoopKiGain.Write(input:=CurrentLoopKiGain);
      SaturationBreakpoint1.Write(input:=SaturationBreakpoint1);
      SaturationBreakpoint3.Write(input:=SaturationBreakpoint3);
      SaturationBreakpoint2.Write(input:=SaturationBreakpoint2);
      SaturationBreakpoint4.Write(input:=SaturationBreakpoint4);
            
      //enable write of sdo data to drive
      PDOIniSSW := 0;
      
      sSaveParasVars.SSWFileHandling := _FinishedFileHandling; 
    //*********************************************************
    //finished file handling
    //*********************************************************
    
    //*********************************************************
  	eXMLFileHandling::_FinishedFileHandling:
      dRetCode := READY;
      sSaveParasVars.SSWFileHandling := _IdleFileHandling;
      
    
    //*********************************************************
  	eXMLFileHandling::_ErrorFileHandling:
      dRetCode := ERROR;
      sSaveParasVars.SSWFileHandling := _IdleFileHandling;
    
  end_case;
  
END_FUNCTION


FUNCTION FDD3000_CanOpenInt::SDOInternal
	VAR_INPUT
		hiIndex 	: HINT;
		usSubIndex 	: USINT;
		usLength 	: USINT;
		bRW 	: BOOL;
		dDataWr 	: DINT;(* := 0 *)
		pRetData 	: ^DINT;(* := NIL *)
	END_VAR
	VAR_OUTPUT
		dRetCode 	: iprStates;
	END_VAR
  VAR
    HlpRetData : DINT;
    HlpRetcode : iprStates;
  END_VAR

  dRetCode := BUSY;
  
  //**********************************************************************************************
  // ASYNC DATA HANDLING
  //**********************************************************************************************
  
  HlpRetcode := AsyncSDOHandling(pHandle  := #HlpHandleInit
                              , iIndex    := hiIndex$INT
                              , siSubIndex:= usSubIndex$SINT
                              , dData     := dDataWr
                              , bRW       := bRW
                              , usLength  := usLength  
                              , pAsyncData:= #HlpRetData
                              );
                              
  // Send SDO --------------------------------------------------
  if HlpRetcode = READY then
  
  // Send SDO was not successful -------------------------------
  elsif HlpRetcode = ERROR then
    if pRetData <> NIL then
      pRetData^ := HlpRetData;
    end_if;
    dRetCode := ERROR;
  
  // Send SDO was successful ------------------------------------  
  elsif HlpRetcode = QUIT then
    if bRW = 0 & pRetData <> NIL then
      pRetData^ := HlpRetData;
    end_if;
    dRetCode := READY;
  end_if;    

END_FUNCTION


FUNCTION TAB FDD3000_CanOpenInt::FDD3000InternalFileHandlingTab

  // Arrangement must be the same as for the FDD3000_Parameters class because data is taken from their servers.
  // RW .... 0 = ReadOnly, 1 = WriteOnly, 2 = Read/Write
  // Mode .. 0 = Openloop, 1 = RFC-A,     2 = Openloop/RFC-A
  // One parameter = 10Byte
  // INDEX(2Byte)   SUBINDEX(1Byte)   DATA(4Byte)   LENGTH(1Byte)   RW(1Byte)   MODE(1Byte) 
  16#2001$HINT,        6$USINT,       0$DINT,       4$USINT,        2$USINT,    2$USINT,  // Pr 01.006  Maximum Reference Clamp 
  16#2001$HINT,        7$USINT,       0$DINT,       4$USINT,        2$USINT,    2$USINT,  // Pr 01.007  Minimum Reference Clamp
  16#2002$HINT,       11$USINT,       0$DINT,       4$USINT,        2$USINT,    2$USINT,  // Pr 02.011  Acceleration Rate 1 
  16#2002$HINT,       21$USINT,       0$DINT,       4$USINT,        2$USINT,    2$USINT,  // Pr 02.021  Deceleration Rate 1 
  16#2005$HINT,        7$USINT,       0$DINT,       4$USINT,        2$USINT,    2$USINT,  // Pr 05.007  Motor Rated Current 
  16#2005$HINT,        8$USINT,       0$DINT,       4$USINT,        2$USINT,    2$USINT,  // Pr 05.008  Motor Rated Speed 
  16#2005$HINT,        9$USINT,       0$DINT,       2$USINT,        2$USINT,    2$USINT,  // Pr 05.009  Motor Rated Voltage  
  16#2005$HINT,       10$USINT,       0$DINT,       2$USINT,        2$USINT,    2$USINT,  // Pr 05.010  Motor Rated Power Factor  
  16#2005$HINT,        6$USINT,       0$DINT,       4$USINT,        2$USINT,    2$USINT,  // Pr 05.006  Motor Rated Frequency  
  16#2005$HINT,       15$USINT,       0$DINT,       2$USINT,        2$USINT,    2$USINT,  // Pr 05.015  Low Frequency Voltage Boost  
  16#2005$HINT,       17$USINT,       0$DINT,       4$USINT,        2$USINT,    2$USINT,  // Pr 05.017  OpenLoop / RFC-A Stator Resistance 
  16#2005$HINT,       24$USINT,       0$DINT,       4$USINT,        2$USINT,    2$USINT,  // Pr 05.024  OpenLoop / RFC-A Transient Inductance
  16#2005$HINT,       25$USINT,       0$DINT,       4$USINT,        2$USINT,    2$USINT,  // Pr 05.025  OpenLoop / RFC-A Stator Inductance
  //OpenLoop Paras                                                          
  16#2005$HINT,       59$USINT,       0$DINT,       4$USINT,        0$USINT,    0$USINT,  // Pr 05.059  OpenLoop Maximum Deadtime compensation
  16#2005$HINT,       60$USINT,       0$DINT,       4$USINT,        0$USINT,    0$USINT,  // Pr 05.060  OpenLoop Current At Maximum Deadtime Compensation
  //RFC-A Paras                                                             
  16#2004$HINT,       13$USINT,       0$DINT,       4$USINT,        2$USINT,    1$USINT,  // Pr 04.013  RFC-A Current Loop Gains 
  16#2004$HINT,       14$USINT,       0$DINT,       4$USINT,        2$USINT,    1$USINT,  // Pr 04.014  RFC-A Current Loop Gains
  16#2005$HINT,       29$USINT,       0$DINT,       2$USINT,        2$USINT,    1$USINT,  // Pr 05.029  RFC-A motor saturation breakpoints
  16#2005$HINT,       30$USINT,       0$DINT,       2$USINT,        2$USINT,    1$USINT,  // Pr 05.030  RFC-A motor saturation breakpoints
  16#2005$HINT,       62$USINT,       0$DINT,       2$USINT,        2$USINT,    1$USINT,  // Pr 05.062  RFC-A motor saturation breakpoints
  16#2005$HINT,       63$USINT,       0$DINT,       2$USINT,        2$USINT,    1$USINT,  // Pr 05.063  RFC-A motor saturation breakpoints
  
END_FUNCTION


FUNCTION VIRTUAL FDD3000_CanOpenInt::CheckDeviceID
	VAR_INPUT
		pStrProductCode 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		bIsOK 	: BOOL;
	END_VAR
  VAR
    aTmpStr1 : Array [0..7] of CHAR;
    udStrlen1 : UDINT;
  END_VAR
  
  bIsOK := FALSE;
  
  if pStrProductCode <> NIL then
    sigclib_strcpy(dst0:=#aTmpStr1[0], src0:=FDD3000_DEVICETYPE);
    udStrlen1 := sigclib_strlen(str:=#aTmpStr1[0]);
    //check first part of product string
    if sigclib_strspn(ps1:=#aTmpStr1[0], ps2:=pStrProductCode) >= udStrlen1$DINT then
      sigclib_strcpy(dst0:=#aTmpStr1[0], src0:=FDD3000_SIGMATEKID);
      udStrlen1 := sigclib_strlen(str:=#aTmpStr1[0]);
      //check second part of product string
      if sigclib_strspn(ps1:=#aTmpStr1[0], ps2:=pStrProductCode) >= udStrlen1$DINT then
        //if device is ok
        bIsOK := TRUE;        
      end_if;
    end_if;
  end_if;

END_FUNCTION


FUNCTION FDD3000_CanOpenInt::SDOCyclicWork
	VAR_OUTPUT
		dRetCode 	: iprStates;
	END_VAR
  VAR
    iRetCode    : INT;
    ActSDO      : t_s_ComSDOCyclic;
//    hdTmpIndex  : HDINT;
    usTmpCnt    : USINT;
  END_VAR
  
  dRetCode   := BUSY;

  case sCyclicSDORW.SSWCyclicSDO of
    //*********************************************************
    eSDOCyclicSSW::_IdleCyclicSDO:
      if sCyclicSDORW.usActiveSDOsInBuffer then 
        sCyclicSDORW.usActSDOEntry := 0;
        sCyclicSDORW.SSWCyclicSDO  := _SetSDORequest;
      else
        dRetCode                   := READY;      
      end_if;
    
    //*********************************************************
    eSDOCyclicSSW::_SetSDORequest:
      if sCyclicSDORW.aSDOCyclicData[sCyclicSDORW.usActSDOEntry].SendMode <> _SendFinished then
        if (ops.tAbsolute-sCyclicSDORW.udStartTime) > FDD3000_CANOPEN_READINTERVALL_CYCLICSDO then

          sCyclicSDORW.udStartTime  := ops.tAbsolute;
          ActSDO := sCyclicSDORW.aSDOCyclicData[sCyclicSDORW.usActSDOEntry];
          
          iRetCode := ChangeSDOobjData(NumberSDO:=sCyclicSDORW.iSDOHandle
                                     , Active   :=1
                                     , Index    := ActSdo.hiIndex$INT
                                     , SubIndex := ActSdo.usSubIndex$SINT
                                     , Data     := ActSDO.dData
                                     , RW       := ActSdo.bRW
                                     , Len      := ActSdo.usLen
                                     );
                                          
          if iRetCode = 0 then
            sCyclicSDORW.bSDORespRdy  := FALSE;
            sCyclicSDORW.bRespError   := FALSE;
            sCyclicSDORW.SSWCyclicSDO := _NextCyclicSDO;
            
          else
            //error occurred
            sCyclicSDORW.SSWCyclicSDOErrorStep := sCyclicSDORW.SSWCyclicSDO;
            sCyclicSDORW.SSWCyclicSDO := _ErrorCyclicSDO;      
          end_if;
        
        end_if;
      else
        sCyclicSDORW.bSDORespRdy  := FALSE;
        sCyclicSDORW.bRespError   := FALSE;
        sCyclicSDORW.SSWCyclicSDO := _NextCyclicSDO;        
      end_if;  
    
    //*********************************************************
    eSDOCyclicSSW::_NextCyclicSDO:
    
      if sCyclicSDORW.bSDORespRdy then
//        if sCyclicSDORW.bRespError = FALSE then
//          hdTmpIndex := to_udint(sCyclicSDORW.aSDOCyclicData[sCyclicSDORW.usActSDOEntry].hiIndex shl 8);
//          hdTmpIndex += sCyclicSDORW.aSDOCyclicData[sCyclicSDORW.usActSDOEntry].usSubIndex;
//          
//          case hdTmpIndex of
//          
//            16#200827: STOInput := sCyclicSDORW.dActSDORespData;
//            16#200828: STOInput2 := sCyclicSDORW.dActSDORespData;
//          
//          end_case;        
//        end_if;
        
        //mark sdo as finished if it is send once
        if  sCyclicSDORW.aSDOCyclicData[sCyclicSDORW.usActSDOEntry].SendMode = _SendOnce then
          sCyclicSDORW.aSDOCyclicData[sCyclicSDORW.usActSDOEntry].SendMode := _SendFinished;
          sCyclicSDORW.usActiveSDOsInBuffer -= 1;
        end_if;
        
        sCyclicSDORW.usActSDOEntry += 1;
        
        for usTmpCnt := sCyclicSDORW.usActSDOEntry to sCyclicSDORW.usSDOsInBuffer do
          sCyclicSDORW.usActSDOEntry := usTmpCnt;
          if sCyclicSDORW.aSDOCyclicData[usTmpcnt].SendMode <> _SendFinished then
            exit;
          end_if;
        end_for;
        
        //check if there are sdos in buffer to send
        if sCyclicSDORW.usActiveSDOsInBuffer then
          //reset entry if it is at end of array
          if sCyclicSDORW.usActSDOEntry >= sCyclicSDORW.usSDOsInBuffer then
            sCyclicSDORW.usActSDOEntry := 0;
          end_if;        
          sCyclicSDORW.SSWCyclicSDO := _SetSDORequest;      
        else
          sCyclicSDORW.SSWCyclicSDO := _FinishedCyclicSDO;        
        end_if;
        dRetCode := READY;
      else      
        if sCyclicSDORW.aSDOCyclicData[sCyclicSDORW.usActSDOEntry].SendMode = _SendFinished then
          //check next sdo
          sCyclicSDORW.usActSDOEntry += 1;
          sCyclicSDORW.SSWCyclicSDO  := _SetSDORequest;
          return;
        end_if;
        //check for timeout
        if (ops.tAbsolute-sCyclicSDORW.udStartTime) >= CO_CAN_Device_TIMEOUT then
          //mark sdo as finished if it is send once
          if  sCyclicSDORW.aSDOCyclicData[sCyclicSDORW.usActSDOEntry].SendMode = _SendOnce then
            sCyclicSDORW.aSDOCyclicData[sCyclicSDORW.usActSDOEntry].SendMode := _SendFinished;
            sCyclicSDORW.usActiveSDOsInBuffer -= 1;
          end_if;        
          sCyclicSDORW.SSWCyclicSDOErrorStep := sCyclicSDORW.SSWCyclicSDO;
          sCyclicSDORW.SSWCyclicSDO := _ErrorCyclicSDO;
        end_if;
      end_if;
    
    //*********************************************************
    eSDOCyclicSSW::_FinishedCyclicSDO:
      dRetCode := READY;
      sCyclicSDORW.SSWCyclicSDO := _IdleCyclicSDO;
      
    
    //*********************************************************
    eSDOCyclicSSW::_ErrorCyclicSDO:
      dRetCode := ERROR;
      sCyclicSDORW.SSWCyclicSDO := _IdleCyclicSDO;
      
  end_case;   
  
END_FUNCTION


FUNCTION FDD3000_CanOpenInt::SDOInternalCallback
	VAR_INPUT
		udTxCount 	: UDINT;
		udRxCount 	: UDINT;
		udErrorCount 	: UDINT;
		dData 	: DINT;
	END_VAR
  
  sCyclicSDORW.udErrorCnt  += udErrorCount;
  
  if udRxCount then
    sCyclicSDORW.udRxCount       += udRxCount;
    sCyclicSDORW.dActSDORespData := dData;
    sCyclicSDORW.bSDORespRdy     := TRUE;  
  end_if;
  
  if udTxCount then
    sCyclicSDORW.udTxCount += udTxCount;
    //set sdo inactive
    ChangeSDOobjData(NumberSDO:=sCyclicSDORW.iSDOHandle
                   , Active   :=0
                   , Index    :=0
                   , SubIndex :=0
                   , Data     :=0
                   , RW       :=0
                   , Len      :=0
                   , bOnlyChangeActive := TRUE
                   ); 
  end_if;

  if udErrorCount then
    sCyclicSDORW.udErrorCnt += udErrorCount;
    sCyclicSDORW.dActSDORespData := dData;
    sCyclicSDORW.bRespError      := TRUE;  
    //set sdo inactive
    ChangeSDOobjData(NumberSDO:=sCyclicSDORW.iSDOHandle
                   , Active   :=0
                   , Index    :=0
                   , SubIndex :=0
                   , Data     :=0
                   , RW       :=0
                   , Len      :=0
                   , bOnlyChangeActive := TRUE
                   ); 
  end_if;  
  
END_FUNCTION


FUNCTION FDD3000_CanOpenInt::SDOCyclicAdd
	VAR_INPUT
		bRW 	: BOOL;
		usLen 	: USINT;
		hiIndex 	: HINT;
		usSubIndex 	: USINT;
		dData 	: DINT;
		eSendMode 	: e_SendModeSDO;
	END_VAR
	VAR_OUTPUT
		dRetCode 	: DINT;
	END_VAR
  VAR
  	usTmpcnt : USINT;
    udTempVar : UDINT;
  END_VAR
  
  //initialize with busy
  dRetCode := 0;
  
  if PDOIniSSW <> 0 then
   return;
  end_if;
  
  udTempVar := sigclib_atomic_cmpxchgU32(pValue:=#sCyclicSDORW.udSDOAddLock, cmpVal:=0, newVal:=1);
  if udTempVar = 0 then
    for usTmpCnt := 0 to FDD3000_CANOPEN_MAXBUFFER_CYCLICSDO-1 do
    
      if sCyclicSDORW.aSDOCyclicData[usTmpCnt].SendMode = _SendFinished then
        sCyclicSDORW.aSDOCyclicData[usTmpCnt].bRW        := bRW;
        sCyclicSDORW.aSDOCyclicData[usTmpCnt].usLen      := usLen;
        sCyclicSDORW.aSDOCyclicData[usTmpCnt].hiIndex    := hiIndex;
        sCyclicSDORW.aSDOCyclicData[usTmpCnt].usSubIndex := usSubIndex;
        sCyclicSDORW.aSDOCyclicData[usTmpCnt].dData      := dData;
        sCyclicSDORW.aSDOCyclicData[usTmpCnt].SendMode   := eSendMode;
        if usTmpcnt >= sCyclicSDORW.usSDOsInBuffer then
          sCyclicSDORW.usSDOsInBuffer := usTmpcnt+1;
        end_if;
        
        //add sdo to active list
        if eSendMode <> _SendFinished then        
          sCyclicSDORW.usActiveSDOsInBuffer += 1;
        end_if;
        //sdo was added - return actual number of sdo at buffer
        dRetCode := usTmpcnt+1;
        exit;
        
      //search for already added sdos with same index and subindex  
      elsif sCyclicSDORW.aSDOCyclicData[usTmpCnt].hiIndex = hiIndex 
      & sCyclicSDORW.aSDOCyclicData[usTmpCnt].usSubIndex = usSubIndex 
      & sCyclicSDORW.aSDOCyclicData[usTmpcnt].bRW = bRW then
        
        sCyclicSDORW.aSDOCyclicData[usTmpCnt].bRW        := bRW;
        sCyclicSDORW.aSDOCyclicData[usTmpCnt].dData      := dData;
        sCyclicSDORW.aSDOCyclicData[usTmpCnt].SendMode   := eSendMode;
        
        //sdo was replaced - return actual number of sdo at buffer
        dRetCode := usTmpcnt+1;
        exit;
      end_if;  
    end_for;
    
    //remove lock
    sigclib_atomic_setU32(pValue := #sCyclicSDORW.udSDOAddLock, value:=0);
  end_if;
  
END_FUNCTION

FUNCTION VIRTUAL FDD3000_CanOpenInt::GetProperty
	VAR_INPUT
		udPropertyID 	: UDINT;
		usDatalength 	: USINT;
		pPropertyValue 	: pVoid;
	END_VAR
	VAR_OUTPUT
		dRetCode 	: DINT;
	END_VAR
  VAR
  	dTempValue : DINT;
    strLen            : UDINT;
    bPropertyValueSet : BOOL;
  END_VAR
  
  //initialize returncode
  dRetCode := 0;
  bPropertyValueSet := FALSE;
  
  if pPropertyValue = NIL then
    //pointer for property value is not valid
    dRetCode := -3;
    return;
  end_if;
  
  if usDatalength < 4 then
    //minimum length of data must be 4 byte
    dRetCode := -4;
    return;
  end_if;
    
  case udPropertyID of
    //*************************************************************************************
    //*********** Get/Set Property ID's DS301:
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_DEVICE_STATE:
      dTempValue := DeviceState$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ERROR_QUIT:
      dTempValue := ErrorQuit$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_CANDISABLED:
      dTempValue := CanDisabled$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_DATAREADY:
      dTempValue := DataReady$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ASYNCSTATE:
      dTempValue := AsyncState$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ERROR_SDO:
      dTempValue := ErrorSDO$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ERROR_ALLOC:
      dTempValue := ErrorAlloc$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_EMCYSTATUSBYTE1:
      dTempValue := EmcyStatusByte0_3$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_EMCYSTATUSBYTE2:
      dTempValue := EmcyStatusByte4_7$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_PDO_DATA_1:
      if usDatalength > CO_MAX_CANOPEN_DATASIZE then
        usDatalength := CO_MAX_CANOPEN_DATASIZE;
      end_if;
      if usDatalength > sizeof(DINT) then      
        _memcpy(ptr1:=pPropertyValue, ptr2:=#RxBufferPdo1, cntr:=usDatalength-1);
      else
        dTempValue := RxBufferPdo1[0]$DINT;
      end_if;
      
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_PDO_DATA_2:
      if usDatalength > CO_MAX_CANOPEN_DATASIZE then
        usDatalength := CO_MAX_CANOPEN_DATASIZE;
      end_if;  
      if usDatalength > sizeof(DINT) then      
        _memcpy(ptr1:=pPropertyValue, ptr2:=#RxBufferPdo2, cntr:=usDatalength-1);
      else
        dTempValue := RxBufferPdo2[0]$DINT;
      end_if;
      
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_PDO_DATA_3:
      if usDatalength > CO_MAX_CANOPEN_DATASIZE then
        usDatalength := CO_MAX_CANOPEN_DATASIZE;
      end_if;
      if usDatalength > sizeof(DINT) then      
        _memcpy(ptr1:=pPropertyValue, ptr2:=#RxBufferPdo3, cntr:=usDatalength-1);
      else
        dTempValue := RxBufferPdo3[0]$DINT;
      end_if;
      
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_PDO_DATA_4:
      if usDatalength > CO_MAX_CANOPEN_DATASIZE then
        usDatalength := CO_MAX_CANOPEN_DATASIZE;
      end_if;
      if usDatalength > sizeof(DINT) then      
        _memcpy(ptr1:=pPropertyValue, ptr2:=#RxBufferPdo4, cntr:=usDatalength-1);
      else
        dTempValue := RxBufferPdo4[0]$DINT;
      end_if;

    //*************************************************************************************
    //*********** Get/Set Property ID's DS402:
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_PROFILEDRIVEMODE:
      dTempValue := ActDriveMode$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_CONTROLWORD_DS402:
      dTempValue := ControlWord$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_STATUSWORD_DS402:
      dTempValue := StatusWord$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_DRIVEERROR:
      dTempValue := DriveError$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_DRIVEERRORSTATUS:
      dTempValue := DriveErrorStatus$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ENABLE:
      dTempValue := Enable$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_POSITION:
      //property id is not available
      dRetCode := -1;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_SPEED:
      dTempValue := ActSpeed$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_CURRENT:
      //property id is not available
      dRetCode := -1;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_DESTINATIONPOS:
      //property id is not available
      dRetCode := -1;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_DESTINATIONSPEED:
      //property id is not available
      dRetCode := -1;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_DESTINATIONACCEL:
      //property id is not available
      dRetCode := -1;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_DESTINATIONDECEL:
      //property id is not available
      dRetCode := -1;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_STOP:
      dTempValue := Stop$DINT;
    
    
    //*************************************************************************************
    //*********** Get/Set Property ID's FDD3000:
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_COMM_MODE:
      dTempValue := _COMMTYPE_CANOPEN$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_STO_INPUT:      
      dTempValue := STOInput;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_STR_PRODUCTCODE:
      strLen := StrProductCode.GetLength();
      dRetCode := -6; // Not enoth space for data
      if usDatalength > strLen then // Must be one Larger for zero termination
        StrProductCode.GetDataAt(pData:=(pPropertyValue)$^USINT, udSize:=strLen, udAt:=0);
        ((pPropertyValue)$^USINT + strLen)^ := 0; // zero
        dRetCode          := 0;
        bPropertyValueSet := TRUE;
      end_if;
      
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_STR_SERIALNO:
      strLen := StrSerialNo.GetLength();
      dRetCode := -6; // Not enoth space for data
      if usDatalength > strLen then // Must be one Larger for zero termination
        StrSerialNo.GetDataAt(pData:=(pPropertyValue)$^USINT, udSize:=strLen, udAt:=0);
        ((pPropertyValue)$^USINT + strLen)^ := 0; // zero
        dRetCode          := 0;
        bPropertyValueSet := TRUE;
      end_if;
      
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_FWVERSIONDRIVE:
      dTempValue := FwVersionDrive$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_FWVERSIONCOMM:
      dTempValue := FwVersionComm$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWVERSIONCOMM:
      dTempValue := HwVersionComm$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_DRIVEMODE:
      dTempValue := OPModeDrive$DINT;    
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_AXERROR:
      dTempValue := DriveError$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_QUITAXERROR:      
      dTempValue := ErrorQuit$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ONLINE:
      dTempValue := Online$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ERROR_SDO_CODE:
      dRetCode := ComSDO.hdErrorRetCode$DINT;


    //*************************************************************************************
    //act drive values on hwk:
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWK_MAXREFCLAMP:    
      dTempValue := MaxRefClamp$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWK_MINREFCLAMP:
      dTempValue := MinRefClamp$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWK_ACCRATE:
      dTempValue := AccRate$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWK_DECRATE:
      dTempValue := DecRate$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWK_MOTORRATEDCURRENT:
      dTempValue := MotorRatedCurrent$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWK_MOTORRATEDSPEED:
      dTempValue := MotorRatedSpeed$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWK_MOTORRATEDVOLTAGE:
      dTempValue := MotorRatedVoltage$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWK_MOTORRATEDPOWERFACTOR:
      dTempValue := MotorRatedPowerFactor$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWK_MOTORRATEDFREQUENCY:
      dTempValue := MotorRatedFrequency$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWK_LOWFREQUENCYVOLTAGEBOOST:
      dTempValue := LowFrequencyVoltageBoost$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWK_STATORRESISTANCE:
      dTempValue := StatorResistance$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWK_TRANSIENTINDUCTANCE:
      dTempValue := TransientInductance$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWK_STATORINDUCTANCE:  
      dTempValue := StatorInductance$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWK_MAXIMUMDEADTIMECOMP:
      dTempValue := MaximumDeadTimeComp$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWK_CURRENTATMAXIMUMDEADTIME:
      dTempValue := CurrentAtMaximumDeadTime$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWK_CURRENTLOOPKPGAIN:
      dTempValue := CurrentLoopKPGain$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWK_CURRENTLOOPKIGAIN:
      dTempValue := CurrentLoopKiGain$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWK_SATURATIONBREAKPOINT1:
      dTempValue := SaturationBreakpoint1$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWK_SATURATIONBREAKPOINT2:
      dTempValue := SaturationBreakpoint2$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWK_SATURATIONBREAKPOINT3:
      dTempValue := SaturationBreakpoint3$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWK_SATURATIONBREAKPOINT4:
      dTempValue := SaturationBreakpoint4$DINT;


    //*************************************************************************************
    //act drive values:  
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTDRIVE_MAXREFCLAMP: 
      dTempValue := FDD3000_ActDriveParas.MaxRefClamp$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTDRIVE_MINREFCLAMP: 
      dTempValue := FDD3000_ActDriveParas.MinRefClamp$DINT; 
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTDRIVE_ACCRATE:  
      dTempValue := FDD3000_ActDriveParas.AccRate$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTDRIVE_DECRATE: 
      dTempValue := FDD3000_ActDriveParas.DecRate$DINT; 
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTDRIVE_MOTORRATEDCURRENT:
      dTempValue := FDD3000_ActDriveParas.MotorRatedCurrent$DINT;  
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTDRIVE_MOTORRATEDSPEED: 
      dTempValue := FDD3000_ActDriveParas.MotorRatedSpeed$DINT; 
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTDRIVE_MOTORRATEDVOLTAGE:
      dTempValue := FDD3000_ActDriveParas.MotorRatedVoltage$DINT;  
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTDRIVE_MOTORRATEDPOWERFACTOR: 
      dTempValue := FDD3000_ActDriveParas.MotorRatedPowerFactor$DINT; 
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTDRIVE_MOTORRATEDFREQUENCY: 
      dTempValue := FDD3000_ActDriveParas.MotorRatedFrequency$DINT; 
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTDRIVE_LOWFREQUENCYVOLTAGEBOOST:
      dTempValue := FDD3000_ActDriveParas.LowFrequencyVoltageBoost$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTDRIVE_STATORRESISTANCE:
      dTempValue := FDD3000_ActDriveParas.StatorResistance$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTDRIVE_TRANSIENTINDUCTANCE: 
      dTempValue := FDD3000_ActDriveParas.TransientInductance$DINT; 
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTDRIVE_STATORINDUCTANCE:
      dTempValue := FDD3000_ActDriveParas.StatorInductance$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTDRIVE_MAXIMUMDEADTIMECOMP:
      dTempValue := FDD3000_ActDriveParas.MaximumDeadTimeComp$DINT;  
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTDRIVE_CURRENTATMAXIMUMDEADTIME:
      dTempValue := FDD3000_ActDriveParas.CurrentAtMaximumDeadTime$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTDRIVE_CURRENTLOOPKPGAIN:  
      dTempValue := FDD3000_ActDriveParas.CurrentLoopKPGain$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTDRIVE_CURRENTLOOPKIGAIN:
      dTempValue := FDD3000_ActDriveParas.CurrentLoopKiGain$DINT;  
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTDRIVE_SATURATIONBREAKPOINT1:  
      dTempValue := FDD3000_ActDriveParas.SaturationBreakpoint1$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTDRIVE_SATURATIONBREAKPOINT2: 
      dTempValue := FDD3000_ActDriveParas.SaturationBreakpoint2$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTDRIVE_SATURATIONBREAKPOINT3: 
      dTempValue := FDD3000_ActDriveParas.SaturationBreakpoint3$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTDRIVE_SATURATIONBREAKPOINT4:
      dTempValue := FDD3000_ActDriveParas.SaturationBreakpoint4$DINT;


    //*************************************************************************************
    //old drive values:  
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_OLDDRIVE_MAXREFCLAMP: 
      dTempValue := FDD3000_OldDriveParas.MaxRefClamp$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_OLDDRIVE_MINREFCLAMP: 
      dTempValue := FDD3000_OldDriveParas.MinRefClamp$DINT; 
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_OLDDRIVE_ACCRATE:  
      dTempValue := FDD3000_OldDriveParas.AccRate$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_OLDDRIVE_DECRATE: 
      dTempValue := FDD3000_OldDriveParas.DecRate$DINT; 
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_OLDDRIVE_MOTORRATEDCURRENT:
      dTempValue := FDD3000_OldDriveParas.MotorRatedCurrent$DINT;  
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_OLDDRIVE_MOTORRATEDSPEED: 
      dTempValue := FDD3000_OldDriveParas.MotorRatedSpeed$DINT; 
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_OLDDRIVE_MOTORRATEDVOLTAGE:
      dTempValue := FDD3000_OldDriveParas.MotorRatedVoltage$DINT;  
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_OLDDRIVE_MOTORRATEDPOWERFACTOR: 
      dTempValue := FDD3000_OldDriveParas.MotorRatedPowerFactor$DINT; 
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_OLDDRIVE_MOTORRATEDFREQUENCY: 
      dTempValue := FDD3000_OldDriveParas.MotorRatedFrequency$DINT; 
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_OLDDRIVE_LOWFREQUENCYVOLTAGEBOOST:
      dTempValue := FDD3000_OldDriveParas.LowFrequencyVoltageBoost$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_OLDDRIVE_STATORRESISTANCE:
      dTempValue := FDD3000_OldDriveParas.StatorResistance$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_OLDDRIVE_TRANSIENTINDUCTANCE: 
      dTempValue := FDD3000_OldDriveParas.TransientInductance$DINT; 
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_OLDDRIVE_STATORINDUCTANCE:
      dTempValue := FDD3000_OldDriveParas.StatorInductance$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_OLDDRIVE_MAXIMUMDEADTIMECOMP:
      dTempValue := FDD3000_OldDriveParas.MaximumDeadTimeComp$DINT;  
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_OLDDRIVE_CURRENTATMAXIMUMDEADTIME:
      dTempValue := FDD3000_OldDriveParas.CurrentAtMaximumDeadTime$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_OLDDRIVE_CURRENTLOOPKPGAIN:  
      dTempValue := FDD3000_OldDriveParas.CurrentLoopKPGain$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_OLDDRIVE_CURRENTLOOPKIGAIN:
      dTempValue := FDD3000_OldDriveParas.CurrentLoopKiGain$DINT;  
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_OLDDRIVE_SATURATIONBREAKPOINT1:  
      dTempValue := FDD3000_OldDriveParas.SaturationBreakpoint1$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_OLDDRIVE_SATURATIONBREAKPOINT2: 
      dTempValue := FDD3000_OldDriveParas.SaturationBreakpoint2$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_OLDDRIVE_SATURATIONBREAKPOINT3: 
      dTempValue := FDD3000_OldDriveParas.SaturationBreakpoint3$DINT;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_OLDDRIVE_SATURATIONBREAKPOINT4:
      dTempValue := FDD3000_OldDriveParas.SaturationBreakpoint4$DINT;
    
    //properties for setup node - autotune - store node parameters (VOV Control)
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_VOV_ACTIVE:
      dTempValue := FDD3000_VOVControl1.VOV_Active$DINT;
    //*************************************************************************************    
    _FDD3000_IF_PROPERTY_ID_ACTCYCLICSTEP:
      dTempValue := FDD3000_VOVControl1.ActCyclicStep$DINT;      
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_START_LSS:
      dTempValue := FDD3000_VOVControl1.StartLSS$DINT; 
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTLLSSTEP:
      dTempValue := FDD3000_VOVControl1.ActLSSStep$DINT;      
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_SETNODEID:
      dTempValue := FDD3000_VOVControl1.SetNodeID$DINT; 
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_SETBITRATE:  
      dTempValue := FDD3000_VOVControl1.SetBitrate$DINT; 
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTSEARCHBITRATE:  
      dTempValue := FDD3000_VOVControl1.ActSearchBitrate$DINT; 
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_STARTAUTOTUNE:
      dTempValue := FDD3000_VOVControl1.StartAutotune$DINT; 
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTAUTOTUNESTEP:
      dTempValue := FDD3000_VOVControl1.ActAutotuneStep$DINT; 
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_SETDRIVEMODE:  
      dTempValue := FDD3000_VOVControl1.SetDriveMode$DINT; 
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_SETUSERMOTORPARAS:
      dTempValue := FDD3000_VOVControl1.SetUserMotorParas$DINT; 
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_DATASOURCE:
      dTempValue := FDD3000_VOVControl1.DataSource$DINT; 
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_FILESELECT:
      dTempValue := FDD3000_VOVControl1.FileSelect$DINT; 
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_MAXSPEED:
      dTempValue := FDD3000_VOVControl1.MaxSpeed$DINT; 
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_MINSPEED:
      dTempValue := FDD3000_VOVControl1.MinSpeed$DINT; 
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTLOGDATA:
      dTempValue := FDD3000_VOVControl1.ActLogData$DINT;      
   
    //*************************************************************************************
    //commands ECAT Specific 
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ECAT_CLASSSTATE:
      //property id is not available
      dRetCode := -1;
    
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ECAT_ETHERCATSTATE:
      //property id is not available
      dRetCode := -1;
    
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ECAT_SLAVESTATE:
      //property id is not available
      dRetCode := -1;
    
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ECAT_DEVICEADRESS:
      //property id is not available
      dRetCode := -1;
    
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ECAT_VENDORID:
      //property id is not available
      dRetCode := -1;
    
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ECAT_PRODUCTCODE:
      //property id is not available
      dRetCode := -1;
    
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ECAT_REVISIONNO:
      //property id is not available
      dRetCode := -1;
    
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ECAT_SERIALNO:
      //property id is not available
      dRetCode := -1;
    
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ECAT_STR_DEVICENAME:
      //property id is not available
      dRetCode := -1;
    
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ECAT_STR_PRODUCTREVISION:
      //property id is not available
      dRetCode := -1;
    
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ECAT_AL_STATUSCODE:
      //property id is not available
      dRetCode := -1;
  
  else
    //property id is not available
    dRetCode := -1;
  end_case;
  
  if (usDatalength = 4) & 
     (dRetCode = 0) & 
     (bPropertyValueSet = FALSE) then
    pPropertyValue^$DINT := dTempValue;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL FDD3000_CanOpenInt::SetProperty
	VAR_INPUT
		udPropertyID 	: UDINT;
		usDatalength 	: USINT;
		pPropertyValue 	: pVoid;
	END_VAR
	VAR_OUTPUT
		dRetCode 	: DINT;
	END_VAR
  VAR
  	dTempValue : DINT;
  END_VAR
  
  //initialize returncode
  dRetCode := 0;
  
  if pPropertyValue = NIL then
    //pointer for property value is not valid
    dRetCode := -3;
    return;
  end_if;
  
  if usDatalength < 4 then
    //minimum length of data must be 4 byte
    dRetCode := -4;
    return;
  end_if;
  
  //get temp value
  dTempValue := pPropertyValue^$DINT;
  
  if FDD3000_VOVControl1.VOV_Active = 1 then
    //class access is locked by vov control
    dRetCode := -5;
    return;
  end_if;
  
  case udPropertyID of

    //*************************************************************************************
    //*********** Get/Set Property ID's DS301:
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_DEVICE_STATE:
      //property id is read Only
      dRetCode := -2;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ERROR_QUIT:
      ErrorQuit.Write(input:=dTempValue);
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_CANDISABLED:
      //property id is read Only
      dRetCode := -2;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_DATAREADY:
      //property id is read Only
      dRetCode := -2;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ASYNCSTATE:
      //property id is read Only
      dRetCode := -2;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ERROR_SDO:
      //property id is read Only
      dRetCode := -2;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ERROR_ALLOC:
      //property id is read Only
      dRetCode := -2;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_EMCYSTATUSBYTE1:
      //property id is read Only
      dRetCode := -2;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_EMCYSTATUSBYTE2:
      //property id is read Only
      dRetCode := -2;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_PDO_DATA_1:
      //property id is not available
      dRetCode := -1;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_PDO_DATA_2: 
      //property id is not available
      dRetCode := -1;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_PDO_DATA_3:  
      //property id is not available
      dRetCode := -1;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_PDO_DATA_4:
      //property id is not available
      dRetCode := -1;


    //*************************************************************************************
    //*********** Get/Set Property ID's DS402:
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_PROFILEDRIVEMODE:
      //property id is read Only
      dRetCode := -2;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_CONTROLWORD_DS402:
      ControlWord.Write(input:=dTempValue$DS402_Control);
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_STATUSWORD_DS402:
      //property id is read Only
      dRetCode := -2;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_DRIVEERROR:
      //property id is read Only
      dRetCode := -2;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_DRIVEERRORSTATUS:
      //property id is read Only
      dRetCode := -2;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ENABLE:
      Enable.Write(input:=dTempValue);
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_POSITION:
      //property id is not available
      dRetCode := -1;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_SPEED: 
      Speed.Write(input:=dTempValue);
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_CURRENT: 
      //property id is not available
      dRetCode := -1;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_DESTINATIONPOS:
      //property id is not available
      dRetCode := -1;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_DESTINATIONSPEED:
      //property id is not available
      dRetCode := -1;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_DESTINATIONACCEL:
      //property id is not available
      dRetCode := -1;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_DESTINATIONDECEL:
      //property id is not available
      dRetCode := -1;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_STOP:
      Stop.Write(input:=dTempValue);
    
    
    //*************************************************************************************
    //*********** Get/Set Property ID's FDD3000:
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_COMM_MODE:
      //property id is read Only
      dRetCode := -2;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_STO_INPUT:
      //property id is read Only
      dRetCode := -2;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_STR_PRODUCTCODE:
      //property id is read Only
      dRetCode := -2;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_STR_SERIALNO:
      //property id is read Only
      dRetCode := -2;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_FWVERSIONDRIVE:
      //property id is read Only
      dRetCode := -2;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_FWVERSIONCOMM:
      //property id is read Only
      dRetCode := -2;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWVERSIONCOMM:
      //property id is read Only
      dRetCode := -2;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_DRIVEMODE:
      //property id is read Only
      dRetCode := -2;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_AXERROR:
      //property id is read Only
      dRetCode := -2;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_QUITAXERROR:
      ErrorQuit.Write(input:=dTempValue);
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ONLINE:
      //property id is read Only
      dRetCode := -2;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ERROR_SDO_CODE:
      //property id is read Only
      dRetCode := -2;

    //*************************************************************************************
    //act drive values on hwk:
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWK_MAXREFCLAMP:
      MaxRefClamp.Write(input:=dTempValue);
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWK_MINREFCLAMP:
      MinRefClamp.Write(input:=dTempValue);
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWK_ACCRATE:
      AccRate.Write(input:=dTempValue);
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWK_DECRATE:
      DecRate.Write(input:=dTempValue);
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWK_MOTORRATEDCURRENT:
      MotorRatedCurrent.Write(input:=dTempValue);
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWK_MOTORRATEDSPEED:
      MotorRatedSpeed.Write(input:=dTempValue);
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWK_MOTORRATEDVOLTAGE:
      MotorRatedVoltage.Write(input:=dTempValue);
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWK_MOTORRATEDPOWERFACTOR:
      MotorRatedPowerFactor.Write(input:=dTempValue);
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWK_MOTORRATEDFREQUENCY:
      MotorRatedFrequency.Write(input:=dTempValue);
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWK_LOWFREQUENCYVOLTAGEBOOST:  
      LowFrequencyVoltageBoost.Write(input:=dTempValue);
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWK_STATORRESISTANCE:  
      StatorResistance.Write(input:=dTempValue);
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWK_TRANSIENTINDUCTANCE:
      TransientInductance.Write(input:=dTempValue);
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWK_STATORINDUCTANCE:  
      StatorInductance.Write(input:=dTempValue);
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWK_MAXIMUMDEADTIMECOMP,
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWK_CURRENTATMAXIMUMDEADTIME:
      //property id is read Only
      dRetCode := -2;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWK_CURRENTLOOPKPGAIN:
      CurrentLoopKPGain.Write(input:=dTempValue);
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWK_CURRENTLOOPKIGAIN:
      CurrentLoopKiGain.Write(input:=dTempValue);
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWK_SATURATIONBREAKPOINT1:
      SaturationBreakpoint1.Write(input:=dTempValue);
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWK_SATURATIONBREAKPOINT2:
      SaturationBreakpoint2.Write(input:=dTempValue);
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWK_SATURATIONBREAKPOINT3:
      SaturationBreakpoint3.Write(input:=dTempValue);
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_HWK_SATURATIONBREAKPOINT4:
      SaturationBreakpoint4.Write(input:=dTempValue);


    //*************************************************************************************
    //act drive values:  
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTDRIVE_MAXREFCLAMP,  
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTDRIVE_MINREFCLAMP,  
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTDRIVE_ACCRATE,  
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTDRIVE_DECRATE,  
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTDRIVE_MOTORRATEDCURRENT,  
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTDRIVE_MOTORRATEDSPEED,  
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTDRIVE_MOTORRATEDVOLTAGE,  
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTDRIVE_MOTORRATEDPOWERFACTOR,  
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTDRIVE_MOTORRATEDFREQUENCY,  
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTDRIVE_LOWFREQUENCYVOLTAGEBOOST,
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTDRIVE_STATORRESISTANCE,
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTDRIVE_TRANSIENTINDUCTANCE,  
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTDRIVE_STATORINDUCTANCE,
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTDRIVE_MAXIMUMDEADTIMECOMP,  
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTDRIVE_CURRENTATMAXIMUMDEADTIME,
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTDRIVE_CURRENTLOOPKPGAIN,  
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTDRIVE_CURRENTLOOPKIGAIN,  
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTDRIVE_SATURATIONBREAKPOINT1,  
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTDRIVE_SATURATIONBREAKPOINT2,  
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTDRIVE_SATURATIONBREAKPOINT3,  
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTDRIVE_SATURATIONBREAKPOINT4: 
      //property id is read Only
      dRetCode := -2;


    //*************************************************************************************
    //old drive values:  
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_OLDDRIVE_MAXREFCLAMP,  
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_OLDDRIVE_MINREFCLAMP,  
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_OLDDRIVE_ACCRATE,  
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_OLDDRIVE_DECRATE,  
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_OLDDRIVE_MOTORRATEDCURRENT,  
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_OLDDRIVE_MOTORRATEDSPEED,  
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_OLDDRIVE_MOTORRATEDVOLTAGE,  
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_OLDDRIVE_MOTORRATEDPOWERFACTOR,  
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_OLDDRIVE_MOTORRATEDFREQUENCY,  
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_OLDDRIVE_LOWFREQUENCYVOLTAGEBOOST,
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_OLDDRIVE_STATORRESISTANCE,
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_OLDDRIVE_TRANSIENTINDUCTANCE,  
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_OLDDRIVE_STATORINDUCTANCE,
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_OLDDRIVE_MAXIMUMDEADTIMECOMP,
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_OLDDRIVE_CURRENTATMAXIMUMDEADTIME,
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_OLDDRIVE_CURRENTLOOPKPGAIN,  
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_OLDDRIVE_CURRENTLOOPKIGAIN,  
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_OLDDRIVE_SATURATIONBREAKPOINT1,  
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_OLDDRIVE_SATURATIONBREAKPOINT2,  
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_OLDDRIVE_SATURATIONBREAKPOINT3,  
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_OLDDRIVE_SATURATIONBREAKPOINT4:
      //property id is read Only
      dRetCode := -2;
    
    //*************************************************************************************    
    _FDD3000_IF_PROPERTY_ID_VOV_ACTIVE:
      //property id is read Only
      dRetCode := -2;
    //*************************************************************************************    
    _FDD3000_IF_PROPERTY_ID_ACTCYCLICSTEP:
      //property id is read Only
      dRetCode := -2;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_START_LSS:
      FDD3000_VOVControl1.StartLSS.Write(input:=dTempValue);
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTLLSSTEP:
      //property id is read Only
      dRetCode := -2;     
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_SETNODEID:
      //property id is read Only
      dRetCode := -2;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_SETBITRATE: 
      //property id is read Only
      dRetCode := -2;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTSEARCHBITRATE:
      //property id is read Only
      dRetCode := -2;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_STARTAUTOTUNE:
      FDD3000_VOVControl1.StartAutotune.Write(input:=dTempValue);
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTAUTOTUNESTEP:
      //property id is read Only
      dRetCode := -2;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_SETDRIVEMODE: 
      FDD3000_VOVControl1.SetDriveMode.Write(input:=dTempValue$FDD3000_VOVControl::eUserDriveMode); 
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_SETUSERMOTORPARAS:    
      FDD3000_VOVControl1.SetUserMotorParas.Write(input:=dTempValue);
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_DATASOURCE:
      FDD3000_VOVControl1.DataSource.Write(input:=dTempValue);
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_FILESELECT:
      FDD3000_VOVControl1.FileSelect.Write(input:=dTempValue);
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_MAXSPEED:
      //property id is read Only
      dRetCode := -2;
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_MINSPEED:
      //property id is read Only
      dRetCode := -2; 
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ACTLOGDATA:
      //property id is read Only
      dRetCode := -2;  
    
    //*************************************************************************************
    //commands ECAT Specific 
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ECAT_CLASSSTATE:
      //property id is not available
      dRetCode := -1;
    
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ECAT_ETHERCATSTATE:
      //property id is not available
      dRetCode := -1;
    
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ECAT_SLAVESTATE:
      //property id is not available
      dRetCode := -1;
    
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ECAT_DEVICEADRESS:
      //property id is not available
      dRetCode := -1;
    
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ECAT_VENDORID:
      //property id is not available
      dRetCode := -1;
    
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ECAT_PRODUCTCODE:
      //property id is not available
      dRetCode := -1;
    
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ECAT_REVISIONNO:
      //property id is not available
      dRetCode := -1;
    
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ECAT_SERIALNO:
      //property id is not available
      dRetCode := -1;
    
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ECAT_STR_DEVICENAME:
      //property id is not available
      dRetCode := -1;
    
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ECAT_STR_PRODUCTREVISION:
      //property id is not available
      dRetCode := -1;
    
    //*************************************************************************************
    _FDD3000_IF_PROPERTY_ID_ECAT_AL_STATUSCODE:
      //property id is not available
      dRetCode := -1;
    
  else
    //property id is not available
    dRetCode := -1;
  end_case;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::ControllerIF::NewInst
	VAR_INPUT
		pPara 	: ^CmdStruct;
		pResult 	: ^results;
	END_VAR
	VAR_OUTPUT
		ret_code 	: iprStates;
	END_VAR
  VAR
  	dTempRetCode : DINT;
  END_VAR
  
  ret_code := ERROR;
  
  case pPara^.uiCmd of
    //*************************************************************************************
    _FDD3000_IF_GET_PROPERTY:
      if pPara^.aPara[0] >= _FDD3000_IF_PROTOCOLVERSION then
        dTempRetCode := GetProperty(udPropertyID:=pPara^.aPara[1]$UDINT, usDatalength:=pPara^.aPara[2]$USINT, pPropertyValue:=pPara^.aPara[3]$pVoid);
        
        pResult^.aData[0]$HINT := _FDD3000_IF_PROTOCOLVERSION;
        pResult^.aData[2]$DINT := dTempRetCode;
        pResult^.uiLng         := sizeof(HINT)+sizeof(DINT);
        ret_code := READY;
      end_if;

    //*************************************************************************************
    _FDD3000_IF_SET_PROPERTY:
      if pPara^.aPara[0] >= _FDD3000_IF_PROTOCOLVERSION then
        dTempRetCode := SetProperty(udPropertyID:=pPara^.aPara[1]$UDINT, usDatalength:=pPara^.aPara[2]$USINT, pPropertyValue:=pPara^.aPara[3]$pVoid);
        pResult^.aData[0]$HINT := _FDD3000_IF_PROTOCOLVERSION;
        pResult^.aData[2]$DINT := dTempRetCode;
        pResult^.uiLng         := sizeof(HINT)+sizeof(DINT);
        ret_code := READY;
      end_if;      
      
    //*************************************************************************************
    _FDD3000_IF_LOGDATA_GETFILEPOINTER:
      if pPara^.aPara[0] >= _FDD3000_IF_PROTOCOLVERSION then
        pResult^.aData[0]$HINT := _FDD3000_IF_PROTOCOLVERSION;
        pResult^.aData[2]$DINT := GetLogFile()$DINT;
        pResult^.uiLng         := sizeof(HINT)+sizeof(DINT);          
        ret_code := READY; 
      end_if;

    //*************************************************************************************
    _FDD3000_IF_LOGDATA_CLEARLOGBUFFER:
      if pPara^.aPara[0] >= _FDD3000_IF_PROTOCOLVERSION then
        sLogFile.AccesNr := 0;
        FDD3000_VOVControl1.ActLogData := 0;
        pResult^.aData[0]$HINT := _FDD3000_IF_PROTOCOLVERSION;
        pResult^.uiLng         := sizeof(HINT);          
        ret_code := READY; 
      end_if;          
    
    //*************************************************************************************
    _FDD3000_IF_FH_SETFILENAME:
      if pPara^.aPara[0] >= _FDD3000_IF_PROTOCOLVERSION then
        dTempRetCode := toFDD3000FileHandling.SetFileName(pName:=pPara^.aPara[1]$^CHAR, pDirectory:=pPara^.aPara[2]$^CHAR);        
        pResult^.aData[0]$HINT := _FDD3000_IF_PROTOCOLVERSION;
        pResult^.aData[2]$DINT := dTempRetCode;
        pResult^.uiLng         := sizeof(HINT)+sizeof(DINT);
        ret_code := READY;
      end_if;    
    
  else
    ret_code := ERROR;
    
  end_case;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::MaxRefClamp::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input > FDD3000_PARA_MAXIMUM_SPEED_FREQ then
    input := FDD3000_PARA_MAXIMUM_SPEED_FREQ;
  elsif input < 0 then
    input := 0;
  end_if;

	MaxRefClamp := input;
  
  dRetCodeResp := SDOCyclicAdd( bRW:=TRUE
                          , usLen:=4
                          , hiIndex:=FDD3000_MENU_01_FREQ_REFERENCE
                          , usSubIndex:=FDD3000_01_PARA_MAX_REF_CLAMP
                          , dData:=input
                          , eSendMode:=_SendOnce);    

  FDD3000_HWKDriveParas.MaxRefClamp.Write(input:=input);                          
	result := MaxRefClamp;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::MinRefClamp::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input > MaxRefClamp then
    input := MaxRefClamp;
  elsif input < 0 then
    input := 0;
  end_if;
  
	MinRefClamp := input;
  
  dRetCodeResp := SDOCyclicAdd( bRW:=TRUE
                          , usLen:=4
                          , hiIndex:=FDD3000_MENU_01_FREQ_REFERENCE
                          , usSubIndex:=FDD3000_01_PARA_MIN_REF_CLAMP
                          , dData:=input
                          , eSendMode:=_SendOnce);
                          
  FDD3000_HWKDriveParas.MinRefClamp.Write(input:=input);
	result := MinRefClamp;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::AccRate::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input > FDD3000_PARA_MAXIMUM_ACC_DEC_RATE then
    input := FDD3000_PARA_MAXIMUM_ACC_DEC_RATE;
  elsif input < 0 then
    input := 0;
  end_if;
  
	AccRate := input;
  
  dRetCodeResp := SDOCyclicAdd( bRW:=TRUE
                          , usLen:=4
                          , hiIndex:=FDD3000_MENU_02_FREQ_RAMPS
                          , usSubIndex:=FDD3000_02_PARA_ACCRATE
                          , dData:=input
                          , eSendMode:=_SendOnce);
  
  FDD3000_HWKDriveParas.AccRate.Write(input:=input);
	result := AccRate;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::DecRate::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input > FDD3000_PARA_MAXIMUM_ACC_DEC_RATE then
    input := FDD3000_PARA_MAXIMUM_ACC_DEC_RATE;
  elsif input < 0 then
    input := 0;
  end_if;
  
	DecRate := input;
  
  dRetCodeResp := SDOCyclicAdd( bRW:=TRUE
                          , usLen:=4
                          , hiIndex:=FDD3000_MENU_02_FREQ_RAMPS
                          , usSubIndex:=FDD3000_02_PARA_DEC_RATE
                          , dData:=input
                          , eSendMode:=_SendOnce);
  
  FDD3000_HWKDriveParas.DecRate.Write(input:=input);
	result := DecRate;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::MotorRatedCurrent::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	MotorRatedCurrent := input;
  
  dRetCodeResp := SDOCyclicAdd( bRW:=TRUE
                          , usLen:=4
                          , hiIndex:=FDD3000_MENU_05_MOTOR_CONTROL
                          , usSubIndex:=FDD3000_05_PARA_MOTOR_CURR
                          , dData:=input
                          , eSendMode:=_SendOnce);
                          
  FDD3000_HWKDriveParas.MotorRatedCurrent.Write(input:=input);
	result := MotorRatedCurrent;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::MotorRatedSpeed::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input > FDD3000_PARA_MAXIMUM_SPEED_RPM then
    input := FDD3000_PARA_MAXIMUM_SPEED_RPM;
  elsif input < 0 then
    input := 0;
  end_if;
  
	MotorRatedSpeed := input;
  
  dRetCodeResp := SDOCyclicAdd( bRW:=TRUE
                          , usLen:=4
                          , hiIndex:=FDD3000_MENU_05_MOTOR_CONTROL
                          , usSubIndex:=FDD3000_05_PARA_MOTOR_SPEED
                          , dData:=input
                          , eSendMode:=_SendOnce);
                          
  FDD3000_HWKDriveParas.MotorRatedSpeed.Write(input:=input);
  //set actual max and min speed for display at vov
  FDD3000_VOVControl1.MaxSpeed := MotorRatedSpeed/10;
  FDD3000_VOVControl1.MinSpeed := -MotorRatedSpeed/10;
	result := MotorRatedSpeed;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::MotorRatedVoltage::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input > FDD3000_PARA_MAXIMUM_VOLTAGE then
    input := FDD3000_PARA_MAXIMUM_VOLTAGE;
  elsif input < 0 then
    input := 0;
  end_if;
  
	MotorRatedVoltage := input;
  
  dRetCodeResp := SDOCyclicAdd( bRW:=TRUE
                          , usLen:=2
                          , hiIndex:=FDD3000_MENU_05_MOTOR_CONTROL
                          , usSubIndex:=FDD3000_05_PARA_MOTOR_VOLTAGE
                          , dData:=input
                          , eSendMode:=_SendOnce);
                          
  FDD3000_HWKDriveParas.MotorRatedVoltage.Write(input:=input);
	result := MotorRatedVoltage;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::MotorRatedPowerFactor::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
  //if stator inductance is <> 0 then motor power factor is calculated by the drive
  if FDD3000_HWKDriveParas.StatorInductance = 0 then
  
    if input > FDD3000_PARA_MAXIMUM_POWERFACTOR then
      input := FDD3000_PARA_MAXIMUM_POWERFACTOR;
    elsif input < 0 then
      input := 0;
    end_if;
    
    dRetCodeResp := SDOCyclicAdd( bRW:=TRUE
                            , usLen:=2
                            , hiIndex:=FDD3000_MENU_05_MOTOR_CONTROL
                            , usSubIndex:=FDD3000_05_PARA_MOTOR_POWERFACTOR
                            , dData:=input
                            , eSendMode:=_SendOnce);
    

  else
    //set motor rated power factor from drive
    input := FDD3000_ActDriveParas.MotorRatedPowerFactor;
  end_if;
  
  //set value on server
  MotorRatedPowerFactor := input;  
  FDD3000_HWKDriveParas.MotorRatedPowerFactor.Write(input:=input);
  result := MotorRatedPowerFactor;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::MotorRatedFrequency::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input > FDD3000_PARA_MAXIMUM_SPEED_FREQ then
    input := FDD3000_PARA_MAXIMUM_SPEED_FREQ;
  elsif input < 0 then
    input := 0;
  end_if;
    
	MotorRatedFrequency := input;
  
  dRetCodeResp := SDOCyclicAdd( bRW:=TRUE
                          , usLen:=4
                          , hiIndex:=FDD3000_MENU_05_MOTOR_CONTROL
                          , usSubIndex:=FDD3000_05_PARA_MOTOR_FREQ
                          , dData:=input
                          , eSendMode:=_SendOnce);
                          
  FDD3000_HWKDriveParas.MotorRatedFrequency.Write(input:=input);
	result := MotorRatedFrequency;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::LowFrequencyVoltageBoost::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input > FDD3000_PARA_MAXIMUM_FREQVOLTAGEBOOST then
    input := FDD3000_PARA_MAXIMUM_FREQVOLTAGEBOOST;
  elsif input < 0 then
    input := 0;
  end_if;
  
	LowFrequencyVoltageBoost := input;
  
  dRetCodeResp := SDOCyclicAdd( bRW:=TRUE
                          , usLen:=2
                          , hiIndex:=FDD3000_MENU_05_MOTOR_CONTROL
                          , usSubIndex:=FDD3000_05_PARA_LOWFREQVOLBOOST
                          , dData:=input
                          , eSendMode:=_SendOnce);
                          
	result := (FDD3000_HWKDriveParas.LowFrequencyVoltageBoost.Write(LowFrequencyVoltageBoost))$DINT;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::StatorResistance::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input > FDD3000_PARA_MAXIMUM_STATORRESISTANCE then
    input := FDD3000_PARA_MAXIMUM_STATORRESISTANCE;
  elsif input < 0 then
    input := 0;
  end_if;
  
	StatorResistance := input;
  
  dRetCodeResp := SDOCyclicAdd( bRW:=TRUE
                          , usLen:=4
                          , hiIndex:=FDD3000_MENU_05_MOTOR_CONTROL
                          , usSubIndex:=FDD3000_05_PARA_STATOR_RESISTANCE
                          , dData:=input
                          , eSendMode:=_SendOnce);
                            
	result := (FDD3000_HWKDriveParas.StatorResistance.Write(StatorResistance))$DINT;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::TransientInductance::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input > FDD3000_PARA_MAXIMUM_TRANSIENTINDUCTANCE then
    input := FDD3000_PARA_MAXIMUM_TRANSIENTINDUCTANCE;
  elsif input < 0 then
    input := 0;
  end_if;
  
	TransientInductance := input;
  
  dRetCodeResp := SDOCyclicAdd( bRW:=TRUE
                          , usLen:=4
                          , hiIndex:=FDD3000_MENU_05_MOTOR_CONTROL
                          , usSubIndex:=FDD3000_05_PARA_TRANSIENT_INDUCTANCE
                          , dData:=input
                          , eSendMode:=_SendOnce);
  
	result := (FDD3000_HWKDriveParas.TransientInductance.Write(TransientInductance))$DINT;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::StatorInductance::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input > FDD3000_PARA_MAXIMUM_STATORINDUCTANCE then
    input := FDD3000_PARA_MAXIMUM_STATORINDUCTANCE;
  elsif input < 0 then
    input := 0;
  end_if;
  
	StatorInductance := input;
  
  dRetCodeResp := SDOCyclicAdd( bRW:=TRUE
                          , usLen:=4
                          , hiIndex:=FDD3000_MENU_05_MOTOR_CONTROL
                          , usSubIndex:=FDD3000_05_PARA_STATOR_INDUCTANCE
                          , dData:=input
                          , eSendMode:=_SendOnce);
  
	result := (FDD3000_HWKDriveParas.StatorInductance.Write(StatorInductance))$DINT;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::CurrentLoopKPGain::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input > FDD3000_PARA_MAXIMUM_KPGAIN then
    input := FDD3000_PARA_MAXIMUM_KPGAIN;
  elsif input < 0 then
    input := 0;
  end_if;
  
	CurrentLoopKPGain := input;
  
  //parameter is only at RFC-A Mode used
  if OPModeDrive = FDD3000_VOVControl::_RFC_A then  
    dRetCodeResp := SDOCyclicAdd( bRW:=TRUE
                            , usLen:=4
                            , hiIndex:=FDD3000_MENU_04_TOURQUE_CURRENT
                            , usSubIndex:=FDD3000_04_PARA_CURRLOOP_KPGAIN
                            , dData:=input
                            , eSendMode:=_SendOnce);
  
  end_if;
    
	result := (FDD3000_HWKDriveParas.CurrentLoopKPGain.Write(CurrentLoopKPGain))$DINT;

END_FUNCTION



FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::CurrentLoopKiGain::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input > FDD3000_PARA_MAXIMUM_KIGAIN then
    input := FDD3000_PARA_MAXIMUM_KIGAIN;
  elsif input < 0 then
    input := 0;
  end_if;
  
	CurrentLoopKiGain := input;
  
  //parameter is only at RFC-A Mode used
  if OPModeDrive = FDD3000_VOVControl::_RFC_A then  
    dRetCodeResp := SDOCyclicAdd( bRW:=TRUE
                            , usLen:=4
                            , hiIndex:=FDD3000_MENU_04_TOURQUE_CURRENT
                            , usSubIndex:=FDD3000_04_PARA_CURRLOOP_KIGAIN
                            , dData:=input
                            , eSendMode:=_SendOnce);
   end_if;                         
  
	result := (FDD3000_HWKDriveParas.CurrentLoopKiGain.Write(CurrentLoopKiGain))$DINT;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::SaturationBreakpoint1::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input > FDD3000_PARA_MAXIMUM_SATURATIONBREAKP then
    input := FDD3000_PARA_MAXIMUM_SATURATIONBREAKP;
  elsif input < 0 then
    input := 0;
  end_if;
  
	SaturationBreakpoint1 := input;
  
  //parameter is only at RFC-A Mode used
  if OPModeDrive = FDD3000_VOVControl::_RFC_A then  
    dRetCodeResp := SDOCyclicAdd( bRW:=TRUE
                            , usLen:=2
                            , hiIndex:=FDD3000_MENU_05_MOTOR_CONTROL
                            , usSubIndex:=FDD3000_05_PARA_SAT_BREAKPOINT1
                            , dData:=input
                            , eSendMode:=_SendOnce);
   end_if;                         
                            
	result := (FDD3000_HWKDriveParas.SaturationBreakpoint1.Write(SaturationBreakpoint1))$DINT;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::SaturationBreakpoint3::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input > FDD3000_PARA_MAXIMUM_SATURATIONBREAKP then
    input := FDD3000_PARA_MAXIMUM_SATURATIONBREAKP;
  elsif input < 0 then
    input := 0;
  end_if;
  
	SaturationBreakpoint3 := input;
  
  //parameter is only at RFC-A Mode used
  if OPModeDrive = FDD3000_VOVControl::_RFC_A then  
    dRetCodeResp := SDOCyclicAdd( bRW:=TRUE
                            , usLen:=2
                            , hiIndex:=FDD3000_MENU_05_MOTOR_CONTROL
                            , usSubIndex:=FDD3000_05_PARA_SAT_BREAKPOINT3
                            , dData:=input
                            , eSendMode:=_SendOnce);
   end_if;                         
                              
	result := (FDD3000_HWKDriveParas.SaturationBreakpoint3.Write(SaturationBreakpoint3))$DINT;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::SaturationBreakpoint2::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input > FDD3000_PARA_MAXIMUM_SATURATIONBREAKP then
    input := FDD3000_PARA_MAXIMUM_SATURATIONBREAKP;
  elsif input < 0 then
    input := 0;
  end_if;
  
	SaturationBreakpoint2 := input;
  
  //parameter is only at RFC-A Mode used
  if OPModeDrive = FDD3000_VOVControl::_RFC_A then  
    dRetCodeResp := SDOCyclicAdd( bRW:=TRUE
                            , usLen:=2
                            , hiIndex:=FDD3000_MENU_05_MOTOR_CONTROL
                            , usSubIndex:=FDD3000_05_PARA_SAT_BREAKPOINT2
                            , dData:=input
                            , eSendMode:=_SendOnce);
   end_if;                         
    
	result := (FDD3000_HWKDriveParas.SaturationBreakpoint2.Write(SaturationBreakpoint2))$DINT;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::SaturationBreakpoint4::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input > FDD3000_PARA_MAXIMUM_SATURATIONBREAKP then
    input := FDD3000_PARA_MAXIMUM_SATURATIONBREAKP;
  elsif input < 0 then
    input := 0;
  end_if;
  
	SaturationBreakpoint4 := input;
  
  //parameter is only at RFC-A Mode used
  if OPModeDrive = FDD3000_VOVControl::_RFC_A then  
    dRetCodeResp := SDOCyclicAdd( bRW:=TRUE
                            , usLen:=2
                            , hiIndex:=FDD3000_MENU_05_MOTOR_CONTROL
                            , usSubIndex:=FDD3000_05_PARA_SAT_BREAKPOINT4
                            , dData:=input
                            , eSendMode:=_SendOnce);
   end_if;                         
                              
	result := (FDD3000_HWKDriveParas.SaturationBreakpoint4.Write(SaturationBreakpoint4))$DINT;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::MaxRefClamp::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	MaxRefClamp := FDD3000_HWKDriveParas.MaxRefClamp.Read();
	output := MaxRefClamp;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::MinRefClamp::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	MinRefClamp := FDD3000_HWKDriveParas.MinRefClamp.Read();
	output := MinRefClamp;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::AccRate::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	AccRate := FDD3000_HWKDriveParas.AccRate.Read();
	output := AccRate;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::DecRate::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	DecRate := FDD3000_HWKDriveParas.DecRate.Read();
	output := DecRate;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::MotorRatedCurrent::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	MotorRatedCurrent := FDD3000_HWKDriveParas.MotorRatedCurrent.Read();
	output := MotorRatedCurrent;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::MotorRatedSpeed::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	MotorRatedSpeed := FDD3000_HWKDriveParas.MotorRatedSpeed.Read();
	output := MotorRatedSpeed;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::MotorRatedVoltage::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	MotorRatedVoltage := FDD3000_HWKDriveParas.MotorRatedVoltage.Read();
	output := MotorRatedVoltage;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::MotorRatedPowerFactor::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	MotorRatedPowerFactor := FDD3000_HWKDriveParas.MotorRatedPowerFactor.Read();
	output := MotorRatedPowerFactor;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::MotorRatedFrequency::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	MotorRatedFrequency := FDD3000_HWKDriveParas.MotorRatedFrequency.Read();
	output := MotorRatedFrequency;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::LowFrequencyVoltageBoost::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	LowFrequencyVoltageBoost := FDD3000_HWKDriveParas.LowFrequencyVoltageBoost.Read();
	output := LowFrequencyVoltageBoost;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::StatorResistance::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	StatorResistance := FDD3000_HWKDriveParas.StatorResistance.Read();
	output := StatorResistance;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::TransientInductance::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	TransientInductance := FDD3000_HWKDriveParas.TransientInductance.Read();
	output := TransientInductance;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::StatorInductance::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	StatorInductance := FDD3000_HWKDriveParas.StatorInductance.Read();
	output := StatorInductance;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::MaximumDeadTimeComp::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	MaximumDeadTimeComp := FDD3000_HWKDriveParas.MaximumDeadTimeComp.Read();
	output := MaximumDeadTimeComp;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::CurrentAtMaximumDeadTime::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	CurrentAtMaximumDeadTime := FDD3000_HWKDriveParas.CurrentAtMaximumDeadTime.Read();
	output := CurrentAtMaximumDeadTime;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::CurrentLoopKPGain::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	CurrentLoopKPGain := FDD3000_HWKDriveParas.CurrentLoopKPGain.Read();
	output := CurrentLoopKPGain;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::CurrentLoopKiGain::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	CurrentLoopKiGain := FDD3000_HWKDriveParas.CurrentLoopKiGain.Read();
	output := CurrentLoopKiGain;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::SaturationBreakpoint1::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	SaturationBreakpoint1 := FDD3000_HWKDriveParas.SaturationBreakpoint1.Read();
	output := SaturationBreakpoint1;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::SaturationBreakpoint3::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	SaturationBreakpoint3 := FDD3000_HWKDriveParas.SaturationBreakpoint3.Read();
	output := SaturationBreakpoint3;

END_FUNCTION



FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::SaturationBreakpoint2::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	SaturationBreakpoint2 := FDD3000_HWKDriveParas.SaturationBreakpoint2.Read();
	output := SaturationBreakpoint2;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL FDD3000_CanOpenInt::SaturationBreakpoint4::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	SaturationBreakpoint4 := FDD3000_HWKDriveParas.SaturationBreakpoint4.Read();
	output := SaturationBreakpoint4;

END_FUNCTION


FUNCTION VIRTUAL FDD3000_CanOpenInt::GetLogFile
	VAR_OUTPUT
		ptrLogFile 	: ^FDD3000AxisVis::_LogFile;
	END_VAR
  
  //get pointer to Logdata
  ptrLogFile := #sLogFile;  
  
END_FUNCTION


FUNCTION FDD3000_CanOpenInt::AlarmListLogger
	VAR_INPUT
		Command 	: FDD3000AxisVis::_CommandList;
		TripCode 	: FDD3000AxisVis::_LogData_TripCode;
	END_VAR
  VAR
  	pLogFile : ^FDD3000AxisVis::_LogStruct;
  END_VAR
  
  //don't log errors occured directly after error quit
  if (ops.tAbsolute-TimeStampResetFault) < 200 then
    return;
  end_if;

	if sLogFile.Logmode <> 0 then 
  
    pLogFile := #sLogFile.LogData[sLogFile.AccesNr];
		
    sLogFile.AccesNr+=1;
    FDD3000_VOVControl1.ActLogData := sLogFile.AccesNr;
    
		if sLogFile.AccesNr > 100 then 
      sLogFile.AccesNr:= 0;
		end_if;

		pLogFile^.Command:=Command;
    
		pLogFile^.TripCode :=TripCode;

    pLogFile^.TimeStamp:=ops.tAbsolute;

		pLogFile^.RTStamp:=OS_GETMICROSEC();

	end_if;

END_FUNCTION