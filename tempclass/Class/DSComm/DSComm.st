//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define _DEBUG_DSCOMM

#define DS_NI				1				// network interface

#define DS_PORTNUMBER_		9981
#define DS_MAX_CHANNEL   1023

#define DS_CONNECT_TIMEOUT  2000

#define DS_RECV_TIMEOUT		  5000		  // Timeout (ms) für recv

#define DS_SEND_TIMEOUT		  2000
#define DS_SEND_TIMEOUT_CNT	20

#define DS_RESP_TIMEOUT		  10000     //Response Timeout 10s
#define DS_RESP_TIMEOUT_LONG 300000    //300000 ms = 5 min. FileContent() für 4GB dauert ca. 9 min.

#define DS_TCPCom_AliveSignalTime      9900  //1237 ms
#define DS_TCPCom_AliveSignalTimeout   35000 //3000    //ms
#define DS_TCPCom_NewConnectionTime    5000  //ms

#define DS_RECORD_NO_PIPE   16

// defines for creating the parallel task
#define DS_TCPCom_TaskPrio         11                          // priority of the parallel task

//*----------------------------------------------------------------------------------------------------------------------*//
#define DS_PROGRESS_INFO_ELMT_CNT   256   //Anzahl der Elemente in ProgressInfo[]
#define DS_PROGRESS_INFO_DIST       4     //Distanz zwischen den Indices in ProgressInfo[]
#define DS_HANDLE_ID_FREE           0xFFFFFFFF$DINT

#define DS_MAJOR_ID_ELMT_CNT  4096    //Anzahl der Elemente in UserEvent_MajorID[]
#define DS_MAJOR_ID_DIST      8       //Distanz zwischen den Indices im Puffer für MajorIDs
#define DS_MINOR_ID_ELMT_CNT  1024    //Anzahl der Elemente in UserEvent_MinorID[]
#define DS_MINOR_ID_DIST      4       //Distanz zwischen den Indices im Puffer für MinorIDs

#define DS_ALL_MINOR_IDs_VALID 0xFFFF //Alle MinorIDs sind gültig

#define AddEventJournalHeaderSize    (sizeof(DSComm::_DS_EventjournalAddCmd) - sizeof(DSComm::_DS_EventjournalAddCmd.pData))
#define GetEventJournalHeaderSize1   (sizeof(DSComm::_DS_EventjournalGetResp) - sizeof(DSComm::_DS_EventjournalGetResp.pData))
#define GetEventJournalHeaderSize2   (sizeof(DSComm::_DS_EventjournalGetResp.Id) + sizeof(DSComm::_DS_EventjournalGetResp.nc) + sizeof(DSComm::_DS_EventjournalGetResp.EvtTime) + sizeof(DSComm::_DS_EventjournalGetResp.EvtDate) + sizeof(DSComm::_DS_EventjournalGetResp.SessionID))
#define GetEventJournalHeaderSize3   (sizeof(DSComm::_DS_EventjournalGetResp.crc) + sizeof(DSComm::_DS_EventjournalGetResp.idxcnt) + sizeof(DSComm::_DS_EventjournalGetResp.valid) + sizeof(DSComm::_DS_EventjournalGetResp.DataLen))
#define EvtJournalEntryValid          0xFF

#define AliveTrigger_BUFFER_SIZE              sizeof(DSComm::_DS_HEADER)
#define CancelCommand_BUFFER_SIZE             sizeof(DSComm::_DS_HEADER) + sizeof(HandleID)
#define GetVersion_BUFFER_SIZE                sizeof(DSComm::_DS_HEADER)
//#define GetProjectName_BUFFER_SIZE            sizeof(DSComm::_DS_HEADER)
#define GetProjectInfo_BUFFER_SIZE            sizeof(DSComm::_DS_HEADER)
//#define StateUpdate_BUFFER_SIZE               sizeof(DSComm::_DS_HEADER) + 1024
//#define Loop_BUFFER_SIZE                      sizeof(DSComm::_DS_Header) + sizeof(DSComm::_DS_FragmentHeader) + sizeof(DSComm::_DS_Header) + sizeof(Station) + 1024     //1024 data bytes
//#define RecipeLoad_BUFFER_SIZE                sizeof(DSComm::_DS_Header) + sizeof(pFilterIncl^) + sizeof(pFilterExcl^) + sizeof(crc) + 1024
//#define RecipeSave_BUFFER_SIZE                sizeof(DSComm::_DS_Header) + sizeof(DSComm::_DS_FragmentHeader) + sizeof(DSComm::_DS_Header) + sizeof(pFilterIncl^) + sizeof(pFilterExcl^) + 1024
//#define SendToAll_BUFFER_SIZE                 sizeof(DSComm::_DS_Header) + 1024                       //1024 data bytes
#define ResetDataservice_BUFFER_SIZE          sizeof(DSComm::_DS_HEADER)
#define RestartDataservice_BUFFER_SIZE        sizeof(DSComm::_DS_HEADER)
//#define AddLocalClient_BUFFER_SIZE            sizeof(DSComm::_DS_Header) + 1024
//#define AddLocalClientRange_BUFFER_SIZE       sizeof(DSComm::_DS_Header) + 1024
#define RemoveThisLocalClient_BUFFER_SIZE     sizeof(DSComm::_DS_Header)
//#define RemoveLocalClient_BUFFER_SIZE         sizeof(DSComm::_DS_Header) + 1024
//#define RemoveLocalClientRange_BUFFER_SIZE    sizeof(DSComm::_DS_Header) + 1024
#define ClearLocalClientList_BUFFER_SIZE      sizeof(DSComm::_DS_Header)
#define GetCurrentID_BUFFER_SIZE              sizeof(DSComm::_DS_Header)
#define GetLocalClientList_BUFFER_SIZE        sizeof(DSComm::_DS_Header)
#define GetLocalClientListDetails_BUFFER_SIZE sizeof(DSComm::_DS_Header)
//#define GetLocalClientByID_BUFFER_SIZE        sizeof(DSComm::_DS_Header) + 1024
#define SendFragmentResponse_BUFFER_SIZE      sizeof(DSComm::_DS_HEADER) + sizeof(UID) + sizeof(ErrorCode)
//#define UserLogin_BUFFER_SIZE                 sizeof(DSComm::_DS_Header) + 1024
#define UserLogout_BUFFER_SIZE                sizeof(DSComm::_DS_HEADER)
//#define UserPasswordChange_BUFFER_SIZE        sizeof(DSComm::_DS_Header) + 1024
//#define CheckAccessLevel_BUFFER_SIZE          sizeof(DSComm::_DS_Header) + sizeof(DSComm::_DS_FragmentHeader) + sizeof(DSComm::_DS_Header) + sizeof(num) + 1026         //171 users
//#define CreateUser_BUFFER_SIZE                sizeof(DSComm::_DS_Header) + sizeof(DSComm::_DS_FragmentHeader) + sizeof(DSComm::_DS_Header) + sizeof(num) + 1024
//#define ChangeUserSettings_BUFFER_SIZE        sizeof(DSComm::_DS_Header) + sizeof(DSComm::_DS_FragmentHeader) + sizeof(DSComm::_DS_Header) + sizeof(num) + 1024
//#define DeleteUser_BUFFER_SIZE                sizeof(DSComm::_DS_Header) + sizeof(DSComm::_DS_FragmentHeader) + sizeof(DSComm::_DS_Header) + sizeof(num) + 1024         //256 users
#define GetUserList_BUFFER_SIZE               sizeof(DSComm::_DS_HEADER)
#define GetUserDetails_BUFFER_SIZE            sizeof(DSComm::_DS_HEADER) + sizeof(userID)
//#define CreateRole_BUFFER_SIZE                sizeof(DSComm::_DS_Header) + sizeof(DSComm::_DS_FragmentHeader) + sizeof(DSComm::_DS_Header) + sizeof(num) + 1024
//#define ChangeRole_BUFFER_SIZE                sizeof(DSComm::_DS_Header) + sizeof(DSComm::_DS_FragmentHeader) + sizeof(DSComm::_DS_Header) + sizeof(num) + 1024
//#define DeleteRole_BUFFER_SIZE                sizeof(DSComm::_DS_Header) + sizeof(DSComm::_DS_FragmentHeader) + sizeof(DSComm::_DS_Header) + sizeof(num) + 1024         //256 roles
#define GetRoleList_BUFFER_SIZE               sizeof(DSComm::_DS_HEADER)
#define GetRoleDetails_BUFFER_SIZE            sizeof(DSComm::_DS_HEADER) + sizeof(roleID)
//#define GetVarIdFromName_BUFFER_SIZE          sizeof(DSComm::_DS_Header) + sizeof(DSComm::_DS_FragmentHeader) + sizeof(DSComm::_DS_Header) + sizeof(num) + 1024
//#define GetVarIdFromLasalId_BUFFER_SIZE       sizeof(DSComm::_DS_Header) + sizeof(DSComm::_DS_FragmentHeader) + sizeof(DSComm::_DS_Header) + sizeof(num) + 1024         //128 Lasal-IDs
//#define GetLasalIdFromName_BUFFER_SIZE        sizeof(DSComm::_DS_Header) + sizeof(DSComm::_DS_FragmentHeader) + sizeof(DSComm::_DS_Header) + sizeof(num) + 1024
//#define GetLasalIdFromVarId_BUFFER_SIZE       sizeof(DSComm::_DS_Header) + sizeof(DSComm::_DS_FragmentHeader) + sizeof(DSComm::_DS_Header) + sizeof(num) + 1024         //256 Var-IDs
//#define GetNameFromVarId_BUFFER_SIZE          sizeof(DSComm::_DS_Header) + sizeof(DSComm::_DS_FragmentHeader) + sizeof(DSComm::_DS_Header) + sizeof(num) + 1024         //256 Var-IDs
//#define GetNameFromLasalId_BUFFER_SIZE        sizeof(DSComm::_DS_Header) + sizeof(DSComm::_DS_FragmentHeader) + sizeof(DSComm::_DS_Header) + sizeof(num) + 1024         //128 Lasal-IDs
#define GetDpList_BUFFER_SIZE                 sizeof(DSComm::_DS_HEADER) + sizeof(pFilterIncl^) + sizeof(pFilterExcl^)
//#define GetDpInfo_BUFFER_SIZE                 sizeof(DSComm::_DS_Header) + sizeof(DSComm::_DS_FragmentHeader) + sizeof(DSComm::_DS_Header) + sizeof(num) + 1024         //256 Var-IDs
//#define GetVarIdFromCRC_BUFFER_SIZE           sizeof(DSComm::_DS_Header) + sizeof(DSComm::_DS_FragmentHeader) + sizeof(DSComm::_DS_Header) + sizeof(num) + 1024         //256 CRCs
//#define GetCRCfromVarId_BUFFER_SIZE           sizeof(DSComm::_DS_Header) + sizeof(DSComm::_DS_FragmentHeader) + sizeof(DSComm::_DS_Header) + sizeof(num) + 1024         //256 Var-IDs
//#define GetValue_BUFFER_SIZE                  sizeof(DSComm::_DS_Header) + sizeof(DSComm::_DS_FragmentHeader) + sizeof(DSComm::_DS_Header) + sizeof(num) + 1024         //128 data points
//#define GetString_BUFFER_SIZE                 sizeof(DSComm::_DS_Header) + sizeof(DSComm::_DS_FragmentHeader) + sizeof(DSComm::_DS_Header) + sizeof(num) + 1024         //128 strings
//#define SetValue_BUFFER_SIZE                  sizeof(DSComm::_DS_Header) + sizeof(DSComm::_DS_FragmentHeader) + sizeof(DSComm::_DS_Header) + sizeof(num) + 1032         //86 data points
//#define SetString_BUFFER_SIZE                 sizeof(DSComm::_DS_Header) + sizeof(DSComm::_DS_FragmentHeader) + sizeof(DSComm::_DS_Header) + sizeof(num) + 1024
//#define IncValue_BUFFER_SIZE                  sizeof(DSComm::_DS_Header) + sizeof(DSComm::_DS_FragmentHeader) + sizeof(DSComm::_DS_Header) + sizeof(num) + 1024         //256 data points
//#define DecValue_BUFFER_SIZE                  sizeof(DSComm::_DS_Header) + sizeof(DSComm::_DS_FragmentHeader) + sizeof(DSComm::_DS_Header) + sizeof(num) + 1024         //256 data points
//#define RefListAdd_BUFFER_SIZE                sizeof(DSComm::_DS_Header) + sizeof(DSComm::_DS_FragmentHeader) + sizeof(DSComm::_DS_Header) + sizeof(channel) + sizeof(num) + 1024     //256 data points
//#define RefListSub_BUFFER_SIZE                sizeof(DSComm::_DS_Header) + sizeof(DSComm::_DS_FragmentHeader) + sizeof(DSComm::_DS_Header) + sizeof(channel) + sizeof(num) + 1024     //256 data points
#define GetStationList_BUFFER_SIZE            sizeof(DSComm::_DS_HEADER)
//#define GetStationStatus_BUFFER_SIZE          sizeof(DSComm::_DS_Header) + sizeof(DSComm::_DS_FragmentHeader) + sizeof(DSComm::_DS_Header) + sizeof(num) + 1024         //256 stations
//#define FileOpen_BUFFER_SIZE                  sizeof(DSComm::_DS_Header) + 1024
#define FileClose_BUFFER_SIZE                 sizeof(DSComm::_DS_HEADER) + sizeof(handle)
#define FileSeek_BUFFER_SIZE                  sizeof(DSComm::_DS_HEADER) + sizeof(handle) + sizeof(start) + sizeof(offset)
#define FileTell_BUFFER_SIZE                  sizeof(DSComm::_DS_HEADER) + sizeof(handle)
#define FileRead_BUFFER_SIZE                  sizeof(DSComm::_DS_HEADER) + sizeof(handle) + sizeof(length)
//#define FileWrite_BUFFER_SIZE                 sizeof(DSComm::_DS_Header) + sizeof(DSComm::_DS_FragmentHeader) + sizeof(DSComm::_DS_Header) + sizeof(handle) + sizeof(length) + 1024   //1024 data bytes
#define FileGet_BUFFER_SIZE                   sizeof(DSComm::_DS_HEADER) + sizeof(handle) + sizeof(length)
//#define FilePut_BUFFER_SIZE                   sizeof(DSComm::_DS_Header) + sizeof(DSComm::_DS_FragmentHeader) + sizeof(DSComm::_DS_Header) + sizeof(handle) + 1024                    //1024 data bytes
#define FileLength_BUFFER_SIZE                sizeof(DSComm::_DS_HEADER) + sizeof(handle)
//#define FileContent_BUFFER_SIZE               sizeof(DSComm::_DS_Header) + 1024
//#define DirCreate_BUFFER_SIZE                 sizeof(DSComm::_DS_Header) + 1024
//#define DirRead_BUFFER_SIZE                   sizeof(DSComm::_DS_Header) + sizeof(FilterIncl) + sizeof(FilterExcl) + 1024
//#define FileRemove_BUFFER_SIZE                sizeof(DSComm::_DS_Header) + sizeof(UDINT) + 1024
//#define FileCopy_BUFFER_SIZE                  sizeof(DSComm::_DS_Header) + sizeof(UDINT) + 1024
//#define FileInfo_BUFFER_SIZE                  sizeof(DSComm::_DS_Header) + 1024
//#define FileRename_BUFFER_SIZE                sizeof(DSComm::_DS_Header) + 1024
//#define FileSetAttribute_BUFFER_SIZE          sizeof(DSComm::_DS_Header) + sizeof(AttributeToSet) + sizeof(AttributeToReset) + 1024
#define GetDriveList_BUFFER_SIZE              sizeof(DSComm::_DS_HEADER)
//#define FileMove_BUFFER_SIZE                  sizeof(DSComm::_DS_Header) + sizeof(UDINT) + 1024
//
//#define EventjournalAdd_BUFFER_SIZE           sizeof(DSComm::_DS_Header) + sizeof(DSComm::_DS_FragmentHeader) + sizeof(DSComm::_DS_Header) + sizeof(num) + 1024
//#define EventjournalGet_BUFFER_SIZE           sizeof(DSComm::_DS_Header) + sizeof(DSComm::_DS_FragmentHeader) + sizeof(DSComm::_DS_Header) + sizeof(num) + 1024         //256 Journal IDs
#define EventjournalGetAll_BUFFER_SIZE        sizeof(DSComm::_DS_HEADER)
//#define EventjournalDel_BUFFER_SIZE           sizeof(DSComm::_DS_Header) + sizeof(DSComm::_DS_FragmentHeader) + sizeof(DSComm::_DS_Header) + sizeof(num) + 1024         //256 Journal IDs
#define EventjournalDelAll_BUFFER_SIZE        sizeof(DSComm::_DS_HEADER)
//#define EventjournalQuitAlarm_BUFF_SIZE       sizeof(DSComm::_DS_Header) + sizeof(DSComm::_DS_FragmentHeader) + sizeof(DSComm::_DS_Header) + sizeof(num) + 1024         //256 alarm IDs
#define EventjournalQuitAll_BUFFER_SIZE       sizeof(DSComm::_DS_HEADER)
//#define SendUserEvent_BUFFER_SIZE             sizeof(DSComm::_DS_Header) + sizeof(DSComm::_DS_FragmentHeader) + sizeof(DSComm::_DS_Header) + 1024                       //1024 data bytes
#define AlarmListUpdate_BUFFER_SIZE           sizeof(DSComm::_DS_HEADER)
#define HotAlarmUpdate_BUFFER_SIZE            sizeof(DSComm::_DS_HEADER) + sizeof(pHotAlarm^)
//#define AlarmDelete_BUFFER_SIZE               sizeof(DSComm::_DS_Header) + sizeof(DSComm::_DS_FragmentHeader) + sizeof(DSComm::_DS_Header) + sizeof(num) + sizeof(toDelState) + 2048  //512 alarms
#define AlarmDeleteAll_BUFFER_SIZE            sizeof(DSComm::_DS_HEADER) + sizeof(toDelState)

//*--- Fehlernummern im Server ClassState -------------------------------------------------------------------------------*//
#define ERR_CREATE_COMM_THREAD        -1  //der Kommunikations-Thread konnte nicht kreiert werden (siehe Fehlernummer in TaskErrorNo)
#define ERR_CIL_IF_NOT_FOUND          -2  //das CIL-Interface "TCP_USER" ist nicht vorhanden
#define ERR_MEM_ALLOC_INIT            -3  //Init() konnte nicht genug Speicher allokieren
#define ERR_IP_ADDR_MISSING           -4  //die IP Adresse des Data Service fehlt (siehe Client <String>)
#define ERR_MEM_ALLOC_RUNTIME         -5  //ReceiveData() konnte nicht genug Speicher allokieren
#define ERR_CREATE_COMM_CHAN          -6  //Interner Kommunikationskanal (cPipe) konnte nicht erzeugt werden

//*--- DSComm Fehlernummern ---------------------------------------------------------------------------------------------*//
#define ERR_JOB_JOURNAL_FULL        -1      //Auftragsverwaltung voll
#define ERR_MALLOC_SEND_BUFFER      -2      //zuwenig RAM für Sendepuffer
#define ERR_MALLOC_RECV_BUFFER      -3      //Empfangspuffer oder Datenpuffer oder beide konnten nicht allokiert werden.
#define ERR_TCPIP                   -4      //TCPIP-Fehler: nicht alle Daten übertragen
#define ERR_WRONG_PARAMETER         -5      //Parameterfehler
#define ERR_INVALID_CHANNEL         -6      //Falsche Kanalnummer (> MAX_CHANNEL)
#define ERR_PROGRESS_INFO_FULL      -7      //ProgressInfo[] voll
#define ERR_HANDLE_ID_NOT_FOUND     -8      //HandleID in ProgressInfo[] nicht gefunden
#define ERR_JOB_TIMEOUT             -9      //Auftrag nach _RespTimeout (10s) / _RespTimeoutlong (60s) noch nicht fertig
#define ERR_DS_RESET                -10     //DataService ist im RESET-Zustand
#define ERR_USER_EVENT_FULL         -11     //UserEvent-Verwaltung voll
#define ERR_USER_EVENT_NOT_FOUND    -12     //UserEvent (MajorID / MinorID) nicht gefunden
#define ERR_USER_EVENT_EXISTS       -13     //UserEvent (MajorID / MinorID) schon vorhanden
#define ERR_NO_OBJECT_FOUND         -14     //Kein Objekt gefunden
#define ERR_MEM_ALLOC               -15     //Es konnte nicht genug Speicher allokiert werden
#define ERR_NO_USER_LOGIN           -16     //Kein Benutzer angemeldet
#define ERR_NO_MORE_OBJECT_ALLOWED  -17     //Es ist kein weiteres Objekt erlaubt

#define DS_ERROR_NONE             0x0000  // kein fehler aufgetreten
#define DS_ERROR_MEMORY           0x0019  // memory allocation failed

#define FlagMemError              0x0001  //Empfangspuffer oder Datenpuffer oder beide konnten nicht allokiert werden

#define MaxBuffers                8       //max. Anzahl der gleichzeitig existierenden Puffer
#define MaxDSBuffSize             16384   //Data Service kann derzeit nicht mehr Daten senden / empfangen

//*--- Data Service Session ID ------------------------------------------------------------------------------------------*//
#define SID_STATION_ALL            256
#define SID_DATASERVICE            511
#define SID_LOCAL_CLIENT_ALL       1024
#define SID_REMOTE_CLIENT_ALL      16384
#define SID_CLIENTS                32768
#define SID_ALL                    65535

//*--- Data Service Major ID --------------------------------------------------------------------------------------------*//
#define SIGMATEK_PROTOKOLL                0xFF00
#define SIGMATEK_EVENT_JOURNAL_PROTOKOLL  0xFF01

#define MAJOR_ID_SYSTEM_HIGH              0xFFFF  //für Anwender verboten
#define MAJOR_ID_SYSTEM_LOW               0xF000
#define MAJOR_ID_APP_HIGH                 0xEFFF  //für Anwender erlaubt
#define MAJOR_ID_APP_LOW                  0x8000
#define MAJOR_ID_USER_HIGH                0x7FFF
#define MAJOR_ID_USER_LOW                 0x0000


//*--- Data Service Minor ID Command ------------------------------------------------------------------------------------*//
#define AliveTriggerCmd               0x0007
#define CancelCmd                     0x000E
#define GetVersionCmd                 0x0010
#define GetProjectInfoCmd             0x0016
#define SendFragmentCmd               0x0031
#define SubscribeStateCmd             0x0035
#define UnsubscribeStateCmd           0x0037
#define GetStateCmd                   0x0040
#define LoopCmd                       0x0062
#define RecipeLoadCmd                 0x0091
#define RecipeSaveCmd                 0x0093
#define SendToAllCmd                  0x009D
#define ResetDataserviceCmd           0x00A0
#define RestartDataserviceCmd         0x00A2

#define AddLocalClientCmd             0x00B0
#define AddLocalClientRangeCmd        0x00B2
#define RemoveThisLocalClientCmd      0x00B4
#define RemoveLocalClientCmd          0x00B6
#define RemoveLocalClientRangeCmd     0x00B8
#define ClearLocalClientListCmd       0x00BA
#define GetCurrentIDCmd               0x00BC
#define GetLocalClientListCmd         0x00BE
#define GetLocalClientListDetailsCmd  0x00C0
#define GetLocalClientByIDCmd         0x00C2

#define UserLoginCmd                  0x0100
#define UserLogoutCmd                 0x0102
#define UserPasswordChangeCmd         0x0104
#define CheckAccessLevelCmd           0x010A
#define CreateUserCmd                 0x0110
#define ChangeUserSettingsCmd         0x0112
#define DeleteUserCmd                 0x0114
#define GetUserListCmd                0x0116
#define GetUserDetailsCmd             0x0118
#define CreateRoleCmd                 0x0120
#define ChangeRoleCmd                 0x0122
#define DeleteRoleCmd                 0x0124
#define GetRoleListCmd                0x0126
#define GetRoleDetailsCmd             0x0128
#define GetVarIdFromNameCmd           0x0204
#define GetVarIdFromLasalIdCmd        0x0206
#define GetLasalIdFromNameCmd         0x0208
#define GetLasalIdFromVarIdCmd        0x020A
#define GetNameFromVarIdCmd           0x020C
#define GetNameFromLasalIdCmd         0x020E
#define GetDpListCmd                  0x0210
#define GetDpInfoCmd                  0x0212
#define GetVarIdFromCRCCmd            0x0214
#define GetCRCfromVarIdCmd            0x0216
#define GetValueCmd                   0x0220
#define GetStringCmd                  0x0222
#define SetValueCmd                   0x0230
#define SetStringCmd                  0x0232
#define IncValueCmd                   0x0236
#define DecValueCmd                   0x0238
#define RefListAddCmd                 0x0240
#define RefListSubCmd                 0x0242
#define GetStationStatusCmd           0x0310
#define GetStationListCmd             0x0312
#define FileOpenCmd                   0x0500
#define FileCloseCmd                  0x0502
#define FileSeekCmd                   0x0504
#define FileTellCmd                   0x0506
#define FileReadCmd                   0x0508
#define FileWriteCmd                  0x050A
#define FileGetCmd                    0x050C
#define FilePutCmd                    0x050E
#define FileLengthCmd                 0x0510
#define FileContentCmd                0x0512
#define DirCreateCmd                  0x0520
#define DirReadCmd                    0x0522
#define FileRemoveCmd                 0x0530
#define FileCopyCmd                   0x0532
#define FileInfoCmd                   0x0534
#define FileRenameCmd                 0x0536
#define FileSetAttributeCmd           0x0538
#define GetDriveListCmd               0x053A
#define FileMoveCmd                   0x053C

#define EventjournalAddCmd            0x0400
#define EventjournalGetCmd            0x0402
#define EventjournalGetAllCmd         0x0404
#define EventjournalDelCmd            0x0406
#define EventjournalDelAllCmd         0x0408
#define EventjournalQuitAlarmCmd      0x0410
#define EventjournalQuitAllCmd        0x0412

#define AlarmListUpdateAddCmd         0x0414
#define AlarmListUpdateSubCmd         0x0416
#define HotAlarmUpdateAddCmd          0x0420
#define HotAlarmUpdateSubCmd          0x0422
#define AlarmDeleteCmd                0x0426
#define AlarmDeleteAllCmd             0x0428

//*--- Data Service Minor ID Response -----------------------------------------------------------------------------------*//
#define AliveTriggerRsp               0x0007
#define CancelCmdRsp                  0x000F
#define GetVersionRsp                 0x0011
#define GetProjectInfoRsp             0x0017
#define SendUserEventRsp              0x0020      //Antwort auf SendUserEvent()
#define SendFragmentRsp               0x0032      //eigene Antwort nachdem ein Fragment empfangen wurde
#define SubscribeStateRsp             0x0036
#define UnsubscribeStateRsp           0x0038
#define GetStateRsp                   0x0041
#define LoopRsp                       0x0063
#define RecipeLoadRsp                 0x0090
#define RecipeSaveRsp                 0x0092
#define SendToAllRsp                  0x009E
#define ResetDataserviceRsp           0x00A1
#define RestartDataserviceRsp         0x00A3

#define AddLocalClientRsp             0x00B1
#define AddLocalClientRangeRsp        0x00B3
#define RemoveThisLocalClientRsp      0x00B5
#define RemoveLocalClientRsp          0x00B7
#define RemoveLocalClientRangeRsp     0x00B9
#define ClearLocalClientListRsp       0x00BB
#define GetCurrentIDRsp               0x00BD
#define GetLocalClientListRsp         0x00BF
#define GetLocalClientListDetailsRsp  0x00C1
#define GetLocalClientByIDRsp         0x00C3

#define UserLoginRsp                  0x0101
#define UserLogoutRsp                 0x0103
#define UserPasswordChangeRsp         0x0105
#define CheckAccessLevelRsp           0x010B
#define CreateUserRsp                 0x0111
#define ChangeUserSettingsRsp         0x0113
#define DeleteUserRsp                 0x0115
#define GetUserListRsp                0x0117
#define GetUserDetailsRsp             0x0119
#define CreateRoleRsp                 0x0121
#define ChangeRoleRsp                 0x0123
#define DeleteRoleRsp                 0x0125
#define GetRoleListRsp                0x0127
#define GetRoleDetailsRsp             0x0129
#define GetVarIdFromNameRsp           0x0205
#define GetVarIdFromLasalIdRsp        0x0207
#define GetLasalIdFromNameRsp         0x0209
#define GetLasalIdFromVarIdRsp        0x020B
#define GetNameFromVarIdRsp           0x020D
#define GetNameFromLasalIdRsp         0x020F
#define GetDpListRsp                  0x0211
#define GetDpInfoRsp                  0x0213
#define GetVarIdFromCRCRsp            0x0215
#define GetCRCfromVarIdRsp            0x0217
#define GetValueRsp                   0x0221
#define GetStringRsp                  0x0223
#define SetValueRsp                   0x0231
#define SetStringRsp                  0x0233
#define IncValueRsp                   0x0237
#define DecValueRsp                   0x0239
#define RefListAddRsp                 0x0241
#define RefListSubRsp                 0x0243
#define GetStationStatusRsp           0x0311
#define GetStationListRsp             0x0313
#define FileOpenRsp                   0x0501
#define FileCloseRsp                  0x0503
#define FileSeekRsp                   0x0505
#define FileTellRsp                   0x0507
#define FileReadRsp                   0x0509
#define FileWriteRsp                  0x050B
#define FileGetRsp                    0x050D
#define FilePutRsp                    0x050F
#define FileLengthRsp                 0x0511
#define FileContentRsp                0x0513
#define DirCreateRsp                  0x0521
#define DirReadRsp                    0x0523
#define FileRemoveRsp                 0x0531
#define FileCopyRsp                   0x0533
#define FileInfoRsp                   0x0535
#define FileRenameRsp                 0x0537
#define FileSetAttributeRsp           0x0539
#define GetDriveListRsp               0x053B
#define FileMoveRsp                   0x053D

#define EventjournalAddRsp            0x0401
#define EventjournalGetRsp            0x0403
#define EventjournalGetAllRsp         0x0405
#define EventjournalDelRsp            0x0407
#define EventjournalDelAllRsp         0x0409
#define EventjournalQuitAlarmRsp      0x0411
#define EventjournalQuitAllRsp        0x0413

#define AlarmListUpdateAddRsp         0x0415
#define AlarmListUpdateSubRsp         0x0417
#define HotAlarmUpdateAddRsp          0x0421
#define HotAlarmUpdateSubRsp          0x0423
#define AlarmDeleteRsp                0x0427
#define AlarmDeleteAllRsp             0x0429

//*--- Data Service Minor ID Push Notifiaction --------------------------------------------------------------------------*//
#define UpdateStatePsh          0x0039
#define ProgressStatusPsh       0x0080
#define SendToAllPsh            0x009D
#define UserLogoutPsh           0x0108
#define RefListUpdatePsh        0x024A
#define RefListUpdateStringPsh  0x024B
#define EventjournalUpdatePsh   0x040C
#define AlarmListUpdatePsh      0x0419
#define HotAlarmUpdatePsh       0x0425
#define AlarmDeleteUpdPsh       0x042A

//*--- Data Service Transaction Src und Dest ----------------------------------------------------------------------------*//
#define TransactSrc             0
#define TransactDest            511

//*--- Data Service Session-IDs (Broadcast) -----------------------------------------------------------------------------*//
#define ID_STATION_ALL          0x0100  //(256)   Broadcast Adresse aller Stationen
#define ID_DATASERVICE          0x01FF  //(511)   Die SessionID des Dataservice
#define ID_LOCAL_CLIENT_ALL     0x0400  //(1024)  Broadcast Adresse aller lokalen Clients
#define ID_REMOTE_CLIENT_ALL    0x4000  //(16384) Broadcast Adresse aller remote Clients
#define ID_CLIENTS              0x8000  //(32768) Broadcast Adresse aller Clients (local + remote)
#define ID_ALL                  0xFFFF  //(65535) Broadcast Adresse aller Geräte (Clients + Stations)

#define MEM_Mark_DS_Comm        7       //erlaubt ist 0 bis 10
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "DSComm"
	Revision           = "2.3"
	GUID               = "{5DFB2027-4D37-475D-A6AE-980FE51CF024}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	DefCyclictime      = "20 ms"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(780,1080)"
	Comment            = "Communication class. Can be used to transmit and receive data between application software and the Data Service.&#13;&#10;The global methods of the class DSComm can only be called using a derivation of the interface class DSComm_Interface.&#13;&#10;&#13;&#10;Kommunikationsklasse. Kann zum Senden und Empfangen von Daten zwischen Anwendungssoftware und Datenservice verwendet werden.&#13;&#10;Die globalen Methoden der Klasse DSComm können nur über eine Ableitung der Schnittstellenklasse DSComm_Interface aufgerufen werden.">
	<Channels>
		<Server Name="ClassState" GUID="{5449FD07-C8DA-4CF2-9B3E-9C2D47F61CB8}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="If Server is &lt;&gt; 0, a severe error occurred in Init() or during runtime.&#13;&#10;&#13;&#10;ERR_CREATE_COMM_THREAD: Init() could not create the communication thread (see error number in TaskErrorNo).&#13;&#10;ERR_CIL_IF_NOT_FOUND:         Init() could not find the CIL-Interface &quot;TCP_USER&quot;.&#13;&#10;ERR_MEM_ALLOC_INIT:             Init() could not allocate enough memory.&#13;&#10;ERR_IP_ADDR_MISSING:           IP address of the Data Service is missing (see client &lt;String&gt;).&#13;&#10;ERR_MEM_ALLOC_RUNTIME:   ReceiveData() could not allocate enough memory. The TCP connection is closed. To establish a new TCP connection StartTCPComm() must be called.&#13;&#10;ERR_CREATE_COMM_CHAN:   The internal communication channel could not be created.&#13;&#10;&#13;&#10;Ist der Server &lt;&gt; 0, dann ist in der Init-Phase oder während der Laufzeit ein schwerer Fehler aufgetreten.&#13;&#10;&#13;&#10;ERR_CREATE_COMM_THREAD: Init() konnnte den Kommunikations-Thread nicht kreieren (siehe Fehlernummer in TaskErrorNo).&#13;&#10;ERR_CIL_IF_NOT_FOUND:         Init() konnte das CIL-Interface &quot;TCP_USER&quot; nicht finden.&#13;&#10;ERR_MEM_ALLOC_INIT:             Init() konnte nicht genug Speicher allokieren.&#13;&#10;ERR_IP_ADDR_MISSING:           die IP Adresse des Data Service fehlt (siehe Client &lt;String&gt;).&#13;&#10;ERR_MEM_ALLOC_RUNTIME    ReceiveData() konnte nicht genug Speicher allokieren. Die TCP-Verbindung wird geschlossen. Um eine neue TCP-Verbindung aufzubauen muss StartTCPComm() aufgerufen werden.&#13;&#10;ERR_CREATE_COMM_CHAN:    Der interne Kommunikationskanal konnte nicht angelegt werden."/>
		<Server Name="ClassSvr" GUID="{A1063204-9E1D-4B97-923E-E3CF6DE710C9}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false" Comment="Dieser Server muss mit dem Client DSComm einer Ableitung der Klasse DSComm_Interface verbunden werden. &#13;&#10;Hier können auch mehrere Ableitungen der Klasse DSCOmm_Interface angeschlossen werden."/>
		<Server Name="DS_BuildNo" GUID="{0CACFCF5-DDD9-4BB6-A405-0E13E9D46A8C}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Build number of the data service to which a connection exists.&#13;&#10;&#13;&#10;Buildnummer des Data Service zu dem eine Verbindung besteht."/>
		<Server Name="DS_Version" GUID="{69CD5700-5797-4F06-ACA0-3CD72D71856C}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Version number of the data service to which a connection exists.&#13;&#10;&#13;&#10;Versionsnummer des Data Service zu dem eine Verbindung besteht."/>
		<Server Name="ErrorReceive" GUID="{1B399269-0082-4B1A-8E9D-30F7F3A63DA7}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Is incremented if an error occurs while receiving.&#13;&#10;&#13;&#10;Wird inkrementiert, wenn beim Empfangen ein Fehler auftritt."/>
		<Server Name="ErrorSend" GUID="{3F1857F9-4471-4E11-B311-241E02734DA5}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Is incremented if an error occurs while sending.&#13;&#10;&#13;&#10;Wird inkrementiert, wenn beim Senden ein Fehler auftritt."/>
		<Server Name="MaxReconnectTime" GUID="{1C4B6F20-D91F-4F1C-8A15-1649AD574BEE}" Visualized="false" Initialize="true" WriteProtected="false" Retentive="false" Comment="Here you can set how long an attempt is made to establish a TCP connection or to reestablish it after a connection termination.&#13;&#10;The time is specified in [ms].&#13;&#10;The value zero means that an unlimited number of attempts are made to establish or reestablish a connection. &#13;&#10;If the time has expired, then StartTCPComm() can be used to try again to establish a connection within the time &lt;MaxReconnectTime&gt;.&#13;&#10;&#13;&#10;Hier wird eingestellt, wie lange versucht wird, eine TCP-Verbindung aufzubauen oder nach einem Verbindungsabbruch wiederaufzubauen.&#13;&#10;Die Zeit wird in [ms] angegeben.&#13;&#10;Der Wert Null bedeutet, dass unbegrenzt lange versucht wird eine Verbindung aufzubauen oder wiederaufzubauen. &#13;&#10;Wenn die Zeit abgelaufen ist, dann kann StartTCPComm() verwendet werden, um erneut zu versuchen, eine Verbindung innerhalb der Zeitspanne &lt;MaxReconnectTime&gt; aufzubauen.&#13;&#10;"/>
		<Server Name="Online" GUID="{118E538D-BCB5-4B2E-AFF1-D2BFAAC70113}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="State of the TCP-IP connection to the Data Service.&#13;&#10;0..Offline&#13;&#10;1..Online&#13;&#10;&#13;&#10;Status der TCP-IP Verbindung zum Data Service.&#13;&#10;0..Offline&#13;&#10;1..Online"/>
		<Server Name="Taskname" GUID="{946728A8-A12B-4AAC-AAF5-5E8211D5D40E}" Class="String" Visualized="false" Initialize="true" WriteProtected="true" Retentive="false" Comment="Name of the communication thread.&#13;&#10;&#13;&#10;Name des Kommunikations-Threads."/>
		<Client Name="cIPaddr" Required="true" Internal="false" Comment="Connection to an object of the String class.&#13;&#10;The string object must contain the IP address of the data service. The IP address is only read in the init phase.&#13;&#10;This client must be connected.&#13;&#10;&#13;&#10;Verbindung zu einem Objekt der Klasse String.&#13;&#10;Das String-Objekt muss die IP-Adresse des Data Service enthalten. Die IP-Adresse wird nur in der Init-Phase gelesen.&#13;&#10;Dieser Client muss verbunden werden."/>
		<Client Name="SigCLib" Required="false" Internal="false" Comment="Connection to the SigCLib library. This client does not need to be connected.&#13;&#10;&#13;&#10;Verbindung zur Library SigCLib. Dieser Client muss nicht verbunden werden."/>
		<Client Name="ThreadName" Required="true" Internal="true"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek GmbH" Author="FucHer"/>
		<Dokumentation Revision="2.3" Date="2021-04-07" Author="FucHer" Company="Sigmatek GmbH" Description="New internal cPipe to serialize requests and to prevent hang up of the background task when sending in blocking mode."/>
		<Dokumentation Revision="2.2" Date="2021-03-23" Author="FucHer" Company="Sigmatek GmbH" Description="New methods SubscribeState(), UnsubscribeState(), GetState(), SubscribeStateResp(), UnsubscribeStateResp(), GetStateResp(), UpdateStatePush(()."/>
		<Dokumentation Revision="2.1" Date="2021-01-31" Author="FucHer" Company="Sigmatek GmbH" Description="New method StrLenUtf8()."/>
		<Dokumentation Revision="2.0" Date="2020-11-05" Author="FucHer" Company="Sigmatek GmbH" Description="DataService communication protocol has changed: All kinds of lists (after &lt;num&gt;) were extended by size. All strings were extended by strlen. User- and role-functions were extended by AccessNumberValid and AccessNumber."/>
		<Dokumentation Revision="1.4" Date="2020-08-28" Author="FucHer" Company="Sigmatek GmbH" Description="Struct _DS_GetProjectInfoResp: new element ProjectCRC. GetRespData_GetProjectInfo(): copy ProjectCRC."/>
		<Dokumentation Revision="1.3" Date="2020-06-18" Author="FucHer" Company="Sigmatek GmbH" Description="DEVVIS-42: the class DSComm shall be extended by the new alarm functions of the data service:&#13;&#10;AlarmList Update Add, AlarmList Update Sub, HotAlarm Update Add, HotAlarm Update Sub, Alarm Delete, Alarm Delete All as well as the associated push messages."/>
		<Dokumentation Revision="1.2" Date="2020-06-10" Author="FucHer" Company="Sigmatek GmbH" Description="DEVVIS-41 (LVD-DB issue 219), GetpUserEvent(): prevent an access exception, when there is no subscriber for the received user event.&#13;&#10;StoreUserEvent(): prevent unwarranted error, when the minorID is not invalid."/>
		<Dokumentation Revision="1.1" Date="2020-01-09" Author="FucHer" Company="Sigmatek GmbH&#13;&#10;" Description="Release."/>
		<Dokumentation Revision="1.0" Date="2019-03-04" Author="FucHer" Company="Sigmatek GmbH" Description="First version."/>
	</RevDoku>
	<Network Name="DSComm">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "ThreadName"
				GUID       = "{C013145F-4F54-4279-8C05-18CBC4BB97DC}"
				Class      = "String"
				Position   = "(210,690)"
				Visualized = "false">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ThreadName" Destination="ThreadName.Data"/>
			<Connection Source="this.Taskname" Destination="ThreadName.Data" Vertices="(698,570),(526,780),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
DSComm : CLASS
	TYPE
	  _DS_AccessType :  //! <Type Public="true" Comment="AccessType for the GetDpInfo() response data.&#13;&#10;&#13;&#10;AccessType für die GetDpInfo() Response-Daten." Name="_DS_AccessType"/>
	  (
	    VarClass,
	    VarServerNumeric,
	    VarServerString,
	    VarClient,
	    VarVariableDataAt,
	    VarConstValue
	  )$UDINT;
#pragma pack(push, 1)
	  _DS_AddLocalClientCmd : STRUCT  //! <Type Public="true" Comment="AddLocalClient() parameters." Name="_DS_AddLocalClientCmd"/>
	    Typ : USINT;  //! <Type Comment="Defines the type of identifier used to define the ID:&#13;&#10;1 = IP-address&#13;&#10;2 = IP-address range&#13;&#10;3 = MAC-address&#13;&#10;4 = MAC-address range&#13;&#10;&#13;&#10;Definiert den Typ des Identifiers über welchen die ID festgelegt wird:&#13;&#10;1 = IP-Adresse&#13;&#10;2 = IP-Adressbereich&#13;&#10;3 = MAC-Adresse&#13;&#10;4 = MAC-Adressbereich" Name="_DS_AddLocalClientCmd.Typ"/>
	    pIdentifier : ^USINT;  //! <Type Comment="Pointer to the identifier string (IP-address / MAC-address).&#13;&#10;&#13;&#10;Zeiger auf den Identifier (IP- / MAC-Adresse)." Name="_DS_AddLocalClientCmd.pIdentifier"/>
	    ID : UDINT;  //! <Type Comment="The desired ID which the client should receive when connecting. Valid range: 1 - 1278.&#13;&#10;&#13;&#10;Die gewünschte ID welche der Client beim Verbinden erhalten soll&#10;. Gültiger Bereich: 1 - 1278." Name="_DS_AddLocalClientCmd.ID"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_AddLocalClientRangeCmd : STRUCT  //! <Type Public="true" Comment="AddLocalClientRange() parameters." Name="_DS_AddLocalClientRangeCmd"/>
	    Typ : USINT;  //! <Type Comment="Defines the type of identifier used to define the ID:&#13;&#10;1 = IP-address&#13;&#10;2 = IP-address range&#13;&#10;3 = MAC-address&#13;&#10;4 = MAC-address range&#13;&#10;&#13;&#10;Definiert den Typ des Identifiers über welchen die ID festgelegt wird:&#13;&#10;1 = IP-Adresse&#13;&#10;2 = IP-Adressbereich&#13;&#10;3 = MAC-Adresse&#13;&#10;4 = MAC-Adressbereich" Name="_DS_AddLocalClientRangeCmd.Typ"/>
	    onDuplicate : USINT;  //! <Type Comment="Defines what should happen if the ID is already assigned:&#13;&#10;0 = reject ID&#13;&#10;1 = use next free ID&#13;&#10;&#13;&#10;Definiert was passieren soll falls die ID bereits vergeben ist:&#13;&#10;0 = ID ablehnen&#13;&#10;1 = nächste freie ID verwenden" Name="_DS_AddLocalClientRangeCmd.onDuplicate"/>
	    pFrom : ^USINT;  //! <Type Comment="Pointer to the first identifier string in the range (IP-address / MAC-address).&#13;&#10;&#13;&#10;Zeiger auf den ersten Identifier des Bereichs (IP- / MAC-Adresse)." Name="_DS_AddLocalClientRangeCmd.pFrom"/>
	    pTo : ^USINT;  //! <Type Comment="Pointer to the last identifier string in the range (IP-address / MAC-address).&#13;&#10;&#13;&#10;Zeiger auf den letzten Identifier des Bereichs (IP- / MAC-Adresse)." Name="_DS_AddLocalClientRangeCmd.pTo"/>
	    ID : UDINT;  //! <Type Comment="The desired first ID in the range which the clients should receive when connecting. Valid range: 1 - 1278.&#13;&#10;&#13;&#10;Die gewünschte erste ID im Bereich welche die Clients beim Verbinden erhalten sollen&#10;. Gültiger Bereich: 1 - 1278." Name="_DS_AddLocalClientRangeCmd.ID"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_AddLocalClientRangeResp : STRUCT  //! <Type Public="true" Comment="AddLocalClientRange() response data.&#13;&#10;&#13;&#10;AddLocalClientRange() Response-Daten." Name="_DS_AddLocalClientRangeResp"/>
	    ID : UDINT;  //! <Type Comment="The first ID in the range which should be assigned to the clients.&#13;&#10;&#13;&#10;Die erste ID im Bereich welche den Clients zugewiesen werden sollte." Name="_DS_AddLocalClientRangeResp.ID"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_AddLocalClientRangeResp.ErrorCode"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_AddLocalClientResp : STRUCT  //! <Type Public="true" Comment="AddLocalClient() response data.&#13;&#10;&#13;&#10;AddLocalClient() Response-Daten." Name="_DS_AddLocalClientResp"/>
	    ID : UDINT;  //! <Type Comment="The ID which should be assigned to the client.&#13;&#10;&#13;&#10;Die ID welche dem Client zugewiesen werden sollte." Name="_DS_AddLocalClientResp.ID"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_AddLocalClientResp.ErrorCode"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_AlarmDeleteAllResp : STRUCT  //! <Type Public="true" Comment="AlarmDeleteAll() response data.&#13;&#10;&#13;&#10;AlarmDeleteAll() Response-Daten." Name="_DS_AlarmDeleteAllResp"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_AlarmDeleteAllResp.ErrorCode"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_AlarmDeleteResp : STRUCT  //! <Type Public="true" Comment="AlarmDelete() response data.&#13;&#10;&#13;&#10;AlarmDelete() Response-Daten." Name="_DS_AlarmDeleteResp"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_AlarmDeleteResp.ErrorCode"/>
	    AlarmID : UDINT;  //! <Type Comment="Alarm ID (Variable ID of the &lt;ClassSvr&gt; of an alarm object (classes _AlarmX0Para - _AlarmX3Para)).&#13;&#10;&#13;&#10;Die ID des Alarms (Variablen ID des &lt;ClassSvr&gt; eines Alarm-Objekts (Klassen _AlarmX0Para - _AlarmX3Para))." Name="_DS_AlarmDeleteResp.AlarmID"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_AlarmDeleteUpdate : STRUCT  //! <Type Public="true" Comment="Sent by the data service when an alarm is deleted.&#13;&#10;&#13;&#10;Wird vom DS verschickt, wenn ein Alarm gelöscht wird." Name="_DS_AlarmDeleteUpdate"/>
	    AlarmID : UDINT;  //! <Type Comment="Alarm ID (Variable ID of the &lt;ClassSvr&gt; of an alarm object (classes _AlarmX0Para - _AlarmX3Para)).&#13;&#10;&#13;&#10;Die ID des Alarms (Variablen ID des &lt;ClassSvr&gt; eines Alarm-Objekts (Klassen _AlarmX0Para - _AlarmX3Para))." Name="_DS_AlarmDeleteUpdate.AlarmID"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_AlarmParameter : STRUCT  //! <Type Public="true" Comment="Alarm parameter." Name="_DS_AlarmParameter"/>
	    Value : DINT;  //! <Type Comment="Value of the client &lt;ParaX&gt; of an alarm object (classes _AlarmX0Para .. _AlarmX3Para).&#13;&#10;&#13;&#10;Wert des Clients &lt;ParaX&gt; eines Alarm-Objekts (Klassen _AlarmX0Para .. _AlarmX3Para)." Name="_DS_AlarmParameter.Value"/>
	    VarID : UDINT;  //! <Type Comment="Variable ID of the server connected to the client &lt;ParaX&gt; of an alarm object (classes _AlarmX0Para .. _AlarmX3Para).&#13;&#10;-1 if the client &lt;ParaX&gt; is not connected to any server.&#13;&#10;&#13;&#10;Variablen ID des Servers der mit dem Client &lt;ParaX&gt; eines Alarm-Objekts (Klassen _AlarmX0Para .. _AlarmX3Para) verbunden ist.&#13;&#10;-1 wenn der Client &lt;ParaX&gt; mit keinem Server verbunden ist." Name="_DS_AlarmParameter.VarID"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_AlarmTimestamps : STRUCT  //! <Type Public="true" Comment="Alarm time stamps in Lasal format (see classes _SysDateTime and _SysDateTime2).&#13;&#10;&#13;&#10;Time Format: HHHHHHHHMMMMMMMMSSSSSSSS&#13;&#10;Bit 24-31 (H) contains the hour from 0 to 23.&#13;&#10;Bit 16-23 (M) contains the minute from 0 to 59. &#13;&#10;Bit 8 -15 (S) contains the second from 0 to 59.&#13;&#10;&#13;&#10;Date Format: YYYYYYYYYYYYYYYYMMMMDDDDDDDDWWWW&#13;&#10;Bit 16-31 (Y) contains the entire year (e.g. 2003).&#13;&#10;Bit 12-15 (M) contains the current month from 1 to 12. &#13;&#10;Bit 4-11 (D) contains the day information from 1 to 31.&#13;&#10;Bit 0-3 (W) contains the day of the week, where 0 stands for Sunday, 1 for Monday, etc.&#13;&#10;&#13;&#10;&#13;&#10;Alarm Zeitstempel im Lasal Format (siehe Klassen _SysDateTime und _SysDateTime2).&#13;&#10;&#13;&#10;Zeit-Format: HHHHHHHHMMMMMMMMSSSSSSSS&#13;&#10;Bit 24-31 (H) beinhaltet die Stunde von 0 bis 23.&#13;&#10;Bit 16-23 (M) beinhaltet die Minute von 0 bis 59.&#13;&#10;Bit 8 -15  (S) beinhaltet die Sekunde von 0 bis 59.&#13;&#10;&#13;&#10;Datums-Format: YYYYYYYYYYYYYYYYMMMMDDDDDDDDWWWW&#13;&#10;Bit 16-31 (Y) beinhaltet die gesamte Jahreszahl (z.B. 2003).&#13;&#10;Bit 12-15 (M) beinhaltet das aktuelle Monat von 1 bis 12. &#13;&#10;Bit 4-11   (D) beinhaltet die Tagesinformation von 1 bis 31.&#13;&#10;Bit 0-3     (W) beinhaltet den Wochentag, wobei 0 für Sonntag, 1 für Montag, usw. steht.&#13;&#10;" Name="_DS_AlarmTimestamps"/>
	    ts_firstTime : UDINT;  //! <Type Comment="Timestamp - AlarmFirstAppearance - Time.&#13;&#10;&#13;&#10;Zeitstempel - Erstes Auftreten - Zeit." Name="_DS_AlarmTimestamps.ts_firstTime"/>
	    ts_firstDate : UDINT;  //! <Type Comment="Timestamp - AlarmFirstAppearance - Date.&#13;&#10;&#13;&#10;Zeitstempel - Erstes Auftreten - Datum." Name="_DS_AlarmTimestamps.ts_firstDate"/>
	    ts_lastTime : UDINT;  //! <Type Comment="Timestamp - AlarmLastAppearance - Time.&#13;&#10;&#13;&#10;Zeitstempel - Letztes Auftreten - Zeit." Name="_DS_AlarmTimestamps.ts_lastTime"/>
	    ts_lastDate : UDINT;  //! <Type Comment="Timestamp - AlarmLastAppearance - Date.&#13;&#10;&#13;&#10;Zeitstempel - Letztes Auftreten - Datum." Name="_DS_AlarmTimestamps.ts_lastDate"/>
	    ts_quittedTime : UDINT;  //! <Type Comment="Timestamp - AlarmLastTimeQuitted - Time.&#13;&#10;&#13;&#10;Zeitstempel - Alarm zuletzt quittiert - Zeit." Name="_DS_AlarmTimestamps.ts_quittedTime"/>
	    ts_quittedDate : UDINT;  //! <Type Comment="Timestamp - AlarmLastTimeQuitted - Date.&#13;&#10;&#13;&#10;Zeitstempel - Alarm zuletzt quittiert - Datum." Name="_DS_AlarmTimestamps.ts_quittedDate"/>
	    ts_disappearedTime : UDINT;  //! <Type Comment="Timestamp - AlarmLastDisappeared - Time.&#13;&#10;&#13;&#10;Zeitstempel - Alarm zuletzt gegangen - Zeit." Name="_DS_AlarmTimestamps.ts_disappearedTime"/>
	    ts_disappearedDate : UDINT;  //! <Type Comment="Timestamp - AlarmLastDisappeared - Date.&#13;&#10;&#13;&#10;Zeitstempel - Alarm zuletzt gegangen - Datum." Name="_DS_AlarmTimestamps.ts_disappearedDate"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_AlarmListUpdate : STRUCT  //! <Type Public="true" Comment="Sent by the data service when the contents of the alarm list changes.&#13;&#10;&#13;&#10;Wird vom DS verschickt, wenn sich der Inhalt der Alarmliste ändert." Name="_DS_AlarmListUpdate"/>
	    VarID : UDINT;  //! <Type Comment="The ID of the alarm (Variable ID of the &lt;ClassSvr&gt; of an alarm object (classes _AlarmX0Para - _AlarmX3Para)).&#13;&#10;&#13;&#10;Die ID des Alarms (Variablen ID des &lt;ClassSvr&gt; eines Alarm-Objekts (Klassen _AlarmX0Para - _AlarmX3Para))." Name="_DS_AlarmListUpdate.VarID"/>
	    Group : UDINT;  //! <Type Comment="Value of the client &lt;Group&gt; of an alarm object (classes _AlarmX0Para .. _AlarmX3Para).&#13;&#10;&#13;&#10;Wert des Clients &lt;Group&gt; eines Alarm-Objekts (Klassen _AlarmX0Para .. _AlarmX3Para)." Name="_DS_AlarmListUpdate.Group"/>
	    Config : UDINT;  //! <Type Comment="Value of the client &lt;Config&gt; of an alarm object (classes _AlarmX0Para .. _AlarmX3Para).&#13;&#10;&#13;&#10;Wert des Clients &lt;Config&gt; eines Alarm-Objekts (Klassen _AlarmX0Para .. _AlarmX3Para)." Name="_DS_AlarmListUpdate.Config"/>
	    State : USINT;  //! <Type Comment="Acknowledged (255), disappeared (0) or present (1).&#13;&#10;&#13;&#10;Quittiert (255), gegangen (0) oder vorhanden (1). " Name="_DS_AlarmListUpdate.State"/>
	    GroupBit : USINT;  //! <Type Comment="Group bit.&#13;&#10;&#13;&#10;Gruppierungsbit." Name="_DS_AlarmListUpdate.GroupBit"/>
	    ParameterNo : USINT;  //! <Type Comment="Number of parameters that &lt;pParameter&gt; points to.&#13;&#10;ATTENTION: when &lt;ParameterNo&gt; is zero, then &lt;pParameter&gt; is nil.&#13;&#10;&#13;&#10;Anzahl der Parameter auf die &lt;pParameter&gt; zeigt.&#13;&#10;ACHTUNG: wenn &lt;ParameterNo&gt; Null ist, dann ist &lt;pParameter&gt; nil." Name="_DS_AlarmListUpdate.ParameterNo"/>
	    nc : USINT;  //! <Type Comment="Unused." Name="_DS_AlarmListUpdate.nc"/>
	    pParameter : ^_DS_AlarmParameter;  //! <Type Comment="Pointer to an array with &lt;ParameterNo&gt;elements of the form &lt;Value, VarID&gt;.&#13;&#10;This array contains the values of clients &lt;Para1&gt; .. &lt;Para3&gt; of an alarm object (classes _AlarmX1Para .. _AlarmX3Para).&#13;&#10;ATTENTION: when &lt;ParameterNo&gt; is zero, then &lt;pParameter&gt; is nil.&#13;&#10;&#13;&#10;Zeiger auf ein Array mit &lt;ParameterNo&gt; Elementen der Form &lt;Value, VarID&gt;.&#13;&#10;Dieses Array enthält die Werte der Clients &lt;Para1&gt; .. &lt;Para3&gt; eines Alarm-Objekts (Klassen _AlarmX1Para .. _AlarmX3Para).&#13;&#10;ACHTUNG: wenn &lt;ParameterNo&gt; Null ist, dann ist &lt;pParameter&gt; nil.&#13;&#10;" Name="_DS_AlarmListUpdate.pParameter"/>
	    pTimestamps : ^_DS_AlarmTimestamps;  //! <Type Comment="Pointer to the alarm time stamps.&#13;&#10;&#13;&#10;Zeiger auf die Alarm Zeitstempel." Name="_DS_AlarmListUpdate.pTimestamps"/>
	    num_appeared : UDINT;  //! <Type Comment="Number of how often an alarm occurred.&#13;&#10;&#13;&#10;Anzahl wie oft der Alarm aufgetreten ist." Name="_DS_AlarmListUpdate.num_appeared"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_AlarmListUpdateAddResp : STRUCT  //! <Type Public="true" Comment="SubscribeAlarmListUpdate() response data.&#13;&#10;&#13;&#10;SubscribeAlarmListUpdate() Response-Daten." Name="_DS_AlarmListUpdateAddResp"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_AlarmListUpdateAddResp.ErrorCode"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_AlarmListUpdateSubResp : STRUCT  //! <Type Public="true" Comment="UnsubscribeAlarmListUpdate() response data.&#13;&#10;&#13;&#10;UnsubscribeAlarmListUpdate() Response-Daten." Name="_DS_AlarmListUpdateSubResp"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_AlarmListUpdateSubResp.ErrorCode"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_Header : STRUCT  //! <Type Comment="Protokoll Header." Name="_DS_Header"/>
	    Length : UDINT;  //! <Type Comment="Länge des gesamten Pakets inclusive Header" Name="_DS_Header.Length"/>
	    MajorID : UINT;  //! <Type Comment="ID des Protokolls:&#13;&#10;0xFF00: Sigmatek Protokoll&#13;&#10;0xFF01: Sigmatek Journal Protokoll" Name="_DS_Header.MajorID"/>
	    MinorID : UINT;  //! <Type Comment="Beschreibt um welches Command es sich handelt." Name="_DS_Header.MinorID"/>
	    TransactionSrc : UINT;  //! <Type Comment="Dient derzeit ausschließlich für den Dataservice zur Identifikation der Clients. &#13;&#10;Alle Clients müssen derzeit immer 0 als TranscationSrc eintragen." Name="_DS_Header.TransactionSrc"/>
	    TransactionDest : UINT;  //! <Type Comment="Für alle hier beschriebenen Komandos immer 511." Name="_DS_Header.TransactionDest"/>
	    MessageID : DINT;  //! <Type Comment="Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;Dazu muss der Client eine eindeutige ID generieren (zB. durch incrementierten einer globalen Variable), welche &#13;&#10;dann vom Dataservice in den Header der Response mit übernommen wird.&#13;&#10;&#13;&#10;Alle Push Notifications bekommen immer die MessageId 0xFFFFFFFF." Name="_DS_Header.MessageID"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_BufferHandling : STRUCT
	    UID : UDINT;
	    HeaderOri : _DS_Header;  //! <Type Comment="Nur bei Fragmentierung: der ursprüngliche Befehls-Header." Name="_DS_BufferHandling.HeaderOri"/>
	    pRecvBufferStart : ^CHAR;
	    pDataBufferStart : ^CHAR;
	    pRecvBuffer : ^CHAR;
	    Flags : DINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_CancelResp : STRUCT  //! <Type Public="true" Comment="CancelCommand() response data.&#13;&#10;&#13;&#10;CancelCommand() Response-Daten." Name="_DS_CancelResp"/>
	    HandleID : UDINT;  //! <Type Comment="The MessageID of the command which should be aborted.&#13;&#10;&#13;&#10;Die MessageID des Kommandos welches abgebrochen werden sollte." Name="_DS_CancelResp.HandleID"/>
	    State : UDINT;  //! <Type Comment="The status of the aborted command.&#13;&#10;&#13;&#10;Der Status des abgebrochenen Kommandos" Name="_DS_CancelResp.State"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_UnsLongLongInt : STRUCT  //! <Type Public="true" Comment="Unsigned long long integer (64 Bit)." Name="_DS_UnsLongLongInt"/>
	    Low32 : UDINT;
	    High32 : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_ChangeRoleCmd : STRUCT  //! <Type Public="true" Comment="ChangeRole() parameter" Name="_DS_ChangeRoleCmd"/>
	    roleID : UDINT;  //! <Type Comment="The ID of the role to be changed.&#13;&#10;&#13;&#10;Die ID der Rolle die geändert werden soll." Name="_DS_ChangeRoleCmd.roleID"/>
	    pRoleName : ^UINT;  //! <Type Comment="Pointer to the new name of the role or pointer to &quot;&quot; if nothing is to be changed.&#13;&#10;&#13;&#10;Zeiger auf den neuen Namen der Rolle oder Zeiger auf &quot;&quot; wenn nichts geändert werden soll." Name="_DS_ChangeRoleCmd.pRoleName"/>
	    pInfo : ^UINT;  //! <Type Comment="Pointer to the changed information or pointer to &quot;&quot; if nothing is to be changed.&#13;&#10;&#13;&#10;Zeiger auf die geänderten Informationen oder Zeiger auf &quot;&quot; wenn nichts geändert werden soll&#10;." Name="_DS_ChangeRoleCmd.pInfo"/>
	    pWriteAccessString : ^UINT;  //! <Type Comment="Pointer to the changed Write Access String or pointer to &quot;&quot; if nothing is to be changed.&#13;&#10;&#13;&#10;Zeiger auf den geänderten Write Access String oder Zeiger auf &quot;&quot; wenn nichts geändert werden soll&#10;." Name="_DS_ChangeRoleCmd.pWriteAccessString"/>
	    pReadAccessString : ^UINT;  //! <Type Comment="Pointer to the changed Read Access String or pointer to &quot;&quot; if nothing is to be changed.&#13;&#10;&#13;&#10;Zeiger auf den geänderten Read Access String oder Zeiger auf &quot;&quot; wenn nichts geändert werden soll&#10;." Name="_DS_ChangeRoleCmd.pReadAccessString"/>
	    privileges : _DS_UnsLongLongInt;  //! <Type Comment="The new privileges of a user, or 0xFFFFFFFFFFFFFFFFFFFF if nothing is to be changed.&#13;&#10;&#13;&#10;Die neuen Berechtigungen eines Benutzers, oder 0xFFFFFFFFFFFFFFFF wenn nichts geändert werden soll." Name="_DS_ChangeRoleCmd.privileges"/>
	    noOperationTimeout : UINT;  //! <Type Comment="The new timeout or 0xFFFFFFFF if nothing is to be changed.&#13;&#10;&#13;&#10;Das neue Timeout für Inaktivität oder 0xFFFFFFFF wenn nichts geändert werden soll." Name="_DS_ChangeRoleCmd.noOperationTimeout"/>
	    AccessNumberValid : USINT;
	    AccessNumber : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_ChangeRoleResp : STRUCT  //! <Type Public="true" Comment="ChangeRole() response data.&#13;&#10;&#13;&#10;ChangeRole() Response-Daten." Name="_DS_ChangeRoleResp"/>
	    roleID : UDINT;  //! <Type Comment="The ID of the role that should be changed (0 in case of errors).&#13;&#10;&#13;&#10;Die ID der Rolle die geändert werden sollte (0 bei Fehlern)." Name="_DS_ChangeRoleResp.roleID"/>
	    ErrorCode : UDINT;  //! <Type Comment="The Error Code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_ChangeRoleResp.ErrorCode"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_ChangeUserSettingsCmd : STRUCT  //! <Type Public="true" Comment="ChangeUserSettings() parameter" Name="_DS_ChangeUserSettingsCmd"/>
	    UserID : UDINT;  //! <Type Comment="The ID of the user to be changed.&#13;&#10;&#13;&#10;Die ID des Benutzers der geändert werden soll." Name="_DS_ChangeUserSettingsCmd.UserID"/>
	    pName : ^UINT;  //! <Type Comment="Pointer to the changed user name or pointer to &quot;&quot; if you do not want to change it.&#13;&#10;&#13;&#10;Zeiger auf den geänderten Benutzernamen oder Zeiger auf &quot;&quot; wenn er nicht geändert werden soll." Name="_DS_ChangeUserSettingsCmd.pName"/>
	    pPassword : ^UINT;  //! <Type Comment="Pointer to the changed password or pointer to &quot;&quot; if nothing is to be changed.&#13;&#10;&#13;&#10;Zeiger auf das geänderte Passwort oder Zeiger auf &quot;&quot; wenn nichts geändert werden soll." Name="_DS_ChangeUserSettingsCmd.pPassword"/>
	    pFirstName : ^UINT;  //! <Type Comment="Pointer to the changed first name or pointer to &quot;&quot; if nothing is to be changed.&#13;&#10;&#13;&#10;Zeiger auf den geänderten Vornamen oder Zeiger auf &quot;&quot; wenn nichts geändert werden soll." Name="_DS_ChangeUserSettingsCmd.pFirstName"/>
	    pLastName : ^UINT;  //! <Type Comment="Pointer to the changed last name or pointer to &quot;&quot; if nothing is to be changed.&#13;&#10;&#13;&#10;Zeiger auf den geänderten Nachnamen oder Zeiger auf &quot;&quot; wenn nichts geändert werden soll." Name="_DS_ChangeUserSettingsCmd.pLastName"/>
	    numRoles : UDINT;  //! <Type Comment="The number of roles or 0xFFFFFFFF if nothing is to be changed.&#13;&#10;&#13;&#10;Die Anzahl der Rollen oder 0xFFFFFFFF wenn nichts geändert werden soll." Name="_DS_ChangeUserSettingsCmd.numRoles"/>
	    pRoleID : ^UDINT;  //! <Type Comment="Pointer to an array with &lt;numRoles&gt; role IDs.&#13;&#10;With &lt;numRoles&gt;= 0xFFFFFFFF these entries are omitted.&#13;&#10;&#13;&#10;Zeiger auf ein Array mit &lt;numRoles&gt; Rollen IDs.&#13;&#10;Bei &lt;numRoles&gt;= 0xFFFFFFFF entfallen diese Einträge." Name="_DS_ChangeUserSettingsCmd.pRoleID"/>
	    pInfo : ^UINT;  //! <Type Comment="Pointer to the changed information or pointer to &quot;&quot; if nothing is to be changed.&#13;&#10;&#13;&#10;Zeiger auf die geänderten Informationen oder Zeiger auf &quot;&quot; wenn nichts geändert werden soll&#10;." Name="_DS_ChangeUserSettingsCmd.pInfo"/>
	    AccessNumberValid : USINT;
	    AccessNumber : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_ChangeUserSettingsResp : STRUCT  //! <Type Public="true" Comment="ChangeUserSettings() response data.&#13;&#10;&#13;&#10;ChangeUserSettings() Response-Daten." Name="_DS_ChangeUserSettingsResp"/>
	    UserID : UDINT;  //! <Type Comment="The ID of the changed user.&#13;&#10;&#13;&#10;Die ID des geänderten Benutzers." Name="_DS_ChangeUserSettingsResp.UserID"/>
	    ErrorCode : UDINT;  //! <Type Comment="The Error Code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_ChangeUserSettingsResp.ErrorCode"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_ChannelInfo : STRUCT  //! <Type Comment="Kanalverwaltung für Ref List Update bzw. Ref List Update String." Name="_DS_ChannelInfo"/>
	    pThis : ^DSComm_Interface;  //! <Type Comment="Zeiger auf ein Objekt für Ref List Update Nachrichten." Name="_DS_ChannelInfo.pThis"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_CheckAccessLevelCmd : STRUCT  //! <Type Public="true" Comment="CheckAccessLevel() parameter." Name="_DS_CheckAccessLevelCmd"/>
	    UserID : UDINT;  //! <Type Comment="The ID of the user for whom the access level is to be checked.&#13;&#10;&#13;&#10;Die ID des Benutzers für den der AccessLevel überprüft werden soll." Name="_DS_CheckAccessLevelCmd.UserID"/>
	    AccessLevel : UINT;  //! <Type Comment="The access level to be checked.&#13;&#10;&#13;&#10;Der AccessLevel der überprüft werden soll." Name="_DS_CheckAccessLevelCmd.AccessLevel"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_CheckAccessLevelResp : STRUCT  //! <Type Public="true" Comment="CheckAccessLevel() response data.&#13;&#10;&#13;&#10;CheckAccessLevel() Response-Daten." Name="_DS_CheckAccessLevelResp"/>
	    UserID : UDINT;  //! <Type Comment="The user ID which was checked.&#13;&#10;&#13;&#10;Die Benutzer ID welche überprüft wurde." Name="_DS_CheckAccessLevelResp.UserID"/>
	    AccessLevel : UINT;  //! <Type Comment="The access level that was checked.&#13;&#10;&#13;&#10;Der AccessLevel der überprüft wurde." Name="_DS_CheckAccessLevelResp.AccessLevel"/>
	    ErrorCode : UDINT;  //! <Type Comment="The Error Code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_CheckAccessLevelResp.ErrorCode"/>
	    writeAllowed : USINT;  //! <Type Comment="The result of the evaluated AccessLogic (all != 0 is allowed).&#13;&#10;&#13;&#10;Das Ergebnis der ausgewerteten AccessLogic (alles != 0 ist erlaubt)." Name="_DS_CheckAccessLevelResp.writeAllowed"/>
	    readAllowed : USINT;  //! <Type Comment="The result of the evaluated AccessLogic (all != 0 is allowed).&#13;&#10;&#13;&#10;Das Ergebnis der ausgewerteten AccessLogic (alles != 0 ist erlaubt)." Name="_DS_CheckAccessLevelResp.readAllowed"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_ClearLocalClientListResp : STRUCT  //! <Type Public="true" Comment="ClearLocalClientList() response data.&#13;&#10;&#13;&#10;ClearLocalClientList() Response-Daten." Name="_DS_ClearLocalClientListResp"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_ClearLocalClientListResp.ErrorCode"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_JobInfoElmt : STRUCT  //! <Type Comment="Ein Element im Job-Array.&#13;&#10;Das Element gilt als frei, wenn StartTime = 0." Name="_DS_JobInfoElmt"/>
	    MessageID : DINT;
	    pThis : ^DSComm_Interface;  //! <Type Comment="Zeiger auf das Objekt in dem die Response-Methode aufgerufen wird." Name="_DS_JobInfoElmt.pThis"/>
	    StartTime : UDINT;  //! <Type Comment="StartTime in [ms] or 0." Name="_DS_JobInfoElmt.StartTime"/>
	    Error : DINT;  //! <Type Comment="TCP error number" Name="_DS_JobInfoElmt.Error"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_CommTask_Rec : STRUCT  //! <Type Comment="Record für den Datentransfer zum Kommunikations-Task." Name="_DS_CommTask_Rec"/>
	    pData : pVoid;  //! <Type Comment="Pointer to the buffer holding data to send." Name="_DS_CommTask_Rec.pData"/>
	    SockNo : DINT;  //! <Type Comment="Socket number" Name="_DS_CommTask_Rec.SockNo"/>
	    pJobElmt : ^_DS_JobInfoElmt;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_CreateRoleCmd : STRUCT  //! <Type Public="true" Comment="CreateRole() parameter" Name="_DS_CreateRoleCmd"/>
	    pRoleName : ^UINT;  //! <Type Comment="Pointer to the name of the new role (Unicode-string).&#13;&#10;&#13;&#10;Zeiger auf den Namen der neuen Rolle (Unicode-String)." Name="_DS_CreateRoleCmd.pRoleName"/>
	    pWriteAccessString : ^UINT;  //! <Type Comment="Pointer to a Unicode-string which is used to evaluate the AccessNumber (e.g. $&lt;15;).&#13;&#10;&#13;&#10;Zeiger auf einen Unicode-String welcher zum Auswerten der AccessNumber verwendet wird (zB. $&lt;15;)." Name="_DS_CreateRoleCmd.pWriteAccessString"/>
	    pReadAccessString : ^UINT;  //! <Type Comment="Pointer to a Unicode-string which is used to evaluate the AccessNumber (e.g. $&lt;15;).&#13;&#10;&#13;&#10;Zeiger auf einen Unicode-String welcher zum Auswerten der AccessNumber verwendet wird (zB. $&lt;15;)." Name="_DS_CreateRoleCmd.pReadAccessString"/>
	    privileges : _DS_UnsLongLongInt;  //! <Type Comment="Privileges of a user.&#13;&#10;&#13;&#10;Berechtigungen eines Benutzers." Name="_DS_CreateRoleCmd.privileges"/>
	    noOperationTimeout : UINT;  //! <Type Comment="Time in seconds until the user is logged out when inactive.&#13;&#10;&#13;&#10;Zeit in Sekunden bis ein Benutzer bei Inaktivität abgemeldet wird." Name="_DS_CreateRoleCmd.noOperationTimeout"/>
	    pInfo : ^UINT;  //! <Type Comment="Pointer to the information that is stored as a Unicode-string in addition to the role.&#13;&#10;&#13;&#10;Zeiger auf die Information die zusätzlich zur Rolle als Unicode-String gespeichert wird." Name="_DS_CreateRoleCmd.pInfo"/>
	    AccessNumberValid : USINT;  //! <Type Comment="TRUE if the &lt;AccessNumber&gt; should be used.&#13;&#10;With FALSE the &lt;AccessNumber&gt; has no meaning.&#13;&#10;&#13;&#10;TRUE, wenn die &lt;AccessNumber&gt; verwendet werden soll.&#13;&#10;Bei FALSE hat die &lt;AccessNumber&gt; keine Bedeutung." Name="_DS_CreateRoleCmd.AccessNumberValid"/>
	    AccessNumber : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_CreateRoleResp : STRUCT  //! <Type Public="true" Comment="CreateRole() response data.&#13;&#10;&#13;&#10;CreateRole() Response-Daten." Name="_DS_CreateRoleResp"/>
	    RoleID : UDINT;  //! <Type Comment="The ID of the new role (0 on error &apos;INSUFFICIENT_PRIVILEGES&apos;).&#13;&#10;&#13;&#10;Die ID der neuen Rolle (0 beim Fehler &apos;INSUFFICIENT_PRIVILEGES&apos;)." Name="_DS_CreateRoleResp.RoleID"/>
	    ErrorCode : UDINT;  //! <Type Comment="The Error Code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_CreateRoleResp.ErrorCode"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_CreateUserCmd : STRUCT  //! <Type Public="true" Comment="CreateUser() parameter." Name="_DS_CreateUserCmd"/>
	    pName : ^UINT;  //! <Type Comment="Pointer to the user name of the new user.&#13;&#10;&#13;&#10;Zeiger auf den Benutzernamen des neuen Benutzers." Name="_DS_CreateUserCmd.pName"/>
	    pPassword : ^UINT;  //! <Type Comment="Pointer to the password of the new user.&#13;&#10;&#13;&#10;Zeiger auf das Passwort des neuen Benutzers." Name="_DS_CreateUserCmd.pPassword"/>
	    pFirstName : ^UINT;  //! <Type Comment="Pointer to the first name of the new user.&#13;&#10;&#13;&#10;Zeiger auf den Vornamen des neunen Benutzers." Name="_DS_CreateUserCmd.pFirstName"/>
	    pLastName : ^UINT;  //! <Type Comment="Pointer to the lastname of the new user.&#13;&#10;&#13;&#10;Zeiger auf den Nachnamen des neuen Benutzers." Name="_DS_CreateUserCmd.pLastName"/>
	    numRoles : UDINT;  //! <Type Comment="The number of rolls.&#13;&#10;&#13;&#10;Die Anzahl der Rollen." Name="_DS_CreateUserCmd.numRoles"/>
	    pRoleID : ^UDINT;  //! <Type Comment="Pointer to an array with &lt;numRoles&gt; role IDs.&#13;&#10;&#13;&#10;Zeiger auf ein Array mit &lt;numRoles&gt; Rollen IDs." Name="_DS_CreateUserCmd.pRoleID"/>
	    pInfo : ^UINT;  //! <Type Comment="Pointer to the information to be stored as a string in addition to the user data.&#13;&#10;&#13;&#10;Zeiger auf die Informationen die zusätzlich zu den Benutzerdaten als String gespeichert werden sollen." Name="_DS_CreateUserCmd.pInfo"/>
	    AccessNumberValid : USINT;  //! <Type Comment="TRUE if the &lt;AccessNumber&gt; should be used.&#13;&#10;With FALSE the &lt;AccessNumber&gt; has no meaning.&#13;&#10;&#13;&#10;TRUE, wenn die &lt;AccessNumber&gt; verwendet werden soll.&#13;&#10;Bei FALSE hat die &lt;AccessNumber&gt; keine Bedeutung." Name="_DS_CreateUserCmd.AccessNumberValid"/>
	    AccessNumber : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_CreateUserResp : STRUCT  //! <Type Public="true" Comment="CreateUser() response data.&#13;&#10;&#13;&#10;CreateUser() Response-Daten." Name="_DS_CreateUserResp"/>
	    UserID : UDINT;  //! <Type Comment="The ID of the newly created user (0 on error &apos;INSUFFICIENT_PRIVILEGES&apos;).&#13;&#10;&#13;&#10;Die ID des neu erstellten Benutzers (0 beim Fehler &apos;INSUFFICIENT_PRIVILEGES&apos;)." Name="_DS_CreateUserResp.UserID"/>
	    ErrorCode : UDINT;  //! <Type Comment="The Error Code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_CreateUserResp.ErrorCode"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_DeleteRoleResp : STRUCT  //! <Type Public="true" Comment="DeleteRole() response data.&#13;&#10;&#13;&#10;DeleteRole() Response-Daten." Name="_DS_DeleteRoleResp"/>
	    RoleID : UDINT;  //! <Type Comment="The ID of the role that should be deleted.&#13;&#10;&#13;&#10;Die ID der Rolle die gelöscht werden sollte." Name="_DS_DeleteRoleResp.RoleID"/>
	    ErrorCode : UDINT;  //! <Type Comment="The Error Code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_DeleteRoleResp.ErrorCode"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_DeleteUserResp : STRUCT  //! <Type Public="true" Comment="DeleteUser() response data.&#13;&#10;&#13;&#10;DeleteUser() Response-Daten." Name="_DS_DeleteUserResp"/>
	    UserID : UDINT;  //! <Type Comment="The ID of the user who should be deleted.&#13;&#10;&#13;&#10;Die ID des Benutzers der gelöscht werden sollte." Name="_DS_DeleteUserResp.UserID"/>
	    ErrorCode : UDINT;  //! <Type Comment="The Error Code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_DeleteUserResp.ErrorCode"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_DirCreateResp : STRUCT  //! <Type Public="true" Comment="DirCreate() response data.&#13;&#10;&#13;&#10;DirCreate() Response-Daten." Name="_DS_DirCreateResp"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_DirCreateResp.ErrorCode"/>
	    pDp : ^CHAR;  //! <Type Comment="Pointer to drive + path of the new directory.&#13;&#10;This is an UTF8-string.&#13;&#10;&#13;&#10;Zeiger auf drive + path des neuen Verzeichnisses.&#13;&#10;Dies ist ein UTF8-String." Name="_DS_DirCreateResp.pDp"/>
	    DpLen : UDINT;  //! <Type Comment="Number of bytes in the string that &lt;pDp&gt; points to. Without end character.&#13;&#10;StrLenUtf8() returns the number of characters.&#13;&#10;&#13;&#10;Anzahl der Bytes im String auf den &lt;pDp&gt; zeigt. Ohne Endezeichen.&#13;&#10;StrLenUtf8() liefert die Anzahl der Zeichen." Name="_DS_DirCreateResp.DpLen"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_DirReadResp : STRUCT  //! <Type Public="true" Comment="DirRead() response data.&#13;&#10;Time and date in Lasal format (see classes _SysDateTime and _SysDateTime2).&#13;&#10;&#13;&#10;Time Format: HHHHHHHHMMMMMMMMSSSSSSSS&#13;&#10;Bit 24-31 (H) contains the hour from 0 to 23.&#13;&#10;Bit 16-23 (M) contains the minute from 0 to 59. &#13;&#10;Bit 8 -15 (S) contains the second from 0 to 59.&#13;&#10;&#13;&#10;Date Format: YYYYYYYYYYYYYYYYMMMMDDDDDDDDWWWW&#13;&#10;Bit 16-31 (Y) contains the entire year (e.g. 2003).&#13;&#10;Bit 12-15 (M) contains the current month from 1 to 12. &#13;&#10;Bit 4-11 (D) contains the day information from 1 to 31.&#13;&#10;Bit 0-3 (W) contains the day of the week, where 0 stands for Sunday, 1 for Monday, etc.&#13;&#10;&#13;&#10;&#13;&#10;DirRead() Response-Daten.&#13;&#10;Zeit und Datum im Lasal Format (siehe Klassen _SysDateTime und _SysDateTime2).&#13;&#10;&#13;&#10;Zeit-Format: HHHHHHHHMMMMMMMMSSSSSSSS&#13;&#10;Bit 24-31 (H) beinhaltet die Stunde von 0 bis 23.&#13;&#10;Bit 16-23 (M) beinhaltet die Minute von 0 bis 59.&#13;&#10;Bit 8 -15  (S) beinhaltet die Sekunde von 0 bis 59.&#13;&#10;&#13;&#10;Datums-Format: YYYYYYYYYYYYYYYYMMMMDDDDDDDDWWWW&#13;&#10;Bit 16-31 (Y) beinhaltet die gesamte Jahreszahl (z.B. 2003).&#13;&#10;Bit 12-15 (M) beinhaltet das aktuelle Monat von 1 bis 12. &#13;&#10;Bit 4-11   (D) beinhaltet die Tagesinformation von 1 bis 31.&#13;&#10;Bit 0-3     (W) beinhaltet den Wochentag, wobei 0 für Sonntag, 1 für Montag, usw. steht." Name="_DS_DirReadResp"/>
	    Attribute : UDINT;  //! <Type Comment="File attributes.&#13;&#10;&#13;&#10;Die Datei-Attribute." Name="_DS_DirReadResp.Attribute"/>
	    Length : _DS_UnsLongLongInt;  //! <Type Comment="File length in bytes.&#13;&#10;&#13;&#10;Dateilänge in Byte." Name="_DS_DirReadResp.Length"/>
	    AccessDate : UDINT;  //! <Type Comment="Date of last access (date in Lasal format).&#13;&#10;&#13;&#10;Datum des letzten Zugriffs (Datum im Lasal Format)." Name="_DS_DirReadResp.AccessDate"/>
	    AccessTime : UDINT;  //! <Type Comment="Time of last access (time in Lasal format).&#13;&#10;&#13;&#10;Uhrzeit des letzten Zugriffs (Zeit im Lasal Format)." Name="_DS_DirReadResp.AccessTime"/>
	    ModifiedDate : UDINT;  //! <Type Comment="Date of last change (date in Lasal format).&#13;&#10;&#13;&#10;Datum der letzten Änderung (Datum im Lasal Format)." Name="_DS_DirReadResp.ModifiedDate"/>
	    ModifiedTime : UDINT;  //! <Type Comment="Time of last change (time in Lasal format).&#13;&#10;&#13;&#10;Uhrzeit der letzten Änderung (Zeit im Lasal Format)." Name="_DS_DirReadResp.ModifiedTime"/>
	    CreatedDate : UDINT;  //! <Type Comment="Creation date (date in Lasal format).&#13;&#10;&#13;&#10;Erstellungsdatum (Datum im Lasal Format)." Name="_DS_DirReadResp.CreatedDate"/>
	    CreatedTime : UDINT;  //! <Type Comment="Creation time (time in Lasal format).&#13;&#10;&#13;&#10;Uhrzeit des Erstellens (Zeit im Lasal Format)." Name="_DS_DirReadResp.CreatedTime"/>
	    pNe : ^CHAR;  //! <Type Comment="Pointer to name + extension of a file.&#13;&#10;This is an UTF8-string.&#13;&#10;&#13;&#10;Zeiger auf Name + Namenserweiterung einer Datei.&#13;&#10;Dies ist ein UTF8-String." Name="_DS_DirReadResp.pNe"/>
	    NeLen : UDINT;  //! <Type Comment="Number of bytes in the string that &lt;pNe&gt; points to. Without end character.&#13;&#10;StrLenUtf8() returns the number of characters.&#13;&#10;&#13;&#10;Anzahl der Bytes im String auf den &lt;pNe&gt; zeigt. Ohne Endezeichen.&#13;&#10;StrLenUtf8() liefert die Anzahl der Zeichen." Name="_DS_DirReadResp.NeLen"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_EventjournalAddCmd : STRUCT  //! <Type Public="true" Comment="EventjournalAdd() parameters.&#13;&#10;&#13;&#10;EventjournalAdd() Parameter." Name="_DS_EventjournalAddCmd"/>
	    Size : UDINT;  //! <Type Comment="Length of the data that &lt;pData&gt; points to in bytes.&#13;&#10;&#13;&#10;Länge der Daten auf die &lt;pData&gt; zeigt in Bytes." Name="_DS_EventjournalAddCmd.Size"/>
	    ID : UINT;  //! <Type Comment="Data identifier.&#13;&#10;&#13;&#10;Datenkennung." Name="_DS_EventjournalAddCmd.ID"/>
	    nc : UINT;  //! <Type Comment="Unused, default = 0." Name="_DS_EventjournalAddCmd.nc"/>
	    EvtTime : UDINT;  //! <Type Comment="Time in Lasal format (see classes _SysDateTime and _SysDateTime2).&#13;&#10;&#13;&#10;Time Format: HHHHHHHHMMMMMMMMSSSSSSSS&#13;&#10;Bit 24-31 (H) contains the hour from 0 to 23.&#13;&#10;Bit 16-23 (M) contains the minute from 0 to 59. &#13;&#10;Bit 8 -15 (S) contains the second from 0 to 59.&#13;&#10;&#13;&#10;Zeit im Lasal Format (siehe Klassen _SysDateTime und _SysDateTime2).&#13;&#10;&#13;&#10;Zeit-Format: HHHHHHHHMMMMMMMMSSSSSSSS&#13;&#10;Bit 24-31 (H) beinhaltet die Stunde von 0 bis 23.&#13;&#10;Bit 16-23 (M) beinhaltet die Minute von 0 bis 59.&#13;&#10;Bit 8 -15  (S) beinhaltet die Sekunde von 0 bis 59." Name="_DS_EventjournalAddCmd.EvtTime"/>
	    EvtDate : UDINT;  //! <Type Comment="Date in Lasal format (see classes _SysDateTime and _SysDateTime2).&#13;&#10;&#13;&#10;Date Format: YYYYYYYYYYYYYYYYMMMMDDDDDDDDWWWW&#13;&#10;Bit 16-31 (Y) contains the entire year (e.g. 2003).&#13;&#10;Bit 12-15 (M) contains the current month from 1 to 12. &#13;&#10;Bit 4-11 (D) contains the day information from 1 to 31.&#13;&#10;Bit 0-3 (W) contains the day of the week, where 0 stands for Sunday, 1 for Monday, etc.&#13;&#10;&#13;&#10;Datum im Lasal Format (siehe Klassen _SysDateTime und _SysDateTime2).&#13;&#10;&#13;&#10;Datums-Format: YYYYYYYYYYYYYYYYMMMMDDDDDDDDWWWW&#13;&#10;Bit 16-31 (Y) beinhaltet die gesamte Jahreszahl (z.B. 2003).&#13;&#10;Bit 12-15 (M) beinhaltet das aktuelle Monat von 1 bis 12. &#13;&#10;Bit 4-11   (D) beinhaltet die Tagesinformation von 1 bis 31.&#13;&#10;Bit 0-3     (W) beinhaltet den Wochentag, wobei 0 für Sonntag, 1 für Montag, usw. steht." Name="_DS_EventjournalAddCmd.EvtDate"/>
	    SessionID : UDINT;  //! <Type Comment="Session ID at time of occurrence (0, filled in by data service).&#13;&#10;&#13;&#10;Session-ID zum Zeitpunkt des Auftretens (0, wird vom Data Service ausgefüllt)." Name="_DS_EventjournalAddCmd.SessionID"/>
	    pData : ^CHAR;  //! <Type Comment="Pointer to the data.&#13;&#10;&#13;&#10;Zeiger auf die Daten." Name="_DS_EventjournalAddCmd.pData"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_EventjournalAddResp : STRUCT  //! <Type Public="true" Comment="EventjournalAdd() response data.&#13;&#10;&#13;&#10;EventjournalAdd() Response-Daten." Name="_DS_EventjournalAddResp"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_EventjournalAddResp.ErrorCode"/>
	    CRC : UDINT;  //! <Type Comment="crc32 starting from &lt;idxcnt&gt; including &lt;DataLen&gt; user data.&#13;&#10;&#13;&#10;crc32 beginnend ab &lt;idxcnt&gt; inklusive von &lt;DataLen&gt; Anwenderdaten." Name="_DS_EventjournalAddResp.CRC"/>
	    idxcnt : UDINT;  //! <Type Comment="Unique record ID.&#13;&#10;&#13;&#10;Eindeutige Record-ID." Name="_DS_EventjournalAddResp.idxcnt"/>
	    valid : UINT;  //! <Type Comment="0xFF = valid.&#13;&#10;&#13;&#10;0xFF = gültig." Name="_DS_EventjournalAddResp.valid"/>
	    DataLen : UINT;  //! <Type Comment="Data length without record header.&#13;&#10;&#13;&#10;Datenlänge ohne Record Header." Name="_DS_EventjournalAddResp.DataLen"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_EventjournalDelAllResp : STRUCT  //! <Type Public="true" Comment="EventjournalDelAll() response data.&#13;&#10;&#13;&#10;EventjournalDelAll() Response-Daten." Name="_DS_EventjournalDelAllResp"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_EventjournalDelAllResp.ErrorCode"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_EventjournalDelResp : STRUCT  //! <Type Public="true" Comment="EventjournalDel() response data.&#13;&#10;&#13;&#10;EventjournalDel() Response-Daten." Name="_DS_EventjournalDelResp"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_EventjournalDelResp.ErrorCode"/>
	    JournalID : UDINT;  //! <Type Comment="The ID of the journal entry.&#13;&#10;&#13;&#10;Die ID des Journaleintrags." Name="_DS_EventjournalDelResp.JournalID"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_EventjournalGetResp : STRUCT  //! <Type Public="true" Comment="EventjournalGet() and EventjournalGetAll() response data.&#13;&#10;&#13;&#10;EventjournalGet() und EventjournalGetAll() Response-Daten." Name="_DS_EventjournalGetResp"/>
	    CRC : UDINT;  //! <Type Comment="crc32 starting from &lt;idxcnt&gt; including &lt;DataLen&gt; user data.&#13;&#10;&#13;&#10;crc32 beginnend ab &lt;idxcnt&gt; inklusive von &lt;DataLen&gt; Anwenderdaten." Name="_DS_EventjournalGetResp.CRC"/>
	    idxcnt : UDINT;  //! <Type Comment="Unique record ID.&#13;&#10;&#13;&#10;Eindeutige Record-ID." Name="_DS_EventjournalGetResp.idxcnt"/>
	    valid : UINT;  //! <Type Comment="0xFF = valid.&#13;&#10;&#13;&#10;0xFF = gültig." Name="_DS_EventjournalGetResp.valid"/>
	    DataLen : UINT;  //! <Type Comment="Length of the data that &lt;pData&gt; points to in bytes.&#13;&#10;&#13;&#10;Länge der Daten auf die &lt;pData&gt; zeigt in Bytes." Name="_DS_EventjournalGetResp.DataLen"/>
	    ID : UINT;  //! <Type Comment="Data identifier.&#13;&#10;&#13;&#10;Datenkennung." Name="_DS_EventjournalGetResp.ID"/>
	    nc : UINT;  //! <Type Comment="Unused, default = 0." Name="_DS_EventjournalGetResp.nc"/>
	    EvtTime : UDINT;  //! <Type Comment="Time in Lasal format (see classes _SysDateTime and _SysDateTime2).&#13;&#10;&#13;&#10;Time Format: HHHHHHHHMMMMMMMMSSSSSSSS&#13;&#10;Bit 24-31 (H) contains the hour from 0 to 23.&#13;&#10;Bit 16-23 (M) contains the minute from 0 to 59. &#13;&#10;Bit 8 -15 (S) contains the second from 0 to 59.&#13;&#10;&#13;&#10;Zeit im Lasal Format (siehe Klassen _SysDateTime und _SysDateTime2).&#13;&#10;&#13;&#10;Zeit-Format: HHHHHHHHMMMMMMMMSSSSSSSS&#13;&#10;Bit 24-31 (H) beinhaltet die Stunde von 0 bis 23.&#13;&#10;Bit 16-23 (M) beinhaltet die Minute von 0 bis 59.&#13;&#10;Bit 8 -15  (S) beinhaltet die Sekunde von 0 bis 59." Name="_DS_EventjournalGetResp.EvtTime"/>
	    EvtDate : UDINT;  //! <Type Comment="Date in Lasal format (see classes _SysDateTime and _SysDateTime2).&#13;&#10;&#13;&#10;Date Format: YYYYYYYYYYYYYYYYMMMMDDDDDDDDWWWW&#13;&#10;Bit 16-31 (Y) contains the entire year (e.g. 2003).&#13;&#10;Bit 12-15 (M) contains the current month from 1 to 12. &#13;&#10;Bit 4-11 (D) contains the day information from 1 to 31.&#13;&#10;Bit 0-3 (W) contains the day of the week, where 0 stands for Sunday, 1 for Monday, etc.&#13;&#10;&#13;&#10;Datum im Lasal Format (siehe Klassen _SysDateTime und _SysDateTime2).&#13;&#10;&#13;&#10;Datums-Format: YYYYYYYYYYYYYYYYMMMMDDDDDDDDWWWW&#13;&#10;Bit 16-31 (Y) beinhaltet die gesamte Jahreszahl (z.B. 2003).&#13;&#10;Bit 12-15 (M) beinhaltet das aktuelle Monat von 1 bis 12. &#13;&#10;Bit 4-11   (D) beinhaltet die Tagesinformation von 1 bis 31.&#13;&#10;Bit 0-3     (W) beinhaltet den Wochentag, wobei 0 für Sonntag, 1 für Montag, usw. steht." Name="_DS_EventjournalGetResp.EvtDate"/>
	    SessionID : UDINT;  //! <Type Comment="Session ID at time of occurrence.&#13;&#10;&#13;&#10;Session-ID zum Zeitpunkt des Auftretens." Name="_DS_EventjournalGetResp.SessionID"/>
	    pData : ^CHAR;  //! <Type Comment="Pointer to the data of the journal entry.&#13;&#10;&#13;&#10;Zeiger auf die Daten des Journaleintrags." Name="_DS_EventjournalGetResp.pData"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_EventjournalQuitAlarmResp : STRUCT  //! <Type Public="true" Comment="EventjournalQuitAlarm() response data.&#13;&#10;&#13;&#10;EventjournalQuitAlarm() Response-Daten." Name="_DS_EventjournalQuitAlarmResp"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_EventjournalQuitAlarmResp.ErrorCode"/>
	    AlarmID : UDINT;  //! <Type Comment="Alarm ID.&#13;&#10;&#13;&#10;Die ID des Alarms." Name="_DS_EventjournalQuitAlarmResp.AlarmID"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_EventjournalQuitAllResp : STRUCT  //! <Type Public="true" Comment="EventjournalQuitAll() response data.&#13;&#10;&#13;&#10;EventjournalQuitAll() Response-Daten." Name="_DS_EventjournalQuitAllResp"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_EventjournalQuitAllResp.ErrorCode"/>
	    StationID : UDINT;  //! <Type Comment="The ID of the station whose alarms are to be acknowledged.&#13;&#10;&#13;&#10;Die ID der Station deren Alarme quittiert werden sollen." Name="_DS_EventjournalQuitAllResp.StationID"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_FileCloseResp : STRUCT  //! <Type Public="true" Comment="FileClose() response data.&#13;&#10;&#13;&#10;FileClose() Response-Daten." Name="_DS_FileCloseResp"/>
	    handle : UDINT;  //! <Type Comment="The handle of the file that should be closed.&#13;&#10;&#13;&#10;Der Handle der Datei die geschlossen werden sollte." Name="_DS_FileCloseResp.handle"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_FileCloseResp.ErrorCode"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_FileContentResp : STRUCT  //! <Type Public="true" Comment="FileContent() response data.&#13;&#10;&#13;&#10;FileContent() Response-Daten." Name="_DS_FileContentResp"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_FileContentResp.ErrorCode"/>
	    paketOffset : _DS_UnsLongLongInt;  //! <Type Comment="Offset of the data of this packet in the file.&#13;&#10;&#13;&#10;Offset der Daten dieses Pakets in der Datei." Name="_DS_FileContentResp.paketOffset"/>
	    fileLength : _DS_UnsLongLongInt;  //! <Type Comment="File length in bytes.&#13;&#10;&#13;&#10;Länge der Datei in Bytes." Name="_DS_FileContentResp.fileLength"/>
	    dataLength : UDINT;  //! <Type Comment="Length of the data in this packet.&#13;&#10;&#13;&#10;Länge der Daten in diesem Paket." Name="_DS_FileContentResp.dataLength"/>
	    pData : ^CHAR;  //! <Type Comment="Pointer to the data of this packet.&#13;&#10;&#13;&#10;Zeiger auf die Daten dieses Pakets." Name="_DS_FileContentResp.pData"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_FileCopyResp : STRUCT  //! <Type Public="true" Comment="FileCopy() response data.&#13;&#10;&#13;&#10;FileCopy() Response-Daten." Name="_DS_FileCopyResp"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_FileCopyResp.ErrorCode"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_FileGetResp : STRUCT  //! <Type Public="true" Comment="FileGet() response data.&#13;&#10;&#13;&#10;FileGet() Response-Daten." Name="_DS_FileGetResp"/>
	    handle : UDINT;  //! <Type Comment="The file handle determined by FileOpen().&#13;&#10;&#13;&#10;Der von FileOpen() ermittelte Datei-Handle." Name="_DS_FileGetResp.handle"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_FileGetResp.ErrorCode"/>
	    length : UDINT;  //! <Type Comment="Number of bytes read.&#13;&#10;&#13;&#10;Anzahl der gelesenen Bytes." Name="_DS_FileGetResp.length"/>
	    pData : ^CHAR;  //! <Type Comment="Pointer to the bytes read.&#13;&#10;&#13;&#10;Zeiger auf die gelesenen Bytes." Name="_DS_FileGetResp.pData"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_FileInfoResp : STRUCT  //! <Type Public="true" Comment="FileInfo() response data.&#13;&#10;Time and date in Lasal format (see classes _SysDateTime and _SysDateTime2).&#13;&#10;&#13;&#10;Time Format: HHHHHHHHMMMMMMMMSSSSSSSS&#13;&#10;Bit 24-31 (H) contains the hour from 0 to 23.&#13;&#10;Bit 16-23 (M) contains the minute from 0 to 59. &#13;&#10;Bit 8 -15 (S) contains the second from 0 to 59.&#13;&#10;&#13;&#10;Date Format: YYYYYYYYYYYYYYYYMMMMDDDDDDDDWWWW&#13;&#10;Bit 16-31 (Y) contains the entire year (e.g. 2003).&#13;&#10;Bit 12-15 (M) contains the current month from 1 to 12. &#13;&#10;Bit 4-11 (D) contains the day information from 1 to 31.&#13;&#10;Bit 0-3 (W) contains the day of the week, where 0 stands for Sunday, 1 for Monday, etc.&#13;&#10;&#13;&#10;&#13;&#10;FileInfo() Response-Daten.&#13;&#10;Zeit und Datum im Lasal Format (siehe Klassen _SysDateTime und _SysDateTime2).&#13;&#10;&#13;&#10;Zeit-Format: HHHHHHHHMMMMMMMMSSSSSSSS&#13;&#10;Bit 24-31 (H) beinhaltet die Stunde von 0 bis 23.&#13;&#10;Bit 16-23 (M) beinhaltet die Minute von 0 bis 59.&#13;&#10;Bit 8 -15  (S) beinhaltet die Sekunde von 0 bis 59.&#13;&#10;&#13;&#10;Datums-Format: YYYYYYYYYYYYYYYYMMMMDDDDDDDDWWWW&#13;&#10;Bit 16-31 (Y) beinhaltet die gesamte Jahreszahl (z.B. 2003).&#13;&#10;Bit 12-15 (M) beinhaltet das aktuelle Monat von 1 bis 12. &#13;&#10;Bit 4-11   (D) beinhaltet die Tagesinformation von 1 bis 31.&#13;&#10;Bit 0-3     (W) beinhaltet den Wochentag, wobei 0 für Sonntag, 1 für Montag, usw. steht." Name="_DS_FileInfoResp"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_FileInfoResp.ErrorCode"/>
	    Attribute : UDINT;  //! <Type Comment="File attributes.&#13;&#10;&#13;&#10;Die Datei-Attribute." Name="_DS_FileInfoResp.Attribute"/>
	    Length : _DS_UnsLongLongInt;  //! <Type Comment="File length in bytes.&#13;&#10;&#13;&#10;Dateilänge in Byte." Name="_DS_FileInfoResp.Length"/>
	    AccessDate : UDINT;  //! <Type Comment="Date of last access (date in Lasal format).&#13;&#10;&#13;&#10;Datum des letzen Zugriffs (Datum im Lasal Format)." Name="_DS_FileInfoResp.AccessDate"/>
	    AccessTime : UDINT;  //! <Type Comment="Time of last access (time in Lasal format).&#13;&#10;&#13;&#10;Uhrzeit des letzten Zugriffs (Zeit im Lasal Format)." Name="_DS_FileInfoResp.AccessTime"/>
	    ModifiedDate : UDINT;  //! <Type Comment="Date of last change (date in Lasal format).&#13;&#10;&#13;&#10;Datum der letzten Änderung (Datum im Lasal Format)." Name="_DS_FileInfoResp.ModifiedDate"/>
	    ModifiedTime : UDINT;  //! <Type Comment="Time of last change (time in Lasal format).&#13;&#10;&#13;&#10;Uhrzeit der letzten Änderung (Zeit im Lasal Format)." Name="_DS_FileInfoResp.ModifiedTime"/>
	    CreatedDate : UDINT;  //! <Type Comment="Creation date (date in Lasal format).&#13;&#10;&#13;&#10;Erstellungsdatum (Datum im Lasal Format)." Name="_DS_FileInfoResp.CreatedDate"/>
	    CreatedTime : UDINT;  //! <Type Comment="Creation time (time in Lasal format).&#13;&#10;&#13;&#10;Uhrzeit des Erstellens (Zeit im Lasal Format)." Name="_DS_FileInfoResp.CreatedTime"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_FileLengthResp : STRUCT  //! <Type Public="true" Comment="FileLength() response data.&#13;&#10;&#13;&#10;FileLength() Response-Daten." Name="_DS_FileLengthResp"/>
	    handle : UDINT;  //! <Type Comment="The file handle determined by FileOpen().&#13;&#10;&#13;&#10;Der von FileOpen() ermittelte Datei-Handle." Name="_DS_FileLengthResp.handle"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_FileLengthResp.ErrorCode"/>
	    length : _DS_UnsLongLongInt;  //! <Type Comment="The file length in bytes.&#13;&#10;&#13;&#10;Die Länge der Datei in Bytes." Name="_DS_FileLengthResp.length"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_FileMoveResp : STRUCT  //! <Type Public="true" Comment="FileMove() response data.&#13;&#10;&#13;&#10;FileMove() Response-Daten." Name="_DS_FileMoveResp"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_FileMoveResp.ErrorCode"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_FileOpenResp : STRUCT  //! <Type Public="true" Comment="FileOpen() response data.&#13;&#10;&#13;&#10;FileOpen() Response-Daten." Name="_DS_FileOpenResp"/>
	    handle : UDINT;  //! <Type Comment="File handle with which the file can be processed.&#13;&#10;&#13;&#10;Datei-Handle mit dem die Datei bearbeitet werden kann." Name="_DS_FileOpenResp.handle"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_FileOpenResp.ErrorCode"/>
	    pDpne : ^CHAR;  //! <Type Comment="Pointer to the path to the file that was opened.&#13;&#10;This is an UTF8-string.&#13;&#10;&#13;&#10;Zeiger auf den Pfad zur Datei welche geöffnet wurde.&#13;&#10;Dies ist ein UTF8-String." Name="_DS_FileOpenResp.pDpne"/>
	    DpneLen : UDINT;  //! <Type Comment="Number of bytes in the string that &lt;pDpne&gt; points to. Without end character.&#13;&#10;StrLenUtf8() returns the number of characters.&#13;&#10;&#13;&#10;Anzahl der Bytes im String auf den &lt;pDpne&gt; zeigt. Ohne Endezeichen.&#13;&#10;StrLenUtf8() liefert die Anzahl der Zeichen." Name="_DS_FileOpenResp.DpneLen"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_FilePutResp : STRUCT  //! <Type Public="true" Comment="FilePut() response data.&#13;&#10;&#13;&#10;FilePut() Response-Daten." Name="_DS_FilePutResp"/>
	    handle : UDINT;  //! <Type Comment="The file handle determined by FileOpen().&#13;&#10;&#13;&#10;Der von FileOpen() ermittelte Datei-Handle." Name="_DS_FilePutResp.handle"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_FilePutResp.ErrorCode"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_FileReadResp : STRUCT  //! <Type Public="true" Comment="FileRead() response data.&#13;&#10;&#13;&#10;FileRead() Response-Daten." Name="_DS_FileReadResp"/>
	    handle : UDINT;  //! <Type Comment="The file handle determined by FileOpen().&#13;&#10;&#13;&#10;Der von FileOpen() ermittelte Datei-Handle." Name="_DS_FileReadResp.handle"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_FileReadResp.ErrorCode"/>
	    length : UDINT;  //! <Type Comment="Number of bytes read.&#13;&#10;&#13;&#10;Anzahl der gelesenen Bytes." Name="_DS_FileReadResp.length"/>
	    pData : ^CHAR;  //! <Type Comment="Pointer to the bytes read.&#13;&#10;&#13;&#10;Zeiger auf die gelesenen Bytes." Name="_DS_FileReadResp.pData"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_FileRemoveResp : STRUCT  //! <Type Public="true" Comment="FileRemove() response data.&#13;&#10;&#13;&#10;FileRemove() Response-Daten." Name="_DS_FileRemoveResp"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_FileRemoveResp.ErrorCode"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_FileRenameResp : STRUCT  //! <Type Public="true" Comment="FileRename() response data.&#13;&#10;&#13;&#10;FileRename() Response-Daten." Name="_DS_FileRenameResp"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_FileRenameResp.ErrorCode"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_FileSeekResp : STRUCT  //! <Type Public="true" Comment="FileSeek() response data.&#13;&#10;&#13;&#10;FileSeek() Response-Daten." Name="_DS_FileSeekResp"/>
	    handle : UDINT;  //! <Type Comment="The file handle determined by FileOpen().&#13;&#10;&#13;&#10;Der von FileOpen() ermittelte Datei-Handle." Name="_DS_FileSeekResp.handle"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_FileSeekResp.ErrorCode"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_FileSetAttributeResp : STRUCT  //! <Type Public="true" Comment="FileSetAttribute() response data.&#13;&#10;&#13;&#10;FileSetAttribute() Response-Daten." Name="_DS_FileSetAttributeResp"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_FileSetAttributeResp.ErrorCode"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_FileTellResp : STRUCT  //! <Type Public="true" Comment="FileTell() response data.&#13;&#10;&#13;&#10;FileTell() Response-Daten." Name="_DS_FileTellResp"/>
	    handle : UDINT;  //! <Type Comment="The file handle determined by FileOpen().&#13;&#10;&#13;&#10;Der von FileOpen() ermittelte Datei-Handle." Name="_DS_FileTellResp.handle"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_FileTellResp.ErrorCode"/>
	    offset : UDINT;  //! <Type Comment="Offset of the file pointer from the beginning of the file in bytes.&#13;&#10;&#13;&#10;Offset des Dateizeigers vom Dateianfang in Byte." Name="_DS_FileTellResp.offset"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_FileWriteResp : STRUCT  //! <Type Public="true" Comment="FileWrite() response data.&#13;&#10;&#13;&#10;FileWrite() Response-Daten." Name="_DS_FileWriteResp"/>
	    handle : UDINT;  //! <Type Comment="The file handle determined by FileOpen().&#13;&#10;&#13;&#10;Der von FileOpen() ermittelte Datei-Handle." Name="_DS_FileWriteResp.handle"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_FileWriteResp.ErrorCode"/>
	    length : UDINT;  //! <Type Comment="Number of bytes written.&#13;&#10;&#13;&#10;Anzahl der geschriebenen Bytes." Name="_DS_FileWriteResp.length"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_FragmentHeader : STRUCT  //! <Type Comment="Wird verwendet um zu große Datenpakete separat zu verschicken. Hierbei wird ein Fragment-Header über die Teilpakete gestülpt." Name="_DS_FragmentHeader"/>
	    UID : UDINT;  //! <Type Comment="Id die vom Sender pro Fragmentierung erhöht wird. Gleiche ID aller zusammengehöriger Pakete." Name="_DS_FragmentHeader.UID"/>
	    MessageID : UDINT;  //! <Type Comment="Message Id des zersetzten Kommandos." Name="_DS_FragmentHeader.MessageID"/>
	    gesLength : _DS_UnsLongLongInt;  //! <Type Comment="Gesamtlänger aller Pakete zusammen." Name="_DS_FragmentHeader.gesLength"/>
	    length : UDINT;  //! <Type Comment="Länge dieses Paketes." Name="_DS_FragmentHeader.length"/>
	    offset : _DS_UnsLongLongInt;  //! <Type Comment="Anhand des offsets ermitteln wir um welches der zusammengehörigen Pakete es sich handelt." Name="_DS_FragmentHeader.offset"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_GetCRCFromVarIdResp : STRUCT  //! <Type Public="true" Comment="GetCRCfromVarId() response data.&#13;&#10;&#13;&#10;GetCRCfromVarId() Response-Daten." Name="_DS_GetCRCFromVarIdResp"/>
	    VarID : UDINT;  //! <Type Comment="Variable ID.&#13;&#10;&#13;&#10;Die Variablen ID." Name="_DS_GetCRCFromVarIdResp.VarID"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;Attention! If ErrorCode is &lt;&gt; 0, then CRC is zero.&#13;&#10;&#13;&#10;Der Fehlercode.&#13;&#10;ACHTUNG! Wenn ErrorCode &lt;&gt; 0 ist, dann ist CRC null." Name="_DS_GetCRCFromVarIdResp.ErrorCode"/>
	    CRC : UDINT;  //! <Type Comment="The CRC of the data point. Attention: if ErrorCode is &lt;&gt; 0, then CRC is zero.&#13;&#10;&#13;&#10;Die CRC des Datenpunkts. ACHTUNG! wenn error &lt;&gt; 0, dann ist CRC null." Name="_DS_GetCRCFromVarIdResp.CRC"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_GetCurrentIDResp : STRUCT  //! <Type Public="true" Comment="GetCurrentID() response data.&#13;&#10;&#13;&#10;GetCurrentID() Response-Daten." Name="_DS_GetCurrentIDResp"/>
	    ID : UDINT;  //! <Type Comment="Client ID of the currently active session.&#13;&#10;&#13;&#10;Client ID der aktuellen Session." Name="_DS_GetCurrentIDResp.ID"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_GetCurrentIDResp.ErrorCode"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_GetDpInfoResp : STRUCT  //! <Type Public="true" Comment="GetDpInfo() response data.&#13;&#10;&#13;&#10;GetDpInfo() Response-Daten." Name="_DS_GetDpInfoResp"/>
	    VarID : UDINT;  //! <Type Comment="Variable ID of the data point.&#13;&#10;&#13;&#10;Variablen ID des Datenpunkts." Name="_DS_GetDpInfoResp.VarID"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;Attention! If ErrorCode is &lt;&gt; 0, then the content of the following fields is zero.&#13;&#10;&#13;&#10;Der Fehlercode.&#13;&#10;ACHTUNG! Wenn ErrorCode &lt;&gt; 0 ist, dann sind die nachfolgenden Felder null." Name="_DS_GetDpInfoResp.ErrorCode"/>
	    LasalID : UDINT;  //! <Type Comment="Lasal ID of the data point. See also ErrorCode.&#13;&#10;&#13;&#10;Die Lasal Id des Datenpunkts. Siehe auch ErrorCode." Name="_DS_GetDpInfoResp.LasalID"/>
	    pName : ^CHAR;  //! <Type Comment="Pointer to the name of the data point.&#13;&#10;Attention! if ErrorCode is &lt;&gt; 0, then pName = nil.&#13;&#10;&#13;&#10;Zeiger auf den Namen des Datenpunkts.&#13;&#10;ACHTUNG! wenn ErrorCode &lt;&gt; 0 ist, dann ist pName = nil." Name="_DS_GetDpInfoResp.pName"/>
	    NameLen : UDINT;  //! <Type Comment="Number of characters in the string that &lt;pName&gt; points to. Without end character.&#13;&#10;Attention! if ErrorCode is &lt;&gt; 0, then NameLen = 0.&#13;&#10;&#13;&#10;Anzahl der Zeichen im String auf den &lt;pName&gt; zeigt. Ohne Endezeichen.&#13;&#10;ACHTUNG! Wenn ErrorCode &lt;&gt; 0 ist, dann ist NameLen = 0." Name="_DS_GetDpInfoResp.NameLen"/>
	    Station : UDINT;  //! <Type Comment="The station of the data point. See also ErrorCode.&#13;&#10;&#13;&#10;Die Station des Datenpunktes. Siehe auch ErrorCode." Name="_DS_GetDpInfoResp.Station"/>
	    Scope : UDINT;  //! <Type Comment="The scope of the data point. See also ErrorCode.&#13;&#10;&#13;&#10;Der Geltungsbereich des Datenpunktes. Siehe auch ErrorCode." Name="_DS_GetDpInfoResp.Scope"/>
	    AccNo : UINT;  //! <Type Comment="The access number. See also ErrorCode.&#13;&#10;&#13;&#10;Die Access Nummer. Siehe auch ErrorCode." Name="_DS_GetDpInfoResp.AccNo"/>
	    LimitLowTyp : UINT;  //! <Type Comment="Info whether &lt;LimitLow&gt; should be interpreted as constant(1) or data point reference(2). See also ErrorCode.&#13;&#10;&#13;&#10;Info ob &lt;LimitLow&gt; als Konstante(1) oder Datenpunktreferenz(2) interpretiert werden soll. Siehe auch ErrorCode." Name="_DS_GetDpInfoResp.LimitLowTyp"/>
	    LimitLow : LREAL;  //! <Type Comment="The lower limit. See also ErrorCode.&#13;&#10;&#13;&#10;Das untere Limit. Siehe auch ErrorCode." Name="_DS_GetDpInfoResp.LimitLow"/>
	    LimitHighTyp : UINT;  //! <Type Comment="Info whether &lt;LimitHigh&gt; should be interpreted as constant(1) or data point reference(2). See also ErrorCode.&#13;&#10;&#13;&#10;Info ob &lt;LimitHigh&gt; als Konstante(1) oder Datenpunktreferenz(2) interpretiert werden soll. Siehe auch ErrorCode." Name="_DS_GetDpInfoResp.LimitHighTyp"/>
	    LimitHigh : LREAL;  //! <Type Comment="The upper limit. See also ErrorCode.&#13;&#10;&#13;&#10;Das obere Limit. Siehe auch ErrorCode." Name="_DS_GetDpInfoResp.LimitHigh"/>
	    RefTime : UDINT;  //! <Type Comment="The Refresh Time set in the LASAL VISU-Designer in [ms]. See also ErrorCode.&#13;&#10;&#13;&#10;Die im LASAL VISUDesigner eingestellte Refresh Time in [ms]. Siehe auch ErrorCode." Name="_DS_GetDpInfoResp.RefTime"/>
	    UserDefBits : _DS_UnsLongLongInt;  //! <Type Comment="The &lt;Userdefined Bits&gt; (LASAL VISUDesigner). See also ErrorCode.&#13;&#10;&#13;&#10;Die &lt;Userdefined Bits&gt; (LASAL VISUDesigner). Siehe auch ErrorCode." Name="_DS_GetDpInfoResp.UserDefBits"/>
	    AccessType : _DS_AccessType;  //! <Type Comment="Access type. See also ErrorCode.&#13;&#10;&#13;&#10;Der Access Type. Siehe auch ErrorCode." Name="_DS_GetDpInfoResp.AccessType"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_GetDpListResp : STRUCT  //! <Type Public="true" Comment="GetDpList() response data.&#13;&#10;&#13;&#10;GetDpList() Response-Daten." Name="_DS_GetDpListResp"/>
	    VarID : UDINT;  //! <Type Comment="&lt;num&gt; variable IDs of the data points.&#13;&#10;&#13;&#10;&lt;num&gt; Variablen IDs der Datenpunkte." Name="_DS_GetDpListResp.VarID"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_GetDriveListResp : STRUCT  //! <Type Public="true" Comment="GetDriveList() response data.&#13;&#10;&#13;&#10;GetDriveList() Response-Daten." Name="_DS_GetDriveListResp"/>
	    pDrives : ^CHAR;  //! <Type Comment="Pointer to a string in which all found drive letters are lined up (e.g. CDMU).&#13;&#10;&#13;&#10;Zeiger auf einen String in dem alle gefundenen Laufwerksbuchstaben aneinander gereiht sind (zB. CDMU)." Name="_DS_GetDriveListResp.pDrives"/>
	    DrivesLen : UDINT;  //! <Type Comment="Number of characters in the string that &lt;pDrives&gt; points to. Without end character.&#13;&#10;&#13;&#10;Anzahl der Zeichen im String auf den &lt;pDrives&gt; zeigt. Ohne Endezeichen." Name="_DS_GetDriveListResp.DrivesLen"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_GetLasalIdFromNameResp : STRUCT  //! <Type Public="true" Comment="GetLasalIdFromName() response data.&#13;&#10;&#13;&#10;GetLasalIdFromName() Response-Daten." Name="_DS_GetLasalIdFromNameResp"/>
	    pName : ^CHAR;  //! <Type Comment="Pointer to the name of the data point.&#13;&#10;&#13;&#10;Zeiger auf den Namen des Datenpunkts." Name="_DS_GetLasalIdFromNameResp.pName"/>
	    NameLen : UDINT;  //! <Type Comment="Number of characters in the string that &lt;pName&gt; points to. Without end character.&#13;&#10;&#13;&#10;Anzahl der Zeichen im String auf den &lt;pName&gt; zeigt. Ohne Endezeichen." Name="_DS_GetLasalIdFromNameResp.NameLen"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;Attention! If ErrorCode is &lt;&gt; 0, then the content of LasalId is zero.&#13;&#10;&#13;&#10;Der Fehlercode.&#13;&#10;ACHTUNG! Wenn ErrorCode &lt;&gt; 0 ist, dann ist LasalId null." Name="_DS_GetLasalIdFromNameResp.ErrorCode"/>
	    LasalId : UDINT;  //! <Type Comment="The Lasal-ID. Attention! If ErrorCode is &lt;&gt; 0, then the content of LasalId is zero.&#13;&#10;&#13;&#10;Die Lasal-ID. ACHTUNG! wenn ErrorCode &lt;&gt; 0 ist, dann ist LasalId null." Name="_DS_GetLasalIdFromNameResp.LasalId"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_GetLasalIdIdFromVarIdResp : STRUCT  //! <Type Public="true" Comment="GetLasalIdFromVarId() response data.&#13;&#10;&#13;&#10;GetLasalIdFromVarId() Response-Daten." Name="_DS_GetLasalIdIdFromVarIdResp"/>
	    VarID : UDINT;  //! <Type Comment="The variable number.&#13;&#10;&#13;&#10;Die Variablen Nummer." Name="_DS_GetLasalIdIdFromVarIdResp.VarID"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;Attention! If ErrorCode is &lt;&gt; 0, then the content of LasalId is zero.&#13;&#10;&#13;&#10;Der Fehlercode.&#13;&#10;ACHTUNG! Wenn ErrorCode &lt;&gt; 0 ist, dann ist LasalId null." Name="_DS_GetLasalIdIdFromVarIdResp.ErrorCode"/>
	    LasalID : UDINT;  //! <Type Comment="The Lasal-ID. Attention! If ErrorCode is &lt;&gt; 0, then the content of LasalId is zero.&#13;&#10;&#13;&#10;Die Lasal-ID. ACHTUNG! wenn ErrorCode &lt;&gt; 0 ist, dann ist LasalId null." Name="_DS_GetLasalIdIdFromVarIdResp.LasalID"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_GetLocalClientByIDCmd : STRUCT  //! <Type Public="true" Comment="GetLocalClientByID() parameters." Name="_DS_GetLocalClientByIDCmd"/>
	    ID : UDINT;  //! <Type Comment="ID of the client which data should be listed.&#13;&#10;&#13;&#10;Die ID des Clients dessen Daten ausgegeben werden sollen." Name="_DS_GetLocalClientByIDCmd.ID"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_GetLocalClientDetailsResp : STRUCT  //! <Type Public="true" Comment="GetLocalClientListDetails() and GetLocalClientByID() response data.&#13;&#10;&#13;&#10;GetLocalClientListDetails() und GetLocalClientByID() Response-Daten." Name="_DS_GetLocalClientDetailsResp"/>
	    ID : UDINT;  //! <Type Comment="The ID which was assigned to the client.&#13;&#10;&#13;&#10;Die ID welche dem Client zugewiesen wurde." Name="_DS_GetLocalClientDetailsResp.ID"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_GetLocalClientDetailsResp.ErrorCode"/>
	    Typ : USINT;  //! <Type Comment="Defines the type of identifier used:&#13;&#10;1 = IP-address&#13;&#10;2 = IP-address range&#13;&#10;3 = MAC-address&#13;&#10;4 = MAC-address range&#13;&#10;&#13;&#10;Definiert den Typ des verwendeten Identifiers:&#13;&#10;1 = IP-Adresse&#13;&#10;2 = IP-Adressbereich&#13;&#10;3 = MAC-Adresse&#13;&#10;4 = MAC-Adressbereich" Name="_DS_GetLocalClientDetailsResp.Typ"/>
	    onDuplicate : USINT;  //! <Type Comment="Defines what should happen if the ID is already assigned:&#13;&#10;0 = reject ID&#13;&#10;1 = use next free ID&#13;&#10;&#13;&#10;Definiert was passieren soll falls die ID bereits vergeben ist:&#13;&#10;0 = ID ablehnen&#13;&#10;1 = nächste freie ID verwenden" Name="_DS_GetLocalClientDetailsResp.onDuplicate"/>
	    pFrom : ^USINT;  //! <Type Comment="Pointer to the first identifier string in the range (IP-address / MAC-address).&#13;&#10;&#13;&#10;Zeiger auf den ersten Identifier des Bereichs (IP- / MAC-Adresse)." Name="_DS_GetLocalClientDetailsResp.pFrom"/>
	    FromLen : UDINT;  //! <Type Comment="Number of characters in the string that &lt;pFrom&gt; points to. Without end character.&#13;&#10;&#13;&#10;Anzahl der Zeichen im String auf den &lt;pFrom&gt; zeigt. Ohne Endezeichen." Name="_DS_GetLocalClientDetailsResp.FromLen"/>
	    pTo : ^USINT;  //! <Type Comment="Pointer to the last identifier string in the range (IP-address / MAC-address).&#13;&#10;&#13;&#10;Zeiger auf den letzten Identifier des Bereichs (IP- / MAC-Adresse)." Name="_DS_GetLocalClientDetailsResp.pTo"/>
	    ToLen : UDINT;  //! <Type Comment="Number of characters in the string that &lt;pTo&gt; points to. Without end character.&#13;&#10;&#13;&#10;Anzahl der Zeichen im String auf den &lt;pTo&gt; zeigt. Ohne Endezeichen." Name="_DS_GetLocalClientDetailsResp.ToLen"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_GetLocalClientListResp : STRUCT  //! <Type Public="true" Comment="GetLocalClientList() response data.&#13;&#10;&#13;&#10;GetLocalClientList() Response-Daten." Name="_DS_GetLocalClientListResp"/>
	    ID : UDINT;  //! <Type Comment="The ID which was assigned to the client.&#13;&#10;&#13;&#10;Die ID welche dem Client zugewiesen wurde." Name="_DS_GetLocalClientListResp.ID"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_GetLocalClientListResp.ErrorCode"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_GetLocalClientListRespInt : STRUCT  //! <Type Comment="Internal GetLocalClientList() response data." Name="_DS_GetLocalClientListRespInt"/>
	    Size : UDINT;  //! <Type Comment="size of the next entry" Name="_DS_GetLocalClientListRespInt.Size"/>
	    ID : UDINT;
	    ErrorCode : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_GetNameFromLasalIdCmd : STRUCT  //! <Type Public="true" Comment="GetNameFromLasalId() parameter" Name="_DS_GetNameFromLasalIdCmd"/>
	    LasalID : UDINT;  //! <Type Comment="Lasal ID of the requested variable.&#13;&#10;&#13;&#10;Lasal ID der gesuchten Variable." Name="_DS_GetNameFromLasalIdCmd.LasalID"/>
	    StationNo : UDINT;  //! <Type Comment="ID or number of the station.&#13;&#10;&#13;&#10;ID bzw. Nummer der Station." Name="_DS_GetNameFromLasalIdCmd.StationNo"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_GetNameFromLasalIdResp : STRUCT  //! <Type Public="true" Comment="GetNameFromLasalId() response data.&#13;&#10;&#13;&#10;GetNameFromLasalId() Response-Daten." Name="_DS_GetNameFromLasalIdResp"/>
	    LasalID : UDINT;  //! <Type Comment="Lasal ID of the requested variable.&#13;&#10;&#13;&#10;Lasal ID der gesuchten Variable." Name="_DS_GetNameFromLasalIdResp.LasalID"/>
	    StationNo : DINT;  //! <Type Comment="ID or number of the station.&#13;&#10;&#13;&#10;ID bzw. Nummer der Station." Name="_DS_GetNameFromLasalIdResp.StationNo"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;Attention! If ErrorCode is &lt;&gt; 0, then the content of the following fields is zero.&#13;&#10;&#13;&#10;Der Fehlercode.&#13;&#10;ACHTUNG! Wenn ErrorCode &lt;&gt; 0 ist, dann sind die nachfolgenden Felder null." Name="_DS_GetNameFromLasalIdResp.ErrorCode"/>
	    pName : ^CHAR;  //! <Type Comment="Pointer to the name of the data point.&#13;&#10;Attention! if ErrorCode is &lt;&gt; 0, then pName = nil.&#13;&#10;&#13;&#10;Zeiger auf den Namen des Datenpunkts.&#13;&#10;ACHTUNG! wenn ErrorCode &lt;&gt; 0 ist, dann ist pName = nil." Name="_DS_GetNameFromLasalIdResp.pName"/>
	    NameLen : UDINT;  //! <Type Comment="Number of characters in the string that &lt;pName&gt; points to. Without end character.&#13;&#10;Attention! if ErrorCode is &lt;&gt; 0, then NameLen = 0.&#13;&#10;&#13;&#10;Anzahl der Zeichen im String auf den &lt;pName&gt; zeigt. Ohne Endezeichen.&#13;&#10;ACHTUNG! wenn ErrorCode &lt;&gt; 0 ist, dann ist NameLen = 0." Name="_DS_GetNameFromLasalIdResp.NameLen"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_GetNameFromVarIdResp : STRUCT  //! <Type Public="true" Comment="GetNameFromVarId() response data.&#13;&#10;&#13;&#10;GetNameFromVarId() Response-Daten." Name="_DS_GetNameFromVarIdResp"/>
	    VarID : UDINT;  //! <Type Comment="The variable number.&#13;&#10;&#13;&#10;Die Variablen Nummer." Name="_DS_GetNameFromVarIdResp.VarID"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;Attention! If ErrorCode is &lt;&gt; 0, then the content of the following fields is zero.&#13;&#10;&#13;&#10;Der Fehlercode.&#13;&#10;ACHTUNG! Wenn ErrorCode &lt;&gt; 0 ist, dann sind die nachfolgenden Felder null." Name="_DS_GetNameFromVarIdResp.ErrorCode"/>
	    pName : ^CHAR;  //! <Type Comment="Pointer to the name of the data point.&#13;&#10;ATTENTION! if ErrorCode is &lt;&gt; 0, then pName = nil.&#13;&#10;&#13;&#10;Zeiger auf den Namen des Datenpunkts.&#13;&#10;ACHTUNG! wenn ErrorCode &lt;&gt; 0 ist, dann ist pName = nil." Name="_DS_GetNameFromVarIdResp.pName"/>
	    NameLen : UDINT;  //! <Type Comment="Number of characters in the string that &lt;pName&gt; points to. Without end character.&#13;&#10;ATTENTION! if ErrorCode is &lt;&gt; 0, then NameLen = 0.&#13;&#10;&#13;&#10;Anzahl der Zeichen im String auf den &lt;pName&gt; zeigt. Ohne Endezeichen.&#13;&#10;ACHTUNG! wenn ErrorCode &lt;&gt; 0 ist, dann ist NameLen = 0." Name="_DS_GetNameFromVarIdResp.NameLen"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_GetProjectInfoResp : STRUCT  //! <Type Public="true" Comment="GetProjectInfo() response data.&#13;&#10;&#13;&#10;GetProjectInfo() Response-Daten." Name="_DS_GetProjectInfoResp"/>
	    VersionNo : UDINT;  //! <Type Comment="The version number of the data service.&#13;&#10;&#13;&#10;Die Versionsnummer des Dataservice." Name="_DS_GetProjectInfoResp.VersionNo"/>
	    BuildNo : UDINT;  //! <Type Comment="The build number of the data service.&#13;&#10;&#13;&#10;Die Buildnummer des Dataservice." Name="_DS_GetProjectInfoResp.BuildNo"/>
	    ProjectCRC : UDINT;  //! <Type Comment="Project checksum.&#13;&#10;&#13;&#10;Projekt-Prüfsumme." Name="_DS_GetProjectInfoResp.ProjectCRC"/>
	    pProjectName : ^UINT;  //! <Type Comment="Pointer to the ProjectName which is always 128 Bytes.&#13;&#10;&#13;&#10;Zeiger auf den Projektnamen der immer 128 Bytes lang ist." Name="_DS_GetProjectInfoResp.pProjectName"/>
	    ProjNameLen : UDINT;  //! <Type Comment="Number of characters in the string that &lt;pProjectName&gt; points to. Without end character.&#13;&#10;&#13;&#10;Anzahl der Zeichen im String auf den &lt;pProjectName&gt; zeigt. Ohne Endezeichen." Name="_DS_GetProjectInfoResp.ProjNameLen"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_GetProjectNameResp : STRUCT  //! <Type Public="true" Comment="GetProjectName() response data.&#13;&#10;&#13;&#10;GetProjectName() Response-Daten." Name="_DS_GetProjectNameResp"/>
	    pProjectName : ^UINT;  //! <Type Comment="Pointer to the ProjectName which is always 128 Bytes.&#13;&#10;&#13;&#10;Zeiger auf den Projektnamen der immer 128 Bytes lang ist." Name="_DS_GetProjectNameResp.pProjectName"/>
	    ProjNameLen : UDINT;  //! <Type Comment="Number of characters in the string that &lt;pProjectName&gt; points to. Without end character.&#13;&#10;&#13;&#10;Anzahl der Zeichen im String auf den &lt;pProjectName&gt; zeigt. Ohne Endezeichen." Name="_DS_GetProjectNameResp.ProjNameLen"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_GetRoleDetailsResp : STRUCT  //! <Type Public="true" Comment="GetRoleDetails() response data.&#13;&#10;Time and date in Lasal format (see classes _SysDateTime and _SysDateTime2).&#13;&#10;&#13;&#10;Time Format: HHHHHHHHMMMMMMMMSSSSSSSS&#13;&#10;Bit 24-31 (H) contains the hour from 0 to 23.&#13;&#10;Bit 16-23 (M) contains the minute from 0 to 59. &#13;&#10;Bit 8 -15 (S) contains the second from 0 to 59.&#13;&#10;&#13;&#10;Date Format: YYYYYYYYYYYYYYYYMMMMDDDDDDDDWWWW&#13;&#10;Bit 16-31 (Y) contains the entire year (e.g. 2003).&#13;&#10;Bit 12-15 (M) contains the current month from 1 to 12. &#13;&#10;Bit 4-11 (D) contains the day information from 1 to 31.&#13;&#10;Bit 0-3 (W) contains the day of the week, where 0 stands for Sunday, 1 for Monday, etc.&#13;&#10;&#13;&#10;&#13;&#10;GetRoleDetails() Response-Daten.&#13;&#10;Zeit und Datum im Lasal Format (siehe Klassen _SysDateTime und _SysDateTime2).&#13;&#10;&#13;&#10;Zeit-Format: HHHHHHHHMMMMMMMMSSSSSSSS&#13;&#10;Bit 24-31 (H) beinhaltet die Stunde von 0 bis 23.&#13;&#10;Bit 16-23 (M) beinhaltet die Minute von 0 bis 59.&#13;&#10;Bit 8 -15  (S) beinhaltet die Sekunde von 0 bis 59.&#13;&#10;&#13;&#10;Datums-Format: YYYYYYYYYYYYYYYYMMMMDDDDDDDDWWWW&#13;&#10;Bit 16-31 (Y) beinhaltet die gesamte Jahreszahl (z.B. 2003).&#13;&#10;Bit 12-15 (M) beinhaltet das aktuelle Monat von 1 bis 12. &#13;&#10;Bit 4-11   (D) beinhaltet die Tagesinformation von 1 bis 31.&#13;&#10;Bit 0-3     (W) beinhaltet den Wochentag, wobei 0 für Sonntag, 1 für Montag, usw. steht." Name="_DS_GetRoleDetailsResp"/>
	    RoleID : UDINT;  //! <Type Comment="The ID of the role that was queried.&#13;&#10;&#13;&#10;Die ID der Rolle die abgefragt wurde." Name="_DS_GetRoleDetailsResp.RoleID"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;Attention! If ErrorCode is &lt;&gt; 0, then the content of the following fields is zero.&#13;&#10;&#13;&#10;Der Fehlercode.&#13;&#10;Achtung!  Ist ErrorCode &lt;&gt; 0, dann ist der Inhalt der nachfolgenden Felder Null." Name="_DS_GetRoleDetailsResp.ErrorCode"/>
	    pName : ^UINT;  //! <Type Comment="Pointer to the name of the role.&#13;&#10;Attention! If ErrorCode is &lt;&gt; 0, then pName = nil..&#13;&#10;&#13;&#10;Zeiger auf den Namen der Rolle.&#13;&#10;Achtung!  ist ErrorCode &lt;&gt; 0, dann ist pName = nil." Name="_DS_GetRoleDetailsResp.pName"/>
	    NameLen : UDINT;  //! <Type Comment="Number of characters in the Unicode-string that &lt;pName&gt; points to. Without end character.&#13;&#10;Attention! if ErrorCode is &lt;&gt; 0, then NameLen = 0.&#13;&#10;&#13;&#10;Anzahl der Zeichen im Unicode-String auf den &lt;pName&gt; zeigt. Ohne Endezeichen.&#13;&#10;ACHTUNG! wenn ErrorCode &lt;&gt; 0 ist, dann ist NameLen = 0." Name="_DS_GetRoleDetailsResp.NameLen"/>
	    pWriteAccessString : ^UINT;  //! <Type Comment="Pointer to the WriteAccessString of the role. See also ErrorCode.&#13;&#10;&#13;&#10;Zeiger auf den WriteAccessString der Rolle. Siehe auch ErrorCode." Name="_DS_GetRoleDetailsResp.pWriteAccessString"/>
	    WriteAccessStrLen : UDINT;  //! <Type Comment="Number of characters in the Unicode-string that &lt;pWriteAccessString&gt; points to. Without end character. See also ErrorCode.&#13;&#10;&#13;&#10;Anzahl der Zeichen im Unicode-String auf den &lt;pWriteAccessString&gt; zeigt. Ohne Endezeichen. Siehe auch ErrorCode." Name="_DS_GetRoleDetailsResp.WriteAccessStrLen"/>
	    pReadAccessString : ^UINT;  //! <Type Comment="Pointer to the ReadAccessString of the role. See also ErrorCode.&#13;&#10;&#13;&#10;Zeiger auf den ReadAccessString der Rolle. Siehe auch ErrorCode." Name="_DS_GetRoleDetailsResp.pReadAccessString"/>
	    ReadAccessStrLen : UDINT;  //! <Type Comment="Number of characters in the Unicode-string that &lt;pReadAccessString&gt; points to. Without end character. See also ErrorCode.&#13;&#10;&#13;&#10;Anzahl der Zeichen im Unicode-String auf den &lt;pReadAccessString&gt; zeigt. Ohne Endezeichen. Siehe auch ErrorCode." Name="_DS_GetRoleDetailsResp.ReadAccessStrLen"/>
	    pInfo : ^UINT;  //! <Type Comment="Pointer to the information which is stored as string in addition to the role. See also ErrorCode.&#13;&#10;&#13;&#10;Zeiger auf die Informationen welche zusätzlich zur Rolle als String gespeichert sind. Siehe auch ErrorCode." Name="_DS_GetRoleDetailsResp.pInfo"/>
	    InfoLen : UDINT;  //! <Type Comment="Number of characters in the Unicode-string that &lt;pInfo&gt; points to. Without end character. See also ErrorCode.&#13;&#10;&#13;&#10;Anzahl der Zeichen im Unicode-String auf den &lt;pInfo&gt; zeigt. Ohne Endezeichen. Siehe auch ErrorCode." Name="_DS_GetRoleDetailsResp.InfoLen"/>
	    privileges : _DS_UnsLongLongInt;  //! <Type Comment="The privileges of the role. See also ErrorCode.&#13;&#10;&#13;&#10;Die Berechtigungen der Rolle. Siehe auch ErrorCode." Name="_DS_GetRoleDetailsResp.privileges"/>
	    noOperationTimeout : UINT;  //! <Type Comment="The time after which the user is logged out when inactive. See also ErrorCode.&#13;&#10;&#13;&#10;Die Zeit nach der bei Inaktivität der Benutzer abgemeldet wird. Siehe auch ErrorCode." Name="_DS_GetRoleDetailsResp.noOperationTimeout"/>
	    CreatedDate : UDINT;  //! <Type Comment="Creation date of the role (date in Lasal format). See also ErrorCode.&#13;&#10;&#13;&#10;Erstellungsdatum der Rolle (Datum im Lasal Format). Siehe auch ErrorCode." Name="_DS_GetRoleDetailsResp.CreatedDate"/>
	    CreatedTime : UDINT;  //! <Type Comment="Creation time (time in Lasal format). See also ErrorCode.&#13;&#10;&#13;&#10;Erstellungszeit der Rolle (Zeit im Lasal Format). Siehe auch ErrorCode." Name="_DS_GetRoleDetailsResp.CreatedTime"/>
	    ModifiedRoleDate : UDINT;  //! <Type Comment="Date of last change (date in Lasal format). See also ErrorCode.&#13;&#10;&#13;&#10;Datum der letzten Änderung der Rolle (Datum im Lasal Format). Siehe auch ErrorCode." Name="_DS_GetRoleDetailsResp.ModifiedRoleDate"/>
	    ModifiedRoleTime : UDINT;  //! <Type Comment="Time of last change (time in Lasal format). See also ErrorCode.&#13;&#10; &#13;&#10;Uhrzeit der letzen Änderung der Rolle (Zeit im Lasal Format). Siehe auch ErrorCode." Name="_DS_GetRoleDetailsResp.ModifiedRoleTime"/>
	    WriteProtected : USINT;  //! <Type Comment="TRUE: this role is predefined. It cannot be changed or deleted.&#13;&#10;FALSE: this role is defined by the application. It can be changed and deleted.&#13;&#10;See also ErrorCode.&#13;&#10;&#13;&#10;TRUE: diese Rolle ist vordefiniert. Sie kann nicht geändert und nicht gelöscht werden.&#13;&#10;FALSE: diese Rolle wurde von der Applikation definiert. Sie kann geändert und gelöscht werden. &#13;&#10;Siehe auch ErrorCode.&#13;&#10;" Name="_DS_GetRoleDetailsResp.WriteProtected"/>
	    AccessNumberValid : USINT;  //! <Type Comment="TRUE, if &lt;AccessNumber&gt; is used. See also ErrorCode.&#13;&#10;If the value is FALSE, then &lt;AccessNumber&gt; is zero.&#13;&#10;&#13;&#10;TRUE, wenn die &lt;AccessNumber&gt; verwendet wird. Siehe auch ErrorCode.&#13;&#10;Wenn der Wert FALSE ist, dann ist &lt;AccessNumber&gt; null.&#13;&#10;" Name="_DS_GetRoleDetailsResp.AccessNumberValid"/>
	    AccessNumber : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_GetRoleListResp : STRUCT  //! <Type Public="true" Comment="GetRoleList() response data.&#13;&#10;&#13;&#10;GetRoleList() Response-Daten." Name="_DS_GetRoleListResp"/>
	    RoleID : UDINT;  //! <Type Comment="The ID of the role.&#13;&#10;&#13;&#10;Die ID der Rolle." Name="_DS_GetRoleListResp.RoleID"/>
	    pName : ^UINT;  //! <Type Comment="Pointer to the role name.&#13;&#10;&#13;&#10;Zeiger auf den Rollennamen." Name="_DS_GetRoleListResp.pName"/>
	    NameLen : UDINT;  //! <Type Comment="Number of characters in the string that &lt;pName&gt; points to. Without end character.&#13;&#10;&#13;&#10;Anzahl der Zeichen im String auf den &lt;pName&gt; zeigt. Ohne Endezeichen." Name="_DS_GetRoleListResp.NameLen"/>
	  END_STRUCT;
#pragma pack(pop)
	  _DS_StateType :  //! <Type Public="true" Comment="The status type (= which status change).&#13;&#10;&#13;&#10;Der Statustyp (= welche Statusänderung)." Name="_DS_StateType"/>
	  (
	    Lasal_ID_List:=1  //! <Type Comment="List of Lasal_IDs.&#13;&#10;&#13;&#10;Liste der Lasal-IDs." Name="_DS_StateType.Lasal_ID_List"/>
	  )$UDINT;
#pragma pack(push, 1)
	  _DS_GetStateCmd : STRUCT  //! <Type Public="true" Comment="Get_State() parameter." Name="_DS_GetStateCmd"/>
	    Target : UDINT;  //! <Type Comment="Bit mask for determining the targets (= whose status change).&#13;&#10;Bit 1 = DataService&#13;&#10;&#13;&#10;Bitmaske zum Bestimmen der Targets (= wessen Statusänderung).&#13;&#10;Bit 1 = DataService" Name="_DS_GetStateCmd.Target"/>
	    Typ : _DS_StateType;  //! <Type Comment="The status type (= which status change).&#13;&#10;Lasal_ID_List: The corresponding station number is specified under &lt;pData&gt; cast as ^DSComm::_DS_GetStateCmd_1.&#13;&#10;&#13;&#10;Der Statustyp (= welche Statusänderung).&#13;&#10;Lasal_ID_List: Die entsprechende Stationsnummer wird unter &lt;pData&gt; gecastet als ^DSComm::_DS_GetStateCmd_1 angegeben." Name="_DS_GetStateCmd.Typ"/>
	    pData : pVoid;  //! <Type Comment="Pointer to additional data which can be sent (depending on &lt;Typ&gt;).&#13;&#10;&#13;&#10;Zeiger auf zusätzliche Daten, welche mitgesendet werden können (abhängig von &lt;Typ&gt;)." Name="_DS_GetStateCmd.pData"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_GetStateCmd_1 : STRUCT  //! <Type Public="true" Comment="Get_State(): additional data.&#13;&#10;&#13;&#10;Get_State(): zusätzliche Daten." Name="_DS_GetStateCmd_1"/>
	    StationNo : UDINT;  //! <Type Comment="Station number.&#13;&#10;&#13;&#10;Stationsummer." Name="_DS_GetStateCmd_1.StationNo"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_GetStateResp : STRUCT  //! <Type Public="true" Comment="Get_State() response data as well as UpdateStatePush() data.&#13;&#10;&#13;&#10;Get_State() Response-Daten sowie UpdateStatePush()-Daten.&#13;&#10;" Name="_DS_GetStateResp"/>
	    Target : UDINT;  //! <Type Comment="Bit mask for determining the targets (= whose status change).&#13;&#10;Bit 1 = DataService&#13;&#10;&#13;&#10;Bitmaske zum Bestimmen der Targets (= wessen Statusänderung).&#13;&#10;Bit 1 = DataService" Name="_DS_GetStateResp.Target"/>
	    Typ : _DS_StateType;  //! <Type Comment="The status type (= which status change).&#13;&#10;Lasal_ID_List: additional data is available under &lt;pData&gt; cast as ^DSComm::_DS_Lasal_IDListState.&#13;&#10;&#13;&#10;Der Statustyp (= welche Statusänderung).&#13;&#10;Lasal_ID_List: zusätzliche Daten sind verfügbar unter &lt;pData&gt; gecastet als ^DSComm::_DS_Lasal_IDListState." Name="_DS_GetStateResp.Typ"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_GetStateResp.ErrorCode"/>
	    pData : pVoid;  //! <Type Comment="Pointer to additional data, depending on &lt;Typ&gt;.&#13;&#10;&#13;&#10;Zeiger auf zusätzliche Daten, abhängig von &lt;Typ&gt;." Name="_DS_GetStateResp.pData"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_GetStringCmd : STRUCT  //! <Type Public="true" Comment="GetString() parameter." Name="_DS_GetStringCmd"/>
	    dpID : UDINT;  //! <Type Comment="The VarID of the data point to be queried.&#13;&#10;&#13;&#10;Die VarID des Datenpunkts der abgefragt werden soll." Name="_DS_GetStringCmd.dpID"/>
	    quality : UDINT;  //! <Type Comment="The quality of the data point (time in ms how old the value in the cache may be).&#13;&#10;&#13;&#10;Die Qualität des Datenpunktes (Zeit in ms wie alt der Wert im Cache sein darf)." Name="_DS_GetStringCmd.quality"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_GetStringResp : STRUCT  //! <Type Public="true" Comment="GetString() response data.&#13;&#10;&#13;&#10;GetString() Response-Daten." Name="_DS_GetStringResp"/>
	    dpID : UDINT;  //! <Type Comment="The VarID of the data point that was queried.&#13;&#10;&#13;&#10;Die VarID des Datenpunkts der abgefragt wurde." Name="_DS_GetStringResp.dpID"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_GetStringResp.ErrorCode"/>
	    quality : UDINT;  //! <Type Comment="The quality of the data point.&#13;&#10;&#13;&#10;Die Qualität des Datenpunktes." Name="_DS_GetStringResp.quality"/>
	    pString : ^UINT;  //! <Type Comment="Pointer to the string variable (value of the data point).&#13;&#10;&#13;&#10;Zeiger auf die String-Variable (Der Wert des Datenpunkts)." Name="_DS_GetStringResp.pString"/>
	    StringLen : UDINT;  //! <Type Comment="Number of characters in the string that &lt;pString&gt; points to. Without end character.&#13;&#10;&#13;&#10;Anzahl der Zeichen im String auf den &lt;pString&gt; zeigt. Ohne Endezeichen." Name="_DS_GetStringResp.StringLen"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_GetUserListResp : STRUCT  //! <Type Public="true" Comment="GetUserList() response data.&#13;&#10;&#13;&#10;GetUserList() Response-Daten." Name="_DS_GetUserListResp"/>
	    UserID : UDINT;  //! <Type Comment="The ID of the user.&#13;&#10;&#13;&#10;Die ID des Benutzers." Name="_DS_GetUserListResp.UserID"/>
	    pName : ^UINT;  //! <Type Comment="Pointer to the user name.&#13;&#10;&#13;&#10;Zeiger auf den Benutzernamen." Name="_DS_GetUserListResp.pName"/>
	    NameLen : UDINT;  //! <Type Comment="Number of characters in the string that &lt;pName&gt; points to. Without end character.&#13;&#10;&#13;&#10;Anzahl der Zeichen im String auf den &lt;pName&gt; zeigt. Ohne Endezeichen." Name="_DS_GetUserListResp.NameLen"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_GetValueCmd : STRUCT  //! <Type Public="true" Comment="GetValue() parameter." Name="_DS_GetValueCmd"/>
	    dpID : UDINT;  //! <Type Comment="The VarID of the data point to be queried.&#13;&#10;&#13;&#10;Die VarID des Datenpunkts der abgefragt werden soll." Name="_DS_GetValueCmd.dpID"/>
	    quality : UDINT;  //! <Type Comment="The quality of the data point (time in ms how old the value in the cache may be).&#13;&#10;&#13;&#10;Die Qualität des Datenpunktes (Zeit in ms wie alt der Wert im Cache sein darf)." Name="_DS_GetValueCmd.quality"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_GetValueResp : STRUCT  //! <Type Public="true" Comment="GetValue() response data.&#13;&#10;&#13;&#10;GetValue() Response-Daten." Name="_DS_GetValueResp"/>
	    dpID : UDINT;  //! <Type Comment="The VarID of the data point that was queried.&#13;&#10;&#13;&#10;Die VarID des Datenpunkts der abgefragt wurde." Name="_DS_GetValueResp.dpID"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_GetValueResp.ErrorCode"/>
	    quality : UDINT;  //! <Type Comment="The quality of the data point.&#13;&#10;&#13;&#10;Die Qualität des Datenpunktes." Name="_DS_GetValueResp.quality"/>
	    value : LREAL;  //! <Type Comment="The value of the data point.&#13;&#10;&#13;&#10;Der Wert des Datenpunkts." Name="_DS_GetValueResp.value"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_GetVarIdFromCRCResp : STRUCT  //! <Type Public="true" Comment="GetVarIdFromCRC() response data.&#13;&#10;&#13;&#10;GetVarIdFromCRC() Response-Daten." Name="_DS_GetVarIdFromCRCResp"/>
	    CRC : UDINT;  //! <Type Comment="CRC of the data point.&#13;&#10;&#13;&#10;Die CRC des Datenpunkts." Name="_DS_GetVarIdFromCRCResp.CRC"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;Attention! If ErrorCode is &lt;&gt; 0, then the content of VarId is zero.&#13;&#10;&#13;&#10;Der Fehlercode.&#13;&#10;ACHTUNG! Wenn ErrorCode &lt;&gt; 0 ist, dann ist VarId null." Name="_DS_GetVarIdFromCRCResp.ErrorCode"/>
	    VarID : UDINT;  //! <Type Comment="The variable ID of the data point. Attention: if ErrorCode is &lt;&gt; 0, then VarId is zero.&#13;&#10;&#13;&#10;Die Variablen ID des Datenpunkts. ACHTUNG! Wenn ErrorCode &lt;&gt; 0 ist, dann ist VarId null." Name="_DS_GetVarIdFromCRCResp.VarID"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_GetVarIdFromLasalIdCmd : STRUCT  //! <Type Public="true" Comment="GetVarIdFromLasalId() parameter" Name="_DS_GetVarIdFromLasalIdCmd"/>
	    LasalID : UDINT;  //! <Type Comment="The Lasal ID of the requested variable number.&#13;&#10;&#13;&#10;Die Lasal ID der gesuchten Variablen Nummer." Name="_DS_GetVarIdFromLasalIdCmd.LasalID"/>
	    StationNo : UDINT;  //! <Type Comment="ID or number of the station.&#13;&#10;&#13;&#10;ID bzw. Nummer der Station." Name="_DS_GetVarIdFromLasalIdCmd.StationNo"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_GetVarIdFromLasalIdResp : STRUCT  //! <Type Public="true" Comment="GetVarIdFromLasalId() response data.&#13;&#10;&#13;&#10;GetVarIdFromLasalId() Response-Daten." Name="_DS_GetVarIdFromLasalIdResp"/>
	    LasalID : UDINT;  //! <Type Comment="The Lasal ID of the requested variable number.&#13;&#10;&#13;&#10;Die Lasal ID der gesuchten Variablen Nummer." Name="_DS_GetVarIdFromLasalIdResp.LasalID"/>
	    StationNo : UDINT;  //! <Type Comment="ID or number of the station.&#13;&#10;&#13;&#10;ID bzw. Nummer der Station." Name="_DS_GetVarIdFromLasalIdResp.StationNo"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;Attention! If ErrorCode is &lt;&gt; 0, then the content of VarId is zero.&#13;&#10;&#13;&#10;Der Fehlercode.&#13;&#10;ACHTUNG! Wenn ErrorCode &lt;&gt; 0 ist, dann ist VarId null." Name="_DS_GetVarIdFromLasalIdResp.ErrorCode"/>
	    VarID : UDINT;  //! <Type Comment="The variable ID. Attention: if ErrorCode is &lt;&gt; 0, then VarId is zero.&#13;&#10;&#13;&#10;Die Variablen ID. ACHTUNG! wenn ErrorCode &lt;&gt; 0 ist, dann ist VarId null." Name="_DS_GetVarIdFromLasalIdResp.VarID"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_GetVarIdFromNameResp : STRUCT  //! <Type Public="true" Comment="GetVarIdFromName() response data.&#13;&#10;&#13;&#10;GetVarIdFromName() Response-Daten." Name="_DS_GetVarIdFromNameResp"/>
	    pName : ^CHAR;  //! <Type Comment="Pointer to the name of the data point.&#13;&#10;&#13;&#10;Zeiger auf den Namen des Datenpunkts." Name="_DS_GetVarIdFromNameResp.pName"/>
	    NameLen : UDINT;  //! <Type Comment="Number of characters in the string that &lt;pName&gt; points to. Without end character.&#13;&#10;&#13;&#10;Anzahl der Zeichen im String auf den &lt;pName&gt; zeigt. Ohne Endezeichen." Name="_DS_GetVarIdFromNameResp.NameLen"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;Attention! If ErrorCode is &lt;&gt; 0, then the content of VarId is zero.&#13;&#10;&#13;&#10;Der Fehlercode.&#13;&#10;ACHTUNG! Wenn ErrorCode &lt;&gt; 0 ist, dann ist VarId null." Name="_DS_GetVarIdFromNameResp.ErrorCode"/>
	    VarID : UDINT;  //! <Type Comment="The variable ID. Attention: if ErrorCode is &lt;&gt; 0, then VarId is zero.&#13;&#10;&#13;&#10;Die Variablen ID. ACHTUNG! Wenn ErrorCode &lt;&gt; 0 ist, dann ist VarId null." Name="_DS_GetVarIdFromNameResp.VarID"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_GetVersionResp : STRUCT  //! <Type Public="true" Comment="GetVersion() response data.&#13;&#10;&#13;&#10;GetVersion() Response-Daten." Name="_DS_GetVersionResp"/>
	    VersionNo : UDINT;  //! <Type Comment="The version number of the data service.&#13;&#10;&#13;&#10;Die Versionsnummer des Dataservice." Name="_DS_GetVersionResp.VersionNo"/>
	    BuildNo : UDINT;  //! <Type Comment="The build number of the data service.&#13;&#10;&#13;&#10;Die Build-Nummer des Dataservice." Name="_DS_GetVersionResp.BuildNo"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_HotAlarmAddCmd : STRUCT  //! <Type Public="true" Comment="SubscribeHotAlarmUpdate() parameter." Name="_DS_HotAlarmAddCmd"/>
	    Typ : USINT;  //! <Type Comment="Bitmask:&#13;&#10; Bit 0 = HotAlarmTimeLast&#13;&#10; Bit 1 = HotAlarmPrioHighest&#13;&#10; Bit 2 = HotAlarmTimeFirst&#13;&#10; Bit 3 = HotAlarmPrioLowest&#10;" Name="_DS_HotAlarmAddCmd.Typ"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_HotAlarmAddResp : STRUCT  //! <Type Public="true" Comment="SubscribeHotAlarmUpdate() response data.&#13;&#10;&#13;&#10;SubscribeHotAlarmUpdate() Response-Daten." Name="_DS_HotAlarmAddResp"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_HotAlarmAddResp.ErrorCode"/>
	    Typ : USINT;  //! <Type Comment="Bitmask:&#13;&#10; Bit 0 = HotAlarmTimeLast&#13;&#10; Bit 1 = HotAlarmPrioHighest&#13;&#10; Bit 2 = HotAlarmTimeFirst&#13;&#10; Bit 3 = HotAlarmPrioLowest&#10;" Name="_DS_HotAlarmAddResp.Typ"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_HotAlarmSubCmd : STRUCT  //! <Type Public="true" Comment="UnsubscribeHotAlarmUpdate() parameter." Name="_DS_HotAlarmSubCmd"/>
	    Typ : USINT;  //! <Type Comment="Bitmask:&#13;&#10; Bit 0 = HotAlarmTimeLast&#13;&#10; Bit 1 = HotAlarmPrioHighest&#13;&#10; Bit 2 = HotAlarmTimeFirst&#13;&#10; Bit 3 = HotAlarmPrioLowest&#10;" Name="_DS_HotAlarmSubCmd.Typ"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_HotAlarmSubResp : STRUCT  //! <Type Public="true" Comment="UnsubscribeHotAlarmUpdate() response data.&#13;&#10;&#13;&#10;UnsubscribeHotAlarmUpdate() Response-Daten." Name="_DS_HotAlarmSubResp"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_HotAlarmSubResp.ErrorCode"/>
	    Typ : USINT;  //! <Type Comment="Bitmask:&#13;&#10; Bit 0 = HotAlarmTimeLast&#13;&#10; Bit 1 = HotAlarmPrioHighest&#13;&#10; Bit 2 = HotAlarmTimeFirst&#13;&#10; Bit 3 = HotAlarmPrioLowest&#10;" Name="_DS_HotAlarmSubResp.Typ"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_HotAlarmUpdate : STRUCT  //! <Type Public="true" Comment="Sent by the data service when a hot alarm changes.&#13;&#10;&#13;&#10;Wird vom DS verschickt, wenn sich ein Hotalarm ändert." Name="_DS_HotAlarmUpdate"/>
	    Typ : USINT;  //! <Type Comment="1: last hot alarm&#13;&#10;2: highest priority&#13;&#10;4: first hot alarm&#13;&#10;8: lowest priority&#13;&#10;&#13;&#10;1: letzter Hot Alarm&#13;&#10;2: höchste Priorität&#13;&#10;4: erster Hot Alarm&#13;&#10;8: niedrigste Priorität " Name="_DS_HotAlarmUpdate.Typ"/>
	    VarID : UDINT;  //! <Type Comment="The ID of the alarm (Variable ID of the &lt;ClassSvr&gt; of an alarm object (classes _AlarmX0Para - _AlarmX3Para)).&#13;&#10;&#13;&#10;Die ID des Alarms (Variablen ID des &lt;ClassSvr&gt; eines Alarm-Objekts (Klassen _AlarmX0Para - _AlarmX3Para))." Name="_DS_HotAlarmUpdate.VarID"/>
	    Group : UDINT;  //! <Type Comment="Value of the client &lt;Group&gt; of an alarm object (classes _AlarmX0Para .. _AlarmX3Para).&#13;&#10;&#13;&#10;Wert des Clients &lt;Group&gt; eines Alarm-Objekts (Klassen _AlarmX0Para .. _AlarmX3Para)." Name="_DS_HotAlarmUpdate.Group"/>
	    Config : UDINT;  //! <Type Comment="Value of the client &lt;Config&gt; of an alarm object (classes _AlarmX0Para .. _AlarmX3Para).&#13;&#10;&#13;&#10;Wert des Clients &lt;Config&gt; eines Alarm-Objekts (Klassen _AlarmX0Para .. _AlarmX3Para)." Name="_DS_HotAlarmUpdate.Config"/>
	    State : USINT;  //! <Type Comment="Acknowledged (255), disappeared (0) or present (1).&#13;&#10;&#13;&#10;Quittiert (255), gegangen (0) oder vorhanden (1). " Name="_DS_HotAlarmUpdate.State"/>
	    GroupBit : USINT;  //! <Type Comment="Group bit.&#13;&#10;&#13;&#10;Gruppierungsbit." Name="_DS_HotAlarmUpdate.GroupBit"/>
	    ParameterNo : USINT;  //! <Type Comment="Number of parameters that &lt;pParameter&gt; points to.&#13;&#10;ATTENTION: when &lt;ParameterNo&gt; is zero, then &lt;pParameter&gt; is nil.&#13;&#10;&#13;&#10;Anzahl der Parameter auf die &lt;pParameter&gt; zeigt..&#13;&#10;ACHTUNG: wenn &lt;ParameterNo&gt; Null ist, dann ist &lt;pParameter&gt; nil." Name="_DS_HotAlarmUpdate.ParameterNo"/>
	    nc : USINT;  //! <Type Comment="Unused." Name="_DS_HotAlarmUpdate.nc"/>
	    pParameter : ^_DS_AlarmParameter;  //! <Type Comment="Pointer to an array with &lt;ParameterNo&gt;elements of the form &lt;Value, VarID&gt;.&#13;&#10;This array contains the values of clients &lt;Para1&gt; .. &lt;Para3&gt; of an alarm object (classes _AlarmX1Para .. _AlarmX3Para).&#13;&#10;ATTENTION: when &lt;ParameterNo&gt; is zero, then &lt;pParameter&gt; is nil.&#13;&#10;&#13;&#10;Zeiger auf ein Array mit &lt;ParameterNo&gt; Elementen der Form &lt;Value, VarID&gt;.&#13;&#10;Dieses Array enthält die Werte der Clients &lt;Para1&gt; .. &lt;Para3&gt; eines Alarm-Objekts (Klassen _AlarmX1Para .. _AlarmX3Para).&#13;&#10;ACHTUNG: wenn &lt;ParameterNo&gt; Null ist, dann ist &lt;pParameter&gt; nil.&#13;&#10;" Name="_DS_HotAlarmUpdate.pParameter"/>
	    pTimestamps : ^_DS_AlarmTimestamps;  //! <Type Comment="Pointer to the alarm time stamps.&#13;&#10;&#13;&#10;Zeiger auf die Alarm Zeitstempel." Name="_DS_HotAlarmUpdate.pTimestamps"/>
	    num_appeared : UDINT;  //! <Type Comment="Number of how often an alarm occurred.&#13;&#10;&#13;&#10;Anzahl wie oft der Alarm aufgetreten ist." Name="_DS_HotAlarmUpdate.num_appeared"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_IncDecValueResp : STRUCT  //! <Type Public="true" Comment="IncValue() / DecValue() response data.&#13;&#10;&#13;&#10;IncValue() / DecValue() Response-Daten." Name="_DS_IncDecValueResp"/>
	    dpID : UDINT;  //! <Type Comment="The VarID of the data point that should be incremented / decremented.&#13;&#10;&#13;&#10;Die VarID des Datenpunkts der inkrementiert / dekrementiert werden sollte." Name="_DS_IncDecValueResp.dpID"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_IncDecValueResp.ErrorCode"/>
	    value : LREAL;  //! <Type Comment="The value that was tried to write.&#13;&#10;&#13;&#10;Der Wert der versucht wurde zu schreiben." Name="_DS_IncDecValueResp.value"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_JobInfo : STRUCT  //! <Type Comment="Auftragsverwaltung." Name="_DS_JobInfo"/>
	    Capacity : UDINT;  //! <Type Comment="Anzahl der Elemente im jeweiligen Job-Array." Name="_DS_JobInfo.Capacity"/>
	    Free : UDINT;  //! <Type Comment="Anzahl der freien Elemente im jeweiligen Job-Array." Name="_DS_JobInfo.Free"/>
	    pJobs : ^_DS_JobInfoElmt;  //! <Type Comment="Zeiger auf das erste Element im jeweiligen Job-Array." Name="_DS_JobInfo.pJobs"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_Lasal_IDListState : STRUCT  //! <Type Public="true" Comment="Additional data depending on &lt;Typ&gt;.&#13;&#10;&#13;&#10;Zusätzliche Daten je nach &lt;Typ&gt;." Name="_DS_Lasal_IDListState"/>
	    StationNo : UDINT;  //! <Type Comment="Station number.&#13;&#10;&#13;&#10;Stationsnummer." Name="_DS_Lasal_IDListState.StationNo"/>
	    Status : UDINT;  //! <Type Comment="Status (0 = not loaded, 1 = loaded).&#13;&#10;&#13;&#10;Status (0 = nicht geladen, 1 = geladen)." Name="_DS_Lasal_IDListState.Status"/>
	  END_STRUCT;
#pragma pack(pop)
	  _DS_Parameter :  //! <Type Public="true" Comment="Parameter numbers." Name="_DS_Parameter"/>
	  (
	    _RespTimeout,  //! <Type Comment="Normal response timeout in [ms]. Default = 10 s (= 10 000 ms).&#13;&#10;&#13;&#10;Normales Response Timeout in [ms]. Default = 10 s  (= 10 000 ms)." Name="_DS_Parameter._RespTimeout"/>
	    _RespTimeoutLong,  //! <Type Comment="Response Timeout in [ms] for long lasting commands (FileContent, FileCopy, FileMove etc). Default = 5 min (= 300 000 ms).&#13;&#10;&#13;&#10;Response Timeout in [ms] für lange dauernde Kommandos (FileContent, FileCopy, FileMove etc). Default = 5 min  (= 300 000 ms)." Name="_DS_Parameter._RespTimeoutLong"/>
	    _SendTimeout,  //! <Type Comment="Timeout for TCP send in [ms]. Default = 2 s (= 2000 ms).&#13;&#10;&#13;&#10;Timeout für TCP-Send in [ms]. Default = 2 s  (= 2000 ms)." Name="_DS_Parameter._SendTimeout"/>
	    _RecvTimeout  //! <Type Comment="Timeout for TCP Receive in [ms]. Default = 5 s (= 5000 ms).&#13;&#10;&#13;&#10;Timeout für TCP-Receive in [ms]. Default = 5 s  (= 5000 ms)." Name="_DS_Parameter._RecvTimeout"/>
	  )$UDINT;
#pragma pack(push, 1)
	  _DS_ProgressInfo : STRUCT  //! <Type Comment="HandleID-Verwaltung für Progress Status Nachrichten." Name="_DS_ProgressInfo"/>
	    pThis : ^DSComm_Interface;  //! <Type Comment="Zeiger auf ein Objekt für Progress Status Nachrichten." Name="_DS_ProgressInfo.pThis"/>
	    HandleID : DINT;  //! <Type Comment="Die Id des Commands für das der Progress gilt." Name="_DS_ProgressInfo.HandleID"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_ProgressStatus : STRUCT  //! <Type Public="true" Comment="Progress status message.&#13;&#10;&#13;&#10;Progress Status Nachricht.&#13;&#10;" Name="_DS_ProgressStatus"/>
	    HandleID : UDINT;  //! <Type Comment="The MessageID of the command to which the Progress applies.&#13;&#10;&#13;&#10;Die MessageID des Kommandos für das der Fortschritt gilt." Name="_DS_ProgressStatus.HandleID"/>
	    State : UDINT;  //! <Type Comment="The status of the command (0 = start, 1 = update, 2 = end).&#13;&#10;&#13;&#10;Der Status des Kommandos (0 = start, 1 = update, 2 = end)." Name="_DS_ProgressStatus.State"/>
	    Percent : UDINT;  //! <Type Comment="The progress in percent (This field contains valid data only if State = update).&#13;&#10;&#13;&#10;Der Fortschritt in Prozent (Dieses Feld enthält nur gültige Daten, wenn State = update)." Name="_DS_ProgressStatus.Percent"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_RecipeLoadResp : STRUCT  //! <Type Public="true" Comment="RecipeLoad() response data.&#13;&#10;&#13;&#10;RecipeLoad() Response-Daten." Name="_DS_RecipeLoadResp"/>
	    ErrorCode : UDINT;  //! <Type Comment="The Error Code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_RecipeLoadResp.ErrorCode"/>
	    pDpne : ^CHAR;  //! <Type Comment="Pointer to the drive path name extension of the file to be loaded (e.g. &quot;c:\recipes\recipe.txt&quot;).&#13;&#10;This is an UTF8-string.&#13;&#10;&#13;&#10;Zeiger auf die Drive-Path-Name-Extension der zu ladenden Datei (zB. &quot;c:\recipes\recipe.txt&quot;).&#13;&#10;Dies ist ein UTF8-String" Name="_DS_RecipeLoadResp.pDpne"/>
	    DpneLen : UDINT;  //! <Type Comment="Number of bytes in the string that &lt;pDpne&gt; points to. Without end character.&#13;&#10;StrLenUtf8() returns the number of characters.&#13;&#10;&#13;&#10;Anzahl der Bytes im String auf den &lt;pDpne&gt; zeigt. Ohne Endezeichen.&#13;&#10;StrLenUtf8() liefert die Anzahl der Zeichen." Name="_DS_RecipeLoadResp.DpneLen"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_RecipeLoadRespInt : STRUCT  //! <Type Comment="Internal RecipeLoad() response data." Name="_DS_RecipeLoadRespInt"/>
	    ErrorCode : UDINT;
	    DpneLen : UDINT;
	    Dpne : ARRAY [0..1] OF CHAR;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_RecipeSaveResp : STRUCT  //! <Type Public="true" Comment="RecipeSave() response data.&#13;&#10;&#13;&#10;RecipeSave() Response-Daten." Name="_DS_RecipeSaveResp"/>
	    ErrorCode : UDINT;  //! <Type Comment="The Error Code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_RecipeSaveResp.ErrorCode"/>
	    pDpne : ^CHAR;  //! <Type Comment="Pointer to the drive path name extension of the recipe file (e.g. &quot;c:\recipes\recipe.txt&quot;).&#13;&#10;This is an UTF8-string.&#13;&#10;&#13;&#10;Zeiger auf die Drive-Path-Name-Extension der Rezept-Speicher-Datei (zB. &quot;c:\recipes\recipe.txt&quot;).&#13;&#10;Dies ist ein UTF8-String." Name="_DS_RecipeSaveResp.pDpne"/>
	    DpneLen : UDINT;  //! <Type Comment="Number of bytes in the string that &lt;pDpne&gt; points to. Without end character.&#13;&#10;StrLenUtf8() returns the number of characters.&#13;&#10;&#13;&#10;Anzahl der Bytes im String auf den &lt;pDpne&gt; zeigt. Ohne Endezeichen.&#13;&#10;StrLenUtf8() liefert die Anzahl der Zeichen." Name="_DS_RecipeSaveResp.DpneLen"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_RecipeSaveRespInt : STRUCT  //! <Type Comment="Internal RecipeSave() response data." Name="_DS_RecipeSaveRespInt"/>
	    ErrorCode : UDINT;
	    DpneLen : UDINT;  //! <Type Comment="Length incl. \0." Name="_DS_RecipeSaveRespInt.DpneLen"/>
	    Dpne : ARRAY [0..1] OF CHAR;  //! <Type Comment="First two bytes of drive path name extension as UTF8-String." Name="_DS_RecipeSaveRespInt.Dpne"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_RefListAddResp : STRUCT  //! <Type Public="true" Comment="RefListAdd() response data.&#13;&#10;&#13;&#10;RefListAdd() Response-Daten." Name="_DS_RefListAddResp"/>
	    dpID : UDINT;  //! <Type Comment="The VarID of the data point that should be added to the refresh list.&#13;&#10;&#13;&#10;Die VarID des Datenpunkts der zur Refresh-Liste hinzugefügt werden sollte." Name="_DS_RefListAddResp.dpID"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_RefListAddResp.ErrorCode"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_RefListSubResp : STRUCT  //! <Type Public="true" Comment="RefListSub() response data.&#13;&#10;&#13;&#10;RefListSub() Response-Daten." Name="_DS_RefListSubResp"/>
	    dpID : UDINT;  //! <Type Comment="The VarID of the data point that should be removed from the refresh list.&#13;&#10;&#13;&#10;Die VarID des Datenpunkts der von der Refresh-Liste entfernt werden sollte." Name="_DS_RefListSubResp.dpID"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_RefListSubResp.ErrorCode"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_RefListUpdate : STRUCT  //! <Type Public="true" Comment="Sent by the data service when the value of a numeric server in the refresh list changes.&#13;&#10;&#13;&#10;Wird vom Data Service verschickt, wenn sich der Wert eines numerischen Servers ändert, welcher sich in der Refresh-Liste befindet." Name="_DS_RefListUpdate"/>
	    dpID : UDINT;  //! <Type Comment="The VarID of the data point whose value has changed.&#13;&#10;&#13;&#10;Die VarID des Datenpunktes dessen Wert sich geändert hat." Name="_DS_RefListUpdate.dpID"/>
	    Value : LREAL;  //! <Type Comment="The new value of the data point.&#13;&#10;&#13;&#10;Der neue Wert des Datenpunktes." Name="_DS_RefListUpdate.Value"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_RefListUpdateString : STRUCT  //! <Type Public="true" Comment="Sent by the data service when the value of a string server in the refresh list changes.&#13;&#10;&#13;&#10;Wird vom Data Service verschickt, wenn sich der Wert eines String-Servers ändert, welcher sich in der Refresh-Liste befindet." Name="_DS_RefListUpdateString"/>
	    dpID : UDINT;  //! <Type Comment="The VarID of the data point whose value has changed.&#13;&#10;&#13;&#10;Die VarId des Datenpunktes dessen Wert sich geändert hat." Name="_DS_RefListUpdateString.dpID"/>
	    pString : ^UINT;  //! <Type Comment="Pointer to the string variable (The new value of the data point).&#13;&#10;&#13;&#10;Zeiger auf die String-Variable (Der neue Wert des Datenpunkts)." Name="_DS_RefListUpdateString.pString"/>
	    StringLen : UDINT;  //! <Type Comment="Number of characters in the string that &lt;pString&gt; points to. Without end character.&#13;&#10;&#13;&#10;Anzahl der Zeichen im String auf den &lt;pString&gt; zeigt. Ohne Endezeichen." Name="_DS_RefListUpdateString.StringLen"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_RemoveLocalClientCmd : STRUCT  //! <Type Public="true" Comment="RemoveLocalClient() parameters." Name="_DS_RemoveLocalClientCmd"/>
	    ID : UDINT;  //! <Type Comment="ID of the client which should be removed.&#13;&#10;&#13;&#10;Die ID des Clients der entfernt werden soll." Name="_DS_RemoveLocalClientCmd.ID"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_RemoveLocalClientRangeCmd : STRUCT  //! <Type Public="true" Comment="RemoveLocalClientRange() parameters." Name="_DS_RemoveLocalClientRangeCmd"/>
	    Typ : USINT;  //! <Type Comment="Defines the type of identifier used:&#13;&#10;1 = IP-address&#13;&#10;2 = IP-address range&#13;&#10;3 = MAC-address&#13;&#10;4 = MAC-address range&#13;&#10;&#13;&#10;Definiert den Typ des verwendeten Identifiers:&#13;&#10;1 = IP-Adresse&#13;&#10;2 = IP-Adressbereich&#13;&#10;3 = MAC-Adresse&#13;&#10;4 = MAC-Adressbereich" Name="_DS_RemoveLocalClientRangeCmd.Typ"/>
	    pFrom : ^USINT;  //! <Type Comment="Pointer to the first identifier string in the range (IP-address / MAC-address).&#13;&#10;&#13;&#10;Zeiger auf den ersten Identifier des Bereichs (IP- / MAC-Adresse)." Name="_DS_RemoveLocalClientRangeCmd.pFrom"/>
	    pTo : ^USINT;  //! <Type Comment="Pointer to the last identifier string in the range (IP-address / MAC-address).&#13;&#10;&#13;&#10;Zeiger auf den letzten Identifier des Bereichs (IP- / MAC-Adresse)." Name="_DS_RemoveLocalClientRangeCmd.pTo"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_RemoveLocalClientRangeResp : STRUCT  //! <Type Public="true" Comment="RemoveLocalClientRange() response data.&#13;&#10;&#13;&#10;RemoveLocalClientRange() Response-Daten." Name="_DS_RemoveLocalClientRangeResp"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_RemoveLocalClientRangeResp.ErrorCode"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_RemoveLocalClientResp : STRUCT  //! <Type Public="true" Comment="RemoveLocalClient() response data.&#13;&#10;&#13;&#10;RemoveLocalClient() Response-Daten." Name="_DS_RemoveLocalClientResp"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_RemoveLocalClientResp.ErrorCode"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_RemoveThisLocalClientResp : STRUCT  //! <Type Public="true" Comment="RemoveThisLocalClient() response data.&#13;&#10;&#13;&#10;RemoveThisLocalClient() Response-Daten." Name="_DS_RemoveThisLocalClientResp"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_RemoveThisLocalClientResp.ErrorCode"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_ResetDataserviceResp : STRUCT  //! <Type Public="true" Comment="ResetDataservice() response data.&#13;&#10;&#13;&#10;ResetDataservice() Response-Daten." Name="_DS_ResetDataserviceResp"/>
	    ErrorCode : UDINT;  //! <Type Comment="The Error Code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_ResetDataserviceResp.ErrorCode"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_RestartDataserviceResp : STRUCT  //! <Type Public="true" Comment="RestartDataservice() response data.&#13;&#10;&#13;&#10;RestartDataservice() Response-Daten." Name="_DS_RestartDataserviceResp"/>
	    ErrorCode : UDINT;  //! <Type Comment="The Error Code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_RestartDataserviceResp.ErrorCode"/>
	  END_STRUCT;
#pragma pack(pop)
	  _DS_SendFragmentResp : DINT;  //! <Type Comment="Jedes Fragment muss mit einem Fragment-Response beantwortet werden (funktioniert scheinbar auch ohne)." Name="_DS_SendFragmentResp"/>
#pragma pack(push, 1)
	  _DS_SetStringCmd : STRUCT  //! <Type Public="true" Comment="SetString() parameters." Name="_DS_SetStringCmd"/>
	    dpID : UDINT;  //! <Type Comment="The VarID of the data point to be written.&#13;&#10;&#13;&#10;Die VarID des Datenpunkts der geschrieben werden soll." Name="_DS_SetStringCmd.dpID"/>
	    pString : ^UINT;  //! <Type Comment="Pointer to the string variable (The value to be written).&#13;&#10;&#13;&#10;Zeiger auf die String-Variable (Der Wert der geschrieben werden soll)." Name="_DS_SetStringCmd.pString"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_SetStringResp : STRUCT  //! <Type Public="true" Comment="SetString() response data.&#13;&#10;&#13;&#10;SetString() Response-Daten." Name="_DS_SetStringResp"/>
	    dpID : UDINT;  //! <Type Comment="The VarID of the data point that should be written.&#13;&#10;&#13;&#10;Die VarID des Datenpunkts der geschrieben werden sollte." Name="_DS_SetStringResp.dpID"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_SetStringResp.ErrorCode"/>
	    pString : ^UINT;  //! <Type Comment="Pointer to the string that was tried to write.&#13;&#10;&#13;&#10;Zeiger auf den String der versucht wurde zu schreiben." Name="_DS_SetStringResp.pString"/>
	    StringLen : UDINT;  //! <Type Comment="Number of characters in the string that &lt;pString&gt; points to. Without end character.&#13;&#10;&#13;&#10;Anzahl der Zeichen im String auf den &lt;pString&gt; zeigt. Ohne Endezeichen." Name="_DS_SetStringResp.StringLen"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_SetValueCmd : STRUCT  //! <Type Public="true" Comment="SetValue() parameter." Name="_DS_SetValueCmd"/>
	    dpID : UDINT;  //! <Type Comment="The VarID of the data point to be written.&#13;&#10;&#13;&#10;Die VarID des Datenpunkts der geschrieben werden soll." Name="_DS_SetValueCmd.dpID"/>
	    value : LREAL;  //! <Type Comment="The value to be written.&#13;&#10;&#13;&#10;Der Wert der geschrieben werden soll." Name="_DS_SetValueCmd.value"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_SetValueResp : STRUCT  //! <Type Public="true" Comment="SetValue() response data.&#13;&#10;&#13;&#10;SetValue() Response-Daten." Name="_DS_SetValueResp"/>
	    dpID : UDINT;  //! <Type Comment="The VarID of the data point that should be written.&#13;&#10;&#13;&#10;Die VarID des Datenpunkts der geschrieben werden sollte." Name="_DS_SetValueResp.dpID"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_SetValueResp.ErrorCode"/>
	    value : LREAL;  //! <Type Comment="The value that was tried to write.&#13;&#10;&#13;&#10;Der Wert der versucht wurde zu schreiben." Name="_DS_SetValueResp.value"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_StationListResp : STRUCT  //! <Type Public="true" Comment="GetStationList() response data.&#13;&#10;&#13;&#10;GetStationList() Response-Daten." Name="_DS_StationListResp"/>
	    StationNo : UDINT;  //! <Type Comment="Station number.&#13;&#10;&#13;&#10;Stationsnummer." Name="_DS_StationListResp.StationNo"/>
	    StationStatus : UDINT;  //! <Type Comment="The status of the station. If the station does not exist, OFFLINE is returned.&#13;&#10;&#13;&#10;Der Status der Station. Existiert die Station nicht, wird OFFLINE zurückgegeben." Name="_DS_StationListResp.StationStatus"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_StationStatusResp : STRUCT  //! <Type Public="true" Comment="GetStationStatus() response data.&#13;&#10;&#13;&#10;GetStationStatus() Response-Daten." Name="_DS_StationStatusResp"/>
	    StationNo : UDINT;  //! <Type Comment="Station number for which the status was queried.&#13;&#10;&#13;&#10;Stationsnummer zu der der Status abgefragt wurde." Name="_DS_StationStatusResp.StationNo"/>
	    StationStatus : UDINT;  //! <Type Comment="The status of the station. If the station does not exist, OFFLINE is returned.&#13;&#10;&#13;&#10;Der Status der Station. Existiert die Station nicht, wird OFFLINE zurückgegeben." Name="_DS_StationStatusResp.StationStatus"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_SubscribeStateCmd : STRUCT  //! <Type Public="true" Comment="SubscribeState() parameters." Name="_DS_SubscribeStateCmd"/>
	    Target : UDINT;  //! <Type Comment="Bit mask for determining the targets (= whose status change).&#13;&#10;Bit 1 = DataService&#13;&#10;&#13;&#10;Bitmaske zum Bestimmen der Targets (= wessen Statusänderung).&#13;&#10;Bit 1 = DataService" Name="_DS_SubscribeStateCmd.Target"/>
	    Typ : _DS_StateType;  //! <Type Comment="The status type (= which status change).&#13;&#10;Lasal_ID_List: The corresponding station number is specified under &lt;pData&gt; cast as ^DSComm::_DS_SubscribeStateCmd_1.&#13;&#10;&#13;&#10;Der Statustyp (= welche Statusänderung).&#13;&#10;Lasal_ID_List: Die entsprechende Stationsnummer wird unter &lt;pData&gt; gecastet als ^DSComm::_DS_ SubscribeStateCmd _1 angegeben." Name="_DS_SubscribeStateCmd.Typ"/>
	    pData : pVoid;  //! <Type Comment="Pointer to additional data which can be sent (depending on &lt;Typ&gt;).&#13;&#10;&#13;&#10;Zeiger auf zusätzliche Daten, welche mitgesendet werden können (abhängig von &lt;Typ&gt;)." Name="_DS_SubscribeStateCmd.pData"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_SubscribeStateCmd_1 : STRUCT  //! <Type Public="true" Comment="SubscribeState(): additional data.&#13;&#10;&#13;&#10;SubscribeState(): zusätzliche Daten." Name="_DS_SubscribeStateCmd_1"/>
	    StationNo : UDINT;  //! <Type Comment="Station number.&#13;&#10;&#13;&#10;Stationsummer." Name="_DS_SubscribeStateCmd_1.StationNo"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_SubscribeStateResp : STRUCT  //! <Type Public="true" Comment="SubscribeState() response data.&#13;&#10;&#13;&#10;SubscribeState() Response-Daten." Name="_DS_SubscribeStateResp"/>
	    ErrorCode : UDINT;  //! <Type Comment="The Error Code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_SubscribeStateResp.ErrorCode"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_UnsubscribeStateCmd : STRUCT  //! <Type Public="true" Comment="UnsubscribeState() parameters." Name="_DS_UnsubscribeStateCmd"/>
	    Target : UDINT;  //! <Type Comment="Bit mask for determining the targets (= whose status change).&#13;&#10;Bit 1 = DataService&#13;&#10;&#13;&#10;Bitmaske zum Bestimmen der Targets (= wessen Statusänderung).&#13;&#10;Bit 1 = DataService" Name="_DS_UnsubscribeStateCmd.Target"/>
	    Typ : _DS_StateType;  //! <Type Comment="The status type (= which status change).&#13;&#10;Lasal_ID_List: The corresponding station number is specified under &lt;pData&gt; cast as ^DSComm::_DS_UnsubscribeStateCmd_1.&#13;&#10;&#13;&#10;Der Statustyp (= welche Statusänderung).&#13;&#10;Lasal_ID_List: Die entsprechende Stationsnummer wird unter &lt;pData&gt; gecastet als ^DSComm::_DS_ UnsubscribeStateCmd _1 angegeben." Name="_DS_UnsubscribeStateCmd.Typ"/>
	    pData : pVoid;  //! <Type Comment="Pointer to additional data which can be sent (depending on &lt;Typ&gt;).&#13;&#10;&#13;&#10;Zeiger auf zusätzliche Daten, welche mitgesendet werden können (abhängig von &lt;Typ&gt;)." Name="_DS_UnsubscribeStateCmd.pData"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_UnsubscribeStateCmd_1 : STRUCT  //! <Type Public="true" Comment="UnsubscribeState(): additional data.&#13;&#10;&#13;&#10;UnsubscribeState(): zusätzliche Daten." Name="_DS_UnsubscribeStateCmd_1"/>
	    StationNo : UDINT;  //! <Type Comment="Station number.&#13;&#10;&#13;&#10;Stationsummer." Name="_DS_UnsubscribeStateCmd_1.StationNo"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_UnsubscribeStateResp : STRUCT  //! <Type Public="true" Comment="UnsubscribeState() response data.&#13;&#10;&#13;&#10;UnsubscribeState() Response-Daten." Name="_DS_UnsubscribeStateResp"/>
	    ErrorCode : UDINT;  //! <Type Comment="The Error Code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_UnsubscribeStateResp.ErrorCode"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_UserEventResp : STRUCT  //! <Type Public="true" Comment="SendUserEvent() response data.&#13;&#10;&#13;&#10;SendUserEvent() Response-Daten." Name="_DS_UserEventResp"/>
	    Status : USINT;  //! <Type Comment="The status of the UserEvent in the DataService (0: nothing was forwarded, 1: it could not be delivered to all, 2: it was delivered to all).&#13;&#10;&#13;&#10;Der Status des UserEvents im DataService (0: nichts wurde weitergeleitet, 1: es konnte nicht an alle zugestellt werden, 2: es wurde an alle zugestellt)." Name="_DS_UserEventResp.Status"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_UserLoginResp : STRUCT  //! <Type Public="true" Comment="UserLogin() response data.&#13;&#10;Time and date in Lasal format (see classes _SysDateTime and _SysDateTime2).&#13;&#10;&#13;&#10;Time Format: HHHHHHHHMMMMMMMMSSSSSSSS&#13;&#10;Bit 24-31 (H) contains the hour from 0 to 23.&#13;&#10;Bit 16-23 (M) contains the minute from 0 to 59. &#13;&#10;Bit 8 -15 (S) contains the second from 0 to 59.&#13;&#10;&#13;&#10;Date Format: YYYYYYYYYYYYYYYYMMMMDDDDDDDDWWWW&#13;&#10;Bit 16-31 (Y) contains the entire year (e.g. 2003).&#13;&#10;Bit 12-15 (M) contains the current month from 1 to 12. &#13;&#10;Bit 4-11 (D) contains the day information from 1 to 31.&#13;&#10;Bit 0-3 (W) contains the day of the week, where 0 stands for Sunday, 1 for Monday, etc.&#13;&#10;&#13;&#10;&#13;&#10;UserLogin() Response-Daten.&#13;&#10;Zeit und Datum im Lasal Format (siehe Klassen _SysDateTime und _SysDateTime2).&#13;&#10;&#13;&#10;Zeit-Format: HHHHHHHHMMMMMMMMSSSSSSSS&#13;&#10;Bit 24-31 (H) beinhaltet die Stunde von 0 bis 23.&#13;&#10;Bit 16-23 (M) beinhaltet die Minute von 0 bis 59.&#13;&#10;Bit 8 -15  (S) beinhaltet die Sekunde von 0 bis 59.&#13;&#10;&#13;&#10;Datums-Format: YYYYYYYYYYYYYYYYMMMMDDDDDDDDWWWW&#13;&#10;Bit 16-31 (Y) beinhaltet die gesamte Jahreszahl (z.B. 2003).&#13;&#10;Bit 12-15 (M) beinhaltet das aktuelle Monat von 1 bis 12. &#13;&#10;Bit 4-11   (D) beinhaltet die Tagesinformation von 1 bis 31.&#13;&#10;Bit 0-3     (W) beinhaltet den Wochentag, wobei 0 für Sonntag, 1 für Montag, usw. steht." Name="_DS_UserLoginResp"/>
	    UserID : UDINT;  //! <Type Comment="The ID of the user who was logged in (0 if an error occurred).&#13;&#10;&#13;&#10;Die ID des Benutzer der angemeldet wurde (0, wenn ein Fehler auftrat)." Name="_DS_UserLoginResp.UserID"/>
	    NameLength : UDINT;  //! <Type Comment="Number of characters in the Unicode-string that &lt;pName&gt; points to. Without end character.&#13;&#10;&#13;&#10;Anzahl der Zeichen im Unicode-String auf den &lt;pName&gt; zeigt. Ohne Endezeichen." Name="_DS_UserLoginResp.NameLength"/>
	    pName : ^UINT;  //! <Type Comment="Pointer to the user name which was passed at the Login Command.&#13;&#10;&#13;&#10;Zeiger auf den Benutzernamen welcher beim Login Kommando übergeben wurde." Name="_DS_UserLoginResp.pName"/>
	    ErrorCode : UDINT;  //! <Type Comment="The error code.&#13;&#10;Attention! If ErrorCdoe is &lt;&gt; 0, then the content of the following fields is zero.&#13;&#10;&#13;&#10;Der Fehlercode.&#13;&#10;Achtung! ist ErrorCode &lt;&gt; 0, dann ist der Inhalt der nachfolgenden Felder Null." Name="_DS_UserLoginResp.ErrorCode"/>
	    FirstNameLength : UDINT;  //! <Type Comment="Number of characters in the Unicode-string that &lt;pFirstName&gt; points to. Without end character. See also ErrorCode.&#13;&#10;&#13;&#10;Anzahl der Zeichen im Unicode-String auf den &lt;pFirstName&gt; zeigt. Ohne Endezeichen. Siehe auch ErrorCode." Name="_DS_UserLoginResp.FirstNameLength"/>
	    pFirstName : ^UINT;  //! <Type Comment="Pointer to the first name of the logged on user. See also ErrorCode.&#13;&#10;&#13;&#10;Zeiger auf den Vornamen des angemeldeten Benutzers. Siehe auch ErrorCode." Name="_DS_UserLoginResp.pFirstName"/>
	    LastNameLength : UDINT;  //! <Type Comment="Number of characters in the Unicode-string that &lt;pLastName&gt; points to. Without end character. See also ErrorCode.&#13;&#10;&#13;&#10;Anzahl der Zeichen im Unicode-String auf den &lt;pLastName&gt; zeigt. Ohne Endezeichen. Siehe auch ErrorCode." Name="_DS_UserLoginResp.LastNameLength"/>
	    pLastName : ^UINT;  //! <Type Comment="Pointer to the last name of the logged on user. See also ErrorCode.&#13;&#10;&#13;&#10;Zeiger auf den Nachnamen des angemeldeten Benutzers. Siehe auch ErrorCode." Name="_DS_UserLoginResp.pLastName"/>
	    NumberOfRoles : UDINT;  //! <Type Comment="The number of roles the user has. See also ErrorCode.&#13;&#10;&#13;&#10;Die Anzahl an Rollen welche der Benutzer hat. Siehe auch ErrorCode." Name="_DS_UserLoginResp.NumberOfRoles"/>
	    pRoleID : ^UDINT;  //! <Type Comment="Pointer to an array with &lt;NumberOfRoles&gt; role IDs. See also ErrorCode.&#13;&#10;&#13;&#10;Zeiger auf ein Array mit &lt;NumberOfRoles&gt; Rollen IDs. Siehe auch ErrorCode." Name="_DS_UserLoginResp.pRoleID"/>
	    WriteAccessLogicLength : UDINT;  //! <Type Comment="Number of characters in the Unicode-string that &lt;pWriteAccessLogic&gt; points to. Without end character. See also ErrorCode.&#13;&#10;&#13;&#10;Anzahl der Zeichen im Unicode-String auf den &lt;pWriteAccessLogic&gt; zeigt. Ohne Endezeichen. Siehe auch ErrorCode." Name="_DS_UserLoginResp.WriteAccessLogicLength"/>
	    pWriteAccessLogic : ^USINT;  //! <Type Comment="Pointer to the AccessLogic which is used to check the AccessLevel. See also ErrorCode.&#13;&#10;&#13;&#10;Zeiger auf die AccessLogic welche verwendet wird um den AccessLevel zu prüfen. Siehe auch ErrorCode." Name="_DS_UserLoginResp.pWriteAccessLogic"/>
	    ReadAccessLogicLength : UDINT;  //! <Type Comment="Number of characters in the Unicode-string that &lt;pReadAccessLogic&gt; points to. Without end character. See also ErrorCode.&#13;&#10;&#13;&#10;Anzahl der Zeichen im Unicode-String auf den &lt;pReadAccessLogic&gt; zeigt. Ohne Endezeichen. Siehe auch ErrorCode." Name="_DS_UserLoginResp.ReadAccessLogicLength"/>
	    pReadAccessLogic : ^USINT;  //! <Type Comment="Pointer to the AccessLogic which is used to check the AccessLevel. See also ErrorCode.&#13;&#10;&#13;&#10;Zeiger auf die AccessLogic welche verwendet wird um den AccessLevel zu prüfen. Siehe auch ErrorCode." Name="_DS_UserLoginResp.pReadAccessLogic"/>
	    UserInfoLength : UDINT;  //! <Type Comment="Number of characters in the Unicode-string that &lt;pUserInfo&gt; points to. Without end character. See also ErrorCode.&#13;&#10;&#13;&#10;Anzahl der Zeichen im Unicode-String auf den &lt;pUserInfo&gt; zeigt. Ohne Endezeichen. Siehe auch ErrorCode." Name="_DS_UserLoginResp.UserInfoLength"/>
	    pUserInfo : ^UINT;  //! <Type Comment="Pointer to the user information. See also ErrorCode.&#13;&#10;&#13;&#10;Zeiger auf die Informationen zum Benutzer. Siehe auch ErrorCode." Name="_DS_UserLoginResp.pUserInfo"/>
	    CreatedDate : UDINT;  //! <Type Comment="Creation date of the account (date in Lasal format). See also ErrorCode.&#13;&#10;&#13;&#10;Erstellungsdatum des Accounts (Datum im Lasal Format). Siehe auch ErrorCode." Name="_DS_UserLoginResp.CreatedDate"/>
	    CreatedTime : UDINT;  //! <Type Comment="Creation time (time in Lasal format). See also ErrorCode.&#13;&#10;&#13;&#10;Erstellungszeit (Zeit im Lasal Format). Siehe auch ErrorCode." Name="_DS_UserLoginResp.CreatedTime"/>
	    ModifiedUserDate : UDINT;  //! <Type Comment="Date of last change (date in Lasal format). See also ErrorCode.&#13;&#10;&#13;&#10;Datum der letzten Änderung (Datum im Lasal Format). Siehe auch ErrorCode." Name="_DS_UserLoginResp.ModifiedUserDate"/>
	    ModifiedUserTime : UDINT;  //! <Type Comment="Time of last change (time in Lasal format). See also ErrorCode.&#13;&#10;&#13;&#10;Uhrzeit der letzen Änderung (Zeit im Lasal Format). Siehe auch ErrorCode." Name="_DS_UserLoginResp.ModifiedUserTime"/>
	    ModifiedPWDate : UDINT;  //! <Type Comment="Date of last password change (date in Lasal format). See also ErrorCode.&#13;&#10;&#13;&#10;Datum der letzten Passwort-Änderung (Datum im Lasal Format). Siehe auch ErrorCode." Name="_DS_UserLoginResp.ModifiedPWDate"/>
	    ModifiedPWTime : UDINT;  //! <Type Comment="Time of the last password change (time in Lasal format). See also ErrorCode.&#13;&#10;&#13;&#10;Uhrzeit der letzten Passwort-Änderung (Zeit im Lasal Format). Siehe auch ErrorCode." Name="_DS_UserLoginResp.ModifiedPWTime"/>
	    LastLoginDate : UDINT;  //! <Type Comment="Date of last login (date in Lasal format). See also ErrorCode.&#13;&#10;&#13;&#10;Datum des letzten Logins (Datum im Lasal Format). Siehe auch ErrorCode." Name="_DS_UserLoginResp.LastLoginDate"/>
	    LastLoginTime : UDINT;  //! <Type Comment="Time of the last login (time in Lasal format). See also ErrorCode.&#13;&#10;&#13;&#10;Uhrzeit des letzen Logins (Zeit im Lasal Format). Siehe auch ErrorCode." Name="_DS_UserLoginResp.LastLoginTime"/>
	    LastLogoutDate : UDINT;  //! <Type Comment="Date of last logout (date in Lasal format). See also ErrorCode.&#13;&#10;&#13;&#10;Datum des letzten Logouts (Datum im Lasal Format). Siehe auch ErrorCode." Name="_DS_UserLoginResp.LastLogoutDate"/>
	    LastLogoutTime : UDINT;  //! <Type Comment="Time of the last logout (time in Lasal format). See also ErrorCode.&#13;&#10;&#13;&#10;Uhrzeit des letzen Logouts (Zeit im Lasal Format). Siehe auch ErrorCode." Name="_DS_UserLoginResp.LastLogoutTime"/>
	    UserPrivileges : _DS_UnsLongLongInt;  //! <Type Comment="The privileges of the user. See also ErrorCode.&#13;&#10;&#13;&#10;Die Berechtigungen des Benutzers. Siehe auch ErrorCode." Name="_DS_UserLoginResp.UserPrivileges"/>
	    OperationTimeout : UINT;  //! <Type Comment="The time in seconds until the user is automatically logged out when inactive. See also ErrorCode.&#13;&#10;&#13;&#10;Die Zeit in Sekunden bis der Benutzer bei Inaktivität automatisch abgemeldet wird. Siehe auch ErrorCode." Name="_DS_UserLoginResp.OperationTimeout"/>
	    WriteProtected : USINT;  //! <Type Comment="TRUE: this user is predefined. It cannot be changed or deleted.&#13;&#10;FALSE: this user is defined by the application. It can be changed and deleted.&#13;&#10;See also ErrorCode.&#13;&#10;&#13;&#10;TRUE: dieser Benutzer ist vordefiniert. Er kann nicht geändert und nicht gelöscht werden.&#13;&#10;FALSE: dieser Benutzer wurde von der Applikation definiert. Er kann geändert und gelöscht werden. &#13;&#10;Siehe auch ErrorCode." Name="_DS_UserLoginResp.WriteProtected"/>
	    AccessNumberValid : USINT;  //! <Type Comment="TRUE, if &lt;AccessNumber&gt; is used. See also ErrorCode.&#13;&#10;If the value is FALSE, then &lt;AccessNumber&gt; is zero.&#13;&#10;&#13;&#10;TRUE, wenn die &lt;AccessNumber&gt; verwendet wird. Siehe auch ErrorCode.&#13;&#10;Wenn der Wert FALSE ist, dann ist &lt;AccessNumber&gt; null." Name="_DS_UserLoginResp.AccessNumberValid"/>
	    AccessNumber : UDINT;  //! <Type Comment="Attention! Only defined if AccessNumberValid is TRUE. Otherwise the value is zero.&#13;&#10;See also ErrorCode.&#13;&#10;&#13;&#10;Achtung! Ist nur definiert, wenn AccessNumberValid TRUE ist. Sonst ist der Wert Null.&#13;&#10;Siehe auch ErrorCode." Name="_DS_UserLoginResp.AccessNumber"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_UserPasswordChangeResp : STRUCT  //! <Type Public="true" Comment="UserPasswordChange() response data.&#13;&#10;&#13;&#10;UserPasswordChange() Response-Daten." Name="_DS_UserPasswordChangeResp"/>
	    ErrorCode : UDINT;  //! <Type Comment="The Error Code.&#13;&#10;&#13;&#10;Der Fehlercode." Name="_DS_UserPasswordChangeResp.ErrorCode"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_UsrEvntMinorID : STRUCT  //! <Type Comment="Die MinorID eines User Events und pThis des Objekts an das das User Event übergeben wird." Name="_DS_UsrEvntMinorID"/>
	    MinorID : UINT;  //! <Type Comment="Die MinorID des User Events." Name="_DS_UsrEvntMinorID.MinorID"/>
	    pThis : ^DSComm_Interface;  //! <Type Comment="Zeiger auf ein Objekt für den Empfang dieses User Events (MajorID / MinorID)." Name="_DS_UsrEvntMinorID.pThis"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _DS_UsrEvntMajorID : STRUCT  //! <Type Comment="Die MajorID eines User Events und die Anzahl der MinorIDs unter dieser MajorID." Name="_DS_UsrEvntMajorID"/>
	    MajorID : UINT;  //! <Type Comment="Die MajorID des User Events." Name="_DS_UsrEvntMajorID.MajorID"/>
	    MinorIDCnt : INT;  //! <Type Comment="Flag &lt;Listed_MinorIDs_invalid&gt; = 0: die Anzahl der gültigen MinorIDs unter dieser MajorID.&#13;&#10;Flag &lt;Listed_MinorIDs_invalid&gt; = 1: die Anzahl der ungültigen MinorIDs unter dieser MajorID.&#13;&#10;&#13;&#10;&lt;pMinorID&gt; zeigt auf den Puffer für die MinorIDs." Name="_DS_UsrEvntMajorID.MinorIDCnt"/>
	    pMinorID : ^_DS_UsrEvntMinorID;  //! <Type Comment="Pointer auf den Puffer mit den MinorIDs für diese MajorID." Name="_DS_UsrEvntMajorID.pMinorID"/>
	    Flags : BINT
	    [
	      1 All_MinorIDs_valid,  //! <Type Comment="0: der Puffer für die MinorIDs enthält jene MinorIDs welche gültig sind.&#13;&#10;1: Alle MinorIDs sind gültig. Der This-Pointer für alle ist im Element 0 hinterlegt." Name="_DS_UsrEvntMajorID.Flags.All_MinorIDs_valid"/>
	      2 Listed_MinorIDs_invalid,  //! <Type Comment="0: der Puffer für die MinorIDs enthält die gültigen MinorIDs. Nur sinnvoll, wenn das Flag &quot;All_MinorIDs_valid&quot; nicht gesetzt ist.&#13;&#10;1: der Puffer für die MinorIDs enthält die ungültigen MinorIDs. Nur sinnvoll, wenn das Flag &quot;All_MinorIDs_valid&quot; gesetzt ist." Name="_DS_UsrEvntMajorID.Flags.Listed_MinorIDs_invalid"/>
	      3 Bit3,
	      4 Bit4,
	      5 Bit5,
	      6 Bit6,
	      7 Bit7,
	      8 Bit8,
	      9 Bit9,
	      10 Bit10,
	      11 Bit11,
	      12 Bit12,
	      13 Bit13,
	      14 Bit14,
	      15 Bit15,
	      16 Bit16,
	    ];
	  END_STRUCT;
#pragma pack(pop)
	  _pDS_JobInfoElmt : ^_DS_JobInfoElmt;
	  _TCPCommSteps :
	  (
	    TCPCom_DoNothing,
	    TCPCom_StartConnecting,
	    TCPCom_ConnectClientToServer,
	    TCPCom_CloseConnection,
	    TCPCom_ConnectionOKSendAlive,
	    TCPCom_WaitNewConnection
	  )$UDINT;
#pragma pack(push, 1)
	  _TCPVariables : STRUCT  //! <Type Comment="Times in milliseconds." Name="_TCPVariables"/>
	    Socket : DINT;
	    TimeOutSend : UDINT;
	    TimeOutRecv : UDINT;
	    TimeOutAlive : UDINT;
	    TimeAliveSignal : UDINT;
	    TimeNewConnection : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _TimeStamps : STRUCT  //! <Type Comment="Times in milliseconds." Name="_TimeStamps"/>
	    AliveCounterExt : UDINT;
	    NewConnection : UDINT;
	    LastSendPackAlive : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  TASK_PARAM : STRUCT
	    thisptr : ^void;
	    newsock : DINT;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
	Online 	: SvrCh_DINT;
	ClassState 	: SvrCh_DINT;
	MaxReconnectTime 	: SvrCh_UDINT;
	DS_Version 	: SvrCh_UDINT;
	DS_BuildNo 	: SvrCh_UDINT;
	Taskname 	: SvrChCmd_UDINT;
	ErrorSend 	: SvrCh_DINT;
	ErrorReceive 	: SvrCh_DINT;
  //Clients:
	cIPaddr 	: CltChCmd_String;
	SigCLib 	: CltChCmd_SigCLib;
	ThreadName 	: CltChCmd_String;
  //Variables:
		BytesToReceive 	: UDINT;
		BytesAvailable 	: DINT;
		IPaddr : ARRAY [0..16] OF CHAR;

		pRecvBuffer 	: ^CHAR;
		RecvBufferSize 	: UDINT;
		DataBufferSize 	: UDINT;
		pRecvBufferStatic 	: ^CHAR;
		pDataBufferStatic 	: ^CHAR;
		pRecvBufferStart 	: ^CHAR;
		pDataBufferStart 	: ^CHAR;
		lsl_tcp_user 	: ^LSL_TCP_USER;
		_MessageID 	: DINT;
		CancelCommandJobs 	: DSComm::_DS_JobInfo;
		CancelCommandJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		GetVersionJobs 	: DSComm::_DS_JobInfo;
		GetVersionJobArray : ARRAY [0..7] OF DSComm::_DS_JobInfoElmt;

		GetProjectInfoJobs 	: DSComm::_DS_JobInfo;
		GetProjectInfoJobArray : ARRAY [0..7] OF DSComm::_DS_JobInfoElmt;

		SendUserEventJobs 	: DSComm::_DS_JobInfo;
		SendUserEventJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		SubscribeStateJobs 	: _DS_JobInfo;
		SubscribeStateJobArray : ARRAY [0..7] OF _DS_JobInfoElmt;

		UnsubscribeStateJobs 	: _DS_JobInfo;
		UnsubscribeStateJobArray : ARRAY [0..7] OF _DS_JobInfoElmt;

		GetStateJobs 	: _DS_JobInfo;
		GetStateJobArray : ARRAY [0..7] OF _DS_JobInfoElmt;

		LoopJobs 	: DSComm::_DS_JobInfo;
		LoopJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		RecipeLoadJobs 	: DSComm::_DS_JobInfo;
		RecipeLoadJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		RecipeSaveJobs 	: DSComm::_DS_JobInfo;
		RecipeSaveJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		SendToAllJobs 	: DSComm::_DS_JobInfo;
		SendToAllJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		ResetDataserviceJobs 	: DSComm::_DS_JobInfo;
		ResetDataserviceJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		RestartDataserviceJobs 	: DSComm::_DS_JobInfo;
		RestartDataserviceJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		AddLocalClientJobs 	: DSComm::_DS_JobInfo;
		AddLocalClientJobArray : ARRAY [0..7] OF DSComm::_DS_JobInfoElmt;

		AddLocalClientRangeJobs 	: DSComm::_DS_JobInfo;
		AddLocalClientRangeJobArray : ARRAY [0..7] OF DSComm::_DS_JobInfoElmt;

		RemoveThisLocalClientJobs 	: DSComm::_DS_JobInfo;
		RemoveThisLocalClientJobArray : ARRAY [0..7] OF DSComm::_DS_JobInfoElmt;

		RemoveLocalClientJobs 	: DSComm::_DS_JobInfo;
		RemoveLocalClientJobArray : ARRAY [0..7] OF DSComm::_DS_JobInfoElmt;

		RemoveLocalClientRangeJobs 	: DSComm::_DS_JobInfo;
		RemoveLocalClientRangeJobArray : ARRAY [0..7] OF DSComm::_DS_JobInfoElmt;

		ClearLocalClientListJobs 	: DSComm::_DS_JobInfo;
		ClearLocalClientListJobArray : ARRAY [0..7] OF DSComm::_DS_JobInfoElmt;

		GetCurrentIDJobs 	: DSComm::_DS_JobInfo;
		GetCurrentIDJobArray : ARRAY [0..7] OF DSComm::_DS_JobInfoElmt;

		GetLocalClientListJobs 	: DSComm::_DS_JobInfo;
		GetLocalClientListJobArray : ARRAY [0..7] OF DSComm::_DS_JobInfoElmt;

		GetLocalClientListDetailsJobs 	: DSComm::_DS_JobInfo;
		GetLocalClientListDetailsJobArray : ARRAY [0..7] OF DSComm::_DS_JobInfoElmt;

		GetLocalClientByIDJobs 	: DSComm::_DS_JobInfo;
		GetLocalClientByIDJobArray : ARRAY [0..7] OF DSComm::_DS_JobInfoElmt;

		UserLoginJobs 	: DSComm::_DS_JobInfo;
		UserLoginJobArray : ARRAY [0..7] OF DSComm::_DS_JobInfoElmt;

		UserLoginData 	: DSComm::_DS_UserLoginResp;
		UserLogoutJobs 	: DSComm::_DS_JobInfo;
		UserLogoutJobArray : ARRAY [0..7] OF DSComm::_DS_JobInfoElmt;

		UserPwdChangeJobs 	: DSComm::_DS_JobInfo;
		UserPwdChangeJobArray : ARRAY [0..7] OF DSComm::_DS_JobInfoElmt;

		CheckAccessLevelJobs 	: DSComm::_DS_JobInfo;
		CheckAccessLevelJobArray : ARRAY [0..7] OF DSComm::_DS_JobInfoElmt;

		CreateUserJobs 	: DSComm::_DS_JobInfo;
		CreateUserJobArray : ARRAY [0..7] OF DSComm::_DS_JobInfoElmt;

		ChangeUserSettingsJobs 	: DSComm::_DS_JobInfo;
		ChangeUserSettingsJobArray : ARRAY [0..1] OF DSComm::_DS_JobInfoElmt;

		DeleteUserJobs 	: DSComm::_DS_JobInfo;
		DeleteUserJobArray : ARRAY [0..7] OF DSComm::_DS_JobInfoElmt;

		GetUserListJobs 	: DSComm::_DS_JobInfo;
		GetUserListJobArray : ARRAY [0..7] OF DSComm::_DS_JobInfoElmt;

		GetUserDetailsJobs 	: DSComm::_DS_JobInfo;
		GetUserDetailsJobArray : ARRAY [0..7] OF DSComm::_DS_JobInfoElmt;

		CreateRoleJobs 	: DSComm::_DS_JobInfo;
		CreateRoleJobArray : ARRAY [0..7] OF DSComm::_DS_JobInfoElmt;

		ChangeRoleJobs 	: DSComm::_DS_JobInfo;
		ChangeRoleJobArray : ARRAY [0..7] OF DSComm::_DS_JobInfoElmt;

		DeleteRoleJobs 	: DSComm::_DS_JobInfo;
		DeleteRoleJobArray : ARRAY [0..7] OF DSComm::_DS_JobInfoElmt;

		GetRoleListJobs 	: DSComm::_DS_JobInfo;
		GetRoleListJobArray : ARRAY [0..7] OF DSComm::_DS_JobInfoElmt;

		GetRoleDetailsJobs 	: DSComm::_DS_JobInfo;
		GetRoleDetailsJobArray : ARRAY [0..7] OF DSComm::_DS_JobInfoElmt;

		RoleDetails 	: DSComm::_DS_GetRoleDetailsResp;
		GetVarIdFromNameJobs 	: DSComm::_DS_JobInfo;
		GetVarIdFromNameJobArray : ARRAY [0..7] OF DSComm::_DS_JobInfoElmt;

		GetVarIdFromLasalIdJobs 	: DSComm::_DS_JobInfo;
		GetVarIdFromLasalIdJobArray : ARRAY [0..7] OF DSComm::_DS_JobInfoElmt;

		GetLasalIdFromNameJobs 	: DSComm::_DS_JobInfo;
		GetLasalIdFromNameJobArray : ARRAY [0..7] OF DSComm::_DS_JobInfoElmt;

		GetLasalIdFromVarIdJobs 	: DSComm::_DS_JobInfo;
		GetLasalIdFromVarIdJobArray : ARRAY [0..7] OF DSComm::_DS_JobInfoElmt;

		GetNameFromVarIdJobs 	: DSComm::_DS_JobInfo;
		GetNameFromVarIdJobArray : ARRAY [0..7] OF DSComm::_DS_JobInfoElmt;

		GetNameFromLasalIdJobs 	: DSComm::_DS_JobInfo;
		GetNameFromLasalIdJobArray : ARRAY [0..7] OF DSComm::_DS_JobInfoElmt;

		GetDpListJobs 	: DSComm::_DS_JobInfo;
		GetDpListJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		GetDpInfoJobs 	: DSComm::_DS_JobInfo;
		GetDpInfoJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		GetVarIdFromCRCJobs 	: DSComm::_DS_JobInfo;
		GetVarIdFromCRCJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		GetCRCfromVarIdJobs 	: DSComm::_DS_JobInfo;
		GetCRCfromVarIdJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		GetValueJobs 	: DSComm::_DS_JobInfo;
		GetValueJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		GetStringJobs 	: DSComm::_DS_JobInfo;
		GetStringJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		SetValueJobs 	: DSComm::_DS_JobInfo;
		SetValueJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		SetStringJobs 	: DSComm::_DS_JobInfo;
		SetStringJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		IncValueJobs 	: DSComm::_DS_JobInfo;
		IncValueJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		DecValueJobs 	: DSComm::_DS_JobInfo;
		DecValueJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		RefListAddJobs 	: DSComm::_DS_JobInfo;
		RefListAddJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		RefListSubJobs 	: DSComm::_DS_JobInfo;
		RefListSubJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		GetStationListJobs 	: DSComm::_DS_JobInfo;
		GetStationListJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		GetStationStatusJobs 	: DSComm::_DS_JobInfo;
		GetStationStatusJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		FileOpenJobs 	: DSComm::_DS_JobInfo;
		FileOpenJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		FileCloseJobs 	: DSComm::_DS_JobInfo;
		FileCloseJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		FileSeekJobs 	: DSComm::_DS_JobInfo;
		FileSeekJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		FileTellJobs 	: DSComm::_DS_JobInfo;
		FileTellJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		FileReadJobs 	: DSComm::_DS_JobInfo;
		FileReadJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		FileWriteJobs 	: DSComm::_DS_JobInfo;
		FileWriteJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		FileGetJobs 	: DSComm::_DS_JobInfo;
		FileGetJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		FilePutJobs 	: DSComm::_DS_JobInfo;
		FilePutJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		FileLengthJobs 	: DSComm::_DS_JobInfo;
		FileLengthJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		FileContentJobs 	: DSComm::_DS_JobInfo;
		FileContentJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		DirCreateJobs 	: DSComm::_DS_JobInfo;
		DirCreateJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		DirReadJobs 	: DSComm::_DS_JobInfo;
		DirReadJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		FileRemoveJobs 	: DSComm::_DS_JobInfo;
		FileRemoveJobArray : ARRAY [0..1] OF DSComm::_DS_JobInfoElmt;

		FileCopyJobs 	: DSComm::_DS_JobInfo;
		FileCopyJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		FileInfoJobs 	: DSComm::_DS_JobInfo;
		FileInfoJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		FileRenameJobs 	: DSComm::_DS_JobInfo;
		FileRenameJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		FileSetAttributeJobs 	: DSComm::_DS_JobInfo;
		FileSetAttributeJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		GetDriveListJobs 	: DSComm::_DS_JobInfo;
		GetDriveListJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		FileMoveJobs 	: DSComm::_DS_JobInfo;
		FileMoveJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		EventjournalAddJobs 	: DSComm::_DS_JobInfo;
		EventjournalAddJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		EventjournalGetJobs 	: DSComm::_DS_JobInfo;
		EventjournalGetJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		EventjournalGetAllJobs 	: DSComm::_DS_JobInfo;
		EventjournalGetAllJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		EventjournalDelJobs 	: DSComm::_DS_JobInfo;
		EventjournalDelJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		EventjournalDelAllJobs 	: DSComm::_DS_JobInfo;
		EventjournalDelAllJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		EventjournalQuitAlarmJobs 	: DSComm::_DS_JobInfo;
		EventjournalQuitAlarmJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		EventjournalQuitAllJobs 	: DSComm::_DS_JobInfo;
		EventjournalQuitAllJobArray : ARRAY [0..15] OF DSComm::_DS_JobInfoElmt;

		AlarmListUpdateAddJobs 	: DSComm::_DS_JobInfo;
		AlarmListUpdateAddJobArray : ARRAY [0..7] OF DSComm::_DS_JobInfoElmt;

		AlarmListUpdateSubJobs 	: DSComm::_DS_JobInfo;
		AlarmListUpdateSubJobArray : ARRAY [0..7] OF DSComm::_DS_JobInfoElmt;

		HotAlarmUpdateAddJobs 	: DSComm::_DS_JobInfo;
		HotAlarmUpdateAddJobArray : ARRAY [0..7] OF DSComm::_DS_JobInfoElmt;

		HotAlarmUpdateSubJobs 	: DSComm::_DS_JobInfo;
		HotAlarmUpdateSubJobArray : ARRAY [0..7] OF DSComm::_DS_JobInfoElmt;

		AlarmDeleteJobs 	: DSComm::_DS_JobInfo;
		AlarmDeleteJobArray : ARRAY [0..7] OF DSComm::_DS_JobInfoElmt;

		AlarmDeleteAllJobs 	: DSComm::_DS_JobInfo;
		AlarmDeleteAllJobArray : ARRAY [0..7] OF DSComm::_DS_JobInfoElmt;

		ChannelInfo : ARRAY [0..DS_MAX_CHANNEL] OF DSComm::_DS_ChannelInfo;

		ProgressInfo : ARRAY [0..DS_PROGRESS_INFO_ELMT_CNT-1] OF DSComm::_DS_ProgressInfo;

		DS_Reset 	: BOOL;
		TimeNow 	: UDINT;
		TimeLast 	: UDINT;
		TimeDiff 	: UDINT;
		TimeMax 	: UDINT;
		_Step 	: DINT;
		SendToAllpThis 	: ^DSComm_Interface;
		pThis_EventJournalUpdate 	: ^DSComm_Interface;
		pThis_AlarmListUpdate 	: ^DSComm_Interface;
		pThis_HotAlarmUpdate 	: ^DSComm_Interface;
		pThis_UpdateState 	: ^DSComm_Interface;
		RespTimeout 	: UDINT;			//! <Variable Comment="Normales Response Timeout in [ms]." Name="RespTimeout"/>
		RespTimeoutLong 	: UDINT;			//! <Variable Comment="Response Timeout in [ms] für lange dauernde Kommandos (FileCopy, FileMove etc)." Name="RespTimeoutLong"/>
		eComSteps 	: DSComm::_TCPCommSteps;
		TCPparameter 	: DSComm::_TCPVariables;
		TimeStamp 	: DSComm::_TimeStamps;
		UnknownMajorIDCount 	: UDINT;
		UnknownMinorIDCount 	: UDINT;
		StartConnectTime 	: UDINT;
		ActConnectTime 	: UDINT;
		ConnectTime 	: UDINT;
		TotalNumIncr 	: UDINT;
		pMajorID 	: ^DSComm::_DS_UsrEvntMajorID;
		MajorIDCount 	: DINT;
		UserIDLogin 	: UDINT;
		DBG_FragRespCount 	: DINT;
		DBG_PaketCount 	: UDINT;
		MuxHdl 	: UDINT;
		BufferHandling : ARRAY [0..MaxBuffers-1] OF DSComm::_DS_BufferHandling;

		DBG_DataTime 	: UDINT;
		DBG_HdrOriTime 	: UDINT;
		DBG_FragHdrTime 	: UDINT;
		DBG_HdrTime 	: UDINT;
		pRecvBuffer_DBG 	: ^CHAR;
		pPipe 	: pVoid;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION __CDECL CommTask
		VAR_INPUT
			pParam 	: ^void;
		END_VAR;
	
	FUNCTION Connection
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="Returns the information whether a connection to the data service exists.&#13;&#10;&#13;&#10;Liefert die Information, ob eine Verbindung zum Dataservice besteht." Name="IsConnected"/>
	FUNCTION GLOBAL IsConnected
		VAR_OUTPUT
			OutParam 	: BOOL;			//! <Variable Comment="TRUE: a connection to the data service is available.&#13;&#10;FALSE: there is no connection to the data service.&#13;&#10;&#13;&#10;TRUE: Verbindung zum Dataservice vorhanden.&#13;&#10;FALSE: keine Verbindung zum Dataservice vorhanden." Name="IsConnected.OutParam"/>
		END_VAR;
	
	FUNCTION NewResponse
		VAR_INPUT
			pHeader 	: ^DSComm::_DS_Header;
			pFragHeader 	: ^DSComm::_DS_FragmentHeader;
			pRecvBuffer 	: ^CHAR;
			pDataBuffer 	: ^CHAR;
			ErrorNo 	: DINT;
		END_VAR;
				//! <Function Comment="Sendet einmal AliveTrigger." Name="AliveTrigger"/>
	FUNCTION AliveTrigger
		VAR_OUTPUT
			RetVal 	: DINT;
		END_VAR;
				//! <Function Comment="Returns the ID of the user who is logged in to the data service.&#13;&#10;&#13;&#10;Liefert die ID des Benutzer welcher beim Dataservice angemeldet ist." Name="GetLoginInfo"/>
	FUNCTION GLOBAL GetLoginInfo
		VAR_OUTPUT
			userID 	: UDINT;			//! <Variable Comment="  = 0: no user is logged in.&#13;&#10;&lt;&gt; 0: ID of the user who is logged in to the data service.&#13;&#10;&#13;&#10;  = 0: Es ist kein Benutzer angemeldet.&#13;&#10;&lt;&gt; 0: Die ID des angemeldeten Benutzers." Name="GetLoginInfo.userID"/>
		END_VAR;
				//! <Function Comment="Used to cancel running background processes (e.g. copying files).&#13;&#10;&#13;&#10;Wird verwendet um laufende Hintergrund Prozesse (zB. kopieren von Dateien) abzubrechen.&#10;&#10;" Name="CancelCommand"/>
	FUNCTION GLOBAL CancelCommand
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="CancelCommand.pThis"/>
			HandleID 	: UDINT;			//! <Variable Comment="The MessageID of the command that is to be canceled.&#13;&#10;&#13;&#10;Die MessageId des Kommandos, das abgebrochen werden soll." Name="CancelCommand.HandleID"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="CancelCommand.MessageID"/>
		END_VAR;
				//! <Function Comment="Returns the version of the data service.&#13;&#10;&#13;&#10;Liefert die Version des Dataservice zurück." Name="GetVersion"/>
	FUNCTION GLOBAL GetVersion
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="GetVersion.pThis"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="GetVersion.MessageID"/>
		END_VAR;
	
	FUNCTION GetIpOfServer
		VAR_INPUT
			pChar 	: ^CHAR;
			dstsize 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION SetSocketOptions
		VAR_INPUT
			socket 	: DINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION SendData;
	
	FUNCTION ReceiveData;
	
	FUNCTION SendDataTCP
		VAR_INPUT
			pData 	: ^CHAR;
			SockNo 	: DINT;
		END_VAR
		VAR_OUTPUT
			RetVal 	: DINT;
		END_VAR;
				//! <Function Comment="SendToCommTask() schreibt Requests thread-safe in eine cPipe um:&#13;&#10;1) Fragmentierte Requests zu serialisieren. Sonst könnte ein nieder-priorer Request von einem höher-prioren zerhackt werden.&#13;&#10;    Der DataService antwortet aber nur auf den zuletzt erhaltenen Request, d.h. den höher-prioren. Der nieder-priore geht verloren.&#13;&#10;2) Wenn das Senden (im blocking mode) nicht in einem eigenen Task erfolgt, kann es vorkommen, dass der Background dort unterbrochen wird.&#13;&#10;    Dann kann der Response schon eintreffen und die Callback-Methode aufgerufen werden, bevor die Applikation eine MessageID bekommen hat.&#13;&#10;    Beispiel: Applikation und DataService auf der gleichen SPS. GetNameFromLasalIdResp() wird aufgerufen obwohl der Background noch in GetNameFromLasalId() hängt." Name="SendToCommTask"/>
	FUNCTION SendToCommTask
		VAR_INPUT
			pData 	: ^CHAR;
			SockNo 	: DINT;
			pJobElmt 	: ^_DS_JobInfoElmt;
		END_VAR
		VAR_OUTPUT
			RetVal 	: DINT;
		END_VAR;
	
	FUNCTION SaveJobInfo
		VAR_INPUT
			pJobInfo 	: ^DSComm::_DS_JobInfo;
			MessageID 	: DINT;
			pThis 	: ^DSComm_Interface;
			ppJobElmt 	: ^_pDS_JobInfoElmt;
		END_VAR
		VAR_OUTPUT
			RetVal 	: DINT;
		END_VAR;
	
	FUNCTION RemoveJob
		VAR_INPUT
			pJobInfo 	: ^DSComm::_DS_JobInfo;
			MessageID 	: DINT;
		END_VAR
		VAR_OUTPUT
			pJobElmt 	: ^DSComm::_DS_JobInfoElmt;
		END_VAR;
				//! <Function Comment="Returns the name of the current project and the version of the data service..&#13;&#10;&#13;&#10;Liefert den Namen des aktuellen Projekts und die Version des DatenService zurück." Name="GetProjectInfo"/>
	FUNCTION GLOBAL GetProjectInfo
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="GetProjectInfo.pThis"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="GetProjectInfo.MessageID"/>
		END_VAR;
				//! <Function Comment="This method registers an object to receive state change events. &#13;&#10;Status change events are passed to the UpdateStatePush() method in the object that called the SubscribeState() method.&#13;&#10;Only one object can be registered to receive state change events.&#13;&#10;&#13;&#10;Mit dieser Methode meldet sich ein Objekt für den Empfang von Statusänderungs-Events an. &#13;&#10;Statusänderungs-Events werden an die Methode UpdateStatePush() in jenem Objekt übergeben, welches die Methode SubscribeState() aufgerufen hat.&#13;&#10;Es kann nur ein Objekt für den Empfang von Statusänderungs-Events angemeldet sein." Name="SubscribeState"/>
	FUNCTION GLOBAL SubscribeState
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="SubscribeState.pThis"/>
			pCmdData 	: ^_DS_SubscribeStateCmd;			//! <Variable Comment="Pointer to the command data.&#13;&#10;&#13;&#10;Zeiger auf die Kommando-Daten." Name="SubscribeState.pCmdData"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: the pointer &lt;pCmdData&gt; is invalid or the type pCmdData^.Typ is unknown.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum Zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Zeiger &lt;pCmdData&gt; ist ungültig oder der Typ pCmdData^.Typ ist unbekannt.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="SubscribeState.MessageID"/>
		END_VAR;
				//! <Function Comment="Remove registration for receiving state change events. &#13;&#10;After calling this method, no more state change events are passed to the UpdateStatePush() method.&#13;&#10;&#13;&#10;Anmeldung für den Empfang von Statusänderungs-Events entfernen. &#13;&#10;Nach dem Aufruf dieser Methode werden keine Statusänderungs-Events mehr an die Methode UpdateStatePush()  übergeben." Name="UnsubscribeState"/>
	FUNCTION GLOBAL UnsubscribeState
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="UnsubscribeState.pThis"/>
			pCmdData 	: ^_DS_UnsubscribeStateCmd;			//! <Variable Comment="Pointer to the command data.&#13;&#10;&#13;&#10;Zeiger auf die Kommando-Daten." Name="UnsubscribeState.pCmdData"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: the pointer &lt;pCmdData&gt; is invalid or the type pCmdData^.Typ is unknown.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum Zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Zeiger &lt;pCmdData&gt; ist ungültig oder der Typ pCmdData^.Typ ist unbekannt.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="UnsubscribeState.MessageID"/>
		END_VAR;
				//! <Function Comment="Returns the requested state in the response data. &#13;&#10;The response data of this command received from the data service is passed to the GetStateResp() method.&#13;&#10;&#13;&#10;Liefert in den Response-Daten den angeforderten Status zurück. &#13;&#10;Die vom Data Service empfangenen Response-Daten dieses Kommandos werden an die Methode GetStateResp() übergeben." Name="Get_State"/>
	FUNCTION GLOBAL Get_State
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="Get_State.pThis"/>
			pCmdData 	: ^_DS_GetStateCmd;			//! <Variable Comment="Pointer to the command data.&#13;&#10;&#13;&#10;Zeiger auf die Kommando-Daten." Name="Get_State.pCmdData"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: the pointer &lt;pCmdData&gt; is invalid or the type pCmdData^.Typ is unknown.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum Zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Zeiger &lt;pCmdData&gt; ist ungültig oder der Typ pCmdData^.Typ ist unbekannt.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="Get_State.MessageID"/>
		END_VAR;
				//! <Function Comment="Sends back the given data.&#13;&#10;Can be used to measure the signal propagation time.&#13;&#10;&#13;&#10;Sendet die Daten, welche mitgegeben wurden 1:1 wieder zurück. &#13;&#10;Kann dazu verwendet werden um die Signallaufzeit zu messen." Name="Loop"/>
	FUNCTION GLOBAL Loop
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="Loop.pThis"/>
			Station 	: UDINT;			//! <Variable Comment="The station to which the data is to be sent (0xFFFFFFFF = DataService).&#13;&#10;&#13;&#10;Die Station zur der die Daten geschickt werden sollen (0xFFFFFFFF = DataService)." Name="Loop.Station"/>
			pDataSrc 	: ^void;			//! <Variable Comment="Pointer to the data to be sent.&#13;&#10;&#13;&#10;Zeiger auf die Daten welche mitgesendet werden sollen." Name="Loop.pDataSrc"/>
			DataLen 	: UDINT;			//! <Variable Comment="Length of the data to be sent in bytes.&#13;&#10;&#13;&#10;Länge der Daten in Bytes welche mitgesendet werden sollen." Name="Loop.DataLen"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: pointer &lt;pDataSrc&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Wert von &lt;pDataSrc&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="Loop.MessageID"/>
		END_VAR;
				//! <Function Comment="Loads a recipe file. The server values contained in the file are written to the controller.&#13;&#10;&#13;&#10;Lädt eine Rezeptdatei. Dabei werden die darin enthaltenen Server-Werte auf die Steuerung geschrieben." Name="RecipeLoad"/>
	FUNCTION GLOBAL RecipeLoad
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="RecipeLoad.pThis"/>
			pFilterIncl 	: ^DSComm::_DS_UnsLongLongInt;			//! <Variable Comment="Pointer to a bit mask as filter, which data points are to be loaded (0 = no filter, i.e. load all data points).&#13;&#10;&#13;&#10;Zeiger auf eine Bitmaske als Filter, welche Datenpunkte geladen werden sollen (0 = kein Filter, d.h. alle Datenpunkte laden)." Name="RecipeLoad.pFilterIncl"/>
			pFilterExcl 	: ^DSComm::_DS_UnsLongLongInt;			//! <Variable Comment="Pointer to a bit mask as filter, which data points should NOT be loaded (0 = no filter).&#13;&#10;&#13;&#10;Zeiger auf eine Bitmaske als Filter, welche Datenpunkte NICHT geladen werden sollen (0 = kein Filter)." Name="RecipeLoad.pFilterExcl"/>
			crc 	: UDINT;			//! <Variable Comment="If a file is to be loaded with the &quot;wrong&quot; CRC, &lt;crc&gt; must match the CRC stored in the file.&#13;&#10;&#13;&#10;Soll eine Datei mit &quot;falschem&quot; CRC geladen werden, muss &lt;crc&gt; mit dem in der Datei hinterlegtem CRC übereinstimmen." Name="RecipeLoad.crc"/>
			pDpne 	: ^CHAR;			//! <Variable Comment="Pointer to the drive path name extension of the file to be loaded (e.g. &quot;c:\recipes\recipe.txt&quot;).&#13;&#10;This is an UTF8-string.&#13;&#10;&#13;&#10;Zeiger auf die Drive-Path-Name-Extension der zu ladenden Datei (zB. &quot;c:\recipes\recipe.txt&quot;).&#13;&#10;Dies ist ein UTF8-String." Name="RecipeLoad.pDpne"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: the pointer &lt;pDpne&gt; or the pointer &lt;pFilterIncl&gt; or the ponter &lt;pFilterExcl&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Zeiger &lt;pDpne&gt; oder der Zeiger &lt;pFilterIncl&gt; oder der Zeiger &lt;pFilterExcl&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="RecipeLoad.MessageID"/>
		END_VAR;
				//! <Function Comment="Saves the values of all marked servers to a recipe file. &#13;&#10;&#13;&#10;Speichert die Werte aller markierten Server in eine Rezept-Datei. " Name="RecipeSave"/>
	FUNCTION GLOBAL RecipeSave
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="RecipeSave.pThis"/>
			pFilterIncl 	: ^DSComm::_DS_UnsLongLongInt;			//! <Variable Comment="Pointer to a bit mask as filter, which data points are to be saved (0 = no filter, i.e. save all data points).&#13;&#10;&#13;&#10;Zeiger auf eine Bitmaske als Filter, welche Datenpunkte gespeichert werden sollen (0 = kein Filter, d.h. alle Datenpunkte speichern)." Name="RecipeSave.pFilterIncl"/>
			pFilterExcl 	: ^DSComm::_DS_UnsLongLongInt;			//! <Variable Comment="Pointer to a bit mask as filter, which data points should NOT be saved (0 = no filter).&#13;&#10;&#13;&#10;Zeiger auf eine Bitmaske als Filter, welche Datenpunkte NICHT gespeichert werden sollen (0 = kein Filter)." Name="RecipeSave.pFilterExcl"/>
			pDpne 	: ^CHAR;			//! <Variable Comment="Pointer to the drive path name extension of the recipe file (e.g. &quot;c:\recipes\recipe.txt&quot;).&#13;&#10;This is an UTF8-String.&#13;&#10;&#13;&#10;Zeiger auf die Drive-Path-Name-Extension der Rezept-Speicher-Datei (zB. &quot;c:\recipes\recipe.txt&quot;).&#13;&#10;Dies ist ein UTF8-String." Name="RecipeSave.pDpne"/>
			pHeaderText 	: ^CHAR;			//! <Variable Comment="Pointer to an ASCII-string to be inserted at the beginning of the recipe file.&#13;&#10;&#13;&#10;Zeiger auf einen ASCII-String welcher am Beginn der Rezeptdatei eingefügt werden soll." Name="RecipeSave.pHeaderText"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: the pointer &lt;pDpne&gt; or the pointer &lt;pHeaderText&gt; or the pointer &lt;pFilterIncl&gt; or the ponter &lt;pFilterExcl&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Zeiger &lt;pDpne&gt; oder der Zeiger &lt;pHeaderText&gt; oder der Zeiger &lt;pFilterIncl&gt; oder der Zeiger &lt;pFilterExcl&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="RecipeSave.MessageID"/>
		END_VAR;
				//! <Function Comment="Distributes the sent data to all connected clients (except itself). &#13;&#10;The sender receives a response and all other clients receive the message as push notification.&#13;&#10;&#13;&#10;Verteilt die mitgeschickten Daten an alle verbundenen Clients (außer an sich selbst). &#13;&#10;Der Sender bekommt eine Response und alle anderen Clients erhalten die Nachricht als Push Notification." Name="SendToAll"/>
	FUNCTION GLOBAL SendToAll
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="SendToAll.pThis"/>
			pDataSrc 	: ^void;			//! <Variable Comment="Pointer to the data to be sent to the other clients.&#13;&#10;&#13;&#10;Zeiger auf die Daten welche an die anderen Clients geschickt werden sollen." Name="SendToAll.pDataSrc"/>
			DataLen 	: UDINT;			//! <Variable Comment="Length of the data in bytes to be sent to the other clients.&#13;&#10;&#13;&#10;Länge der Daten in Bytes welche an die anderen Clients geschickt werden sollen." Name="SendToAll.DataLen"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: the pointer &lt;pDataSrc&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Wert von &lt;pDataSrc&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="SendToAll.MessageID"/>
		END_VAR;
				//! <Function Comment="Sets the data service to reset mode.&#13;&#10;&#13;&#10;Setzt den Dataservice in den Reset Modus." Name="ResetDataservice"/>
	FUNCTION GLOBAL ResetDataservice
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="ResetDataservice.pThis"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="ResetDataservice.MessageID"/>
		END_VAR;
				//! <Function Comment="Resets the data service to the running state.&#13;&#10;&#13;&#10;Setzt den Dataservice zurück in den Running State." Name="RestartDataservice"/>
	FUNCTION GLOBAL RestartDataservice
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="RestartDataservice.pThis"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="RestartDataservice.MessageID"/>
		END_VAR;
				//! <Function Comment="Adds an additional local client.&#13;&#10;&#13;&#10;Fügt einen zusätzlichen Local Client hinzu." Name="AddLocalClient"/>
	FUNCTION GLOBAL AddLocalClient
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="AddLocalClient.pThis"/>
			pLocalClient 	: ^DSComm::_DS_AddLocalClientCmd;			//! <Variable Comment="Pointer to the data of the local client.&#13;&#10;&#13;&#10;Zeiger auf die Daten des Local Client." Name="AddLocalClient.pLocalClient"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: the pointer &lt;pLocalClient&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Zeiger &lt;pLocalClient&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="AddLocalClient.MessageID"/>
		END_VAR;
				//! <Function Comment="Adds a range of additional local clients.&#13;&#10;&#13;&#10;Fügt eine Reihe von lokalen Clients hinzu." Name="AddLocalClientRange"/>
	FUNCTION GLOBAL AddLocalClientRange
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="AddLocalClientRange.pThis"/>
			pLocalClientRange 	: ^DSComm::_DS_AddLocalClientRangeCmd;			//! <Variable Comment="Pointer to the data of the local clients.&#13;&#10;&#13;&#10;Zeiger auf die Daten der Local Clients." Name="AddLocalClientRange.pLocalClientRange"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: the pointer &lt;pLocalClientRange&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Zeiger &lt;pLocalClientRange&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="AddLocalClientRange.MessageID"/>
		END_VAR;
				//! <Function Comment="Removes the current local client from the list.&#13;&#10;&#13;&#10;Entfernt den aktuellen Local Client aus der Liste." Name="RemoveThisLocalClient"/>
	FUNCTION GLOBAL RemoveThisLocalClient
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="RemoveThisLocalClient.pThis"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="RemoveThisLocalClient.MessageID"/>
		END_VAR;
				//! <Function Comment="Removes the specified local client from the list.&#13;&#10;&#13;&#10;Entfernt den angegebenen Local Client aus der Liste." Name="RemoveLocalClient"/>
	FUNCTION GLOBAL RemoveLocalClient
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="RemoveLocalClient.pThis"/>
			pLocalClient 	: ^DSComm::_DS_RemoveLocalClientCmd;			//! <Variable Comment="Pointer to the data of the local client.&#13;&#10;&#13;&#10;Zeiger auf die Daten des Local Client." Name="RemoveLocalClient.pLocalClient"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: the pointer &lt;pLocalClient&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Zeiger &lt;pLocalClient&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="RemoveLocalClient.MessageID"/>
		END_VAR;
				//! <Function Comment="Removes a range of local clients from the list.&#13;&#10;&#13;&#10;Entfernt eine Reihe von lokalen Clients aus der Liste." Name="RemoveLocalClientRange"/>
	FUNCTION GLOBAL RemoveLocalClientRange
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="RemoveLocalClientRange.pThis"/>
			pLocalClientRange 	: ^DSComm::_DS_RemoveLocalClientRangeCmd;			//! <Variable Comment="Pointer to the data of the local clients.&#13;&#10;&#13;&#10;Zeiger auf die Daten der Local Clients." Name="RemoveLocalClientRange.pLocalClientRange"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: the pointer &lt;pLocalClientRange&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Zeiger &lt;pLocalClientRange&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="RemoveLocalClientRange.MessageID"/>
		END_VAR;
				//! <Function Comment="Deletes the entire Local Client list.&#13;&#10;&#13;&#10;Löscht die gesamte Local Client Liste." Name="ClearLocalClientList"/>
	FUNCTION GLOBAL ClearLocalClientList
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="ClearLocalClientList.pThis"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="ClearLocalClientList.MessageID"/>
		END_VAR;
				//! <Function Comment="Returns the ID of the currently connected session.&#13;&#10;&#13;&#10;Gibt die ID der gerade verbundenen Session zurück." Name="GetCurrentID"/>
	FUNCTION GLOBAL GetCurrentID
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="GetCurrentID.pThis"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="GetCurrentID.MessageID"/>
		END_VAR;
				//! <Function Comment="Returns the entire Local Client list.&#13;&#10;&#13;&#10;Gibt die gesamte Client Liste zurück." Name="GetLocalClientList"/>
	FUNCTION GLOBAL GetLocalClientList
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="GetLocalClientList.pThis"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="GetLocalClientList.MessageID"/>
		END_VAR;
				//! <Function Comment="Returns the entire client list in detail.&#13;&#10;&#13;&#10;Gibt die Details der gesamten Client Liste zurück." Name="GetLocalClientListDetails"/>
	FUNCTION GLOBAL GetLocalClientListDetails
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="GetLocalClientListDetails.pThis"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="GetLocalClientListDetails.MessageID"/>
		END_VAR;
				//! <Function Comment="Returns details of the client with the specified ID.&#13;&#10;&#13;&#10;Gibt Details des Clients mit der angegebenen ID zurück." Name="GetLocalClientByID"/>
	FUNCTION GLOBAL GetLocalClientByID
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="GetLocalClientByID.pThis"/>
			pLocalClient 	: ^DSComm::_DS_GetLocalClientByIDCmd;			//! <Variable Comment="Pointer to the data of the local client.&#13;&#10;&#13;&#10;Zeiger auf die Daten des Local Client." Name="GetLocalClientByID.pLocalClient"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: the pointer &lt;pLocalClient&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Zeiger &lt;pLocalClient&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="GetLocalClientByID.MessageID"/>
		END_VAR;
				//! <Function Comment="Logs on a user.&#13;&#10;&#13;&#10;Meldet einen Benutzer an." Name="UserLogin"/>
	FUNCTION GLOBAL UserLogin
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="UserLogin.pThis"/>
			pUserName 	: ^UINT;			//! <Variable Comment="Pointer to the user name of the user to be logged on.&#13;&#10;&#13;&#10;Zeiger auf den Benutzernamen des anzumeldenden Benutzers." Name="UserLogin.pUserName"/>
			pPassword 	: ^UINT;			//! <Variable Comment="Pointer to the password in plain text.&#13;&#10;&#13;&#10;Zeiger auf das Passwort im Klartext." Name="UserLogin.pPassword"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: the pointer &lt;pUserName&gt; or the pointer &lt;pPassword&gt; is invalid.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Wert von &lt;pUserName&gt; oder &lt;pPassword&gt; ist ungültig." Name="UserLogin.MessageID"/>
		END_VAR;
	
	FUNCTION GetRespData_RecipeLoad
		VAR_INPUT
			pRecipeLoadRspInt 	: ^_DS_RecipeLoadRespInt;
			pRecipeLoadRsp 	: ^DSComm::_DS_RecipeLoadResp;
		END_VAR;
	
	FUNCTION GetRespData_RecipeSave
		VAR_INPUT
			pRecipeSaveRspInt 	: ^_DS_RecipeSaveRespInt;
			pRecipeSaveRsp 	: ^DSComm::_DS_RecipeSaveResp;
		END_VAR;
	
	FUNCTION GetRespData_UserLogin
		VAR_INPUT
			pData 	: ^CHAR;
			pUserLoginData 	: ^DSComm::_DS_UserLoginResp;
		END_VAR;
				//! <Function Comment="Logs off the currently logged in user.&#13;&#10;&#13;&#10;Meldet den aktuell eingeloggten Benutzer ab." Name="UserLogout"/>
	FUNCTION GLOBAL UserLogout
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="UserLogout.pThis"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="UserLogout.MessageID"/>
		END_VAR;
				//! <Function Comment="Changes the password of the currently logged in user.&#13;&#10;&#13;&#10;Ändert das Passwort des aktuell eingeloggten Benutzers." Name="UserPasswordChange"/>
	FUNCTION GLOBAL UserPasswordChange
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="UserPasswordChange.pThis"/>
			pOldPassword 	: ^UINT;			//! <Variable Comment="Pointer to the old password of the user.&#13;&#10;&#13;&#10;Zeiger auf das alte Passwort des Benutzers." Name="UserPasswordChange.pOldPassword"/>
			pNewPassword 	: ^UINT;			//! <Variable Comment="Pointer to the new password of the user.&#13;&#10;&#13;&#10;Zeiger auf das neue Passwort des Benutzers." Name="UserPasswordChange.pNewPassword"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: the pointer &lt;pOldPassword&gt; or the pointer &lt;pNewPassword&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Wert von &lt;pOldPassword&gt; oder &lt;pNewPassword&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="UserPasswordChange.MessageID"/>
		END_VAR;
				//! <Function Comment="Checks whether the given users are allowed to write and read the given access level.&#13;&#10;&#13;&#10;Prüft ob die übergebenen Benutzer den übergebenen AccessLevel schreiben und lesen dürfen." Name="CheckAccessLevel"/>
	FUNCTION GLOBAL CheckAccessLevel
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="CheckAccessLevel.pThis"/>
			num 	: UDINT;			//! <Variable Comment="The number of passed entries.&#13;&#10;&#13;&#10;Anzahl der übergebenen Einträge." Name="CheckAccessLevel.num"/>
			pCheckAccessLevel 	: ^DSComm::_DS_CheckAccessLevelCmd;			//! <Variable Comment="Pointer to an array with &lt;num&gt; users to check.&#13;&#10;&#13;&#10;Zeiger auf ein Array mit &lt;num&gt; zu prüfenden Benutzern." Name="CheckAccessLevel.pCheckAccessLevel"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: the pointer &lt;pCheckAccessLevel&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Wert von &lt;pCheckAccessLevel&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="CheckAccessLevel.MessageID"/>
		END_VAR;
				//! <Function Comment="Creates a new user in the system.&#13;&#10;&#13;&#10;Legt einen neuen Benutzer im System an." Name="CreateUser"/>
	FUNCTION GLOBAL CreateUser
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="CreateUser.pThis"/>
			num 	: UDINT;			//! <Variable Comment="The number of passed entries.&#13;&#10;&#13;&#10;Anzahl der übergebenen Einträge." Name="CreateUser.num"/>
			pCreateUser 	: ^DSComm::_DS_CreateUserCmd;			//! <Variable Comment="Pointer to an array with &lt;num&gt; users to be created.&#13;&#10;&#13;&#10;Zeiger auf ein Array mit &lt;num&gt; anzulegenden Benutzern." Name="CreateUser.pCreateUser"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: &lt;num&gt; is zero or the pointer &lt;pCreateUser&gt; is invalid or&#13;&#10;  a pointer in the structure _DS_CreateUserCmd is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: &lt;num&gt; ist null oder der Zeiger &lt;pCreateUser&gt; ist ungültig oder&#13;&#10;  ein Zeiger in der Struktur _DS_CreateUserCmd ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="CreateUser.MessageID"/>
		END_VAR;
				//! <Function Comment="Changes the data of existing users. &#13;&#10;Note: only users created with CreateUser() can be changed.&#13;&#10;&#13;&#10;Ändert die Daten von bereits bestehenden Benutzern. &#13;&#10;Hinweis: es können nur jene Benutzer geändert werden, welche mit CreateUser() angelegt wurden." Name="ChangeUserSettings"/>
	FUNCTION GLOBAL ChangeUserSettings
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="ChangeUserSettings.pThis"/>
			num 	: UDINT;			//! <Variable Comment="The number of passed entries.&#13;&#10;&#13;&#10;Anzahl der übergebenen Einträge." Name="ChangeUserSettings.num"/>
			pChangeUsrSettings 	: ^DSComm::_DS_ChangeUserSettingsCmd;			//! <Variable Comment="Pointer to an array with &lt;num&gt; users to be modified.&#13;&#10;&#13;&#10;Zeiger auf ein Array mit &lt;num&gt; zu ändernden Benutzern." Name="ChangeUserSettings.pChangeUsrSettings"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: &lt;num&gt; is zero or the pointer &lt;pChangeUsrSettings&gt; is invalid or&#13;&#10;  a pointer in the structure _DS_ChangeUserSettingsCmd is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: &lt;num&gt; ist null oder der Zeiger &lt;pChangeUsrSettings&gt; ist ungültig oder&#13;&#10;  ein Zeiger in der Struktur _DS_ChangeUserSettingsCmd ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="ChangeUserSettings.MessageID"/>
		END_VAR;
				//! <Function Comment="Deletes the given users from the system. &#13;&#10;Note: only users created with CreateUser() can be deleted.&#13;&#10;&#13;&#10;Löscht die übergebenen Benutzer aus dem System. &#13;&#10;Hinweis: es können nur jene Benutzer gelöscht werden, welche mit CreateUser() angelegt wurden." Name="DeleteUser"/>
	FUNCTION GLOBAL DeleteUser
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="DeleteUser.pThis"/>
			num 	: UDINT;			//! <Variable Comment="The number of passed entries.&#13;&#10;&#13;&#10;Anzahl der übergebenen Einträge." Name="DeleteUser.num"/>
			pUserID 	: ^UDINT;			//! <Variable Comment="Pointer to an array with &lt;num&gt; users to be deleted.&#13;&#10;&#13;&#10;Zeiger auf ein Array mit &lt;num&gt; Benutzer-IDs die gelöscht werden sollen." Name="DeleteUser.pUserID"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;  ERR_WRONG_PARAMETER: &lt;num&gt; is zero or the pointer &lt;pUserID&gt; is invalid.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Wert von &lt;num&gt; ist null oder der Zeiger &lt;pUserID&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="DeleteUser.MessageID"/>
		END_VAR;
				//! <Function Comment="Query the entire user list. All known user IDs are returned with the corresponding user names.&#13;&#10;&#13;&#10;Abfrage der gesamten Benutzerliste. Es werden alle bekannten BenutzerIDs mit den zugehörigen Benutzernamen zurückgeliefert." Name="GetUserList"/>
	FUNCTION GLOBAL GetUserList
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="GetUserList.pThis"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="GetUserList.MessageID"/>
		END_VAR;
				//! <Function Comment="Returns all data for a specific user.&#13;&#10;&#13;&#10;Liefert alle Daten zu einem bestimmten Benutzer." Name="GetUserDetails"/>
	FUNCTION GLOBAL GetUserDetails
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="GetUserDetails.pThis"/>
			userID 	: UDINT;			//! <Variable Comment="The ID of the user for whom details are to be queried.&#13;&#10;&#13;&#10;Die ID des Benutzers zu dem Details abgefragt werden sollen." Name="GetUserDetails.userID"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="GetUserDetails.MessageID"/>
		END_VAR;
				//! <Function Comment="Creates a new role in the system.&#13;&#10;&#13;&#10;Legt eine neue Rolle im System an." Name="CreateRole"/>
	FUNCTION GLOBAL CreateRole
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="CreateRole.pThis"/>
			num 	: UDINT;			//! <Variable Comment="The number of passed entries.&#13;&#10;&#13;&#10;Anzahl der übergebenen Einträge." Name="CreateRole.num"/>
			pCreateRolePara 	: ^DSComm::_DS_CreateRoleCmd;			//! <Variable Comment="Pointer to an array with &lt;num&gt; roles to be created.&#13;&#10;&#13;&#10;Zeiger auf ein Array mit &lt;num&gt; anzulegenden Rollen." Name="CreateRole.pCreateRolePara"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: &lt;num&gt; is zero or the pointer &lt;pCreateRolePara&gt; is invalid or&#13;&#10;  a pointer in the structure _DS_CreateRoleCmd is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Wert von &lt;num&gt; ist null oder der Zeiger &lt;pCreateRolePara&gt; ist ungültig oder&#13;&#10;  ein Zeiger in der Struktur _DS_CreateRoleCmd ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="CreateRole.MessageID"/>
		END_VAR;
				//! <Function Comment="Modifies an existing role.&#13;&#10;&#13;&#10;Ändert eine bereits bestehende Rolle ab." Name="ChangeRole"/>
	FUNCTION GLOBAL ChangeRole
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="ChangeRole.pThis"/>
			num 	: UDINT;			//! <Variable Comment="The number of passed entries.&#13;&#10;&#13;&#10;Anzahl der übergebenen Einträge." Name="ChangeRole.num"/>
			pChangeRole 	: ^DSComm::_DS_ChangeRoleCmd;			//! <Variable Comment="Pointer to an array with &lt;num&gt; roles to be modified.&#13;&#10;&#13;&#10;Zeiger auf ein Array mit &lt;num&gt; zu ändernden Rollen." Name="ChangeRole.pChangeRole"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: &lt;num&gt; is zero or the pointer &lt;pChangeRole&gt; is invalid or&#13;&#10;  a pointer in the structure _DS_ChangeRoleCmd is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Wert von &lt;num&gt; ist null oder der Zeiger &lt;pChangeRole&gt; ist ungültig oder&#13;&#10;  ein Zeiger in der Struktur _DS_ChangeRoleCmd ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="ChangeRole.MessageID"/>
		END_VAR;
				//! <Function Comment="Deletes the given roles from the system.&#13;&#10;&#13;&#10;Löscht die übergebenen Rollen aus dem System." Name="DeleteRole"/>
	FUNCTION GLOBAL DeleteRole
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="DeleteRole.pThis"/>
			num 	: UDINT;			//! <Variable Comment="The number of passed entries.&#13;&#10;&#13;&#10;Anzahl der übergebenen Einträge." Name="DeleteRole.num"/>
			pRoleID 	: ^UDINT;			//! <Variable Comment="Pointer to an array with &lt;num&gt; roles to be deleted.&#13;&#10;&#13;&#10;Zeiger auf ein Array mit &lt;num&gt; RollenIDs die gelöscht werden sollen." Name="DeleteRole.pRoleID"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: &lt;num&gt; is zero or the pointer &lt;pRoleID&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Wert von &lt;num&gt; ist null oder der Zeiger &lt;pRoleID&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="DeleteRole.MessageID"/>
		END_VAR;
				//! <Function Comment="Query the entire role list. &#13;&#10;All role IDs are returned with the corresponding role names.&#13;&#10;&#13;&#10;Abfrage der gesamten Rollenliste. &#13;&#10;Es werden alle RollenIDs mit den dazugehörigen Rollennamen zurückgeliefert." Name="GetRoleList"/>
	FUNCTION GLOBAL GetRoleList
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="GetRoleList.pThis"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="GetRoleList.MessageID"/>
		END_VAR;
				//! <Function Comment="Returns all data belonging to the role.&#13;&#10;&#13;&#10;Liefert alle zu der Rolle gehörigen Daten zurück." Name="GetRoleDetails"/>
	FUNCTION GLOBAL GetRoleDetails
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="GetRoleDetails.pThis"/>
			roleID 	: UDINT;			//! <Variable Comment="The ID of the role for which details are to be queried.&#13;&#10;&#13;&#10;Die ID der Rolle zu der Details abgefragt werden sollen." Name="GetRoleDetails.roleID"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="GetRoleDetails.MessageID"/>
		END_VAR;
				//! <Function Comment="Determines the variable IDs from the datapoint names.&#13;&#10;&#13;&#10;Ermittelt die Variablen-Id aus den Datenpunkt-Namen." Name="GetVarIdFromName"/>
	FUNCTION GLOBAL GetVarIdFromName
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="GetVarIdFromName.pThis"/>
			num 	: UDINT;			//! <Variable Comment="The number of passed entries.&#13;&#10;&#13;&#10;Anzahl der übergebenen Einträge." Name="GetVarIdFromName.num"/>
			ppName 	: ^pChar;			//! <Variable Comment="Pointer to an array with &lt;num&gt; pointers to the names of the data points.&#13;&#10;The names are in the form &lt;StationNo&gt;:&lt;Objectname&gt;.&lt;Servername&gt;.&#13;&#10;&#13;&#10;Zeiger auf ein Array mit &lt;num&gt; Zeigern auf die Namen der Datenpunkte.&#13;&#10;Die Namen haben die Form &lt;Stationsnr&gt;:&lt;Objektname&gt;.&lt;Servername&gt;" Name="GetVarIdFromName.ppName"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: &lt;num&gt; is zero or the pointer &lt;ppName&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Wert von &lt;num&gt; ist null oder der Zeiger &lt;ppName&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="GetVarIdFromName.MessageID"/>
		END_VAR;
				//! <Function Comment="Determines the variable Ids from the Lasal Ids.&#13;&#10;&#13;&#10;Ermittelt die Variablen Id aus der Lasal Id." Name="GetVarIdFromLasalId"/>
	FUNCTION GLOBAL GetVarIdFromLasalId
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="GetVarIdFromLasalId.pThis"/>
			num 	: UDINT;			//! <Variable Comment="The number of passed entries.&#13;&#10;&#13;&#10;Anzahl der übergebenen Einträge." Name="GetVarIdFromLasalId.num"/>
			pLasalId 	: ^DSComm::_DS_GetVarIdFromLasalIdCmd;			//! <Variable Comment="Pointer to an array with &lt;num&gt; Lasal-ID descriptions of the data points.&#13;&#10;&#13;&#10;Zeiger auf ein Array mit &lt;num&gt; Lasal-ID-Beschreibungen der Datenpunkte." Name="GetVarIdFromLasalId.pLasalId"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: &lt;num&gt; is zero or the pointer &lt;pLasalId&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Wert von &lt;num&gt; ist null oder der Zeiger &lt;pLasalId&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="GetVarIdFromLasalId.MessageID"/>
		END_VAR;
				//! <Function Comment="Determines the Lasal Ids from the names.&#13;&#10;&#13;&#10;Ermitteln der Lasal Ids aus den Namen." Name="GetLasalIdFromName"/>
	FUNCTION GLOBAL GetLasalIdFromName
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="GetLasalIdFromName.pThis"/>
			num 	: UDINT;			//! <Variable Comment="The number of passed entries.&#13;&#10;&#13;&#10;Anzahl der übergebenen Einträge." Name="GetLasalIdFromName.num"/>
			ppName 	: ^pChar;			//! <Variable Comment="Pointer to an array with &lt;num&gt; pointers to the names of the data points.&#13;&#10;The names are in the form &lt;StationNo&gt;:&lt;Objectname&gt;.&lt;Servername&gt;.&#13;&#10;&#13;&#10;Zeiger auf ein Array mit &lt;num&gt; Zeigern auf die Namen der Datenpunkte.&#13;&#10;Die Namen haben die Form &lt;Stationsnr&gt;:&lt;Objektname&gt;.&lt;Servername&gt;" Name="GetLasalIdFromName.ppName"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: &lt;num&gt; is zero or the pointer &lt;ppName&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Wert von &lt;num&gt; ist null oder der Zeiger &lt;ppName&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="GetLasalIdFromName.MessageID"/>
		END_VAR;
				//! <Function Comment="Determines the Lasal Ids from the variable Ids.&#13;&#10;&#13;&#10;Ermittelt die Lasal Ids aus den Variablen Ids." Name="GetLasalIdFromVarId"/>
	FUNCTION GLOBAL GetLasalIdFromVarId
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="GetLasalIdFromVarId.pThis"/>
			num 	: UDINT;			//! <Variable Comment="The number of passed entries.&#13;&#10;&#13;&#10;Anzahl der übergebenen Einträge." Name="GetLasalIdFromVarId.num"/>
			pVarId 	: ^UDINT;			//! <Variable Comment="Pointer to an array with &lt;num&gt; variable numbers of the data points.&#13;&#10;&#13;&#10;Zeiger auf ein Array mit &lt;num&gt; Variablen-Nummern der Datenpunkte." Name="GetLasalIdFromVarId.pVarId"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: &lt;num&gt; is zero or the pointer &lt;pVarId&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Wert von &lt;num&gt; ist null oder der Zeiger &lt;pVarId&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="GetLasalIdFromVarId.MessageID"/>
		END_VAR;
				//! <Function Comment="Determines the variable names from the variable IDs.&#13;&#10;&#13;&#10;Ermittelt die Variablen Namen aus den Variablen Ids." Name="GetNameFromVarId"/>
	FUNCTION GLOBAL GetNameFromVarId
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="GetNameFromVarId.pThis"/>
			num 	: UDINT;			//! <Variable Comment="The number of passed entries.&#13;&#10;&#13;&#10;Anzahl der übergebenen Einträge." Name="GetNameFromVarId.num"/>
			pVarId 	: ^UDINT;			//! <Variable Comment="Pointer to an array with &lt;num&gt; variable numbers of the data points.&#13;&#10;&#13;&#10;Zeiger auf ein Array mit &lt;num&gt; Variablen-Nummern der Datenpunkte." Name="GetNameFromVarId.pVarId"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: &lt;num&gt; is zero or the pointer &lt;pVarId&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Wert von &lt;num&gt; ist null oder der Zeiger &lt;pVarId&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="GetNameFromVarId.MessageID"/>
		END_VAR;
				//! <Function Comment="Determines the variable names from the Lasal Ids.&#13;&#10;&#13;&#10;Ermittelt die Variablen Namen aus den Lasal Ids." Name="GetNameFromLasalId"/>
	FUNCTION GLOBAL GetNameFromLasalId
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="GetNameFromLasalId.pThis"/>
			num 	: UDINT;			//! <Variable Comment="The number of passed entries.&#13;&#10;&#13;&#10;Anzahl der übergebenen Einträge." Name="GetNameFromLasalId.num"/>
			pLasalId 	: ^DSComm::_DS_GetNameFromLasalIdCmd;			//! <Variable Comment="Pointer to an array with &lt;num&gt; Lasal-ID descriptions of the data points.&#13;&#10;&#13;&#10;Zeiger auf ein Array mit &lt;num&gt; Lasal-ID-Beschreibungen der Datenpunkte." Name="GetNameFromLasalId.pLasalId"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: &lt;num&gt; is zero or the pointer &lt;pLasalId&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Wert von &lt;num&gt; ist null oder der Zeiger &lt;pLasalId&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="GetNameFromLasalId.MessageID"/>
		END_VAR;
				//! <Function Comment="Returns the list of all data points.&#13;&#10;&#13;&#10;Liefert die Liste aller Datenpunkte." Name="GetDpList"/>
	FUNCTION GLOBAL GetDpList
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="GetDpList.pThis"/>
			pFilterIncl 	: ^DSComm::_DS_UnsLongLongInt;			//! <Variable Comment="Pointer to the include filter. Zero = include all data points.&#13;&#10;&#13;&#10;Zeiger auf den Include Filter. Null = alle Datenpunkte einschließen." Name="GetDpList.pFilterIncl"/>
			pFilterExcl 	: ^DSComm::_DS_UnsLongLongInt;			//! <Variable Comment="Pointer to the exclude filter. Zero = do not exclude any data points.&#13;&#10;&#13;&#10;Zeiger auf den Exclude Filter. Null = keine Datenpunkte ausschließen." Name="GetDpList.pFilterExcl"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: the pointer &lt;pFilterIncl&gt; or the pointer &lt;pFilterExcl&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Zeiger &lt;pFilterIncl&gt; oder der Zeiger &lt;pFilterExcl&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="GetDpList.MessageID"/>
		END_VAR;
				//! <Function Comment="Returns all information about a specific data point.&#13;&#10;&#13;&#10;Liefert alle Informationen zu einem bestimmten Datenpunkt." Name="GetDpInfo"/>
	FUNCTION GLOBAL GetDpInfo
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="GetDpInfo.pThis"/>
			num 	: UDINT;			//! <Variable Comment="The number of passed entries.&#13;&#10;&#13;&#10;Anzahl der übergebenen Einträge." Name="GetDpInfo.num"/>
			pVarId 	: ^UDINT;			//! <Variable Comment="Pointer to an array with &lt;num&gt; variable numbers of the data points.&#13;&#10;&#13;&#10;Zeiger auf ein Array mit &lt;num&gt; Variablen-Nummern der Datenpunkte." Name="GetDpInfo.pVarId"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: &lt;num&gt; is zero or the pointer &lt;pVarId&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Wert von &lt;num&gt; ist null oder der Zeiger &lt;pVarId&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="GetDpInfo.MessageID"/>
		END_VAR;
				//! <Function Comment="Determines the variable IDs using the CRC values.&#13;&#10;&#13;&#10;Ermittelt die Variablen Ids anhand des CRC-Werte." Name="GetVarIdFromCRC"/>
	FUNCTION GLOBAL GetVarIdFromCRC
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="GetVarIdFromCRC.pThis"/>
			num 	: UDINT;			//! <Variable Comment="The number of passed entries.&#13;&#10;&#13;&#10;Anzahl der übergebenen Einträge." Name="GetVarIdFromCRC.num"/>
			pCRC 	: ^UDINT;			//! <Variable Comment="Pointer to an array with &lt;num&gt; CRCs of the data points.&#13;&#10;&#13;&#10;Zeiger auf ein Array mit &lt;num&gt; CRCs der Datenpunkte." Name="GetVarIdFromCRC.pCRC"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: &lt;num&gt; is zero or the pointer &lt;pCRC&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Wert von &lt;num&gt; ist null oder der Zeiger &lt;pCRC&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="GetVarIdFromCRC.MessageID"/>
		END_VAR;
				//! <Function Comment="Determines the CRC values using the variable IDs.&#13;&#10;&#13;&#10;Ermittelt die CRC-Werte anhand der Variablen Ids." Name="GetCRCfromVarId"/>
	FUNCTION GLOBAL GetCRCfromVarId
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="GetCRCfromVarId.pThis"/>
			num 	: UDINT;			//! <Variable Comment="The number of passed entries.&#13;&#10;&#13;&#10;Anzahl der übergebenen Einträge." Name="GetCRCfromVarId.num"/>
			pVarId 	: ^UDINT;			//! <Variable Comment="Pointer to an array with &lt;num&gt; variable numbers of the data points.&#13;&#10;&#13;&#10;Zeiger auf ein Array mit &lt;num&gt; Variablen-Nummern der Datenpunkte." Name="GetCRCfromVarId.pVarId"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: &lt;num&gt; is zero or the pointer &lt;pVarId&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Wert von &lt;num&gt; ist null oder der Zeiger &lt;pVarId&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="GetCRCfromVarId.MessageID"/>
		END_VAR;
				//! <Function Comment="Queries the values of numeric data points.&#13;&#10;&#13;&#10;Fragt die Werte von numerischen Datenpunkten ab." Name="GetValue"/>
	FUNCTION GLOBAL GetValue
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="GetValue.pThis"/>
			num 	: UDINT;			//! <Variable Comment="The number of passed entries.&#13;&#10;&#13;&#10;Anzahl der übergebenen Einträge." Name="GetValue.num"/>
			pGetValue 	: ^DSComm::_DS_GetValueCmd;			//! <Variable Comment="Pointer to an array with &lt;num&gt; descriptions of the numeric data points.&#13;&#10;&#13;&#10;Zeiger auf ein Array mit &lt;num&gt; Beschreibungen der numerischen Datenpunkte." Name="GetValue.pGetValue"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: &lt;num&gt; is zero or the pointer &lt;pGetValue&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Wert von &lt;num&gt; ist null oder der Zeiger &lt;pGetValue&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="GetValue.MessageID"/>
		END_VAR;
				//! <Function Comment="Queries the values of string data points.&#13;&#10;&#13;&#10;Fragt die Werte von String-Datenpunkten ab." Name="GetString"/>
	FUNCTION GLOBAL GetString
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="GetString.pThis"/>
			num 	: UDINT;			//! <Variable Comment="The number of passed entries.&#13;&#10;&#13;&#10;Anzahl der übergebenen Einträge." Name="GetString.num"/>
			pGetString 	: ^DSComm::_DS_GetStringCmd;			//! <Variable Comment="Pointer to an array with &lt;num&gt; descriptions of the string data points.&#13;&#10;&#13;&#10;Zeiger auf ein Array mit &lt;num&gt; Beschreibungen der String-Datenpunkte." Name="GetString.pGetString"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: &lt;num&gt; is zero or the pointer &lt;pGetString&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Wert von &lt;num&gt; ist null oder der Zeiger &lt;pGetString&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="GetString.MessageID"/>
		END_VAR;
				//! <Function Comment="Sets the values of numeric data points.&#13;&#10;&#13;&#10;Setzt die Werte von numerischen Datenpunkten." Name="SetValue"/>
	FUNCTION GLOBAL SetValue
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="SetValue.pThis"/>
			num 	: UDINT;			//! <Variable Comment="The number of passed entries.&#13;&#10;&#13;&#10;Anzahl der übergebenen Einträge." Name="SetValue.num"/>
			pSetValue 	: ^DSComm::_DS_SetValueCmd;			//! <Variable Comment="Pointer to an array with &lt;num&gt; numeric data points to be written.&#13;&#10;&#13;&#10;Zeiger auf ein Array mit &lt;num&gt; zu schreibenden numerischen Datenpunkten." Name="SetValue.pSetValue"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: &lt;num&gt; is zero or the pointer &lt;pSetValue&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Wert von &lt;num&gt; ist null oder der Zeiger &lt;pSetValue&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="SetValue.MessageID"/>
		END_VAR;
				//! <Function Comment="Sets the values of string data points.&#13;&#10;&#13;&#10;Setzt die Werte von String-Datenpunkten." Name="SetString"/>
	FUNCTION GLOBAL SetString
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="SetString.pThis"/>
			num 	: UDINT;			//! <Variable Comment="The number of passed entries.&#13;&#10;&#13;&#10;Anzahl der übergebenen Einträge." Name="SetString.num"/>
			pSetString 	: ^DSComm::_DS_SetStringCmd;			//! <Variable Comment="Pointer to an array with &lt;num&gt; string data points to be written.&#13;&#10;&#13;&#10;Zeiger auf ein Array mit &lt;num&gt; zu schreibenden String-Datenpunkten." Name="SetString.pSetString"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: &lt;num&gt; is zero or the pointer &lt;pSetString&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Wert von &lt;num&gt; ist null oder der Zeiger &lt;pSetString&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="SetString.MessageID"/>
		END_VAR;
	
	FUNCTION GetRespData_GetString
		VAR_INPUT
			pData 	: ^CHAR;			//! <Variable Comment="Ptr to data source." Name="GetRespData_GetString.pData"/>
			pGetStringRsp 	: ^DSComm::_DS_GetStringResp;			//! <Variable Comment="Ptr to destination array." Name="GetRespData_GetString.pGetStringRsp"/>
			num 	: UDINT;			//! <Variable Comment="Number of elements in destination array." Name="GetRespData_GetString.num"/>
		END_VAR;
	
	FUNCTION GetRespData_SetString
		VAR_INPUT
			pData 	: ^CHAR;
			pSetStringRsp 	: ^DSComm::_DS_SetStringResp;
			num 	: UDINT;
		END_VAR;
				//! <Function Comment="Copy uni-0-string from &lt;src&gt; to &lt;dst&gt;. &#13;&#10;Function returns a pointer behind the binary-0 of the destination string." Name="_StrCpy16"/>
	FUNCTION _StrCpy16
		VAR_INPUT
			dst 	: ^UINT;
			src 	: ^UINT;
			pLen 	: ^UDINT;			//! <Variable Comment="If &lt;pLen&gt; is not nil, the string length in bytes (without binary-0) is returned here." Name="_StrCpy16.pLen"/>
		END_VAR
		VAR_OUTPUT
			Next 	: ^UINT;			//! <Variable Comment="Points behind the binary-0 of the destination string." Name="_StrCpy16.Next"/>
		END_VAR;
	
	FUNCTION GetRespData_GetUserList
		VAR_INPUT
			pData 	: ^CHAR;
			pGetUserListRsp 	: ^DSComm::_DS_GetUserListResp;
			num 	: UDINT;
		END_VAR;
	
	FUNCTION GetRespData_GetRoleList
		VAR_INPUT
			pData 	: ^CHAR;
			pGetRoleListRsp 	: ^DSComm::_DS_GetRoleListResp;
			num 	: UDINT;
		END_VAR;
	
	FUNCTION GetRespData_GetRoleDetails
		VAR_INPUT
			pData 	: ^CHAR;
			pGetRoleDetailsRsp 	: ^DSComm::_DS_GetRoleDetailsResp;
		END_VAR;
	
	FUNCTION GetRespData_GetVarIdFromName
		VAR_INPUT
			pData 	: ^CHAR;
			pGetVarIdFromNameRsp 	: ^DSComm::_DS_GetVarIdFromNameResp;
			num 	: UDINT;
		END_VAR;
	
	FUNCTION GetRespData_GetVarIdFromLasalId
		VAR_INPUT
			pData 	: ^CHAR;
			pGetVarIdFromLasalIdRsp 	: ^DSComm::_DS_GetVarIdFromLasalIdResp;
			num 	: UDINT;
		END_VAR;
	
	FUNCTION GetRespData_GetLasalIdFromName
		VAR_INPUT
			pData 	: ^CHAR;
			pGetLasalIdFromNameRsp 	: ^DSComm::_DS_GetLasalIdFromNameResp;
			num 	: UDINT;
		END_VAR;
	
	FUNCTION GetRespData_GetLasalIdIdFromVarId
		VAR_INPUT
			pData 	: ^CHAR;
			pGetLasalIdIdFromVarIdRsp 	: ^DSComm::_DS_GetLasalIdIdFromVarIdResp;
			num 	: UDINT;
		END_VAR;
	
	FUNCTION GetRespData_GetNameFromVarId
		VAR_INPUT
			pData 	: ^CHAR;
			pGetNameFromVarIdRsp 	: ^DSComm::_DS_GetNameFromVarIdResp;
			num 	: UDINT;
		END_VAR;
	
	FUNCTION GetRespData_GetNameFromLasalId
		VAR_INPUT
			pData 	: ^CHAR;
			pGetNameFromLasalIdRsp 	: ^DSComm::_DS_GetNameFromLasalIdResp;
			num 	: UDINT;
		END_VAR;
				//! <Function Comment="Increments the values of one ore more numeric data points.&#13;&#10;&#13;&#10;Inkrementiert die Werte von numerischen Datenpunkten." Name="IncValue"/>
	FUNCTION GLOBAL IncValue
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="IncValue.pThis"/>
			num 	: UDINT;			//! <Variable Comment="The number of passed entries.&#13;&#10;&#13;&#10;Anzahl der übergebenen Einträge." Name="IncValue.num"/>
			pDpId 	: ^UDINT;			//! <Variable Comment="Pointer to an array with &lt;num&gt; VarIDs of the numeric data points to be incremented.&#13;&#10;&#13;&#10;Zeiger auf ein Array mit &lt;num&gt; VarIDs der numerischen Datenpunkte die inkrementiert werden sollen." Name="IncValue.pDpId"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: &lt;num&gt; is zero or the pointer &lt;pDpId&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Wert von &lt;num&gt; ist null oder der Zeiger &lt;pDpId&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="IncValue.MessageID"/>
		END_VAR;
				//! <Function Comment="Decrements the values of one ore more numeric data points.&#13;&#10;&#13;&#10;Dekrementiert die Werte von numerischen Datenpunkten." Name="DecValue"/>
	FUNCTION GLOBAL DecValue
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="DecValue.pThis"/>
			num 	: UDINT;			//! <Variable Comment="The number of passed entries.&#13;&#10;&#13;&#10;Anzahl der übergebenen Einträge." Name="DecValue.num"/>
			pDpId 	: ^UDINT;			//! <Variable Comment="Pointer to an array with &lt;num&gt; VarIDs of the numeric data points to be decremented.&#13;&#10;&#13;&#10;Zeiger auf ein Array mit &lt;num&gt; VarIDs der numerischen Datenpunkte die dekrementiert werden sollen." Name="DecValue.pDpId"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: &lt;num&gt; is zero or the pointer &lt;pDpId&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Wert von &lt;num&gt; ist null oder der Zeiger &lt;pDpId&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="DecValue.MessageID"/>
		END_VAR;
				//! <Function Comment="Adds numeric data points and string data points to the refresh list.&#13;&#10;&#13;&#10;Fügt numerische Datenpunkte und String-Datenpunkte zur Refresh-Liste hinzu." Name="RefListAdd"/>
	FUNCTION GLOBAL RefListAdd
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="RefListAdd.pThis"/>
			channel 	: UDINT;			//! <Variable Comment="ID of the Reflist channel to which the data points are to be added. &#13;&#10;The maximum allowed value is MAX_CHANNEL.&#13;&#10;&#13;&#10;ID des Reflist Kanals zu dem die Datenpunkte hinzugefügt werden sollen. &#13;&#10;Der maximal erlaubte Wert ist MAX_CHANNEL." Name="RefListAdd.channel"/>
			num 	: UDINT;			//! <Variable Comment="The number of passed entries.&#13;&#10;&#13;&#10;Anzahl der übergebenen Einträge." Name="RefListAdd.num"/>
			pDpId 	: ^UDINT;			//! <Variable Comment="Pointer to an array with &lt;num&gt; VarIDs of the data points to be added to the refresh list.&#13;&#10;&#13;&#10;Zeiger auf ein Array mit &lt;num&gt; VarIDs der Datenpunkte, die zur Refresh-Liste hinzugefügt werden sollen." Name="RefListAdd.pDpId"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: &lt;num&gt; is zero or the pointer &lt;pDpId&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Wert von &lt;num&gt; ist null oder der Zeiger &lt;pDpId&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="RefListAdd.MessageID"/>
		END_VAR;
				//! <Function Comment="Removes numeric data points and string data points from the refresh list.&#13;&#10;&#13;&#10;Löscht Datenpunkte aus der Refresh-Liste." Name="RefListSub"/>
	FUNCTION GLOBAL RefListSub
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="RefListSub.pThis"/>
			channel 	: UDINT;			//! <Variable Comment="ID of the Reflist channel from which the data points are to be removed. &#13;&#10;The maximum allowed value is MAX_CHANNEL.&#13;&#10;&#13;&#10;ID des Reflist Kanals von dem die Datenpunkte entfernt werden sollen. &#13;&#10;Der maximal erlaubte Wert ist MAX_CHANNEL." Name="RefListSub.channel"/>
			num 	: UDINT;			//! <Variable Comment="The number of passed entries.&#13;&#10;&#13;&#10;Anzahl der übergebenen Einträge." Name="RefListSub.num"/>
			pDpId 	: ^UDINT;			//! <Variable Comment="Pointer to an array with &lt;num&gt; VarIDs of the data points to be removed from the refresh list.&#13;&#10;&#13;&#10;Zeiger auf ein Array mit &lt;num&gt; VarIDs der Datenpunkte die von der Refresh-Liste entfernt werden sollen." Name="RefListSub.pDpId"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: &lt;num&gt; is zero or the pointer &lt;pDpId&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Wert von &lt;num&gt; ist null oder der Zeiger &lt;pDpId&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="RefListSub.MessageID"/>
		END_VAR;
	
	FUNCTION FindJob
		VAR_INPUT
			pJobInfo 	: ^DSComm::_DS_JobInfo;
			MessageID 	: DINT;
		END_VAR
		VAR_OUTPUT
			pJobElmt 	: ^DSComm::_DS_JobInfoElmt;
		END_VAR;
	
	FUNCTION GetRespData_GetDpList
		VAR_INPUT
			pData 	: ^CHAR;
			pGetDpListRsp 	: ^_DS_GetDpListResp;
			num 	: UDINT;
		END_VAR;
	
	FUNCTION GetRespData_GetDpInfo
		VAR_INPUT
			pData 	: ^CHAR;
			pGetDpInfoRsp 	: ^DSComm::_DS_GetDpInfoResp;
			num 	: UDINT;
		END_VAR;
				//! <Function Comment="Returns a list with all stations.&#13;&#10;&#13;&#10;Gibt eine List mit allen Stationen zurück." Name="GetStationList"/>
	FUNCTION GLOBAL GetStationList
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="GetStationList.pThis"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="GetStationList.MessageID"/>
		END_VAR;
				//! <Function Comment="Returns the status of stations.&#13;&#10;&#13;&#10;Liefert den Status von Stationen zurück." Name="GetStationStatus"/>
	FUNCTION GLOBAL GetStationStatus
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="GetStationStatus.pThis"/>
			num 	: UDINT;			//! <Variable Comment="The number of passed entries.&#13;&#10;&#13;&#10;Anzahl der übergebenen Einträge." Name="GetStationStatus.num"/>
			pStationNo 	: ^UDINT;			//! <Variable Comment="Pointer to an array with &lt;num&gt; station numbers whose states are to be queried.&#13;&#10;&#13;&#10;Zeiger auf ein Array mit &lt;num&gt; Stationsnummern deren Stati abgefragt werden sollen." Name="GetStationStatus.pStationNo"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: &lt;num&gt; is zero or the pointer &lt;pStationNo&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Wert von &lt;num&gt; ist null oder der Zeiger &lt;pStationNo&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="GetStationStatus.MessageID"/>
		END_VAR;
				//! <Function Comment="Opens a file and returns a handle.&#13;&#10;&#13;&#10;Öffnet eine Datei und gibt ein Handle zurück." Name="FileOpen"/>
	FUNCTION GLOBAL FileOpen
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="FileOpen.pThis"/>
			pDpne 	: ^CHAR;			//! <Variable Comment="Pointer to the drive-path-name-extension of the file to be opened.&#13;&#10;This is an UTF8-string.&#13;&#10;&#13;&#10;Zeiger auf die Drive-Path-Name-Extension der zu öffnenden Datei.&#13;&#10;Dies ist ein UTF8-String." Name="FileOpen.pDpne"/>
			pMode 	: ^CHAR;			//! <Variable Comment="Pointer to the mode string how the file should be opened.&#13;&#10;&quot;r&quot;: Opens a file for reading. The file must already exist.&#13;&#10;&quot;w&quot;: Creates an empty file for writing. If the file already exists, its contents are deleted and the file is treated as a new empty file.&#13;&#10;&quot;a&quot;: Opens the file to append data to the end of the file. The file pointer cannot be adjusted with FileSeek().&#13;&#10;      The new data is always written to the end of the file. If the file does not exist yet, it will be created.&#13;&#10;&#13;&#10;&#10;&#10;For a file to be treated as binary, the character &apos;b&apos; must be present at the end of the mode string (&quot;rb&quot;, &quot;wb&quot;, &quot;ab&quot;).&#13;&#10;&#13;&#10;&#13;&#10;Zeiger auf den Mode-String wie die Datei geöffnet werden soll.&#13;&#10;&quot;r&quot;: Öffnet eine Datei zum Lesen. Die Datei muss bereits vorhanden sein.&#13;&#10;&quot;w&quot;: Erzeugt eine leere Datei zum Schreiben. Falls die Datei schon existiert, wird ihr Inhalt gelöscht und die Datei wird wie eine neue leere Datei behandelt.&#13;&#10;&quot;a&quot;: Öffnet die Datei zum Anhängen von Daten an das Ende der Datei. Der Dateizeiger kann nicht mit FileSeek() verstellt werden.&#13;&#10;       Die neuen Daten werden immer an das Ende der Datei geschrieben. Falls die Datei noch nicht existiert wird sie neu erzeugt.&#13;&#10;&#13;&#10;Damit eine Datei als Binärdatei behandelt wird, muss das Zeichen b am Ende des Mode-String vorhanden sein (&quot;rb&quot;, &quot;wb&quot;, &quot;ab&quot;)." Name="FileOpen.pMode"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: the pointer &lt;pDpne&gt; or the pointer &lt;pMode&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Zeiger &lt;pDpne&gt; oder der Zeiger &lt;pMode&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="FileOpen.MessageID"/>
		END_VAR;
	
	FUNCTION GetRespData_GetVarIdFromCRC
		VAR_INPUT
			pData 	: ^CHAR;
			pGetVarIdFromCRCRsp 	: ^DSComm::_DS_GetVarIdFromCRCResp;
			num 	: UDINT;
		END_VAR;
	
	FUNCTION GetRespData_GetCRCfromVarId
		VAR_INPUT
			pData 	: ^CHAR;
			pGetCRCfromVarIdRsp 	: ^DSComm::_DS_GetCRCFromVarIdResp;
			num 	: UDINT;
		END_VAR;
	
	FUNCTION GetRespData_RefListUpdate
		VAR_INPUT
			pData 	: ^CHAR;
			pRefListUpdate 	: ^_DS_RefListUpdate;
			num 	: UDINT;
		END_VAR;
	
	FUNCTION GetRespData_RefListUpdateString
		VAR_INPUT
			pData 	: ^CHAR;
			pRefListUpdateString 	: ^DSComm::_DS_RefListUpdateString;
			num 	: UDINT;
		END_VAR;
	
	FUNCTION GetRespData_FileOpen
		VAR_INPUT
			pData 	: ^CHAR;
			pFileOpenRsp 	: ^DSComm::_DS_FileOpenResp;
		END_VAR;
				//! <Function Comment="Closes a file.&#13;&#10;&#13;&#10;Schließt eine Datei." Name="FileClose"/>
	FUNCTION GLOBAL FileClose
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="FileClose.pThis"/>
			handle 	: UDINT;			//! <Variable Comment="The file handle of the file to be closed.&#13;&#10;&#13;&#10;Der Filehandle jener Datei, die geschlossen werden soll." Name="FileClose.handle"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="FileClose.MessageID"/>
		END_VAR;
				//! <Function Comment="Positions the file pointer.&#13;&#10;&#13;&#10;Positioniert den Dateizeiger." Name="FileSeek"/>
	FUNCTION GLOBAL FileSeek
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="FileSeek.pThis"/>
			handle 	: UDINT;			//! <Variable Comment="The file handle.&#13;&#10;&#13;&#10;Der Filehandle." Name="FileSeek.handle"/>
			start 	: UDINT;			//! <Variable Comment="From where the &lt;offset&gt; is to be calculated (0 = start of file, 1 = current position, 2 = end of file).&#13;&#10;&#13;&#10;Von wo weg der &lt;offset&gt; gerechnet werden soll (0 = Dateianfang, 1 = aktuelle Position, 2 = Dateiende)." Name="FileSeek.start"/>
			offset 	: UDINT;			//! <Variable Comment="Offset in Byte.&#13;&#10;&#13;&#10;Offset in Byte." Name="FileSeek.offset"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="FileSeek.MessageID"/>
		END_VAR;
				//! <Function Comment="Returns the position of the file pointer.&#13;&#10;&#13;&#10;Gibt die Position des Dateizeigers zurück." Name="FileTell"/>
	FUNCTION GLOBAL FileTell
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="FileTell.pThis"/>
			handle 	: UDINT;			//! <Variable Comment="The file handle.&#13;&#10;&#13;&#10;Der Filehandle." Name="FileTell.handle"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="FileTell.MessageID"/>
		END_VAR;
				//! <Function Comment="Reads data from a file.&#13;&#10;&#13;&#10;Liest Daten aus einer Datei aus." Name="FileRead"/>
	FUNCTION GLOBAL FileRead
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="FileRead.pThis"/>
			handle 	: UDINT;			//! <Variable Comment="The file handle.&#13;&#10;&#13;&#10;Der Filehandle." Name="FileRead.handle"/>
			length 	: UDINT;			//! <Variable Comment="Number of bytes to be read.&#13;&#10;&#13;&#10;Anzahl der Bytes die gelesen werden sollen." Name="FileRead.length"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="FileRead.MessageID"/>
		END_VAR;
	
	FUNCTION GetRespData_FileRead
		VAR_INPUT
			pData 	: ^CHAR;
			pFileReadRsp 	: ^DSComm::_DS_FileReadResp;
		END_VAR;
				//! <Function Comment="Writes data to a file.&#13;&#10;&#13;&#10;Schreibt Daten in eine Datei." Name="FileWrite"/>
	FUNCTION GLOBAL FileWrite
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="FileWrite.pThis"/>
			handle 	: UDINT;			//! <Variable Comment="The file handle.&#13;&#10;&#13;&#10;Der Filehandle." Name="FileWrite.handle"/>
			length 	: UDINT;			//! <Variable Comment="Number of bytes to be written.&#13;&#10;&#13;&#10;Anzahl der zu schreibenden Bytes." Name="FileWrite.length"/>
			pWriteData 	: ^CHAR;			//! <Variable Comment="Pointer to the data to be written.&#13;&#10;&#13;&#10;Zeiger auf die zu schreibenden Daten." Name="FileWrite.pWriteData"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: the pointer &lt;pWriteData&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Zeiger &lt;pWriteData&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="FileWrite.MessageID"/>
		END_VAR;
				//! <Function Comment="Reads &lt;length&gt; characters from a file, or until the next NewLine character.&#13;&#10;&#13;&#10;Liest &lt;length&gt; Zeichen aus einer Datei, oder bis zum nächsten NewLine Zeichen." Name="FileGet"/>
	FUNCTION GLOBAL FileGet
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="FileGet.pThis"/>
			handle 	: UDINT;			//! <Variable Comment="The file handle.&#13;&#10;&#13;&#10;Der Filehandle." Name="FileGet.handle"/>
			length 	: UDINT;			//! <Variable Comment="The maximum number of bytes to be read.&#13;&#10;&#13;&#10;Wie viele Bytes maximal gelesen werden sollen." Name="FileGet.length"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="FileGet.MessageID"/>
		END_VAR;
	
	FUNCTION GetRespData_FileGet
		VAR_INPUT
			pData 	: ^CHAR;
			pFileGetRsp 	: ^DSComm::_DS_FileGetResp;
		END_VAR;
				//! <Function Comment="Writes an ASCII string to a file.&#13;&#10;&#13;&#10;Schreibt einen ASCII-String in eine Datei." Name="FilePut"/>
	FUNCTION GLOBAL FilePut
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="FilePut.pThis"/>
			handle 	: UDINT;			//! <Variable Comment="The file handle.&#13;&#10;&#13;&#10;Der Filehandle." Name="FilePut.handle"/>
			pString 	: ^CHAR;			//! <Variable Comment="Pointer to the string to be written to the file.&#13;&#10;&#13;&#10;Zeiger auf den String, der in die Datei geschrieben werden soll." Name="FilePut.pString"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: the pointer &lt;pString&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Zeiger &lt;pString&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="FilePut.MessageID"/>
		END_VAR;
				//! <Function Comment="Returns the length of a file.&#13;&#10;&#13;&#10;Gibt die Länge einer Datei zurück." Name="FileLength"/>
	FUNCTION GLOBAL FileLength
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="FileLength.pThis"/>
			handle 	: UDINT;			//! <Variable Comment="The file handle.&#13;&#10;&#13;&#10;Der Filehandle." Name="FileLength.handle"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="FileLength.MessageID"/>
		END_VAR;
				//! <Function Comment="Reads the entire contents of a file package by package.&#13;&#10;&#13;&#10;Liest den gesamten Inhalt einer Datei paketweise aus." Name="FileContent"/>
	FUNCTION GLOBAL FileContent
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="FileContent.pThis"/>
			pDpne 	: ^CHAR;			//! <Variable Comment="Pointer to the drive path name extension of the file to be read.&#13;&#10;This is an UTF8-string.&#13;&#10;&#13;&#10;Zeiger auf die Drive-Path-Name-Extension der zu lesenden Datei.&#13;&#10;Dies ist ein UTF8-String." Name="FileContent.pDpne"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: the pointer &lt;pDpne&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Zeiger &lt;pDpne&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="FileContent.MessageID"/>
		END_VAR;
				//! <Function Comment="Die Datei ist zu groß für ein Datenpaket und wird in zwei oder mehr Fragmenten übertragen.&#13;&#10;pData zeigt auf den _DS_FragmentHeader." Name="GetRespData_FileContent_1"/>
	FUNCTION GetRespData_FileContent_1
		VAR_INPUT
			pData 	: ^CHAR;
			pFragHdr 	: ^DSComm::_DS_FragmentHeader;
			pFileContentRsp 	: ^DSComm::_DS_FileContentResp;
		END_VAR;
				//! <Function Comment="Creates a new directory.&#13;&#10;&#13;&#10;Legt ein neues Verzeichnis an." Name="DirCreate"/>
	FUNCTION GLOBAL DirCreate
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="DirCreate.pThis"/>
			pDp 	: ^CHAR;			//! <Variable Comment="Pointer to the drive path of the new directory.&#13;&#10;This is an UTF8-string.&#13;&#10;&#13;&#10;Zeiger auf Drive-Path des neuen Verzeichnisses.&#13;&#10;Dies ist ein UTF8-String." Name="DirCreate.pDp"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: the pointer &lt;pDp&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Zeiger &lt;pDp&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="DirCreate.MessageID"/>
		END_VAR;
				//! <Function Comment="Die Datei passt in ein Datenpaket.&#13;&#10;pData zeigt auf die Antwortdaten: UDINT error, U64 filelength, char^ data." Name="GetRespData_FileContent_2"/>
	FUNCTION GetRespData_FileContent_2
		VAR_INPUT
			pData 	: ^CHAR;
			pFileContentRsp 	: ^DSComm::_DS_FileContentResp;
		END_VAR;
	
	FUNCTION GetRespData_DirCreate
		VAR_INPUT
			pData 	: ^CHAR;
			pDirCreateRsp 	: ^DSComm::_DS_DirCreateResp;
		END_VAR;
				//! <Function Comment="Reads the contents of a directory.&#13;&#10;&#13;&#10;Liest den Inhalt eines Verzeichnisses aus." Name="DirRead"/>
	FUNCTION GLOBAL DirRead
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="DirRead.pThis"/>
			FilterIncl 	: UDINT;			//! <Variable Comment="File attributes to include.&#13;&#10;&#13;&#10;Zu inkludierende File-Attribute." Name="DirRead.FilterIncl"/>
			FilterExcl 	: UDINT;			//! <Variable Comment="File attributes to exclude.&#13;&#10;&#13;&#10;Zu exkludierende File-Attribute." Name="DirRead.FilterExcl"/>
			pDp 	: ^CHAR;			//! <Variable Comment="Pointer to the drive path of the directory to be read.&#13;&#10;This is an UTF8-string.&#13;&#10;&#13;&#10;Zeiger auf Drive-Path des Verzeichnisses das ausgelesen werden soll.&#13;&#10;Dies ist ein UTF8-String." Name="DirRead.pDp"/>
			pNe 	: ^CHAR;			//! <Variable Comment="Pointer to name extension as filter (e.g. *.*&#41;.&#13;&#10;This is an UTF8-string.&#13;&#10;&#13;&#10;Zeiger auf Name-Extension als Filter (zB. *.*&#41;.&#13;&#10;Dies ist ein UTF8-String." Name="DirRead.pNe"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: the pointer &lt;pDp&gt; or the pointer &lt;pNe&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Zeiger &lt;pDp&gt; oder der Zeiger &lt;pNe&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="DirRead.MessageID"/>
		END_VAR;
	
	FUNCTION GetRespData_DirRead
		VAR_INPUT
			pData 	: ^CHAR;
			pDirReadRsp 	: ^DSComm::_DS_DirReadResp;
			num 	: UDINT;
		END_VAR;
				//! <Function Comment="Deletes a file or a directory.&#13;&#10;Wildcard characters are not supported.&#13;&#10;&#13;&#10;Löscht eine Datei oder ein Verzeichnis.&#13;&#10;Wildcard-Zeichen werden nicht unterstützt." Name="FileRemove"/>
	FUNCTION GLOBAL FileRemove
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="FileRemove.pThis"/>
			pDpne 	: ^CHAR;			//! <Variable Comment="Pointer to the drive path name extension of the object to be deleted (file or directory).&#13;&#10;This is an UTF8-string.&#13;&#10;&#13;&#10;Zeiger auf die Drive-Path-Name-Extension des zu löschenden Objekts (Datei oder Verzeichnis).&#13;&#10;Dies ist ein UTF8-String." Name="FileRemove.pDpne"/>
			updateProgress 	: BOOL;			//! <Variable Comment="TRUE: the data service should send progress frames.&#13;&#10;FALSE: the data service should not send progress frames.&#13;&#10;Progress frames will be passed to the method ProgressStatusPush() &#13;&#10;in the object where FileRemove() was called.&#13;&#10;&#13;&#10;TRUE: der Data Service soll Progress Frames verschicken.&#13;&#10;FALSE: der Data Service soll keine Progress Frames verschicken.&#13;&#10;Die vom Data Service verschickten Progress Frames werden an die Methode ProgressStatusPush() &#13;&#10;in jenem Objekt übergeben in dem FileRemove() aufgerufen wurde." Name="FileRemove.updateProgress"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: the pointer &lt;pDpne&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Zeiger &lt;pDpne&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="FileRemove.MessageID"/>
		END_VAR;
				//! <Function Comment="Copies a file or a directory.&#13;&#10;Wildcard characters are not supported.&#13;&#10;&#13;&#10;Kopiert eine Datei oder ein Verzeichnis.&#13;&#10;Wildcard-Zeichen werden nicht unterstützt." Name="FileCopy"/>
	FUNCTION GLOBAL FileCopy
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="FileCopy.pThis"/>
			pDpneSrc 	: ^CHAR;			//! <Variable Comment="Pointer to the path to the object to be copied (file or directory).&#13;&#10;This is an UTF8-string.&#13;&#10;&#13;&#10;Zeiger auf den Pfad zum Objekt das kopiert werden soll (Datei oder Verzeichnis).&#13;&#10;Dies ist ein UTF8-String." Name="FileCopy.pDpneSrc"/>
			pDpneDest 	: ^CHAR;			//! <Variable Comment="Pointer to the path to the target.&#13;&#10;This is an UTF8-string.&#13;&#10;&#13;&#10;Zeiger auf den Pfad zum Ziel.&#13;&#10;Dies ist ein UTF8-String." Name="FileCopy.pDpneDest"/>
			updateProgress 	: BOOL;			//! <Variable Comment="TRUE: the data service should send progress frames.&#13;&#10;FALSE: the data service should not send progress frames.&#13;&#10;Progress frames will be passed to the method ProgressStatusPush() &#13;&#10;in the object where FileCopy() was called.&#13;&#10;&#13;&#10;TRUE: der Data Service soll Progress Frames verschicken.&#13;&#10;FALSE: der Data Service soll keine Progress Frames verschicken.&#13;&#10;Die vom Data Service verschickten Progress Frames werden an die Methode ProgressStatusPush() &#13;&#10;in jenem Objekt übergeben in dem FileCopy() aufgerufen wurde." Name="FileCopy.updateProgress"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: the pointer &lt;pDpneSrc&gt; or the pointer &lt;pDpneDest&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Zeiger &lt;pDpneSrc&gt; oder der Zeiger &lt;pDpneDest&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="FileCopy.MessageID"/>
		END_VAR;
				//! <Function Comment="Returns information about a file.&#13;&#10;&#13;&#10;Gibt Informationen zu einer Datei zurück." Name="FileInfo"/>
	FUNCTION GLOBAL FileInfo
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="FileInfo.pThis"/>
			pDpne 	: ^CHAR;			//! <Variable Comment="Pointer to the drive path name extension of the file.&#13;&#10;This is an UTF8-string.&#13;&#10;&#13;&#10;Zeiger auf die Drive-Path-Name-Extension der Datei.&#13;&#10;Dies ist ein UTF8-String." Name="FileInfo.pDpne"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: the pointer &lt;pDpne&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Zeiger &lt;pDpne&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="FileInfo.MessageID"/>
		END_VAR;
				//! <Function Comment="Changes the name of a file.&#13;&#10;&#13;&#10;Ändert den Namen einer Datei." Name="FileRename"/>
	FUNCTION GLOBAL FileRename
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="FileRename.pThis"/>
			pDpneOld 	: ^CHAR;			//! <Variable Comment="Pointer to the drive path name extension of the file to be renamed.&#13;&#10;This is an UTF8-string.&#13;&#10;&#13;&#10;Zeiger auf die Drive-Path-Name-Extension der Datei die umbenannt werden soll.&#13;&#10;Dies ist ein UTF8-String." Name="FileRename.pDpneOld"/>
			pDpneNew 	: ^CHAR;			//! <Variable Comment="Pointer to the new drive path name extension of the file.&#13;&#10;This is an UTF8-string.&#13;&#10;&#13;&#10;Zeiger auf die neue Drive-Path-Name-Extension der Datei.&#13;&#10;Dies ist ein UTF8-String." Name="FileRename.pDpneNew"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: the pointer &lt;pDpneOld&gt; or the pointer &lt;pDpneNew&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Zeiger &lt;pDpneOld&gt; oder der Zeiger &lt;pDpneNew&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="FileRename.MessageID"/>
		END_VAR;
				//! <Function Comment="Changes the attributes of a file.&#13;&#10;&#13;&#10;Ändert die Attribute einer Datei." Name="FileSetAttribute"/>
	FUNCTION GLOBAL FileSetAttribute
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="FileSetAttribute.pThis"/>
			pDpne 	: ^CHAR;			//! <Variable Comment="Pointer to the drive path name extension of the file.&#13;&#10;This is an UTF8-string.&#13;&#10;&#13;&#10;Zeiger auf die Drive-Path-Name-Extension der Datei.&#13;&#10;Dies ist ein UTF8-String." Name="FileSetAttribute.pDpne"/>
			AttributeToSet 	: UDINT;			//! <Variable Comment="All attributes that are to be set.&#13;&#10;&#13;&#10;Alle Attribute welche neu gesetzt werden sollen." Name="FileSetAttribute.AttributeToSet"/>
			AttributeToReset 	: UDINT;			//! <Variable Comment="All attributes to be deleted.&#13;&#10;&#13;&#10;Alle Attribute welche gelöscht werden sollen." Name="FileSetAttribute.AttributeToReset"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: the pointer &lt;pDpne&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Zeiger &lt;pDpne&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="FileSetAttribute.MessageID"/>
		END_VAR;
				//! <Function Comment="Returns a list of all connected drives in the response data.&#13;&#10;&#13;&#10;Gibt in den Response-Daten eine Liste aller verbundenen Laufwerke zurück." Name="GetDriveList"/>
	FUNCTION GLOBAL GetDriveList
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="GetDriveList.pThis"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="GetDriveList.MessageID"/>
		END_VAR;
	
	FUNCTION GetRespData_GetDriveList
		VAR_INPUT
			pData 	: ^CHAR;
			pGetDriveListRsp 	: ^DSComm::_DS_GetDriveListResp;
		END_VAR;
				//! <Function Comment="Moves a file or a directory.&#13;&#10;Wildcard characters are not supported.&#13;&#10;&#13;&#10;Verschiebt eine Datei oder ein Verzeichnis.&#13;&#10;Wildcard-Zeichen werden nicht unterstützt." Name="FileMove"/>
	FUNCTION GLOBAL FileMove
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="FileMove.pThis"/>
			pDpneSrc 	: ^CHAR;			//! <Variable Comment="Pointer to the path to the object to be moved (file or directory).&#13;&#10;This is an UTF8-string.&#13;&#10;&#13;&#10;Zeiger auf den Pfad zum zu verschiebenden Objekt (Datei oder Verzeichnis).&#13;&#10;Dies ist ein UTF8-String." Name="FileMove.pDpneSrc"/>
			pDpneDest 	: ^CHAR;			//! <Variable Comment="Pointer to the path to the target.&#13;&#10;This is an UTF8-string.&#13;&#10;&#13;&#10;Zeiger auf den Pfad zum Ziel.&#13;&#10;Dies ist ein UTF8-String." Name="FileMove.pDpneDest"/>
			updateProgress 	: BOOL;			//! <Variable Comment="TRUE: the data service should send progress frames.&#13;&#10;FALSE: the data service should not send progress frames.&#13;&#10;Progress frames will be passed to the method ProgressStatusPush() &#13;&#10;in the object where FileMove() was called.&#13;&#10;&#13;&#10;TRUE: der Data Service soll Progress Frames verschicken.&#13;&#10;FALSE: der Data Service soll keine Progress Frames verschicken.&#13;&#10;Die vom Data Service verschickten Progress Frames werden an die Methode ProgressStatusPush() &#13;&#10;in jenem Objekt übergeben in dem FileMove() aufgerufen wurde." Name="FileMove.updateProgress"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: the pointer &lt;pDpneSrc&gt; or the pointer &lt;pDpneDest&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Zeiger &lt;pDpneSrc&gt; oder der Zeiger &lt;pDpneDest&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="FileMove.MessageID"/>
		END_VAR;
				//! <Function Comment="Adds an entry to the event journal.&#13;&#10;&#13;&#10;Fügt einen Eintrag zum Eventjournal hinzu." Name="EventjournalAdd"/>
	FUNCTION GLOBAL EventjournalAdd
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="EventjournalAdd.pThis"/>
			num 	: UDINT;			//! <Variable Comment="The number of passed entries.&#13;&#10;&#13;&#10;Anzahl der übergebenen Einträge." Name="EventjournalAdd.num"/>
			pEventjournalAdd 	: ^DSComm::_DS_EventjournalAddCmd;			//! <Variable Comment="Pointer to an array with &lt;num&gt; journal entries.&#13;&#10;&#13;&#10;Zeiger auf ein Array mit &lt;num&gt; Journaleinträgen." Name="EventjournalAdd.pEventjournalAdd"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: &lt;num&gt; is zero or the pointer &lt;pEventjournalAdd&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Wert von &lt;num&gt; ist null oder der Zeiger &lt;pEventjournalAdd&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="EventjournalAdd.MessageID"/>
		END_VAR;
				//! <Function Comment="Reads an entry from the event journal.&#13;&#10;&#13;&#10;Liest einen Eintrag aus dem Eventjournal aus." Name="EventjournalGet"/>
	FUNCTION GLOBAL EventjournalGet
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="EventjournalGet.pThis"/>
			num 	: UDINT;			//! <Variable Comment="The number of passed entries.&#13;&#10;&#13;&#10;Anzahl der übergebenen Einträge." Name="EventjournalGet.num"/>
			pJournalId 	: ^UDINT;			//! <Variable Comment="Pointer to an array with &lt;num&gt; IDs of the journal entries.&#13;&#10;&#13;&#10;Zeiger auf ein Array mit &lt;num&gt; IDs der Journaleinträge." Name="EventjournalGet.pJournalId"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: &lt;num&gt; is zero or the pointer &lt;pJournalId&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Wert von &lt;num&gt; ist null oder der Zeiger &lt;pJournalId&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="EventjournalGet.MessageID"/>
		END_VAR;
	
	FUNCTION GetRespData_EventjournalAdd
		VAR_INPUT
			pData 	: ^CHAR;
			pEventjournalAddRsp 	: ^_DS_EventjournalAddResp;
			num 	: UDINT;
		END_VAR;
	
	FUNCTION GetRespData_EventjournalGet
		VAR_INPUT
			pData 	: ^CHAR;
			pEventjournalGetRsp 	: ^DSComm::_DS_EventjournalGetResp;
			num 	: UDINT;
		END_VAR;
				//! <Function Comment="Reads all entries from the event journal.&#13;&#10;&#13;&#10;Liest alle Einträge aus dem Eventjournal aus." Name="EventjournalGetAll"/>
	FUNCTION GLOBAL EventjournalGetAll
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="EventjournalGetAll.pThis"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="EventjournalGetAll.MessageID"/>
		END_VAR;
				//! <Function Comment="Deletes an entry from the event journal.&#13;&#10;&#13;&#10;Löscht einen Eintrag aus dem Eventjournal." Name="EventjournalDel"/>
	FUNCTION GLOBAL EventjournalDel
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="EventjournalDel.pThis"/>
			num 	: UDINT;			//! <Variable Comment="The number of passed entries.&#13;&#10;&#13;&#10;Anzahl der übergebenen Einträge." Name="EventjournalDel.num"/>
			pJournalId 	: ^UDINT;			//! <Variable Comment="Pointer to an array with &lt;num&gt; IDs of the journal entries.&#13;&#10;&#13;&#10;Zeiger auf ein Array mit &lt;num&gt; IDs der Journaleinträge." Name="EventjournalDel.pJournalId"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: &lt;num&gt; is zero or the pointer &lt;pJournalId&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Wert von &lt;num&gt; ist null oder der Zeiger &lt;pJournalId&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="EventjournalDel.MessageID"/>
		END_VAR;
				//! <Function Comment="Deletes all entries from the event journal.&#13;&#10;&#13;&#10;Löscht das gesamte Eventjournal." Name="EventjournalDelAll"/>
	FUNCTION GLOBAL EventjournalDelAll
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="EventjournalDelAll.pThis"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="EventjournalDelAll.MessageID"/>
		END_VAR;
				//! <Function Comment="Acknowledges one or more alarms.&#13;&#10;&#13;&#10;Quittiert einen oder mehrere Alarme." Name="EventjournalQuitAlarm"/>
	FUNCTION GLOBAL EventjournalQuitAlarm
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="EventjournalQuitAlarm.pThis"/>
			num 	: UDINT;			//! <Variable Comment="The number of passed entries.&#13;&#10;&#13;&#10;Anzahl der übergebenen Einträge." Name="EventjournalQuitAlarm.num"/>
			pAlarmId 	: ^UDINT;			//! <Variable Comment="Pointer to an array with &lt;num&gt; variable IDs of the &lt;ClassSvr&gt; of one or more alarm objects (classes _AlarmX0Para - _AlarmX3Para).&#13;&#10;&#13;&#10;Zeiger auf ein Array mit &lt;num&gt; Variablen IDs der &lt;ClassSvr&gt; von ein oder mehreren Alarm-Objekten (Klassen _AlarmX0Para - _AlarmX3Para)." Name="EventjournalQuitAlarm.pAlarmId"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: &lt;num&gt; is zero or the pointer &lt;pAlarmId&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Wert von &lt;num&gt; ist null oder der Zeiger &lt;pAlarmId&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="EventjournalQuitAlarm.MessageID"/>
		END_VAR;
				//! <Function Comment="Acknowledge all alarms.&#13;&#10;&#13;&#10;Quittiert alle Alarme." Name="EventjournalQuitAll"/>
	FUNCTION GLOBAL EventjournalQuitAll
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="EventjournalQuitAll.pThis"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="EventjournalQuitAll.MessageID"/>
		END_VAR;
	
	FUNCTION GenerateMessageID
		VAR_OUTPUT
			MessageID 	: DINT;
		END_VAR;
	
	FUNCTION GetpProgressInfo
		VAR_INPUT
			HandleID 	: DINT;
		END_VAR
		VAR_OUTPUT
			pProgressInfo 	: ^DSComm::_DS_ProgressInfo;
		END_VAR;
	
	FUNCTION StoreProgressInfo
		VAR_INPUT
			HandleID 	: DINT;
			pThis 	: ^DSComm_Interface;
		END_VAR
		VAR_OUTPUT
			ErrorNo 	: DINT;
		END_VAR;
	
	FUNCTION GetFreeProgressInfo
		VAR_INPUT
			HandleID 	: DINT;
		END_VAR
		VAR_OUTPUT
			pProgressInfo 	: ^DSComm::_DS_ProgressInfo;
		END_VAR;
	
	FUNCTION DeletepProgressInfo
		VAR_INPUT
			HandleID 	: DINT;
		END_VAR
		VAR_OUTPUT
			ErrorNo 	: DINT;
		END_VAR;
	
	FUNCTION TimeoutCheck;
				//! <Function Comment="Sends messages (MajorID and MinorID plus data) to different communication partners (= local/remote clients or stations).&#13;&#10;&#13;&#10;Sendet Nachrichten (MajorID und MinorID plus Daten) an verschiedene Kommunikationspartner (= local/remote Clients oder Stations)." Name="SendUserEvent"/>
	FUNCTION GLOBAL SendUserEvent
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="SendUserEvent.pThis"/>
			MajorID 	: UINT;			//! <Variable Comment="MajorID assigned by the user for the user event. &#13;&#10;The MajorID must not be in the range 0xF000 to 0xFFFF.&#13;&#10;&#13;&#10;Vom Anwender vergebene MajorID für das User Event. &#13;&#10;Die MajorID darf nicht im Bereich 0xF000 bis 0xFFFF sein." Name="SendUserEvent.MajorID"/>
			MinorID 	: UINT;			//! <Variable Comment="MinorID assigned by the user for the user event. &#13;&#10;&#13;&#10;Vom Anwender vergebene MinorID für das User Event." Name="SendUserEvent.MinorID"/>
			SessionID 	: UINT;			//! <Variable Comment="The SessionId of the remote station. For stations, the SessionId corresponds to the station number.&#13;&#10;&#10;&#10;To be able to send messages to all devices of a group, broadcast addresses are available for each group as well as for all devices:&#13;&#10;&#13;&#10;&#10;&#10;From                  To                        Name                                 Description&#13;&#10;&#10;0x0000 (0)        0x00FF (255)        ID_STATION                      Unique station number&#13;&#10;&#10;0x0100 (256)                                 ID_STATION_ALL              Broadcast address of all stations&#13;&#10;&#10;0x0101 (257)    0x01FE (510)         ---                                    Reserved / Invalid&#10;&#13;&#10;0x01FF (511)                                 ID_DATASERVICE              The SessionID of the Data Service&#13;&#10;&#10;0x0200 (512)    0x03FF(1023)      ID_LOCAL_CLIENT             Unique Id of a local Client&#13;&#10;&#10;0x0400 (1024)                              ID_LOCAL_CLIENT_ALL      Broadcast Address of all local clients&#13;&#10;&#10;0x0401 (1025)  0x04FF (1279)      ---                                      Reserved / Invalid&#10;&#13;&#10;0x0500 (1280)  0x3FFF (16383)    ID_REMOTE_CLIENT          Unique Id of a remote Client&#13;&#10;&#10;0x4000 (16384)                             ID_REMOTE_CLIENT_ALL  Broadcast Address of all remote clients&#10;&#13;&#10;0x4001 (16385) 0x7FFF (32767)    ---                                     Reserved / Invalid&#13;&#10;&#10;0x8000 (32768)                             ID_CLIENTS                       Broadcast address of all clients (local + remote)&#13;&#10;&#10;0x8001 (32769) 0xFFFE (65534)    ---                                     Reserved / Invalid&#10;&#13;&#10;0xFFFF (65535)                              ID_ALL                               Broadcast Address of all devices (Clients + Stations)&#10;&#10;&#13;&#10;&#13;&#10;&#13;&#10;Die SessionId der Gegenstelle. Bei Stationen entspricht die SessionId der Stationsnummer.&#13;&#10;Um einfach Nachrichten an alle Geräte einer Gruppe senden zu können, sind Broadcast Adressen für jede Gruppe, sowie für alle Gräte vorhanden:&#13;&#10;&#13;&#10;Von                     Bis                       Name                                 Beschreibung&#13;&#10;0x0000 (0)         0x00FF (255)       ID_STATION                      Eindeutige Stationsnummer&#13;&#10;0x0100 (256)                                 ID_STATION_ALL               Broadcast Adresse aller Stationen&#13;&#10;0x0101 (257)      0x01FE (510)      ---                                     Reserved / Invalid&#13;&#10;0x01FF (511)                                  ID_DATASERVICE             Die SessionID des Dataservice&#13;&#10;0x0200 (512)      0x03FF(1023)     ID_LOCAL_CLIENT            Eindeutige Id eines lokalen Clients&#13;&#10;0x0400 (1024)                               ID_LOCAL_CLIENT_ALL     Broadcast Adresse aller lokalen Clients&#13;&#10;0x0401 (1025)    0x04FF (1279)     ---                                     Reserved / Invalid&#13;&#10;0x0500 (1280)    0x3FFF (16383)  ID_REMOTE_CLIENT          Eindeutige Id eines remote Clients&#13;&#10;0x4000 (16384)                             ID_REMOTE_CLIENT_ALL  Broadcast Adresse aller remote Clients&#13;&#10;0x4001 (16385)  0x7FFF (32767)  ---                                      Reserved / Invalid&#13;&#10;0x8000 (32768)                             ID_CLIENTS                       Broadcast Adresse aller Clients (local + remote)&#13;&#10;0x8001 (32769)  0xFFFE (65534)  ---                                      Reserved / Invalid&#13;&#10;0xFFFF (65535)                              ID_ALL                              Broadcast Adresse aller Geräte (Clients + Stations)" Name="SendUserEvent.SessionID"/>
			pDataSrc 	: ^void;			//! <Variable Comment="Pointer to the data for the user event.&#13;&#10;&#13;&#10;Zeiger auf die Daten für das User Event." Name="SendUserEvent.pDataSrc"/>
			DataLen 	: UDINT;			//! <Variable Comment="Length of the data to be sent in bytes.&#13;&#10;&#13;&#10;Länge der zu sendenden Daten in Bytes." Name="SendUserEvent.DataLen"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: &lt;MajorID&gt; is out of range or the pointer &lt;pDataSrc&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: &lt;MajorID&gt; ist außerhalb des gültigen Bereichs oder der Zeiger &lt;pDataSrc&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="SendUserEvent.MessageID"/>
		END_VAR;
				//! <Function Comment="Event journal updates are passed to the EventjournalUpdatePush() method in the object that called this method.&#13;&#10;&#13;&#10;Aktualisierungen des Event Journals werden an die Methode EventjournalUpdatePush() in jenem Objekt übergeben, welches diese Methode aufgerufen hat." Name="SubscribeEventjournalUpdates"/>
	FUNCTION GLOBAL SubscribeEventjournalUpdates
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="SubscribeEventjournalUpdates.pThis"/>
		END_VAR;
				//! <Function Comment="After calling this method, no more Eventjournal updates are passed to the EventjournalUpdatePush() method.&#13;&#10;&#13;&#10;Nach dem Aufruf dieser Methode werden keine Aktualisierungen des Event Journals mehr an die Methode EventjournalUpdatePush() übergeben." Name="UnsubscribeEventjournalUpdates"/>
	FUNCTION GLOBAL UnsubscribeEventjournalUpdates;
				//! <Function Comment="With this method, an object logs on to receive user events. &#13;&#10;User events with the values &lt;MajorID&gt;&lt;MinorID&gt; are passed to the UserEventReceive() method in the object that called this method.&#13;&#10;&#13;&#10;Mit dieser Methode meldet sich ein Objekt für den Empfang von User Events an. &#13;&#10;User Events mit den Werten &lt;MajorID&gt;&lt;MinorID&gt; werden an die Methode UserEventReceive() in jenem Objekt übergeben, welches diese Methode aufgerufen hat." Name="SubscribeUserEvents"/>
	FUNCTION GLOBAL SubscribeUserEvents
		VAR_INPUT
			MajorID 	: UINT;			//! <Variable Comment="MajorID of the user event.&#13;&#10;&#13;&#10;MajorID des User Events." Name="SubscribeUserEvents.MajorID"/>
			MinorID 	: UINT;			//! <Variable Comment="MinorID of the user event. The value 65535 means that all MinorIDs are valid.&#13;&#10;&#13;&#10;MinorID des User Events. Der Wert 65535 bedeutet, dass alle MinorIDs gültig sind." Name="SubscribeUserEvents.MinorID"/>
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="SubscribeUserEvents.pThis"/>
		END_VAR
		VAR_OUTPUT
			ErrorNo 	: DINT;			//! <Variable Comment="0: no error.&#13;&#10;ERR_WRONG_PARAMETER: the MajorID must not be in the range 0xF000 to 0xFFFF.&#13;&#10;ERR_MEM_ALLOC: the buffer for the Minor-IDs could not be allocated.&#13;&#10;ERR_USER_EVENT_FULL: no further user events can be registered.&#13;&#10;ERR_USER_EVENT_EXISTS: the user event &lt;MajorID&gt;&lt;MinorID&gt; has already been registered.&#13;&#10;&#13;&#10;0: kein Fehler.&#13;&#10;ERR_WRONG_PARAMETER: die MajorID darf nicht im Bereich 0xF000 bis 0xFFFF sein.&#13;&#10;ERR_MEM_ALLOC: der Puffer für die Minor-IDs konnte nicht angelegt werden.&#13;&#10;ERR_USER_EVENT_FULL: es können keine weiteren User Events registriert werden.&#13;&#10;ERR_USER_EVENT_EXISTS: das User Event &lt;MajorID&gt;&lt;MinorID&gt; wurde schon registriert." Name="SubscribeUserEvents.ErrorNo"/>
		END_VAR;
				//! <Function Comment="After calling this method, no more user events with the values &lt;MajorID&gt;&lt;MinorID&gt; are passed to the method UserEventReceive().&#13;&#10;Registered User Events with other values of &lt;MajorID&gt;&lt;MinorID&gt; are still passed to the method.&#13;&#10;&#13;&#10;Nach dem Aufruf dieser Methode werden keine User Events mehr mit den Werten &lt;MajorID&gt;&lt;MinorID&gt; an die Methode UserEventReceive() übergeben.&#13;&#10;Registrierte User Events mit anderen Werten von &lt;MajorID&gt;&lt;MinorID&gt; werden weiterhin übergeben." Name="UnsubscribeUserEvents"/>
	FUNCTION GLOBAL UnsubscribeUserEvents
		VAR_INPUT
			MajorID 	: UINT;			//! <Variable Comment="MajorID of the user event.&#13;&#10;&#13;&#10;MajorID des User Events." Name="UnsubscribeUserEvents.MajorID"/>
			MinorID 	: UINT;			//! <Variable Comment="MinorID of the user event. The value 65535 makes all MinorIDs invalid.&#13;&#10;&#13;&#10;MinorID des User Events. Mit dem Wert 65535 werden alle MinorIDs abgemeldet." Name="UnsubscribeUserEvents.MinorID"/>
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="UnsubscribeUserEvents.pThis"/>
		END_VAR
		VAR_OUTPUT
			ErrorNo 	: DINT;			//! <Variable Comment="0: no error.&#13;&#10;ERR_WRONG_PARAMETER: the MajorID must not be in the range 0xF000 to 0xFFFF.&#13;&#10;ERR_USER_EVENT_NOT_FOUND: UserEvent (MajorID / MinorID) not found.&#13;&#10;&#13;&#10;0: kein Fehler.&#13;&#10;ERR_WRONG_PARAMETER: die &lt;MajorID&gt; darf nicht im Bereich 0xF000 bis 0xFFFF sein.&#13;&#10;ERR_USER_EVENT_NOT_FOUND: UserEvent (MajorID / MinorID) nicht gefunden." Name="UnsubscribeUserEvents.ErrorNo"/>
		END_VAR;
				//! <Function Comment="Sets software parameters.&#13;&#10;&#13;&#10;Setzt Software Parameter." Name="SetParameter"/>
	FUNCTION GLOBAL SetParameter
		VAR_INPUT
			ParaNo 	: DSComm::_DS_Parameter;			//! <Variable Comment="Parameter number.&#13;&#10;&#13;&#10;Parameter Nummer." Name="SetParameter.ParaNo"/>
			Value 	: DINT;			//! <Variable Comment="Parameter value.&#13;&#10;&#13;&#10;Parameter Wert." Name="SetParameter.Value"/>
			Mode 	: DINT;			//! <Variable Comment="No significance at present.&#13;&#10;&#13;&#10;Derzeit ohne Bedeutung." Name="SetParameter.Mode"/>
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;			//! <Variable Comment="ERR_WRONG_PARAMETER: &lt;ParaNo&gt; unknown.&#13;&#10;&#13;&#10;ERR_WRONG_PARAMETER: &lt;ParaNo&gt; unbekannt." Name="SetParameter.Retcode"/>
		END_VAR;
				//! <Function Comment="Reads software parameters.&#13;&#10;&#13;&#10;Liest Software Parameter." Name="GetParameter"/>
	FUNCTION GLOBAL GetParameter
		VAR_INPUT
			ParaNo 	: DSComm::_DS_Parameter;			//! <Variable Comment="Parameter number.&#13;&#10;&#13;&#10;Parameter Nummer." Name="GetParameter.ParaNo"/>
			pValue 	: ^DINT;			//! <Variable Comment="Pointer to a buffer for the parameter value.&#13;&#10;&#13;&#10;Zeiger auf einen Puffer für den Parameterwert." Name="GetParameter.pValue"/>
			Mode 	: DINT;			//! <Variable Comment="No significance at present.&#13;&#10;&#13;&#10;Derzeit ohne Bedeutung." Name="GetParameter.Mode"/>
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;			//! <Variable Comment="ERR_WRONG_PARAMETER: &lt;ParaNo&gt; unknown or &lt;pValue&gt; invalid.&#13;&#10;&#13;&#10;ERR_WRONG_PARAMETER: &lt;ParaNo&gt; unbekannt oder &lt;pValue&gt; ungültig." Name="GetParameter.Retcode"/>
		END_VAR;
	
	FUNCTION CreateTaskName
		VAR_INPUT
			pTaskName 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
	
	FUNCTION GetpUserEvent
		VAR_INPUT
			MajorID 	: UINT;
			MinorID 	: UINT;
		END_VAR
		VAR_OUTPUT
			pUserEvent 	: ^DSComm::_DS_UsrEvntMinorID;
		END_VAR;
	
	FUNCTION StoreUserEvent
		VAR_INPUT
			MajorID 	: UINT;
			MinorID 	: UINT;
			pThis 	: ^DSComm_Interface;
		END_VAR
		VAR_OUTPUT
			ErrorNo 	: DINT;
		END_VAR;
	
	FUNCTION DeleteUserEvent
		VAR_INPUT
			MajorID 	: UINT;
			MinorID 	: UINT;
			pThis 	: ^DSComm_Interface;
		END_VAR
		VAR_OUTPUT
			ErrorNo 	: DINT;
		END_VAR;
	
	FUNCTION GetpMajorID
		VAR_INPUT
			pMajorIDIn 	: ^DSComm::_DS_UsrEvntMajorID;
			MajorID 	: UINT;
		END_VAR
		VAR_OUTPUT
			pMajorIDOut 	: ^DSComm::_DS_UsrEvntMajorID;			//! <Variable Comment=" = nil: gesuchtes Element nicht gefunden und kein Platz mehr frei.&#13;&#10;&lt;&gt;nil: gesuchtes Element oder freien Platz gefunden." Name="GetpMajorID.pMajorIDOut"/>
		END_VAR;
	
	FUNCTION GetpMinorID
		VAR_INPUT
			pMinorIDIn 	: ^DSComm::_DS_UsrEvntMinorID;
			MinorID 	: UINT;
		END_VAR
		VAR_OUTPUT
			pMinorIDOut 	: ^DSComm::_DS_UsrEvntMinorID;			//! <Variable Comment=" = nil: gesuchtes Element nicht gefunden und kein Platz mehr frei.&#13;&#10;&lt;&gt;nil: gesuchtes Element oder freien Platz gefunden." Name="GetpMinorID.pMinorIDOut"/>
		END_VAR;
	
	FUNCTION DeleteMajorID
		VAR_INPUT
			pMajorIDIn 	: ^DSComm::_DS_UsrEvntMajorID;
			MajorID 	: UINT;
		END_VAR
		VAR_OUTPUT
			ErrorNo 	: DINT;
		END_VAR;
	
	FUNCTION DeleteMinorID
		VAR_INPUT
			pMinorIDIn 	: ^DSComm::_DS_UsrEvntMinorID;
			MinorID 	: UINT;
		END_VAR
		VAR_OUTPUT
			ErrorNo 	: DINT;
		END_VAR;
				//! <Function Comment="After calling this method, attempts are made to establish a TCP connection again.&#13;&#10;&#13;&#10;Nach Aufruf dieser Methode wird wieder versucht eine TCP-Verbindung aufzubauen." Name="StartTCPComm"/>
	FUNCTION GLOBAL StartTCPComm;
				//! <Function Comment="Wenn der Puffer Thread-Safe sein muss, dann muss &lt;statbuff&gt; eine lokale Variable sein." Name="BufferCreate"/>
	FUNCTION BufferCreate
		VAR_INPUT
			statbuff 	: ^void;
			statbuff_size 	: UDINT;
			expected_size 	: UDINT;
			MemMark 	: USINT;
		END_VAR
		VAR_OUTPUT
			RetPtr 	: ^void;
		END_VAR;
	
	FUNCTION BufferDestroy
		VAR_INPUT
			statbuff 	: ^void;
			buffer 	: ^void;
		END_VAR;
	
	FUNCTION SectionStart;
	
	FUNCTION SectionStop;
	
	FUNCTION GetRespData_GetProjectInfo
		VAR_INPUT
			pData 	: ^CHAR;
			pGetProjectInfoRsp 	: ^DSComm::_DS_GetProjectInfoResp;
		END_VAR;
	
	FUNCTION GetRespData_GetLocalClientList
		VAR_INPUT
			pData 	: ^CHAR;
			pGetLocalClientListRsp 	: ^_DS_GetLocalClientListResp;
			num 	: UDINT;
		END_VAR;
	
	FUNCTION GetRespData_GetLocalClientListDetails
		VAR_INPUT
			pData 	: ^CHAR;
			pGetLocalClientListDetailsRsp 	: ^DSComm::_DS_GetLocalClientDetailsResp;
			num 	: UDINT;
			SkipSize 	: BOOL;
		END_VAR;
	
	FUNCTION SendFragmentResponse
		VAR_INPUT
			UID 	: UDINT;
			ErrorCode 	: UDINT;
		END_VAR
		VAR_OUTPUT
			RetVal 	: DINT;
		END_VAR;
	
	FUNCTION GetBufferHdlEntry
		VAR_INPUT
			UID 	: UDINT;
		END_VAR
		VAR_OUTPUT
			Idx 	: DINT;
		END_VAR;
	
	FUNCTION GetFreeBufferHdlEntry
		VAR_OUTPUT
			Idx 	: DINT;
		END_VAR;
	
	FUNCTION FreeBufferHdlEntry
		VAR_INPUT
			idx 	: DINT;
		END_VAR;
				//! <Function Comment="When the alarm list changes, the method AlarmListUpdatePush() is called in the object that called this method.&#13;&#10;When an alarm is deleted, the method AlarmDeleteUpdatePush() is called in the object that called this method.&#13;&#10;&#13;&#10;Bei Änderungen der Alarmliste wird die Methode AlarmListUpdatePush() in jenem Objekt aufgerufen, welches diese Methode aufgerufen hat.&#13;&#10;Wenn Alarme gelöscht werden, dann wird die Methode AlarmDeleteUpdatePush() in jenem Objekt aufgerufen, welches diese Methode aufgerufen hat." Name="SubscribeAlarmListUpdate"/>
	FUNCTION GLOBAL SubscribeAlarmListUpdate
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="SubscribeAlarmListUpdate.pThis"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="SubscribeAlarmListUpdate.MessageID"/>
		END_VAR;
				//! <Function Comment="After calling this method, no more alarm list updates are passed to the AlarmListUpdatePush() method.&#13;&#10;&#13;&#10;Nach dem Aufruf dieser Methode werden Änderungen der Alarmliste nicht mehr an die Methode AlarmListUpdatePush() übergeben." Name="UnsubscribeAlarmListUpdate"/>
	FUNCTION GLOBAL UnsubscribeAlarmListUpdate
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="UnsubscribeAlarmListUpdate.pThis"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="UnsubscribeAlarmListUpdate.MessageID"/>
		END_VAR;
	
	FUNCTION GetRespData_AlarmListUpdate
		VAR_INPUT
			pData 	: ^CHAR;
			pAlarmListUpdate 	: ^DSComm::_DS_AlarmListUpdate;
			num 	: UDINT;
		END_VAR;
				//! <Function Comment="When a HotAlarm changes, the HotAlarmUpdatePush() method is called in the object that called this method.&#13;&#10;&#13;&#10;Wenn sich ein HotAlarm ändert, wird die Methode HotAlarmUpdatePush() in jenem Objekt aufgerufen, welches diese Methode aufgerufen hat." Name="SubscribeHotAlarmUpdate"/>
	FUNCTION GLOBAL SubscribeHotAlarmUpdate
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="SubscribeHotAlarmUpdate.pThis"/>
			pHotAlarm 	: ^_DS_HotAlarmAddCmd;			//! <Variable Comment="Pointer to the HotAlarm data.&#13;&#10;&#13;&#10;Zeiger auf die HotAlarm Daten." Name="SubscribeHotAlarmUpdate.pHotAlarm"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: the pointer &lt;pHotAlarm&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Zeiger &lt;pHotAlarm&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="SubscribeHotAlarmUpdate.MessageID"/>
		END_VAR;
				//! <Function Comment="After calling this method, HotAlarm changes are no longer passed to the HotAlarmtUpdatePush() method.&#13;&#10;&#13;&#10;Nach dem Aufruf dieser Methode werden Änderungen eines HotAlarms nicht mehr an die Methode HotAlarmtUpdatePush() übergeben." Name="UnsubscribeHotAlarmUpdate"/>
	FUNCTION GLOBAL UnsubscribeHotAlarmUpdate
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="UnsubscribeHotAlarmUpdate.pThis"/>
			pHotAlarm 	: ^_DS_HotAlarmSubCmd;			//! <Variable Comment="Pointer to the HotAlarm data.&#13;&#10;&#13;&#10;Zeiger auf die HotAlarm Daten." Name="UnsubscribeHotAlarmUpdate.pHotAlarm"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: the pointer &lt;pHotAlarm&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Zeiger &lt;pHotAlarm&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="UnsubscribeHotAlarmUpdate.MessageID"/>
		END_VAR;
	
	FUNCTION GetRespData_HotAlarmUpdate
		VAR_INPUT
			pData 	: ^CHAR;
			pHotAlarmUpdate 	: ^_DS_HotAlarmUpdate;
			num 	: UDINT;
		END_VAR;
				//! <Function Comment="Marks the specified alarms corresponding to &lt;toDelState&gt; as deleted.&#13;&#10;&#13;&#10;Markiert die angegebenen Alarme, die &lt;toDelState&gt; entsprechen, als gelöscht." Name="AlarmDelete"/>
	FUNCTION GLOBAL AlarmDelete
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="AlarmDelete.pThis"/>
			num 	: UDINT;			//! <Variable Comment="The number of passed entries.&#13;&#10;&#13;&#10;Anzahl der übergebenen Einträge." Name="AlarmDelete.num"/>
			toDelState 	: USINT;			//! <Variable Comment="Bitmask: 0 = all alarms, Bit 0 = all  acknowledged alarms, Bit 1 = all disappeared alarms.&#13;&#10;&#13;&#10;Bitmaske: 0 = Alle Alarme, Bit 0 = alle quittierten Alarme, Bit 1 = alle gegangenen Alarme." Name="AlarmDelete.toDelState"/>
			pAlarmID 	: ^UDINT;			//! <Variable Comment="Pointer to an array with &lt;num&gt; IDs of the alarm entries.&#13;&#10;&#13;&#10;Zeiger auf ein Array mit &lt;num&gt; IDs der Alarmeinträge." Name="AlarmDelete.pAlarmID"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_WRONG_PARAMETER: &lt;num&gt; is zero or the pointer &lt;pAlarm&gt; is invalid.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_WRONG_PARAMETER: der Wert von &lt;num&gt; ist null oder der Zeiger &lt;pAlarm&gt; ist ungültig.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="AlarmDelete.MessageID"/>
		END_VAR;
				//! <Function Comment="Marks alarms corresponding to &lt;toDelState&gt; as deleted.&#13;&#10;&#13;&#10;Markiert jene Alarme, die &lt;toDelState&gt; entsprechen, als gelöscht." Name="AlarmDeleteAll"/>
	FUNCTION GLOBAL AlarmDeleteAll
		VAR_INPUT
			pThis 	: ^DSComm_Interface;			//! <Variable Comment="Pointer to the calling object (DSComm_Interface).&#13;&#10;&#13;&#10;Zeiger auf das aufrufende Objekt (DSComm_Interface)." Name="AlarmDeleteAll.pThis"/>
			toDelState 	: USINT;			//! <Variable Comment="Bitmask: 0 = all alarms, Bit 0 = all  acknowledged alarms, Bit 1 = all disappeared alarms.&#13;&#10;&#13;&#10;Bitmaske: 0 = Alle Alarme, Bit 0 = alle quittierten Alarme, Bit 1 = alle gegangenen Alarme." Name="AlarmDeleteAll.toDelState"/>
		END_VAR
		VAR_OUTPUT
			MessageID 	: DINT;			//! <Variable Comment="&gt;= 0: Used to match the response with the corresponding command.&#13;&#10;  &lt; 0: Error.&#13;&#10;  ERR_MALLOC_SEND_BUFFER: not enough RAM for the send buffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: the command journal is full.&#13;&#10;  ERR_TCPIP: not all data has been transferred.&#13;&#10;  ERR_DS_RESET: DataService is in RESET state.&#13;&#10;  ERR_NO_USER_LOGIN: there is no user logged in.&#13;&#10;&#13;&#10;&gt;= 0: Dient zum zusammenfinden der Response mit dem entsprechendem Command.&#13;&#10;  &lt; 0: Fehler&#13;&#10;  ERR_MALLOC_SEND_BUFFER: zu wenig RAM für den Sendepuffer.&#13;&#10;  ERR_JOB_JOURNAL_FULL: die Auftragsverwaltung ist voll.&#13;&#10;  ERR_TCPIP: es wurden nicht alle Daten übertragen.&#13;&#10;  ERR_DS_RESET: DataService ist im RESET-Zustand.&#13;&#10;  ERR_NO_USER_LOGIN: Es ist kein Benutzer angemeldet." Name="AlarmDeleteAll.MessageID"/>
		END_VAR;
	
	FUNCTION GetRespData_GetValue
		VAR_INPUT
			pData 	: ^CHAR;
			pGetValueRsp 	: ^_DS_GetValueResp;
			num 	: UDINT;
		END_VAR;
	
	FUNCTION GetRespData_SetValue
		VAR_INPUT
			pData 	: ^CHAR;
			pSetValueRsp 	: ^_DS_SetValueResp;
			num 	: UDINT;
		END_VAR;
	
	FUNCTION GetRespData_RefListAdd
		VAR_INPUT
			pData 	: ^CHAR;
			pRefListAddRsp 	: ^_DS_RefListAddResp;
			num 	: UDINT;
		END_VAR;
	
	FUNCTION GetRespData_RefListSub
		VAR_INPUT
			pData 	: ^CHAR;
			pRefListSubRsp 	: ^_DS_RefListSubResp;
			num 	: UDINT;
		END_VAR;
	
	FUNCTION GetRespData_StationList
		VAR_INPUT
			pData 	: ^CHAR;
			pStationListRsp 	: ^_DS_StationListResp;
			num 	: UDINT;
		END_VAR;
	
	FUNCTION GetRespData_StationStatus
		VAR_INPUT
			pData 	: ^CHAR;
			pStationStatusRsp 	: ^_DS_StationStatusResp;
			num 	: UDINT;
		END_VAR;
	
	FUNCTION GetRespData_EventjournalDel
		VAR_INPUT
			pData 	: ^CHAR;
			pEventjournalDelRsp 	: ^_DS_EventjournalDelResp;
			num 	: UDINT;
		END_VAR;
	
	FUNCTION GetRespData_EventjournalQuitAlarm
		VAR_INPUT
			pData 	: ^CHAR;
			pEventjournalQuitAlarmRsp 	: ^_DS_EventjournalQuitAlarmResp;
			num 	: UDINT;
		END_VAR;
	
	FUNCTION GetRespData_EventjournalQuitAll
		VAR_INPUT
			pData 	: ^CHAR;
			pEventjournalQuitAllRsp 	: ^_DS_EventjournalQuitAllResp;
			num 	: UDINT;
		END_VAR;
	
	FUNCTION GetRespData_AlarmDelete
		VAR_INPUT
			pData 	: ^CHAR;
			pAlarmDeleteRsp 	: ^_DS_AlarmDeleteResp;
			num 	: UDINT;
		END_VAR;
	
	FUNCTION GetRespData_AlarmDeleteUpdate
		VAR_INPUT
			pData 	: ^CHAR;
			pAlarmDeleteUpd 	: ^_DS_AlarmDeleteUpdate;
			num 	: UDINT;
		END_VAR;
	
	FUNCTION GetRespData_CheckAccessLevel
		VAR_INPUT
			pData 	: ^CHAR;
			pCheckAccessLevelRsp 	: ^_DS_CheckAccessLevelResp;
			num 	: UDINT;
		END_VAR;
	
	FUNCTION GetRespData_CreateUser
		VAR_INPUT
			pData 	: ^CHAR;
			pCreateUserRsp 	: ^_DS_CreateUserResp;
			num 	: UDINT;
		END_VAR;
	
	FUNCTION GetRespData_ChangeUserSettings
		VAR_INPUT
			pData 	: ^CHAR;
			pChangeUserSettingsRsp 	: ^_DS_ChangeUserSettingsResp;
			num 	: UDINT;
		END_VAR;
	
	FUNCTION GetRespData_DeleteUser
		VAR_INPUT
			pData 	: ^CHAR;
			pDeleteUserRsp 	: ^_DS_DeleteUserResp;
			num 	: UDINT;
		END_VAR;
	
	FUNCTION GetRespData_CreateRole
		VAR_INPUT
			pData 	: ^CHAR;
			pCreateRoleRsp 	: ^_DS_CreateRoleResp;
			num 	: UDINT;
		END_VAR;
	
	FUNCTION GetRespData_ChangeRole
		VAR_INPUT
			pData 	: ^CHAR;
			pChangeRoleRsp 	: ^_DS_ChangeRoleResp;
			num 	: UDINT;
		END_VAR;
	
	FUNCTION GetRespData_DeleteRole
		VAR_INPUT
			pData 	: ^CHAR;
			pDeleteRoleRsp 	: ^_DS_DeleteRoleResp;
			num 	: UDINT;
		END_VAR;
				//! <Function Comment="Returns the number of characters, not bytes in the UTF8-String. Without end character \0.&#13;&#10;&#13;&#10;Liefert die Anzahl der Zeichen, nicht der Bytes, im UTF8-String. Ohne Endezeichen \0." Name="StrLenUtf8"/>
	FUNCTION GLOBAL StrLenUtf8
		VAR_INPUT
			Str_Utf8 	: ^CHAR;			//! <Variable Comment="Pointer to a null-terminated UTF8-String.&#13;&#10;&#13;&#10;Zeiger auf einen Null-terminierten UTF8-String." Name="StrLenUtf8.Str_Utf8"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;			//! <Variable Comment="Number of characters, not bytes in the UTF8-String. Without end character \0.&#13;&#10;&#13;&#10;Anzahl der Zeichen, nicht der Bytes, im UTF8-String. Ohne Endezeichen \0." Name="StrLenUtf8.retcode"/>
		END_VAR;
	
	FUNCTION GetRespData_GetState
		VAR_INPUT
			pData 	: ^CHAR;
			pGetStateRsp 	: ^_DS_GetStateResp;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Taskname::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using String
#pragma usingLtd SigCLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB DSComm::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_DSCOMM
2$UINT, 3$UINT, (SIZEOF(::DSComm))$UINT, 
9$UINT, 3$UINT, 0$UINT, 
TO_UDINT(3848629641), "DSComm", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::DSComm.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::DSComm.Online.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1858763116), "Online", 
(::DSComm.ClassState.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1096059024), "ClassState", 
(::DSComm.MaxReconnectTime.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1304298081), "MaxReconnectTime", 
(::DSComm.DS_Version.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2922881490), "DS_Version", 
(::DSComm.DS_BuildNo.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1207855178), "DS_BuildNo", 
(::DSComm.Taskname.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(3136881463), "Taskname", 
(::DSComm.ErrorSend.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3711595188), "ErrorSend", 
(::DSComm.ErrorReceive.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2505317415), "ErrorReceive", 
//Clients:
(::DSComm.cIPaddr.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3179316328), "cIPaddr", TO_UDINT(1850111279), "String", 1$UINT, 11$UINT, 
(::DSComm.SigCLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(77440046), "SigCLib", TO_UDINT(77440046), "SigCLib", 0$UINT, 37$UINT, 
(::DSComm.ThreadName.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(394930896), "ThreadName", TO_UDINT(1850111279), "String", 1$UINT, 11$UINT, 
END_FUNCTION


#define USER_CNT_DSComm 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_DSComm] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION DSComm::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_DSComm, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Write		:= #M_WR_DIRECT();
	vmt.CmdTable.Init		:= #Init();
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	MaxReconnectTime.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF MaxReconnectTime.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, Taskname.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Read		:= #Taskname::Read();
	Taskname.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF Taskname.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

#pragma usingLtd DSComm_Interface

//{{LSL_IMPLEMENTATION
#include <lsl_st_tcp_user.h>

//#pragma using DSComm_Interface

FUNCTION VIRTUAL GLOBAL DSComm::Init
VAR
  dRet              : DINT;
  taskhandle	      : UDINT;
  pProgressInfoLoc 	: ^DSCOMM::_DS_ProgressInfo;
	tmpI              : DINT;
  szTaskName        : array[0..40] of char;
END_VAR

  if _firstscan then
    // -------------------------------------------------------------------
    // - IP-Adresse des DataService holen
    // -------------------------------------------------------------------
    if GetIpOfServer(pChar:=#IPaddr[0], sigclib_arraysize(IPaddr)) = FALSE then
      // Fehler IP Adresse nicht gesetzt
      ClassState := ERR_IP_ADDR_MISSING;
    end_if;      

    // -------------------------------------------------------------------
    // - Pipe zum Kommunikationa-Task anlegen
    // -------------------------------------------------------------------
    pPipe := cPipe_CTor(sizeof(_DS_CommTask_Rec), DS_RECORD_NO_PIPE);
    if pPipe = nil then
      ClassState := ERR_CREATE_COMM_CHAN;
    end_if;

    // --------------------------------------------------------------------------
    // - Pufferverwaltung für fragmentierte Daten initialisieren.
    // - Pro fragmentierter Übertragung wird ein Puffer allokiert (ReceiveData())
    // - und in BufferHandling[] verwaltet.
    // --------------------------------------------------------------------------
    for tmpI:=0 to MaxBuffers-1 do
      BufferHandling[tmpI].pRecvBufferStart := nil;
    end_for;

    // ----------------------------------------------------------------------
    // - Empfangspuffer und Datenpuffer für nicht fragmentierte Daten anlegen
    // ----------------------------------------------------------------------
    RecvBufferSize := MaxDSBuffSize;
    pRecvBufferStatic$^void := sigclib_mallocV1(RecvBufferSize, MEM_Mark_DS_Comm);
  	if pRecvBufferStatic = NIL then
      ClassState := ERR_MEM_ALLOC_INIT;
      TRACE("Error: zuwenig RAM fuer den Empfangspuffer");
    end_if;

    DataBufferSize := RecvBufferSize * 3 / 2; //+50% ist garantiert groß genug
	  pDataBufferStatic$^void := sigclib_mallocV1(DataBufferSize, MEM_Mark_DS_Comm);
  	if pDataBufferStatic = NIL then
      ClassState := ERR_MEM_ALLOC_INIT;
  	  sigclib_free(pRecvBufferStatic);
      TRACE("Error: zuwenig RAM fuer den Datenpuffer");
    end_if;

    pMajorID$^void := sigclib_mallocV1(DS_MAJOR_ID_ELMT_CNT*sizeof(_DS_UsrEvntMajorID), MEM_Mark_DS_Comm);
  	if pMajorID = NIL then
      ClassState := ERR_MEM_ALLOC_INIT;
  	  sigclib_free(pRecvBufferStatic);
  	  sigclib_free(pDataBufferStatic);
      TRACE("Error: zuwenig RAM fuer den UserEvent Puffer");
    end_if;
    _memset(dest:=pMajorID, usByte:=0, cntr:=DS_MAJOR_ID_ELMT_CNT*sizeof(_DS_UsrEvntMajorID));

    // -------------------------------------------------------------------
    // - Zeiger auf TCP_USER-Interface holen
    // -------------------------------------------------------------------
    lsl_tcp_user := NIL;
    OS_CILGet("TCP_USER", #lsl_tcp_user);
  	if lsl_tcp_user = NIL then
      ClassState := ERR_CIL_IF_NOT_FOUND;
      TRACE("Error: Interface TCP_USER nicht vorhanden.");
    end_if;
   
    // -------------------------------------------------------------------
    // - Communication thread erzeugen 
    // -------------------------------------------------------------------
    dRet := CreateTaskName(pTaskName := #szTaskName[0]);
    if (dRet = 0) then
      // Create Task
      taskhandle := sigclib_thread_create(#CommTask(), DS_TCPCom_TaskPrio, this, #szTaskName[0]);
      if taskhandle = NIL then
        // is any error detected
        ClassState := ERR_CREATE_COMM_THREAD;
      else
        eComSteps := TCPCom_StartConnecting;
      end_if;
    end_if;

    // -------------------------------------------------------------------
    // - Timeouts in Millisekunden parametrieren.
    // -------------------------------------------------------------------
    TCPparameter.TimeOutSend       := DS_SEND_TIMEOUT;
    TCPparameter.TimeOutRecv       := DS_RECV_TIMEOUT;
    TCPparameter.TimeOutAlive      := DS_TCPCom_AliveSignalTimeout;
    TCPparameter.TimeNewConnection := DS_TCPCom_NewConnectionTime;
    TCPparameter.TimeAliveSignal   := DS_TCPCom_AliveSignalTime;

    RespTimeout     := DS_RESP_TIMEOUT;      //Response-Timeout für normale Kommandos
    RespTimeoutLong := DS_RESP_TIMEOUT_LONG; //Response-Timeout für lang dauernde Kommandos

    TimeStamp.LastSendPackAlive := ops.tAbsolute;

    // -------------------------------------------------------------------
    // - Auftragsverwaltung initialisieren.
    // -------------------------------------------------------------------
    _MessageID := 0;

    pProgressInfoLoc := #ProgressInfo[0];
    for tmpI:=0 to DS_PROGRESS_INFO_ELMT_CNT - 1 do
      pProgressInfoLoc^.pThis    := nil;
      pProgressInfoLoc^.HandleID := DS_HANDLE_ID_FREE;
      pProgressInfoLoc += sizeof(DSCOMM::_DS_ProgressInfo);
    end_for;

    CancelCommandJobs.Capacity := sigclib_arraysize(CancelCommandJobArray);
    CancelCommandJobs.Free     := CancelCommandJobs.Capacity;
    CancelCommandJobs.pJobs    := #CancelCommandJobArray[0];

    GetVersionJobs.Capacity   := sigclib_arraysize(GetVersionJobArray);
    GetVersionJobs.Free       := GetVersionJobs.Capacity;
    GetVersionJobs.pJobs      := #GetVersionJobArray[0];

    GetProjectInfoJobs.Capacity:= sigclib_arraysize(GetProjectInfoJobArray);
    GetProjectInfoJobs.Free    := GetProjectInfoJobs.Capacity;
    GetProjectInfoJobs.pJobs   := #GetProjectInfoJobArray[0];

    SubscribeStateJobs.Capacity := sigclib_arraysize(SubscribeStateJobArray);
    SubscribeStateJobs.Free     := SubscribeStateJobs.Capacity;
    SubscribeStateJobs.pJobs    := #SubscribeStateJobArray[0];

    UnsubscribeStateJobs.Capacity := sigclib_arraysize(UnsubscribeStateJobArray);
    UnsubscribeStateJobs.Free     := UnsubscribeStateJobs.Capacity;
    UnsubscribeStateJobs.pJobs    := #UnsubscribeStateJobArray[0];

    GetStateJobs.Capacity         := sigclib_arraysize(GetStateJobArray);
    GetStateJobs.Free             := GetStateJobs.Capacity;
    GetStateJobs.pJobs            := #GetStateJobArray[0];

    LoopJobs.Capacity         := sigclib_arraysize(LoopJobArray);
    LoopJobs.Free             := LoopJobs.Capacity;
    LoopJobs.pJobs            := #LoopJobArray[0];

    RecipeLoadJobs.Capacity   := sigclib_arraysize(RecipeLoadJobArray);
    RecipeLoadJobs.Free       := RecipeLoadJobs.Capacity;
    RecipeLoadJobs.pJobs      := #RecipeLoadJobArray[0];

    RecipeSaveJobs.Capacity   := sigclib_arraysize(RecipeSaveJobArray);
    RecipeSaveJobs.Free       := RecipeSaveJobs.Capacity;
    RecipeSaveJobs.pJobs      := #RecipeSaveJobArray[0];

    SendToAllJobs.Capacity    := sigclib_arraysize(SendToAllJobArray);
    SendToAllJobs.Free        := SendToAllJobs.Capacity;
    SendToAllJobs.pJobs       := #SendToAllJobArray[0];

    ResetDataserviceJobs.Capacity    := sigclib_arraysize(ResetDataserviceJobArray);
    ResetDataserviceJobs.Free        := ResetDataserviceJobs.Capacity;
    ResetDataserviceJobs.pJobs       := #ResetDataserviceJobArray[0];

    RestartDataserviceJobs.Capacity  := sigclib_arraysize(RestartDataserviceJobArray);
    RestartDataserviceJobs.Free      := RestartDataserviceJobs.Capacity;
    RestartDataserviceJobs.pJobs     := #RestartDataserviceJobArray[0];

    AddLocalClientJobs.Capacity      := sigclib_arraysize(AddLocalClientJobArray);
    AddLocalClientJobs.Free          := AddLocalClientJobs.Capacity;
    AddLocalClientJobs.pJobs         := #AddLocalClientJobArray[0];

    AddLocalClientRangeJobs.Capacity := sigclib_arraysize(AddLocalClientRangeJobArray);
    AddLocalClientRangeJobs.Free     := AddLocalClientRangeJobs.Capacity;
    AddLocalClientRangeJobs.pJobs    := #AddLocalClientRangeJobArray[0];

    RemoveThisLocalClientJobs.Capacity:= sigclib_arraysize(RemoveThisLocalClientJobArray);
    RemoveThisLocalClientJobs.Free    := RemoveThisLocalClientJobs.Capacity;
    RemoveThisLocalClientJobs.pJobs   := #RemoveThisLocalClientJobArray[0];

    RemoveLocalClientJobs.Capacity   := sigclib_arraysize(RemoveLocalClientJobArray);
    RemoveLocalClientJobs.Free       := RemoveLocalClientJobs.Capacity;
    RemoveLocalClientJobs.pJobs      := #RemoveLocalClientJobArray[0];

    RemoveLocalClientRangeJobs.Capacity:= sigclib_arraysize(RemoveLocalClientRangeJobArray);
    RemoveLocalClientRangeJobs.Free    := RemoveLocalClientRangeJobs.Capacity;
    RemoveLocalClientRangeJobs.pJobs   := #RemoveLocalClientRangeJobArray[0];

    ClearLocalClientListJobs.Capacity  := sigclib_arraysize(ClearLocalClientListJobArray);
    ClearLocalClientListJobs.Free      := ClearLocalClientListJobs.Capacity;
    ClearLocalClientListJobs.pJobs     := #ClearLocalClientListJobArray[0];

    GetCurrentIDJobs.Capacity := sigclib_arraysize(GetCurrentIDJobArray);
    GetCurrentIDJobs.Free     := GetCurrentIDJobs.Capacity;
    GetCurrentIDJobs.pJobs    := #GetCurrentIDJobArray[0];

    GetLocalClientListJobs.Capacity := sigclib_arraysize(GetLocalClientListJobArray);
    GetLocalClientListJobs.Free     := GetLocalClientListJobs.Capacity;
    GetLocalClientListJobs.pJobs    := #GetLocalClientListJobArray[0];

    GetLocalClientListDetailsJobs.Capacity := sigclib_arraysize(GetLocalClientListDetailsJobArray);
    GetLocalClientListDetailsJobs.Free     := GetLocalClientListDetailsJobs.Capacity;
    GetLocalClientListDetailsJobs.pJobs    := #GetLocalClientListDetailsJobArray[0];

    GetLocalClientByIDJobs.Capacity := sigclib_arraysize(GetLocalClientByIDJobArray);
    GetLocalClientByIDJobs.Free     := GetLocalClientByIDJobs.Capacity;
    GetLocalClientByIDJobs.pJobs    := #GetLocalClientByIDJobArray[0];

    UserLoginJobs.Capacity    := sigclib_arraysize(UserLoginJobArray);
    UserLoginJobs.Free        := UserLoginJobs.Capacity;
    UserLoginJobs.pJobs       := #UserLoginJobArray[0];

    UserLogoutJobs.Capacity   := sigclib_arraysize(UserLogoutJobArray);
    UserLogoutJobs.Free       := UserLogoutJobs.Capacity;
    UserLogoutJobs.pJobs      := #UserLoginJobArray[0];

    UserPwdChangeJobs.Capacity := sigclib_arraysize(UserPwdChangeJobArray);
    UserPwdChangeJobs.Free     := UserPwdChangeJobs.Capacity;
    UserPwdChangeJobs.pJobs    := #UserPwdChangeJobArray[0];

    CheckAccessLevelJobs.Capacity := sigclib_arraysize(CheckAccessLevelJobArray);
    CheckAccessLevelJobs.Free     := CheckAccessLevelJobs.Capacity;
    CheckAccessLevelJobs.pJobs    := #CheckAccessLevelJobArray[0];

    CreateUserJobs.Capacity   := sigclib_arraysize(CreateUserJobArray);
    CreateUserJobs.Free       := CreateUserJobs.Capacity;
    CreateUserJobs.pJobs      := #CreateUserJobArray[0];

    ChangeUserSettingsJobs.Capacity := sigclib_arraysize(ChangeUserSettingsJobArray);
    ChangeUserSettingsJobs.Free     := ChangeUserSettingsJobs.Capacity;
    ChangeUserSettingsJobs.pJobs    := #ChangeUserSettingsJobArray[0];

    DeleteUserJobs.Capacity   := sigclib_arraysize(DeleteUserJobArray);
    DeleteUserJobs.Free       := DeleteUserJobs.Capacity;
    DeleteUserJobs.pJobs      := #DeleteUserJobArray[0];

    GetUserListJobs.Capacity  := sigclib_arraysize(GetUserListJobArray);
    GetUserListJobs.Free      := GetUserListJobs.Capacity;
    GetUserListJobs.pJobs     := #GetUserListJobArray[0];

    GetUserDetailsJobs.Capacity  := sigclib_arraysize(GetUserDetailsJobArray);
    GetUserDetailsJobs.Free      := GetUserDetailsJobs.Capacity;
    GetUserDetailsJobs.pJobs     := #GetUserDetailsJobArray[0];

    CreateRoleJobs.Capacity   := sigclib_arraysize(CreateRoleJobArray);
    CreateRoleJobs.Free       := CreateRoleJobs.Capacity;
    CreateRoleJobs.pJobs      := #CreateRoleJobArray[0];

    ChangeRoleJobs.Capacity   := sigclib_arraysize(ChangeRoleJobArray);
    ChangeRoleJobs.Free       := ChangeRoleJobs.Capacity;
    ChangeRoleJobs.pJobs      := #ChangeRoleJobArray[0];

    DeleteRoleJobs.Capacity   := sigclib_arraysize(DeleteRoleJobArray);
    DeleteRoleJobs.Free       := DeleteRoleJobs.Capacity;
    DeleteRoleJobs.pJobs      := #DeleteRoleJobArray[0];

    GetRoleListJobs.Capacity  := sigclib_arraysize(GetRoleListJobArray);
    GetRoleListJobs.Free      := GetRoleListJobs.Capacity;
    GetRoleListJobs.pJobs     := #GetRoleListJobArray[0];

    GetRoleDetailsJobs.Capacity  := sigclib_arraysize(GetRoleDetailsJobArray);
    GetRoleDetailsJobs.Free      := GetRoleDetailsJobs.Capacity;
    GetRoleDetailsJobs.pJobs     := #GetRoleDetailsJobArray[0];

    GetVarIdFromNameJobs.Capacity := sigclib_arraysize(GetVarIdFromNameJobArray);
    GetVarIdFromNameJobs.Free     := GetVarIdFromNameJobs.Capacity;
    GetVarIdFromNameJobs.pJobs    := #GetVarIdFromNameJobArray[0];

    GetVarIdFromLasalIdJobs.Capacity  := sigclib_arraysize(GetVarIdFromLasalIdJobArray);
    GetVarIdFromLasalIdJobs.Free      := GetVarIdFromLasalIdJobs.Capacity;
    GetVarIdFromLasalIdJobs.pJobs     := #GetVarIdFromLasalIdJobArray[0];

    GetLasalIdFromNameJobs.Capacity := sigclib_arraysize(GetLasalIdFromNameJobArray);
    GetLasalIdFromNameJobs.Free     := GetLasalIdFromNameJobs.Capacity;
    GetLasalIdFromNameJobs.pJobs    := #GetLasalIdFromNameJobArray[0];

    GetLasalIdFromVarIdJobs.Capacity := sigclib_arraysize(GetLasalIdFromVarIdJobArray);
    GetLasalIdFromVarIdJobs.Free     := GetLasalIdFromVarIdJobs.Capacity;
    GetLasalIdFromVarIdJobs.pJobs    := #GetLasalIdFromVarIdJobArray[0];

    GetNameFromVarIdJobs.Capacity := sigclib_arraysize(GetNameFromVarIdJobArray);
    GetNameFromVarIdJobs.Free     := GetNameFromVarIdJobs.Capacity;
    GetNameFromVarIdJobs.pJobs    := #GetNameFromVarIdJobArray[0];

    GetNameFromLasalIdJobs.Capacity := sigclib_arraysize(GetNameFromLasalIdJobArray);
    GetNameFromLasalIdJobs.Free     := GetNameFromLasalIdJobs.Capacity;
    GetNameFromLasalIdJobs.pJobs    := #GetNameFromLasalIdJobArray[0];

    GetDpListJobs.Capacity    := sigclib_arraysize(GetDpListJobArray);
    GetDpListJobs.Free        := GetDpListJobs.Capacity;
    GetDpListJobs.pJobs       := #GetDpListJobArray[0];

    GetDpInfoJobs.Capacity    := sigclib_arraysize(GetDpInfoJobArray);
    GetDpInfoJobs.Free        := GetDpInfoJobs.Capacity;
    GetDpInfoJobs.pJobs       := #GetDpInfoJobArray[0];

    GetVarIdFromCRCJobs.Capacity := sigclib_arraysize(GetVarIdFromCRCJobArray);
    GetVarIdFromCRCJobs.Free     := GetVarIdFromCRCJobs.Capacity;
    GetVarIdFromCRCJobs.pJobs    := #GetVarIdFromCRCJobArray[0];

    GetCRCfromVarIdJobs.Capacity := sigclib_arraysize(GetCRCfromVarIdJobArray);
    GetCRCfromVarIdJobs.Free     := GetCRCfromVarIdJobs.Capacity;
    GetCRCfromVarIdJobs.pJobs    := #GetCRCfromVarIdJobArray[0];

    GetValueJobs.Capacity     := sigclib_arraysize(GetValueJobArray);
    GetValueJobs.Free         := GetValueJobs.Capacity;
    GetValueJobs.pJobs        := #GetValueJobArray[0];

    SetValueJobs.Capacity     := sigclib_arraysize(SetValueJobArray);
    SetValueJobs.Free         := SetValueJobs.Capacity;
    SetValueJobs.pJobs        := #SetValueJobArray[0];
    
    GetStringJobs.Capacity    := sigclib_arraysize(GetStringJobArray);
    GetStringJobs.Free        := GetStringJobs.Capacity;
    GetStringJobs.pJobs       := #GetStringJobArray[0];

    SetStringJobs.Capacity    := sigclib_arraysize(SetStringJobArray);
    SetStringJobs.Free        := SetStringJobs.Capacity;
    SetStringJobs.pJobs       := #SetStringJobArray[0];

    IncValueJobs.Capacity     := sigclib_arraysize(IncValueJobArray);
    IncValueJobs.Free         := IncValueJobs.Capacity;
    IncValueJobs.pJobs        := #IncValueJobArray[0];

    DecValueJobs.Capacity     := sigclib_arraysize(DecValueJobArray);
    DecValueJobs.Free         := DecValueJobs.Capacity;
    DecValueJobs.pJobs        := #DecValueJobArray[0];

    RefListAddJobs.Capacity   := sigclib_arraysize(RefListAddJobArray);
    RefListAddJobs.Free       := RefListAddJobs.Capacity;
    RefListAddJobs.pJobs      := #RefListAddJobArray[0];

    RefListSubJobs.Capacity   := sigclib_arraysize(RefListSubJobArray);
    RefListSubJobs.Free       := RefListSubJobs.Capacity;
    RefListSubJobs.pJobs      := #RefListSubJobArray[0];

    GetStationListJobs.Capacity := sigclib_arraysize(GetStationListJobArray);
    GetStationListJobs.Free     := GetStationListJobs.Capacity;
    GetStationListJobs.pJobs    := #GetStationListJobArray[0];

    GetStationStatusJobs.Capacity  := sigclib_arraysize(GetStationStatusJobArray);
    GetStationStatusJobs.Free      := GetStationStatusJobs.Capacity;
    GetStationStatusJobs.pJobs     := #GetStationStatusJobArray[0];

    FileOpenJobs.Capacity     := sigclib_arraysize(FileOpenJobArray);
    FileOpenJobs.Free         := FileOpenJobs.Capacity;
    FileOpenJobs.pJobs        := #FileOpenJobArray[0];

    FileCloseJobs.Capacity    := sigclib_arraysize(FileCloseJobArray);
    FileCloseJobs.Free        := FileCloseJobs.Capacity;
    FileCloseJobs.pJobs       := #FileCloseJobArray[0];

    FileSeekJobs.Capacity     := sigclib_arraysize(FileSeekJobArray);
    FileSeekJobs.Free         := FileSeekJobs.Capacity;
    FileSeekJobs.pJobs        := #FileSeekJobArray[0];

    FileTellJobs.Capacity     := sigclib_arraysize(FileTellJobArray);
    FileTellJobs.Free         := FileTellJobs.Capacity;
    FileTellJobs.pJobs        := #FileTellJobArray[0];

    FileReadJobs.Capacity     := sigclib_arraysize(FileReadJobArray);
    FileReadJobs.Free         := FileReadJobs.Capacity;
    FileReadJobs.pJobs        := #FileReadJobArray[0];

    FileWriteJobs.Capacity    := sigclib_arraysize(FileWriteJobArray);
    FileWriteJobs.Free        := FileWriteJobs.Capacity;
    FileWriteJobs.pJobs       := #FileWriteJobArray[0];

    FileGetJobs.Capacity      := sigclib_arraysize(FileGetJobArray);
    FileGetJobs.Free          := FileGetJobs.Capacity;
    FileGetJobs.pJobs         := #FileGetJobArray[0];

    FilePutJobs.Capacity      := sigclib_arraysize(FilePutJobArray);
    FilePutJobs.Free          := FilePutJobs.Capacity;
    FilePutJobs.pJobs         := #FilePutJobArray[0];

    FileLengthJobs.Capacity   := sigclib_arraysize(FileLengthJobArray);
    FileLengthJobs.Free       := FileLengthJobs.Capacity;
    FileLengthJobs.pJobs      := #FileLengthJobArray[0];

    FileContentJobs.Capacity  := sigclib_arraysize(FileContentJobArray);
    FileContentJobs.Free      := FileContentJobs.Capacity;
    FileContentJobs.pJobs     := #FileContentJobArray[0];

    DirCreateJobs.Capacity    := sigclib_arraysize(DirCreateJobArray);
    DirCreateJobs.Free        := DirCreateJobs.Capacity;
    DirCreateJobs.pJobs       := #DirCreateJobArray[0];

    DirReadJobs.Capacity      := sigclib_arraysize(DirReadJobArray);
    DirReadJobs.Free          := DirReadJobs.Capacity;
    DirReadJobs.pJobs         := #DirReadJobArray[0];

    FileRemoveJobs.Capacity   := sigclib_arraysize(FileRemoveJobArray);
    FileRemoveJobs.Free       := FileRemoveJobs.Capacity;
    FileRemoveJobs.pJobs      := #FileRemoveJobArray[0];

    FileCopyJobs.Capacity     := sigclib_arraysize(FileCopyJobArray);
    FileCopyJobs.Free         := FileCopyJobs.Capacity;
    FileCopyJobs.pJobs        := #FileCopyJobArray[0];

    FileInfoJobs.Capacity     := sigclib_arraysize(FileInfoJobArray);
    FileInfoJobs.Free         := FileInfoJobs.Capacity;
    FileInfoJobs.pJobs        := #FileInfoJobArray[0];

    FileRenameJobs.Capacity   := sigclib_arraysize(FileRenameJobArray);
    FileRenameJobs.Free       := FileRenameJobs.Capacity;
    FileRenameJobs.pJobs      := #FileRenameJobArray[0];

    FileSetAttributeJobs.Capacity := sigclib_arraysize(FileSetAttributeJobArray);
    FileSetAttributeJobs.Free     := FileSetAttributeJobs.Capacity;
    FileSetAttributeJobs.pJobs    := #FileSetAttributeJobArray[0];

    GetDriveListJobs.Capacity := sigclib_arraysize(GetDriveListJobArray);
    GetDriveListJobs.Free     := GetDriveListJobs.Capacity;
    GetDriveListJobs.pJobs    := #GetDriveListJobArray[0];

    FileMoveJobs.Capacity     := sigclib_arraysize(FileMoveJobArray);
    FileMoveJobs.Free         := FileMoveJobs.Capacity;
    FileMoveJobs.pJobs        := #FileMoveJobArray[0];

    EventjournalAddJobs.Capacity  := sigclib_arraysize(EventjournalAddJobArray);
    EventjournalAddJobs.Free      := EventjournalAddJobs.Capacity;
    EventjournalAddJobs.pJobs     := #EventjournalAddJobArray[0];

    EventjournalGetJobs.Capacity  := sigclib_arraysize(EventjournalGetJobArray);
    EventjournalGetJobs.Free      := EventjournalGetJobs.Capacity;
    EventjournalGetJobs.pJobs     := #EventjournalGetJobArray[0];

    EventjournalGetAllJobs.Capacity  := sigclib_arraysize(EventjournalGetAllJobArray);
    EventjournalGetAllJobs.Free      := EventjournalGetAllJobs.Capacity;
    EventjournalGetAllJobs.pJobs     := #EventjournalGetAllJobArray[0];

    EventjournalDelJobs.Capacity  := sigclib_arraysize(EventjournalDelJobArray);
    EventjournalDelJobs.Free      := EventjournalDelJobs.Capacity;
    EventjournalDelJobs.pJobs     := #EventjournalDelJobArray[0];

    EventjournalDelAllJobs.Capacity  := sigclib_arraysize(EventjournalDelAllJobArray);
    EventjournalDelAllJobs.Free      := EventjournalDelAllJobs.Capacity;
    EventjournalDelAllJobs.pJobs     := #EventjournalDelAllJobArray[0];

    EventjournalQuitAlarmJobs.Capacity := sigclib_arraysize(EventjournalQuitAlarmJobArray);
    EventjournalQuitAlarmJobs.Free     := EventjournalQuitAlarmJobs.Capacity;
    EventjournalQuitAlarmJobs.pJobs    := #EventjournalQuitAlarmJobArray[0];

    EventjournalQuitAllJobs.Capacity  := sigclib_arraysize(EventjournalQuitAllJobArray);
    EventjournalQuitAllJobs.Free      := EventjournalQuitAllJobs.Capacity;
    EventjournalQuitAllJobs.pJobs     := #EventjournalQuitAllJobArray[0];

    SendUserEventJobs.Capacity        := sigclib_arraysize(SendUserEventJobArray);
    SendUserEventJobs.Free            := SendUserEventJobs.Capacity;
    SendUserEventJobs.pJobs           := #SendUserEventJobArray[0];

    AlarmListUpdateAddJobs.Capacity := sigclib_arraysize(AlarmListUpdateAddJobArray);
    AlarmListUpdateAddJobs.Free     := AlarmListUpdateAddJobs.Capacity;
    AlarmListUpdateAddJobs.pJobs    := #AlarmListUpdateAddJobArray[0];

    AlarmListUpdateSubJobs.Capacity := sigclib_arraysize(AlarmListUpdateSubJobArray);
    AlarmListUpdateSubJobs.Free     := AlarmListUpdateSubJobs.Capacity;
    AlarmListUpdateSubJobs.pJobs    := #AlarmListUpdateSubJobArray[0];

    HotAlarmUpdateAddJobs.Capacity  := sigclib_arraysize(HotAlarmUpdateAddJobArray);
    HotAlarmUpdateAddJobs.Free      := HotAlarmUpdateAddJobs.Capacity;
    HotAlarmUpdateAddJobs.pJobs     := #HotAlarmUpdateAddJobArray[0];

    HotAlarmUpdateSubJobs.Capacity  := sigclib_arraysize(HotAlarmUpdateSubJobArray);
    HotAlarmUpdateSubJobs.Free      := HotAlarmUpdateSubJobs.Capacity;
    HotAlarmUpdateSubJobs.pJobs     := #HotAlarmUpdateSubJobArray[0];

    AlarmDeleteJobs.Capacity        := sigclib_arraysize(AlarmDeleteJobArray);
    AlarmDeleteJobs.Free            := AlarmDeleteJobs.Capacity;
    AlarmDeleteJobs.pJobs           := #AlarmDeleteJobArray[0];

    AlarmDeleteAllJobs.Capacity     := sigclib_arraysize(AlarmDeleteAllJobArray);
    AlarmDeleteAllJobs.Free         := AlarmDeleteAllJobs.Capacity;
    AlarmDeleteAllJobs.pJobs        := #AlarmDeleteAllJobArray[0];
  end_if;

END_FUNCTION

(*
FUNCTION DSComm::CreateTaskName
VAR_INPUT
  pTaskName 	: ^CHAR;
END_VAR
VAR_OUTPUT
  Retcode 	  : DINT;
END_VAR
VAR
  udCRC32       : UDINT;
  udStrLen      : UDINT;
  szObjectName  : ARRAY [0..255] OF CHAR;
  szCRC32       : ARRAY [0..15]  OF CHAR;
END_VAR

  Retcode := 0;

  if (pTaskName = NIL) then
    Retcode := -1001;
    return;
  end_if;


  SigCLib.StrCpy(dst0 := pTaskName,
                 src0 := TCPCom_TaskName);

  _GetObjName(pThis := this,
              pName := #szObjectName[0]);

  udStrLen := _StrLen(src := #szObjectName[0]);

  udCRC32  := _CheckSum1.CRC32(pBuffer  := #szObjectName[0],
                             len      := udStrLen,
                             CrcStart := 0);

  SigCLib.IToA(val  := udCRC32$DINT,
               dst  := #szCRC32[0],
               base := 0x10);

  SigCLib.StrCat(ps1 := pTaskName,
                 ps2 := #szCRC32[0]);

  udStrLen := _StrLen(src := pTaskName);

  ThreadName.WriteDataOff(udLen := udStrLen,
                          udOff := 0,
                          pData := pTaskName);

END_FUNCTION
*)

FUNCTION DSComm::CreateTaskName
VAR_INPUT
  pTaskName 	: ^CHAR;
END_VAR
VAR_OUTPUT
  Retcode 	  : DINT;
END_VAR

  Retcode := -1001;

  if (pTaskName <> NIL) then
    sigclib_mutex_name(pTaskName, sigclib_nameof_class(this), this);
    //Name am Server Taskname anzeigen
    ThreadName.TxtSet(sizeof(char), pTaskName, sizeof(char));
    retcode := 0;
  end_if;
  
END_FUNCTION


FUNCTION GLOBAL DSComm::SetParameter
	VAR_INPUT
		ParaNo 	: _DS_Parameter;
		Value 	: DINT;
		Mode 	: DINT;
	END_VAR
	VAR_OUTPUT
		Retcode 	: DINT;
	END_VAR

  Retcode := 0;

  case ParaNo of
    _RespTimeout:
      RespTimeout := Value$UDINT;
    
    _RespTimeoutLong:
      RespTimeoutLong := Value$UDINT;
    
    _SendTimeout:
      TCPparameter.TimeOutSend := Value$UDINT;
    
    _RecvTimeout:
      TCPparameter.TimeOutRecv := Value$UDINT;

    else
      Retcode := ERR_WRONG_PARAMETER;   //unbekannte Parameternummer
  end_case;
END_FUNCTION


FUNCTION GLOBAL DSComm::GetParameter
	VAR_INPUT
		ParaNo 	: _DS_Parameter;
		pValue 	: ^DINT;
		Mode 	: DINT;
	END_VAR
	VAR_OUTPUT
		Retcode 	: DINT;
	END_VAR

  Retcode := 0;

  if pValue then
    case ParaNo of
      _RespTimeout:
        pValue^ := RespTimeout$DINT;
      
      _RespTimeoutLong:
        pValue^ := RespTimeoutLong$DINT;
      
      _SendTimeout:
        pValue^ := TCPparameter.TimeOutSend$DINT;
      
      _RecvTimeout:
        pValue^ := TCPparameter.TimeOutRecv$DINT;

      else
        Retcode := ERR_WRONG_PARAMETER;   //unbekannte Parameternummer
    end_case;
  else
    Retcode := ERR_WRONG_PARAMETER;       //ungültiger Zeiger
  end_if;

END_FUNCTION


FUNCTION __CDECL DSComm::CommTask
	VAR_INPUT
		pParam 	: ^void;
	END_VAR

  if ClassState = 0 then
    while 1 do
      if Connection() then
        SendData();
        ReceiveData();
      end_if;
      TimeoutCheck();
      sigclib_thread_delay(1);
    end_while;
  end_if;

END_FUNCTION


FUNCTION DSComm::Connection
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
    dRetcode : dint;
  END_VAR

  // Baut die Verbindung zwischen Client/Server auf.
  case eComSteps of
  
    // Do Nothing
    TCPCom_DoNothing:
  

    // Verbindungsaufbau starten.
    TCPCom_StartConnecting:
      if StartConnectTime = 0 then
        StartConnectTime := ops.tAbsolute;
      else
        if MaxReconnectTime then
          ActConnectTime := ops.tAbsolute;
          ConnectTime := ActConnectTime - StartConnectTime;
          if ConnectTime >= MaxReconnectTime then
            eComSteps := TCPCom_DoNothing;
            retcode := FALSE;
            Online := FALSE;
            return;
          end_if;
        end_if;
      end_if;

      TCPparameter.Socket := OS_TCP_USER_SOCKET_EX(DS_NI);				            // Client socket öffnen
      
      if TCPparameter.Socket >= 0 then
        // Socket Optionen setzen
        if SetSocketOptions(socket:=TCPparameter.Socket) = TRUE then
          eComSteps :=TCPCom_ConnectClientToServer;  
        else
          eComSteps := TCPCom_CloseConnection;
        end_if;
      else 
        eComSteps := TCPCom_DoNothing;
      end_if;
      
      
    // Client : Baut Verbindung zu Server auf.  
    TCPCom_ConnectClientToServer:
   
      dRetcode := OS_TCP_USER_CONNECT(TCPparameter.Socket, 0, #IPaddr[0], DS_PORTNUMBER_, DS_CONNECT_TIMEOUT);

      if (dRetcode < 0) & (dRetcode <> TCP_NOT_READY) then 
        // Verbindung schließen und erneut aufmachen.
        eComSteps := TCPCom_CloseConnection; 
      elsif dRetcode = 0 then 
        // Verbindung ist hergestellt.
        eComSteps := TCPCom_ConnectionOKSendAlive;
        
        // ist notwendig wegen Fehler im OS , da bei Connect das Blocking Bit zurückgesetzt wird.
        // Rückgabewert auswerte hat keinen Sinn , da auch noch Fehler im OS ist.
        OS_TCP_USER_IOCTLSOCKET(TCPparameter.Socket, SET_SOCKET_MODE, 0);
        
        TimeStamp.AliveCounterExt := ops.tAbsolute;
      end_if;
     
  
    TCPCom_CloseConnection: // Verbindung schließen.
      
      OS_TCP_USER_CLOSESOCKET(TCPparameter.Socket, 1);
      TCPparameter.Socket := 0; 
      TimeStamp.NewConnection := ops.tAbsolute;

      UserIDLogin := 0;  //Nach Abbruch der Verbindung ist kein Benutzer angemeldet.

      eComSteps := TCPCom_WaitNewConnection;

   TCPCom_WaitNewConnection :
   
      if ( ops.tAbsolute -  TimeStamp.NewConnection) >= TCPparameter.TimeNewConnection then
        eComSteps := TCPCom_StartConnecting; 
      end_if;
      
    // Alive Signal verschicken und überprüfen
    TCPCom_ConnectionOKSendAlive: 

      if (ops.tAbsolute - TimeStamp.LastSendPackAlive) >= TCPparameter.TimeAliveSignal then
        AliveTrigger();
        TimeStamp.LastSendPackAlive := ops.tAbsolute;
      end_if;
    
      if (ops.tAbsolute - TimeStamp.AliveCounterExt) >= TCPparameter.TimeOutAlive then
        eComSteps := TCPCom_CloseConnection;
      end_if;

  end_case;
  
  if eComSteps = TCPCom_ConnectionOKSendAlive then
    StartConnectTime := 0;
    retcode := TRUE;
    Online := TRUE;
  else
    retcode := FALSE;
    Online := FALSE;
  end_if;

END_FUNCTION


FUNCTION DSComm::GetIpOfServer
	VAR_INPUT
		pChar 	: ^CHAR;
		dstsize 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR

  retcode := FALSE;
  
  // Wurde ein String eingegeben ?
  if(cIPaddr.TxtLen() >= 7) then
    cIPaddr.ToAscii();
    cIPaddr.TxtGet(pChar, dstsize);
    retcode := TRUE;
  end_if;

END_FUNCTION


FUNCTION DSComm::SetSocketOptions
	VAR_INPUT
		socket 	: DINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
  	option_name   : DINT;                      
    option_value  : DINT;                      
    optionalen    : DINT;
    dRetval       : DINT;
  END_VAR
  
  retcode := FALSE;
  
  // Variables for Socket-Option
  option_name   := SO_REUSEADDR;            // 4 ... Option that the Socket could be reopened
  option_value  := 1;                       // 1 ... Option should be activated
  optionalen    := sizeof(option_value);    // size of option_value
  
  dRetval := OS_TCP_USER_SETSOCKOPT(socket, SOL_SOCKET, option_name, #option_value$CHAR, optionalen); // Set Socket Option, that the Socket could be reopened
          
  if dRetval = 0 then
  
    option_name   := SO_DELAYED_ACK;          // 1024 ... _Delayd_Ack (the Acknowlegde should not be sended imidiatly)
    option_value  := 0;                       // 0 ... Option should be deactivated
    optionalen    := sizeof(option_value);    // size of option_value

    dRetval := OS_TCP_USER_SETSOCKOPT(socket, SOL_SOCKET, option_name, #option_value$CHAR, optionalen); // Set Socket Option, that the Socket could be reopened
    
    if dRetval = 0 then         
      option_name   := SO_NAGLE;                
      option_value  := 0;                       // 0 ... Option should be deactivated
      optionalen    := sizeof(option_value);    // size of option_value

      dRetval := OS_TCP_USER_SETSOCKOPT(socket, SOL_SOCKET, option_name, #option_value$CHAR, optionalen); // Set Socket Option, that the Socket could be reopened
      
      if dRetval = 0 then         
        // Set the socket to non-blocking (onoff=1) or blocking (onoff=0) mode
        dRetval := OS_TCP_USER_IOCTLSOCKET(socket, SET_SOCKET_MODE, 0);
        
        if dRetval = 0 then
          retcode := TRUE;
        else
          retcode := TRUE; // retcode := FALSE;  //testing
        end_if;
      end_if;
    end_if;
  end_if;

END_FUNCTION


FUNCTION DSComm::AliveTrigger
	VAR_OUTPUT
		RetVal 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^char;
  	pHeader     : ^_DS_Header;
    SendBuffer  : array[0..AliveTrigger_BUFFER_SIZE] of char; 
  END_VAR

  pSendBuff := #SendBuffer[0];

  //*--- Header für Alive Trigger aufbauen --------------------------------------------------*//
  pheader := pSendBuff$^_DS_Header;
  pheader^.Length         := AliveTrigger_BUFFER_SIZE;
  pheader^.MajorID        := SIGMATEK_PROTOKOLL;
  pheader^.MinorID        := AliveTriggerCmd;
  pHeader^.TransactionSrc := TransactSrc;
  pHeader^.TransactionDest:= TransactDest;
  pheader^.MessageID      := 0;

  RetVal := SendDataTCP(pData:=pSendBuff, TCPparameter.Socket);

END_FUNCTION


FUNCTION GLOBAL DSComm::GetVersion
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^char;
  	pHeader     : ^_DS_Header;
    pJobElmt    : ^_DS_JobInfoElmt;
    RetVal      : DINT;
  END_VAR

  if pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

//  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#GetVersionJobs, MessageID, pThis, #pJobElmt);
//  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=GetVersion_BUFFER_SIZE, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      //*--- Header für Get Version aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := GetVersion_BUFFER_SIZE;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := GetVersionCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#GetVersionJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::GetProjectInfo
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^char;
  	pHeader     : ^_DS_Header;
    pJobElmt    : ^_DS_JobInfoElmt;
    RetVal      : DINT;
  END_VAR

  if pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#GetProjectInfoJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=GetProjectInfo_BUFFER_SIZE, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      //*--- Header für Get Project Info aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := GetProjectInfo_BUFFER_SIZE;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := GetProjectInfoCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#GetProjectInfoJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION DSComm::GetRespData_GetProjectInfo
	VAR_INPUT
		pData 	: ^CHAR;
		pGetProjectInfoRsp 	: ^_DS_GetProjectInfoResp;
	END_VAR
  VAR
  	StringLen   : UDINT;
  END_VAR

    pGetProjectInfoRsp^.VersionNo := (pData$^UDINT)^;
    pData += sizeof(pGetProjectInfoRsp^.VersionNo);

    pGetProjectInfoRsp^.BuildNo   := (pData$^UDINT)^;
    pData += sizeof(pGetProjectInfoRsp^.BuildNo);
    
    pGetProjectInfoRsp^.ProjectCRC := (pData$^UDINT)^;
    pData += sizeof(pGetProjectInfoRsp^.ProjectCRC);

    StringLen := SigCLib.StrLen16(str0:=pData$^UINT);   //Anzahl der Zeichen im uni-0-String ohne Endezeichen.
    pGetProjectInfoRsp^.ProjNameLen  := StringLen;
    pGetProjectInfoRsp^.pProjectName := pData$^UINT;
END_FUNCTION


FUNCTION DSComm::ReceiveData
  VAR
    socknr			      : DINT;
    bExit			        : BOOL;
    Buffer_Size       : UDINT;
    DS_Header_ori     : _DS_Header;
    DS_Header         : _DS_Header;
    FragmentHdr       : _DS_FragmentHeader;
    pHeaderOri        : ^_DS_Header;
    pHeader 		      : ^_DS_Header;
    pFragmentHdr      : ^_DS_FragmentHeader;
    pBufferHandling   : ^_DS_BufferHandling;
    rc				        : DINT;
    timeloc           : UDINT;
    idx               : DINT;
    ErrorNo           : DINT;
  END_VAR;


  socknr := TCPparameter.Socket;

	bExit := FALSE;

	BytesToReceive := sizeof(_DS_Header);
  pHeader        := #DS_Header;
  pHeaderOri     := #DS_Header_ori;
  pFragmentHdr   := #FragmentHdr;

  timeloc := OS_READMICROSEC();
  TimeDiff := timeloc - TimeLast;
  TimeLast := timeloc;
  if TimeDiff > TimeMax then
    TimeMax := TimeDiff;
  end_if;

  BytesAvailable := OS_TCP_USER_NREAD_AVAILABLE(socknr);

  if BytesAvailable >= BytesToReceive$DINT then
    TimeStamp.AliveCounterExt := ops.tAbsolute;
    //Header lesen.
    rc := OS_TCP_USER_RECV(socknr, pHeader$^char, BytesToReceive, 0, 0);
    if rc > 0 then
      if pHeader^.MajorID = SIGMATEK_PROTOKOLL & pHeader^.MinorID = SendFragmentCmd then
        //=============================================================================================//
        //*--- Fragmentierung. Es werden zwei oder mehr Pakete (je max. 16 KB) empfangen.             *//
        //=============================================================================================//
#ifdef _DEBUG_DSCOMM
        if DBG_HdrTime = 0 then
          DBG_HdrTime := OS_READMICROSEC();   //===TEST===
        end_if;
#endif
        //Fragment Header lesen.
        while 1 do
          BytesAvailable := OS_TCP_USER_NREAD_AVAILABLE(socknr);
          if BytesAvailable >= sizeof(_DS_FragmentHeader) then
            rc := OS_TCP_USER_RECV(socknr, pFragmentHdr$^char, sizeof(_DS_FragmentHeader), 0, 0);
#ifdef _DEBUG_DSCOMM
            if DBG_FragHdrTime = 0 then
              DBG_FragHdrTime := OS_READMICROSEC();   //===TEST===
            end_if;
#endif
            if rc > 0 then
              //Puffergröße für die Daten aller Pakete. _DS_Header und _DS_FragmentHeader haben eigene Puffer.
              Buffer_Size := pFragmentHdr^.gesLength.Low32;
              exit;     //Fragment Header lesen.
            else
              //Fehler
              ErrorReceive +=1;
              eComSteps := TCPCom_CloseConnection;
              return;
            end_if;
          elsif BytesAvailable >= 0 | BytesAvailable = TCP_NOT_READY then
            //Noch nicht genug Daten vorhanden (Header) / TCP_NOT_READY.
            TimeoutCheck();
        	  sigclib_thread_delay(1);
          else
            //Fehler
            ErrorReceive +=1;
            eComSteps := TCPCom_CloseConnection;
            return;
          end_if;
        end_while;

        if pFragmentHdr^.offset.Low32 = 0 then
          //Nur beim ersten fragmentierten Paket: ursprünglichen Befehls-Header lesen und in der Pufferverwaltung merken.
          while 1 do
            BytesAvailable := OS_TCP_USER_NREAD_AVAILABLE(socknr);

            if BytesAvailable >= sizeof(_DS_Header)$DINT then
              rc := OS_TCP_USER_RECV(socknr, pHeaderOri$^char, sizeof(_DS_Header), 0, 0);
#ifdef _DEBUG_DSCOMM
              if DBG_HdrOriTime = 0 then
                DBG_HdrOriTime := OS_READMICROSEC();   //===TEST===
              end_if;
#endif
              if rc < 0 then
                //Fehler
                ErrorReceive +=1;
                eComSteps := TCPCom_CloseConnection;
              end_if;
              exit;
            elsif BytesAvailable >= 0 | BytesAvailable = TCP_NOT_READY then
              //Noch nicht genug Daten vorhanden (Header) / TCP_NOT_READY.
              TimeoutCheck();
              sigclib_thread_delay(1);
            else
              //Fehler
              ErrorReceive +=1;
              eComSteps := TCPCom_CloseConnection;
              return;
            end_if;
          end_while;

          //Nur beim ersten fragmentierten Paket: freien Eintrag in der Pufferverwaltung suchen.
          idx := GetFreeBufferHdlEntry();
          if idx >= 0 then
            pBufferHandling := #BufferHandling[idx];

            if pHeaderOri^.MinorID = FileContentRsp then
              //Puffer nur für ein Paket, nicht für die ganze Datei.
              Buffer_Size := pHeader^.Length;
            end_if;

            //Nur beim ersten fragmentierten Paket: Empfangspuffer und Datenpuffer allokieren.
            pBufferHandling^.pRecvBufferStart := (sigclib_mallocV1(Buffer_Size, MEM_Mark_DS_Comm))$^char;
            pBufferHandling^.pDataBufferStart := (sigclib_mallocV1(Buffer_Size * 3/2, MEM_Mark_DS_Comm))$^char;

            if pBufferHandling^.pRecvBufferStart & pBufferHandling^.pDataBufferStart then
              pBufferHandling^.UID         := pFragmentHdr^.UID;
              pBufferHandling^.HeaderOri   := DS_Header_ori;
              pBufferHandling^.pRecvBuffer := pBufferHandling^.pRecvBufferStart;
//              pRecvBuffer_DBG := pBufferHandling^.pRecvBuffer;  //===TEST===
              pBufferHandling^.Flags       := 0;
            else
              //Fataler Fehler: Empfangspuffer oder Datenpuffer oder beide konnten nicht allokiert werden.
              SendFragmentResponse(pFragmentHdr^.UID, ErrorCode:=DS_ERROR_MEMORY);

              //Puffer freigeben.
              if pBufferHandling^.pRecvBufferStart then
                sigclib_free(pBufferHandling^.pRecvBufferStart);
              end_if;
              if pBufferHandling^.pDataBufferStart then
                sigclib_free(pBufferHandling^.pDataBufferStart);
              end_if;

              //Bei ERR_MALLOC_RECV_BUFFER die im Init() allokierten Puffer verwenden.
              pBufferHandling^.pRecvBufferStart := pRecvBufferStatic;
              pBufferHandling^.pDataBufferStart := pDataBufferStatic;

              pBufferHandling^.UID         := pFragmentHdr^.UID;
              pBufferHandling^.HeaderOri   := DS_Header_ori;
              pBufferHandling^.pRecvBuffer := pBufferHandling^.pRecvBufferStart;
              pBufferHandling^.Flags       := pBufferHandling^.Flags or FlagMemError;
            end_if;

            //Ursprünglicher Befehls-Header wurde oben schon gelesen.
            BytesToReceive := pFragmentHdr^.length - sizeof(_DS_Header);
          end_if;
        else
          //Bei weiteren fragmentierten Paketen: Eintrag in der Pufferverwaltung suchen.
          idx := GetBufferHdlEntry(pFragmentHdr^.UID);
          pBufferHandling := #BufferHandling[idx];

          BytesToReceive := pFragmentHdr^.length;
        end_if;

        if idx >= 0 then
          while 1 do
            BytesAvailable := OS_TCP_USER_NREAD_AVAILABLE(socknr);
            if BytesAvailable >= BytesToReceive$DINT then
              //Daten lesen.
              rc := OS_TCP_USER_RECV(socknr, pBufferHandling^.pRecvBuffer, BytesToReceive, 0, 0);
              if rc > 0  then
                TimeStamp.AliveCounterExt := ops.tAbsolute;
                pBufferHandling^.pRecvBuffer += rc;
                BytesToReceive  -= rc$UDINT;
                if BytesToReceive = 0 then
#ifdef _DEBUG_DSCOMM
                  if DBG_DataTime = 0 then
                    DBG_DataTime := OS_READMICROSEC();   //===TEST===
                  end_if;
                  DBG_PaketCount += 1;  //===TEST
#endif
                  if pBufferHandling^.Flags and FlagMemError then
                    //Nicht genug RAM für fragmentierte Daten. Die Daten werden vom TCP-Stack gelesen und verworfen.
                    //Pufferzeiger dazu wieder an den Anfang des statischen Puffers stellen.
                    pBufferHandling^.pRecvBuffer := pBufferHandling^.pRecvBufferStart;
                    ErrorNo := ERR_MALLOC_RECV_BUFFER;
                  else
                    ErrorNo := 0;
                    ErrorSend := SendFragmentResponse(pFragmentHdr^.UID, ErrorCode:=DS_ERROR_NONE);
                  end_if;

//                if pBufferHandling^.FragmentHeader.offset.Low32 + pBufferHandling^.FragmentHeader.length >= pBufferHandling^.FragmentHeader.gesLength.Low32 then
                  if pFragmentHdr^.offset.Low32 + pFragmentHdr^.length >= pFragmentHdr^.gesLength.Low32 then
                    //Alle Fragmente vorhanden. Bei <FileContentRsp>: letztes Fragment. 
                    //pBufferHandling^.HeaderOri zeigt auf den ursprünglichen Befehls-Header (pHeader zeigt auf den Send Fragment Befehl).
                    NewResponse(#pBufferHandling^.HeaderOri, pFragmentHdr, pBufferHandling^.pRecvBufferStart, pBufferHandling^.pDataBufferStart, ErrorNo);
                    if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
                      //Bei ERR_MALLOC_RECV_BUFFER werden die im Init() allokierten Puffer benützt. Diese dürfen nicht freigegeben werden.
                      sigclib_free(pBufferHandling^.pRecvBufferStart);
                      sigclib_free(pBufferHandling^.pDataBufferStart);
                    end_if;
                    FreeBufferHdlEntry(idx);
                  elsif pBufferHandling^.HeaderOri.MinorID = FileContentRsp then
                    //Nur ein Fragment vorhanden.
                    //pBufferHandling^.HeaderOri zeigt auf den ursprünglichen Befehls-Header (pHeader zeigt auf den Send Fragment Befehl).
                    NewResponse(#pBufferHandling^.HeaderOri, pFragmentHdr, pBufferHandling^.pRecvBufferStart, pBufferHandling^.pDataBufferStart, ErrorNo);
                    pBufferHandling^.pRecvBuffer := pBufferHandling^.pRecvBufferStart;
//                    pRecvBuffer_DBG := pBufferHandling^.pRecvBuffer;  //===TEST===
                  end_if;
                  BytesToReceive := sizeof(_DS_Header);
                  exit;
                else
                  TimeoutCheck();
                  sigclib_thread_delay(1);
                end_if;
              else
                //Fehler
                ErrorReceive +=1;
                eComSteps := TCPCom_CloseConnection;
                return;
              end_if;
            elsif BytesAvailable >= 0 | BytesAvailable = TCP_NOT_READY then 
              // TCP_NOT_READY
              TimeoutCheck();
              sigclib_thread_delay(1);
            else
              //Fehler
              ErrorReceive +=1;
              eComSteps := TCPCom_CloseConnection;
              return;
            end_if;
          end_while;
        else
          //Fataler Fehler: Kein Platz in der Pufferverwaltung (idx < 0).
          ErrorReceive +=1;
          ClassState := ERR_MEM_ALLOC_RUNTIME;
          OS_TCP_USER_CLOSESOCKET(TCPparameter.Socket, 1);
          TCPparameter.Socket := 0;
          eComSteps := TCPCom_DoNothing; 
        end_if;
      else
        //=============================================================================================//
        //*--- Keine Fragmentierung. Es wird nur ein Paket (max. 16 KB) empfangen.                    *//
        //=============================================================================================//
        BytesToReceive := pHeader^.Length - sizeof(_DS_Header);
        if BytesToReceive <= MaxDSBuffSize then
          if BytesToReceive > 0 then
            pRecvBuffer := pRecvBufferStatic;
            while 1 do
              BytesAvailable := OS_TCP_USER_NREAD_AVAILABLE(socknr);
              if BytesAvailable >= BytesToReceive$DINT then
                //Daten lesen.
                rc := OS_TCP_USER_RECV(socknr, pRecvBuffer, BytesToReceive, 0, 0);
                if rc > 0  then
                  TimeStamp.AliveCounterExt := ops.tAbsolute;
                  pRecvBuffer    += rc;
                  BytesToReceive -= rc$UDINT;
                  if BytesToReceive = 0 then
                    //Empfangspuffer auswerten: Kommando mit Daten.
                    NewResponse(pHeader, nil, pRecvBufferStatic, pDataBufferStatic, 0);
                    BytesToReceive := sizeof(_DS_Header);
                    exit;
                  else
                    TimeoutCheck();
                    sigclib_thread_delay(1);
                  end_if;
                else
                  //Fehler
                  ErrorReceive +=1;
                  eComSteps := TCPCom_CloseConnection;
                  return;
                end_if;
              elsif BytesAvailable >= 0 | BytesAvailable = TCP_NOT_READY then 
                // TCP_NOT_READY
                TimeoutCheck();
                sigclib_thread_delay(1);
              else
                //Fehler
                ErrorReceive +=1;
                eComSteps := TCPCom_CloseConnection;
                return;
              end_if;
            end_while;
          else
            TimeStamp.AliveCounterExt := ops.tAbsolute;
            //Empfangspuffer auswerten: Kommando ohne Daten (nur Header).
            NewResponse(pHeader, nil, nil, nil, 0);
            BytesToReceive := sizeof(_DS_Header);
          end_if;
        end_if;
      end_if;
    else
      //Fehler
      ErrorReceive +=1;  
      eComSteps := TCPCom_CloseConnection;
    end_if;
  elsif BytesAvailable >= 0 | BytesAvailable = TCP_NOT_READY then 
    //Noch nicht genug Daten vorhanden (Header) / TCP_NOT_READY.
    TimeoutCheck();
//  	sigclib_thread_delay(1); //wird in CommTask() aufgerufen.
  else
    //Fehler
    ErrorReceive +=1;  
    eComSteps := TCPCom_CloseConnection;
  end_if;

END_FUNCTION


FUNCTION DSComm::SendDataTCP
	VAR_INPUT
		pData 	: ^CHAR;
		SockNo 	: DINT;
	END_VAR
	VAR_OUTPUT
		RetVal 	: DINT;
	END_VAR
  VAR
    TotalBytes    : UDINT;
	  BytesToSend   : UDINT;
	  BytesSent     : UDINT;
    Databytes     : UDINT;
    bExit			    : BOOL;
    TimeoutCnt    : DINT;
    pHeader 		  : ^_DS_Header;
    pFragmentHdr  : ^_DS_FragmentHeader;
    pHeader_ori   : ^_DS_Header;
//    HeaderBuffer  : array[0..sizeof(DSComm::_DS_Header) + sizeof(DSComm::_DS_FragmentHeader) - 1] of char;
  END_VAR

  bExit      := FALSE;
  TimeoutCnt := 0;
  BytesSent  := 0;

  //Ptr auf originalen Header
  pHeader_ori := pData$^_DS_Header;
  TotalBytes  := pHeader_ori^.Length;   //ohne sizeof(_DS_Header) + sizeof(_DS_FragmentHeader)

  if TotalBytes > MaxDSBuffSize then
    //=============================================================================================//
    //*--- Daten senden mit Fragmentierung -------------------------------------------------------*//
    //=============================================================================================//


    //*--- Header für Send Fragment aufbauen --------------------------------------------------*//
    //Vor pData ist noch Platz für einen _DS_Header und _DS_FragmentHeader.
    pHeader := (pData - sizeof(_DS_FragmentHeader) - sizeof(_DS_Header))$^_DS_Header;
    pHeader^.Length         := MaxDSBuffSize;
    pHeader^.MajorID        := SIGMATEK_PROTOKOLL;
    pHeader^.MinorID        := SendFragmentCmd;
    pHeader^.TransactionSrc := TransactSrc;
    pHeader^.TransactionDest:= TransactDest;
    pHeader^.MessageID      := pHeader_ori^.MessageID;
    
    //*--- Fragment Header aufbauen -----------------------------------------------------------*//
    pFragmentHdr := (pData - sizeof(_DS_FragmentHeader))$^_DS_FragmentHeader;
    pFragmentHdr^.UID             := pHeader_ori^.MessageID$UDINT;   //zum UID erzeugen würde ein Mutex benötigt werden
    pFragmentHdr^.MessageID       := pHeader_ori^.MessageID$UDINT;
    pFragmentHdr^.gesLength.Low32 := pHeader_ori^.Length;
    pFragmentHdr^.gesLength.High32:= 0;
    pFragmentHdr^.length          := MaxDSBuffSize - sizeof(_DS_Header) - sizeof(_DS_FragmentHeader);
    pFragmentHdr^.offset.Low32    := 0;
    pFragmentHdr^.offset.High32   := 0;

    while TotalBytes & bExit = FALSE do
      BytesToSend := TotalBytes + sizeof(_DS_Header) + sizeof(_DS_FragmentHeader);
      if BytesToSend > MaxDSBuffSize then
        BytesToSend := MaxDSBuffSize;
      end_if;

      pData := pHeader$^char;
      while BytesToSend > 0 & bExit = FALSE do
        //-------------------------------------------------------------------------------------------//
        //--- Rückgabewerte (RetVal) von OS_TCP_USER_SEND() sind die gesendeten Bytes ---------------//
        RetVal := OS_TCP_USER_SEND(SockNo, pData, BytesToSend, 0, TCPparameter.TimeOutSend);
        if RetVal < 0 & RetVal <> TCP_TIMEOUT & RetVal <> TCP_NOT_READY then
          bExit := TRUE;
          ErrorSend +=1;
          eComSteps := TCPCom_CloseConnection;
        elsif RetVal = TCP_TIMEOUT | RetVal = TCP_NOT_READY then
          TimeoutCnt += 1;

          if TimeoutCnt >= DS_SEND_TIMEOUT_CNT then
            bExit := TRUE;
            ErrorSend +=1;
            eComSteps := TCPCom_CloseConnection;
          end_if;
        elsif RetVal = 0 then
//          ErrorSend +=1;
//          eComSteps := TCPCom_CloseConnection;
          bExit := TRUE;	    //0 = End of File (EOF), kein Fehler
        elsif RetVal > 0 then
          Databytes   := RetVal$UDINT - sizeof(_DS_Header) - sizeof(_DS_FragmentHeader);  //nur Daten ohne Header
          BytesSent   += Databytes;
          BytesToSend -= RetVal$UDINT;
          TotalBytes  -= Databytes;
          pData += RetVal;
          RetVal := BytesSent$DINT;
        end_if;
      end_while;
      
      if TotalBytes then
        //*--- Header und Fragment Header kopieren -----------------------------------------------*//
        _memcpy(ptr1:=pData - sizeof(_DS_FragmentHeader) - sizeof(_DS_Header), ptr2:=pHeader, cntr:=sizeof(_DS_Header) + sizeof(_DS_FragmentHeader));

        //*--- Header aktualisieren --------------------------------------------------------------*//
        pHeader := (pData - sizeof(_DS_FragmentHeader) - sizeof(_DS_Header))$^_DS_Header;

        if TotalBytes < pFragmentHdr^.length then
          //Neue Länge: letztes Paket ist kürzer
          pHeader^.Length := TotalBytes + sizeof(_DS_Header) + sizeof(_DS_FragmentHeader);
        end_if;

        //*--- Fragment Header aktualisieren -----------------------------------------------------*//
        pFragmentHdr := (pData - sizeof(_DS_FragmentHeader))$^_DS_FragmentHeader;

        //Neuer offset = alter offset + alte Länge
        pFragmentHdr^.offset.Low32 += pFragmentHdr^.length;

        if TotalBytes < pFragmentHdr^.length then
          //Neue Länge: letztes Fragment ist kürzer
          pFragmentHdr^.length := TotalBytes;
        end_if;
      end_if;
    end_while;
  else
    //=============================================================================================//
    //*--- Daten senden ohne Fragmentierung ------------------------------------------------------*//
    //=============================================================================================//
    BytesToSend := TotalBytes;

    while BytesToSend > 0 & bExit = FALSE do
      //-------------------------------------------------------------------------------------------//
      //--- Rückgabewerte (RetVal) von OS_TCP_USER_SEND() sind die gesendeten Bytes ---------------//
      RetVal := OS_TCP_USER_SEND(SockNo, pData, BytesToSend, 0, TCPparameter.TimeOutSend);
      if RetVal < 0 & RetVal <> TCP_TIMEOUT & RetVal <> TCP_NOT_READY then
        bExit := TRUE;
        ErrorSend +=1;
        eComSteps := TCPCom_CloseConnection;
      elsif RetVal = TCP_TIMEOUT | RetVal = TCP_NOT_READY then
        TimeoutCnt += 1;

        if TimeoutCnt >= DS_SEND_TIMEOUT_CNT then
          bExit := TRUE;
          ErrorSend +=1;
          eComSteps := TCPCom_CloseConnection;
        end_if;
      elsif RetVal = 0 then
//        ErrorSend +=1;
//        eComSteps := TCPCom_CloseConnection;
        bExit := TRUE;    //0 = End of File (EOF), kein Fehler
      elsif RetVal > 0 then
        BytesSent   += RetVal$UDINT;
        BytesToSend -= RetVal$UDINT;
        RetVal := BytesSent$DINT;
      end_if;
    end_while;
  end_if;

END_FUNCTION


FUNCTION DSComm::SaveJobInfo
	VAR_INPUT
		pJobInfo 	: ^DSComm::_DS_JobInfo;
		MessageID 	: DINT;
		pThis 	: ^DSComm_Interface;
		ppJobElmt 	: ^_pDS_JobInfoElmt;
	END_VAR
	VAR_OUTPUT
		RetVal 	: DINT;
	END_VAR
  VAR
    pJobElmt  : ^_DS_JobInfoElmt;
  	index     : UDINT;
  END_VAR

  if DS_Reset then
    RetVal := ERR_DS_RESET;  //DataService ist im RESET-Zustand
  elsif UserIDLogin = 0 then
    RetVal := ERR_NO_USER_LOGIN; //Kein Benutzer angemeldet.
  elsif Online = 0 then
    RetVal := TCP_NOT_READY;     //Keine Verbindung zum DS
  else
    RetVal := ERR_JOB_JOURNAL_FULL;  //Auftragsverwaltung voll

    if pJobInfo^.Capacity & pJobInfo^.Free then
      index    := MessageID$UDINT mod pJobInfo^.Capacity;
      pJobElmt := pJobInfo^.pJobs + index * sizeof(_DS_JobInfoElmt);

      if pJobElmt^.StartTime = 0 then
        //Element ist frei
        ppJobElmt^ := pJobElmt;
        pJobElmt^.MessageID := MessageID;
        pJobElmt^.pThis     := pThis;
        pJobElmt^.Error     := 0;
       #if sigclib_version >= 34 
        pJobElmt^.StartTime := sigclib_tabsolute_nonzero();  //in [ms]
       #else
        pJobElmt^.StartTime := sigclib_tabsolute(); //in [ms]
        if(pJobElmt^.StartTime = 0) then
          pJobElmt^.StartTime := 16#FFFFFFFF;
        end_if;
       #endif 
        sigclib_atomic_decU32(#pJobInfo^.Free);
        RetVal := 1;
      else
        //Element ist schon belegt.
        //a) bei Timeout Callback mit Fehler "timeout" aufrufen, Element verwenden.
        //b) kein Timeout: linked list anlegen oder Fehler melden oder ???
      end_if;
    end_if;
  end_if;

END_FUNCTION


FUNCTION DSComm::RemoveJob
	VAR_INPUT
		pJobInfo 	: ^_DS_JobInfo;
		MessageID 	: DINT;
	END_VAR
	VAR_OUTPUT
		pJobElmt 	: ^_DS_JobInfoElmt;
	END_VAR
  VAR
  	index     : UDINT;
  END_VAR

//  Section.SectionStart(); // *********************
  if pJobInfo^.Capacity <> pJobInfo^.Free then
    index    := MessageID$UDINT mod pJobInfo^.Capacity;
    pJobElmt := pJobInfo^.pJobs + index * sizeof(_DS_JobInfoElmt);

    if pJobElmt^.MessageID = MessageID then
      sigclib_atomic_incU32(#pJobInfo^.Free);
      pJobElmt^.StartTime := 0;
      pJobElmt := nil;      //success
    end_if;
  end_if;
//  Section.SectionStop(); // *********************

END_FUNCTION


FUNCTION DSComm::FindJob
	VAR_INPUT
		pJobInfo 	: ^_DS_JobInfo;
		MessageID 	: DINT;
	END_VAR
	VAR_OUTPUT
		pJobElmt 	: ^_DS_JobInfoElmt;
	END_VAR
  VAR
  	index      : UDINT;
  END_VAR

  pJobElmt := nil;      //error

  if pJobInfo^.Capacity <> pJobInfo^.Free then
    index    := MessageID$UDINT mod pJobInfo^.Capacity;
    pJobElmt := pJobInfo^.pJobs + index * sizeof(_DS_JobInfoElmt);

    if pJobElmt^.MessageID <> MessageID | pJobElmt^.StartTime = 0 then
      pJobElmt := nil;      //error
    end_if;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::UserLogin
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		pUserName 	: ^UINT;
		pPassword 	: ^UINT;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff     : ^void;
  	pHeader       : ^_DS_Header;
    pData         : ^UINT;
    pLen          : ^UDINT;
    pJobElmt      : ^_DS_JobInfoElmt;
    DataLen       : UDINT;
    SendBuffSize  : UDINT;
    RetVal        : DINT;
    UserIDLogin_Save :UDINT;
  END_VAR

  if pUserName = nil | pPassword = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  UserIDLogin_Save := UserIDLogin;
  UserIDLogin := 1;
  RetVal := SaveJobInfo(pJobInfo:=#UserLoginJobs, MessageID, pThis, #pJobElmt);
  UserIDLogin := UserIDLogin_Save;
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    //Datenlänge und Puffergröße ermitteln                                                            UserNameLen+PasswortLen
    DataLen := (SigCLib.StrLen16(str0:=pUserName)+1) * 2 + (SigCLib.StrLen16(str0:=pPassword)+1) * 2 + 2*sizeof(UDINT);   //in Bytes inkl. Endezeichen
    SendBuffSize := sizeof(_DS_Header) + DataLen;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header);  //dest
      pLen  := pData$^UDINT;                    //Zeiger auf Stringlänge merken
      pData := _StrCpy16(dst:=pData+sizeof(UDINT), src:=pUserName, pLen:=pData$^UDINT);  //pData wird weitergestellt
      pLen^ := pLen^ + 2;                       //Stringlänge + Endezeichen in Byte

      pLen  := pData$^UDINT;                    //Zeiger auf Stringlänge merken
      pData := _StrCpy16(dst:=pData+sizeof(UDINT), src:=pPassword, pLen:=pData$^UDINT);
      pLen^ := pLen^ + 2;                       //Stringlänge + Endezeichen in Byte
    
  	  //*--- Header für User Login aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
	    pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := UserLoginCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#UserLoginJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION DSComm::GetRespData_UserLogin
	VAR_INPUT
		pData 	: ^CHAR;
		pUserLoginData 	: ^_DS_UserLoginResp;
	END_VAR
  VAR
  	StringLen   : UDINT;    //Zwischenvariable ergibt kürzeren Code (ARM und Intel)
  END_VAR


  _memset(dest:=pUserLoginData, usByte:=0, cntr:=sizeof(_DS_UserLoginResp));

  //--- userID -----------------------------------------------------------------------------------------------//
  pUserLoginData^.UserID := (pData$^UDINT)^;
  pData += sizeof(pUserLoginData^.UserID);

  //--- namelen ----------------------------------------------------------------------------------------------//
  StringLen := (pData$^UDINT)^;                       //Anzahl der Bytes im uni-0-String mit Endezeichen.
  pUserLoginData^.NameLength := (StringLen-2) / 2;    //Anzahl der Zeichen im uni-0-String ohne Endezeichen.
  pData += sizeof(UDINT);

  //--- name -------------------------------------------------------------------------------------------------//
  pUserLoginData^.pName      := pData$^UINT;
  pData += StringLen;                                //+ Anzahl der Bytes im uni-0-String mit Endezeichen.

  //--- ErrorCode --------------------------------------------------------------------------------------------//
  pUserLoginData^.ErrorCode := (pData$^UDINT)^;
  pData += sizeof(pUserLoginData^.ErrorCode);

  if pUserLoginData^.ErrorCode then
    return;   //Im Fehlerfall endet die Nachricht hier
  end_if;

  //--- Number Of Roles --------------------------------------------------------------------------------------//
  pUserLoginData^.NumberOfRoles := (pData$^UDINT)^;
  pData += sizeof(pUserLoginData^.NumberOfRoles);

  //--- RoleID -----------------------------------------------------------------------------------------------//
  pUserLoginData^.pRoleID := pData$^UDINT;
  pData += pUserLoginData^.NumberOfRoles * sizeof(pUserLoginData^.pRoleID^);

  //--- firstNameLen -----------------------------------------------------------------------------------------//
  StringLen := pData$^UDINT^;                         //Anzahl der Bytes im uni-0-String mit Endezeichen.
  pUserLoginData^.FirstNameLength := (StringLen-2)/2; //Anzahl der Zeichen im uni-0-String ohne Endezeichen.
  pData += sizeof(UDINT);

  //--- firstName --------------------------------------------------------------------------------------------//
  pUserLoginData^.pFirstName      := pData$^UINT;
  pData += StringLen;                                 //+ Anzahl der Bytes im uni-0-String mit Endezeichen.

  //--- lastNameLen ------------------------------------------------------------------------------------------//
  StringLen := pData$^UDINT^;                         //Anzahl der Bytes im uni-0-String mit Endezeichen.
  pUserLoginData^.LastNameLength := (StringLen-2) / 2;//Anzahl der Zeichen im uni-0-String ohne Endezeichen.
  pData += sizeof(UDINT);

  //--- lastName ---------------------------------------------------------------------------------------------//
  pUserLoginData^.pLastName      := pData$^UINT;
  pData += StringLen;                                 //+ Anzahl der Bytes im uni-0-String mit Endezeichen.

  //--- UserInfoLen ------------------------------------------------------------------------------------------//
  StringLen := pData$^UDINT^;                         //Anzahl der Bytes im uni-0-String mit Endezeichen.
  pUserLoginData^.UserInfoLength := (StringLen-2) / 2;//Anzahl der Zeichen im uni-0-String ohne Endezeichen.
  pData += sizeof(UDINT);

  //--- User Info --------------------------------------------------------------------------------------------//
  pUserLoginData^.pUserInfo      := pData$^UINT;
  pData += StringLen;                                 //+ Anzahl der Bytes im uni-0-String mit Endezeichen.

  //--- Write Access Logic Length ----------------------------------------------------------------------------//
  StringLen := (pData$^UDINT)^;                       //Anzahl der Bytes im Bytestream.
  pUserLoginData^.WriteAccessLogicLength := StringLen;//Anzahl der Bytes im Bytestream.
  pData += sizeof(UDINT);

  //--- Write Access Logic -----------------------------------------------------------------------------------//
  pUserLoginData^.pWriteAccessLogic :=pData$^USINT;
  pData += StringLen;                                 //+ Anzahl der Bytes im Bytestream.

  //--- Read Access Logic Length -----------------------------------------------------------------------------//
  StringLen := (pData$^UDINT)^;                       //Anzahl der Bytes im Bytestream.
  pUserLoginData^.ReadAccessLogicLength := StringLen; //Anzahl der Bytes im Bytestream.
  pData += sizeof(UDINT);

  //--- Read Access Logic ------------------------------------------------------------------------------------//
  pUserLoginData^.pReadAccessLogic :=pData$^USINT;
  pData += StringLen;                                 //+ Anzahl der Bytes im Bytestream.

  //--- Created Date - Time ----------------------------------------------------------------------------------//
  _memcpy(ptr1:=#pUserLoginData^.CreatedDate, ptr2:=pData, cntr:=sizeof(pUserLoginData^.CreatedDate));
  pData += sizeof(pUserLoginData^.CreatedDate);

  _memcpy(ptr1:=#pUserLoginData^.CreatedTime, ptr2:=pData, cntr:=sizeof(pUserLoginData^.CreatedTime));
  pData += sizeof(pUserLoginData^.CreatedTime);

  //--- Modified User Date - Time ----------------------------------------------------------------------------//
  _memcpy(ptr1:=#pUserLoginData^.ModifiedUserDate, ptr2:=pData, cntr:=sizeof(pUserLoginData^.ModifiedUserDate));
  pData += sizeof(pUserLoginData^.ModifiedUserDate);

  _memcpy(ptr1:=#pUserLoginData^.ModifiedUserTime, ptr2:=pData, cntr:=sizeof(pUserLoginData^.ModifiedUserTime));
  pData += sizeof(pUserLoginData^.ModifiedUserTime);

  //--- Modified Password Date - Time ------------------------------------------------------------------------//
  _memcpy(ptr1:=#pUserLoginData^.ModifiedPWDate, ptr2:=pData, cntr:=sizeof(pUserLoginData^.ModifiedPWDate));
  pData += sizeof(pUserLoginData^.ModifiedPWDate);

  _memcpy(ptr1:=#pUserLoginData^.ModifiedPWTime, ptr2:=pData, cntr:=sizeof(pUserLoginData^.ModifiedPWTime));
  pData += sizeof(pUserLoginData^.ModifiedPWTime);

  //--- Last Login Date - Time -------------------------------------------------------------------------------//
  _memcpy(ptr1:=#pUserLoginData^.LastLoginDate, ptr2:=pData, cntr:=sizeof(pUserLoginData^.LastLoginDate));
  pData += sizeof(pUserLoginData^.LastLoginDate);

  _memcpy(ptr1:=#pUserLoginData^.LastLoginTime, ptr2:=pData, cntr:=sizeof(pUserLoginData^.LastLoginTime));
  pData += sizeof(pUserLoginData^.LastLoginTime);

  //--- Last Logout Date - Time ------------------------------------------------------------------------------//
  _memcpy(ptr1:=#pUserLoginData^.LastLogoutDate, ptr2:=pData, cntr:=sizeof(pUserLoginData^.LastLogoutDate));
  pData += sizeof(pUserLoginData^.LastLogoutDate);

  _memcpy(ptr1:=#pUserLoginData^.LastLogoutTime, ptr2:=pData, cntr:=sizeof(pUserLoginData^.LastLogoutTime));
  pData += sizeof(pUserLoginData^.LastLogoutTime);

  //--- User Privileges Low - High ---------------------------------------------------------------------------//
  _memcpy(ptr1:=#pUserLoginData^.UserPrivileges, ptr2:=pData, cntr:=sizeof(pUserLoginData^.UserPrivileges));
  pData += sizeof(pUserLoginData^.UserPrivileges);
  
  //--- Operation Timeout ------------------------------------------------------------------------------------//
  _memcpy(ptr1:=#pUserLoginData^.OperationTimeout, ptr2:=pData, cntr:=sizeof(pUserLoginData^.OperationTimeout));
  pData += sizeof(pUserLoginData^.OperationTimeout);

  //--- Write Protected --------------------------------------------------------------------------------------//
  pUserLoginData^.WriteProtected := pData^;
  pData += sizeof(pUserLoginData^.WriteProtected);

  //--- Access Number Valid ----------------------------------------------------------------------------------//
  pUserLoginData^.AccessNumberValid := pData^;
  pData += sizeof(pUserLoginData^.AccessNumberValid);

  if pUserLoginData^.AccessNumberValid = FALSE then
    return;   //Ohne AccessNumber endet die Nachricht hier
  end_if;

  //--- AccessNumber -----------------------------------------------------------------------------------------//
  pUserLoginData^.AccessNumber := pData$^UDINT^;
//  pData += sizeof(pUserLoginData^.AccessNumber);
END_FUNCTION


FUNCTION GLOBAL DSComm::GetValue
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		num 	: UDINT;
		pGetValue 	: ^DSComm::_DS_GetValueCmd;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff     : ^void;
  	pHeader       : ^_DS_Header;
    pJobElmt      : ^_DS_JobInfoElmt;
    tmpI          : UDINT;
    pData         : ^CHAR;
    DataLen       : UDINT;
    SendBuffSize  : UDINT;
    RetVal        : DINT;
  END_VAR

  if num = 0 | pGetValue = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#GetValueJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    //Datenlänge und Puffergröße ermitteln: num * (size + Daten)
    DataLen := num * (sizeof(UDINT) + sizeof(pGetValue^));

    SendBuffSize := sizeof(_DS_Header) + sizeof(num) + DataLen;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest
    
      pData$^UDINT^ := num;
      pData += sizeof(num);
    
      //Datenpunktbeschreibungen kopieren
      for tmpI:=0 to num-1 do
        //--- size -------------------------------------------------------------------------------------//
        pData$^UDINT^ := sizeof(pGetValue^);  //Größe des nächsten Eintrags
        pData += sizeof(UDINT);

        //--- dpId + quality ---------------------------------------------------------------------------//
        pData$^_DS_GetValueCmd^ := pGetValue^;
        pData += sizeof(pGetValue^);

        //-- Src-Pointer weiterstellen -----------------------------------------------------------------//
        pGetValue += sizeof(pGetValue^);
      end_for;

  	  //*--- Header für Get Value aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
	    pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := GetValueCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;
    
      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#GetValueJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION DSComm::GetRespData_GetValue
	VAR_INPUT
		pData 	: ^CHAR;
		pGetValueRsp 	: ^_DS_GetValueResp;
		num 	: UDINT;
	END_VAR
  VAR
    max         : UDINT;
    tmpI        : UDINT;
  END_VAR

  max := num - 1;
  for tmpI:=0 to max do
    pData += sizeof(UDINT);   //Size überspringen

    pGetValueRsp^.dpID := (pData$^UDINT)^;
    pData += sizeof(pGetValueRsp^.dpID);

    pGetValueRsp^.ErrorCode := (pData$^UDINT)^;
    pData += sizeof(pGetValueRsp^.ErrorCode);

    pGetValueRsp^.quality := (pData$^UDINT)^;
    pData += sizeof(pGetValueRsp^.quality);

    pGetValueRsp^.value := (pData$^LREAL)^;
    pData += sizeof(pGetValueRsp^.value);

    pGetValueRsp += sizeof(_DS_GetValueResp);
  end_for;

END_FUNCTION


FUNCTION GLOBAL DSComm::SetValue
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		num 	: UDINT;
		pSetValue 	: ^_DS_SetValueCmd;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff     : ^void;
  	pHeader       : ^_DS_Header;
    pData         : ^CHAR;
    pJobElmt      : ^_DS_JobInfoElmt;
    tmpI          : UDINT;
    DataLen       : UDINT;
    SendBuffSize  : UDINT;
    RetVal        : DINT;
  END_VAR

  if num = 0 | pSetValue = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#SetValueJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    //Datenlänge und Puffergröße ermitteln: num * (size + Daten)
    DataLen := num * (sizeof(UDINT) + sizeof(_DS_SetValueCmd));

    SendBuffSize := sizeof(_DS_Header) + sizeof(num) + DataLen;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest
    
      pData$^UDINT^ := num;
      pData += sizeof(num);
    
      //Datenpunktbeschreibungen kopieren
      for tmpI:=0 to num-1 do
        //--- size -------------------------------------------------------------------------------------//
        pData$^UDINT^ := sizeof(pSetValue^);  //Größe des nächsten Eintrags
        pData += sizeof(UDINT);

        //--- dpId + quality ---------------------------------------------------------------------------//
        pData$^_DS_SetValueCmd^ := pSetValue^;
        pData += sizeof(pSetValue^);

        //-- Src-Pointer weiterstellen -----------------------------------------------------------------//
        pSetValue += sizeof(pSetValue^);
      end_for;

  	  //*--- Header für Set Value aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
	    pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := SetValueCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;
    
      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#SetValueJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION DSComm::GetRespData_SetValue
	VAR_INPUT
		pData 	: ^CHAR;
		pSetValueRsp 	: ^_DS_SetValueResp;
		num 	: UDINT;
	END_VAR
  VAR
    max         : UDINT;
    tmpI        : UDINT;
  END_VAR

  max := num - 1;
  for tmpI:=0 to max do
    pData += sizeof(UDINT);           //size überspringen

    pSetValueRsp^.dpID := (pData$^UDINT)^;
    pData += sizeof(pSetValueRsp^.dpID);

    pSetValueRsp^.ErrorCode := (pData$^UDINT)^;
    pData += sizeof(pSetValueRsp^.ErrorCode);

    _memcpy(ptr1:=#pSetValueRsp^.value, ptr2:=pData, cntr:=sizeof(pSetValueRsp^.value)); 
    pData += sizeof(pSetValueRsp^.value);

    pSetValueRsp += sizeof(_DS_SetValueResp);
  end_for;

END_FUNCTION


FUNCTION GLOBAL DSComm::GetString
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		num 	: UDINT;
		pGetString 	: ^_DS_GetStringCmd;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff     : ^void;
  	pHeader       : ^_DS_Header;
    pData         : ^CHAR;
    pJobElmt      : ^_DS_JobInfoElmt;
    tmpI          : UDINT;
    DataLen       : UDINT;
    SendBuffSize  : UDINT;
    RetVal        : DINT;
  END_VAR

  if num = 0 | pGetString = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#GetStringJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    //Datenlänge und Puffergröße ermitteln: num * (size + Daten)
    DataLen := num * (sizeof(UDINT) + sizeof(_DS_GetStringCmd));

    SendBuffSize := sizeof(_DS_Header) + sizeof(num) + DataLen;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest
    
      pData$^UDINT^ := num;
      pData += sizeof(num);
    
      //Datenpunktbeschreibungen kopieren
      for tmpI:=0 to num-1 do
        //--- size -------------------------------------------------------------------------------------//
        pData$^UDINT^ := sizeof(pGetString^);  //Größe des nächsten Eintrags
        pData += sizeof(UDINT);

        //--- dpId + quality ---------------------------------------------------------------------------//
        pData$^_DS_GetStringCmd^ := pGetString^;
        pData += sizeof(pGetString^);

        //-- Src-Pointer weiterstellen -----------------------------------------------------------------//
        pGetString += sizeof(pGetString^);
      end_for;

  	  //*--- Header für Get String aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
	    pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := GetStringCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;
    
      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#GetStringJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::SetString
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		num 	: UDINT;
		pSetString 	: ^_DS_SetStringCmd;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff     : ^void;
  	pHeader       : ^_DS_Header;
		pSetStringLoc : ^_DS_SetStringCmd;
    pJobElmt      : ^_DS_JobInfoElmt;
    pSize         : ^UDINT;
    pLen          : ^UDINT;
    pData         : ^CHAR;
    DataLen       : UDINT;
    tmpI          : UDINT;
    StrLen        : UDINT;    //in Bytes inkl. Endezeichen
    SendBuffSize  : UDINT;
    RetVal        : DINT;
  END_VAR

  if num = 0 | pSetString = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#SetStringJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    //Datenlänge und Puffergröße ermitteln
    RetVal  := 0;
    DataLen := 0;
    pSetStringLoc := pSetString;

    for tmpI:=0 to num-1 do
      if pSetStringLoc^.pString then
        //pString <> nil: Stringlänge ermitteln
        StrLen  := (SigCLib.StrLen16(str0:=pSetStringLoc^.pString)+1) * 2;   //in Bytes inkl. Endezeichen
        //                                                 size+valueLen
        DataLen += sizeof(pSetStringLoc^.dpID) + StrLen + 2*sizeof(UDINT);
      else
        RetVal := ERR_WRONG_PARAMETER; //Parameterfehler
        exit;
      end_if;

      //Src-Pointer weiterstellen
      pSetStringLoc += sizeof(_DS_SetStringCmd);
    end_for;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#SetStringJobs, MessageID);
      MessageID := RetVal;
      return;
    end_if;

    SendBuffSize := sizeof(_DS_Header) + sizeof(num) + DataLen;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest
    
      pData$^UDINT^ := num;
      pData += sizeof(num);

      //Datenpunktbeschreibungen kopieren
      for tmpI:=0 to num-1 do
        //Größe des nächsten Eintrags
        pSize := pData$^UDINT;
        pSize^:= 2 * sizeof(UDINT); //dpId + valueLen
        pData += sizeof(UDINT);

        //dpId in Sendepuffer kopieren
        pData$^UDINT^ := pSetString^.dpID;
        pData += sizeof(pSetString^.dpID);

        //String in Sendepuffer kopieren und valueLen eintragen
        pLen  := pData$^UDINT;                    //Zeiger auf Stringlänge merken
        pData += sizeof(UDINT);

        pData := (_StrCpy16(dst:=pData$^UINT, src:=pSetString^.pString, pLen))$^char;  //pData wird weitergestellt
        pLen^ := pLen^ + 2;                       //Stringlänge + Endezeichen in Byte

        pSize^ += pLen^;  //+ Stringlänge + Endezeichen

        //Src-Pointer weiterstellen
        pSetString += sizeof(_DS_SetStringCmd);
      end_for;

   	  //*--- Header für Set String aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := SetStringCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#SetStringJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION DSComm::GetRespData_GetString
	VAR_INPUT
		pData 	: ^CHAR;
		pGetStringRsp 	: ^_DS_GetStringResp;
		num 	: UDINT;
	END_VAR
  VAR
  	StringLen   : UDINT;
    max         : UDINT;
    tmpI        : UDINT;
  END_VAR

  max := num - 1;
  for tmpI:=0 to max do
    pData += sizeof(UDINT);           //size überspringen

    pGetStringRsp^.dpID := (pData$^UDINT)^;
    pData += sizeof(pGetStringRsp^.dpID);

    pGetStringRsp^.ErrorCode := (pData$^UDINT)^;
    pData += sizeof(pGetStringRsp^.ErrorCode);

    pGetStringRsp^.quality := (pData$^UDINT)^;
    pData += sizeof(pGetStringRsp^.quality);

    //--- valueLen ---------------------------------------------------------------------------------------------//
    StringLen := (pData$^UDINT)^;                       //Anzahl der Bytes im uni-0-String mit Endezeichen.
    pGetStringRsp^.StringLen := (StringLen-2) / 2;      //Anzahl der Zeichen im uni-0-String ohne Endezeichen.
    pData += sizeof(UDINT);

    //--- uni-0-String -----------------------------------------------------------------------------------------//
    pGetStringRsp^.pString := pData$^UINT;
    pData += StringLen;                                //+ Anzahl der Bytes im uni-0-String mit Endezeichen.

    pGetStringRsp += sizeof(_DS_GetStringResp);
  end_for;

END_FUNCTION


FUNCTION DSComm::GetRespData_SetString
	VAR_INPUT
		pData 	: ^CHAR;
		pSetStringRsp 	: ^_DS_SetStringResp;
		num 	: UDINT;
	END_VAR
  VAR
  	StringLen   : UDINT;
    max         : UDINT;
    tmpI        : UDINT;
  END_VAR

  max := num - 1;
  for tmpI:=0 to max do
    pData += sizeof(UDINT);           //size überspringen

    pSetStringRsp^.dpID := (pData$^UDINT)^;
    pData += sizeof(pSetStringRsp^.dpID);

    pSetStringRsp^.ErrorCode := (pData$^UDINT)^;
    pData += sizeof(pSetStringRsp^.ErrorCode);

    StringLen := pData$^UDINT^;                         //Anzahl der Bytes im uni-0-String mit Endezeichen.
    pData += sizeof(UDINT);

    pSetStringRsp^.StringLen := (StringLen - 2) / 2;    //Anzahl der Zeichen im uni-0-String ohne Endezeichen.
    pSetStringRsp^.pString   := pData$^UINT;
    pData += StringLen;                                 //+ Anzahl der Bytes im uni-0-String mit Endezeichen.

    pSetStringRsp += sizeof(_DS_SetStringResp);
  end_for;

END_FUNCTION


FUNCTION GLOBAL DSComm::CancelCommand
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		HandleID 	: UDINT;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^char;
  	pHeader     : ^_DS_Header;
    pData       : ^CHAR;
    pJobElmt    : ^_DS_JobInfoElmt;
    RetVal      : DINT;
  END_VAR

  if pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#CancelCommandJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=CancelCommand_BUFFER_SIZE, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header);
      pData$^UDINT^ := HandleID;

      //*--- Header für Cancel Command aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := CancelCommand_BUFFER_SIZE;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := CancelCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#CancelCommandJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::Loop
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		Station 	: UDINT;
		pDataSrc 	: pVoid;
		DataLen 	: UDINT;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff     : ^void;
  	pHeader       : ^_DS_Header;
    pJobElmt      : ^_DS_JobInfoElmt;
    pData         : ^CHAR;
    SendBuffSize  : UDINT;
    RetVal        : DINT;
  END_VAR

  if DataLen = 0 | pDataSrc = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#LoopJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    SendBuffSize := sizeof(_DS_Header) + sizeof(Station) + DataLen;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest

      pData$^UDINT^ := Station;
      pData += sizeof(Station);

      _memcpy(ptr1:=pData, ptr2:=pDataSrc, cntr:=DataLen);
    
  	  //*--- Header für Loop aufbauen --------------------------------------------------*//
      pheader                 := pSendBuff$^_DS_Header;
	    pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := LoopCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pheader$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#LoopJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::RecipeLoad
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		pFilterIncl 	: ^_DS_UnsLongLongInt;
		pFilterExcl 	: ^_DS_UnsLongLongInt;
		crc 	: UDINT;
		pDpne 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^void;
  	pHeader     : ^_DS_Header;
    pData       : ^CHAR;
    pJobElmt    : ^_DS_JobInfoElmt;
    DpneLen     : UDINT;
    size        : UDINT;
    SendBuffSize: UDINT;
    RetVal      : DINT;
  END_VAR

  if pDpne = nil | pThis = nil | pFilterIncl = nil | pFilterExcl = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#RecipeLoadJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    //Länge des UTF8-Strings mit \0
    DpneLen :=  _StrLen(src:=pDpne) + 1;
    //                                                                                                dpnelen
    SendBuffSize := sizeof(_DS_Header) + sizeof(pFilterIncl^) + sizeof(pFilterExcl^) + sizeof(crc) + sizeof(UDINT) + DpneLen;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest
    
      _memcpy(ptr1:=pData, ptr2:=pFilterIncl, cntr:=sizeof(pFilterIncl^));
      pData += sizeof(pFilterIncl^);

      size := sizeof(pFilterExcl^);
      _memcpy(ptr1:=pData, ptr2:=pFilterExcl, cntr:=size);
      pData += size;

      pData$^UDINT^ := crc;
      pData += sizeof(crc);
    
      pData$^UDINT^ := DpneLen;
      pData += sizeof(DpneLen);
      
      pData := SigCLib.StrCpy(dst0:=pData, src0:=pDpne);

  	  //*--- Header für Recipe Load aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
	    pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := RecipeLoadCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#RecipeLoadJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::RecipeSave
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		pFilterIncl 	: ^_DS_UnsLongLongInt;
		pFilterExcl 	: ^_DS_UnsLongLongInt;
		pDpne 	: ^CHAR;
		pHeaderText 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff     : ^void;
  	pHeader       : ^_DS_Header;
    pData         : ^CHAR;
    pJobElmt      : ^_DS_JobInfoElmt;
    size          : UDINT;
    DpneLen       : UDINT;
    HdrTxtLen     : UDINT;
    SendBuffSize  : UDINT;
    RetVal        : DINT;
  END_VAR

  if pDpne = nil | pHeaderText = nil | pThis = nil | pFilterIncl = nil | pFilterExcl = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#RecipeSaveJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    DpneLen   := _StrLen(src:=pDpne) + 1;         //Länge des UTF8-Strings in Bytes mit \0
    HdrTxtLen := _StrLen(src:=pHeaderText) + 1;   //Länge des ASCII-Strings in Bytes mit \0
    //                                                                                dpnelen+headerLen
    SendBuffSize := sizeof(_DS_Header) + sizeof(pFilterIncl^) + sizeof(pFilterExcl^) + 2*sizeof(UDINT) + DpneLen + HdrTxtLen;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest
    
      _memcpy(ptr1:=pData, ptr2:=pFilterIncl, cntr:=sizeof(pFilterIncl^));
      pData += sizeof(pFilterIncl^);

      size := sizeof(pFilterExcl^);
      _memcpy(ptr1:=pData, ptr2:=pFilterExcl, cntr:=size);
      pData += size;

      pData$^UDINT^ := DpneLen;
      pData += sizeof(DpneLen);

      pData := SigCLib.StrCpy(dst0:=pData, src0:=pDpne);
      pData += DpneLen;

      pData$^UDINT^ := HdrTxtLen;
      pData += sizeof(HdrTxtLen);

      pData := SigCLib.StrCpy(dst0:=pData, src0:=pHeaderText);
//      pData += HdrTxtLen;

  	  //*--- Header für Recipe Save aufbauen --------------------------------------------------*//
      pheader                 := pSendBuff$^_DS_Header;
	    pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := RecipeSaveCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pheader$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#RecipeSaveJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::SendToAll
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		pDataSrc 	: pVoid;
		DataLen 	: UDINT;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^void;
  	pHeader     : ^_DS_Header;
    pData       : ^CHAR;
    pJobElmt    : ^_DS_JobInfoElmt;
    SendBuffSize: UDINT;
    RetVal      : DINT;
  END_VAR

  if DataLen = 0 | pDataSrc = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#SendToAllJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    SendBuffSize := sizeof(_DS_Header) + DataLen;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest

      _memcpy(ptr1:=pData, ptr2:=pDataSrc, cntr:=DataLen);
    
  	  //*--- Header für Send To All aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
	    pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := SendToAllCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#SendToAllJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::UserLogout
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^char;
  	pHeader     : ^_DS_Header;
    pJobElmt    : ^_DS_JobInfoElmt;
    RetVal      : DINT;
  END_VAR

  if pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#UserLogoutJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=UserLogout_BUFFER_SIZE, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      //*--- Header für User Logout aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := UserLogout_BUFFER_SIZE;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := UserLogoutCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#UserLogoutJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::UserPasswordChange
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		pOldPassword 	: ^UINT;
		pNewPassword 	: ^UINT;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^void;
  	pHeader     : ^_DS_Header;
    pData       : ^CHAR;
    pJobElmt    : ^_DS_JobInfoElmt;
    SizeOldPwd  : UDINT;
    SizeNewPwd  : UDINT;
    SendBuffSize: UDINT;
    RetVal      : DINT;
  END_VAR

  if pOldPassword = nil | pNewPassword = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#UserPwdChangeJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    SizeOldPwd := (SigCLib.StrLen16(str0:=pOldPassword)+1) * 2;    //in Bytes inkl. Endezeichen
    SizeNewPwd := (SigCLib.StrLen16(str0:=pNewPassword)+1) * 2;
    //                                  oldPwLen + newPwLen
    SendBuffSize := sizeof(_DS_Header) + 2 * sizeof(UDINT) + SizeOldPwd + SizeNewPwd;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest

      pData$^UDINT^ := SizeOldPwd;  //oldPwLen
      pData += sizeof(SizeOldPwd);

      pData := (_StrCpy16(dst:=pData$^UINT, src:=pOldPassword, nil))$^CHAR;  //pData wird weitergestellt

      pData$^UDINT^ := SizeNewPwd;  //newPwLen
      pData += sizeof(SizeNewPwd);

      pData := (_StrCpy16(dst:=pData$^UINT, src:=pNewPassword, nil))$^CHAR;

  	  //*--- Header für User Password Change aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
	    pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := UserPasswordChangeCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#UserPwdChangeJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::CheckAccessLevel
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		num 	: UDINT;
		pCheckAccessLevel 	: ^_DS_CheckAccessLevelCmd;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff     : ^void;
  	pHeader       : ^_DS_Header;
    pData         : ^CHAR;
    pJobElmt      : ^_DS_JobInfoElmt;
    tmpI          : UDINT;
    DataLen       : UDINT;
    SendBuffSize  : UDINT;
    RetVal        : DINT;
  END_VAR

  if num = 0 | pCheckAccessLevel = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#CheckAccessLevelJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    //Datenlänge und Puffergröße ermitteln: num * (size + Daten)
    DataLen      := num * (sizeof(UDINT) + sizeof(_DS_CheckAccessLevelCmd));
    SendBuffSize := sizeof(_DS_Header) + sizeof(num) + DataLen;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest

      pData$^UDINT^ := num;
      pData += sizeof(num);

      //Daten in den Sendepuffer kopieren
      for tmpI:=0 to num-1 do
        //--- size -------------------------------------------------------------------------------------//
        pData$^UDINT^ := sizeof(pCheckAccessLevel^);  //Größe des nächsten Eintrags
        pData += sizeof(UDINT);

        //--- userId + accessLevel ---------------------------------------------------------------------//
        pData$^_DS_CheckAccessLevelCmd^ := pCheckAccessLevel^;
        pData += sizeof(pCheckAccessLevel^);

        //-- Src-Pointer weiterstellen -----------------------------------------------------------------//
        pCheckAccessLevel += sizeof(pCheckAccessLevel^);
      end_for;
    
  	  //*--- Header für Check Access Level aufbauen --------------------------------------------------*//
      pheader                 := pSendBuff$^_DS_Header;
	    pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := CheckAccessLevelCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pheader$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#CheckAccessLevelJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION

FUNCTION DSComm::GetRespData_CheckAccessLevel
	VAR_INPUT
		pData 	: ^CHAR;
		pCheckAccessLevelRsp 	: ^_DS_CheckAccessLevelResp;
		num 	: UDINT;
	END_VAR
  VAR
    max   : UDINT;
    tmpI  : UDINT;
  END_VAR

  max := num - 1;
  for tmpI:=0 to max do
    //--- size überspringen ----------------------------------------------------------------------------------//
    pData += sizeof(UDINT);

    //--- Daten umkopieren -----------------------------------------------------------------------------------//
    pCheckAccessLevelRsp^ := pData$^_DS_CheckAccessLevelResp^;
    pData += sizeof(_DS_CheckAccessLevelResp);

    //--- Dest-Pointer weiterstellen -------------------------------------------------------------------------//
    pCheckAccessLevelRsp += sizeof(_DS_CheckAccessLevelResp);
  end_for;

END_FUNCTION


FUNCTION GLOBAL DSComm::CreateUser
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		num 	: UDINT;
		pCreateUser 	: ^_DS_CreateUserCmd;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff     : ^void;
  	pHeader       : ^_DS_Header;
    pCreateUserLoc:^_DS_CreateUserCmd;
    pSize         : ^UDINT;
    pLen          : ^UDINT;
    pData         : ^CHAR;
    pJobElmt      : ^_DS_JobInfoElmt;
    tmpI          : UDINT;
    sizeRoleID    : UDINT;
    SendBuffSize  : UDINT;
    RetVal        : DINT;
  END_VAR

  if num = 0 | pCreateUser = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#CreateUserJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    RetVal := 0;

    //Datenlänge und Puffergröße ermitteln:         size + nameLen + passwordLen + firstNameLen + lastNameLen + infoLen
    SendBuffSize := sizeof(_DS_Header) + sizeof(num) + num * 6 * sizeof(UDINT);

    pCreateUserLoc := pCreateUser;
    for tmpI:=0 to num-1 do
      //--- name -------------------------------------------------------------------------------------------------//
      if pCreateUserLoc^.pName then
        SendBuffSize += (SigCLib.StrLen16(str0:=pCreateUserLoc^.pName)+1) * 2;        //in Bytes inkl. Endezeichen
      else
        RetVal := ERR_WRONG_PARAMETER; //Parameterfehler
        exit;
      end_if;

      //--- password ---------------------------------------------------------------------------------------------//
      if pCreateUserLoc^.pPassword then
        SendBuffSize += (SigCLib.StrLen16(str0:=pCreateUserLoc^.pPassword)+1) * 2;    //in Bytes inkl. Endezeichen
      else
        RetVal := ERR_WRONG_PARAMETER; //Parameterfehler
        exit;
      end_if;

      //--- firstName --------------------------------------------------------------------------------------------//
      if pCreateUserLoc^.pFirstName then
        SendBuffSize += (SigCLib.StrLen16(str0:=pCreateUserLoc^.pFirstName)+1) * 2;   //in Bytes inkl. Endezeichen
      else
        RetVal := ERR_WRONG_PARAMETER; //Parameterfehler
        exit;
      end_if;

      //--- lastName ---------------------------------------------------------------------------------------------//
      if pCreateUserLoc^.pLastName then
        SendBuffSize += (SigCLib.StrLen16(str0:=pCreateUserLoc^.pLastName)+1) * 2;    //in Bytes inkl. Endezeichen
      else
        RetVal := ERR_WRONG_PARAMETER; //Parameterfehler
        exit;
      end_if;

      //--- numRoles + RoleID ------------------------------------------------------------------------------------//
      if pCreateUserLoc^.pRoleID then
        SendBuffSize += sizeof(pCreateUserLoc^.numRoles);
        SendBuffSize += pCreateUserLoc^.numRoles * sizeof(pCreateUserLoc^.pRoleID^);
      else
        RetVal := ERR_WRONG_PARAMETER; //Parameterfehler
        exit;
      end_if;

      //--- Info -------------------------------------------------------------------------------------------------//
      if pCreateUserLoc^.pInfo then
        SendBuffSize += (SigCLib.StrLen16(str0:=pCreateUserLoc^.pInfo)+1) * 2;        //in Bytes inkl. Endezeichen
      else
        RetVal := ERR_WRONG_PARAMETER; //Parameterfehler
        exit;
      end_if;

      //--- AccessNumberValid + AccessNumber ---------------------------------------------------------------------//
      if pCreateUserLoc^.AccessNumberValid then
        SendBuffSize += sizeof(pCreateUserLoc^.AccessNumberValid) + sizeof(pCreateUserLoc^.AccessNumber);
      else
        //Der Eintrag <AccessNumber> existiert nicht
        SendBuffSize += sizeof(pCreateUserLoc^.AccessNumberValid);
      end_if;

      //--- Src-Pointer weiterstellen ----------------------------------------------------------------------------//
      pCreateUserLoc += sizeof(_DS_CreateUserCmd);
    end_for;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#CreateUserJobs, MessageID);
      MessageID := RetVal;
      return;
    end_if;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest

      pData$^UDINT^ := num;
      pData += sizeof(num);

      for tmpI:=0 to num-1 do
        //--- size -------------------------------------------------------------------------------------------------//
        pSize := pData$^UDINT;                    //Zeiger auf <size> merken
        pData += sizeof(UDINT);
        // <size> ermitteln: nameLen + passwordLen + firstNameLen + lastNameLen + infoLen + siehe unten
        pSize^ := 5 * sizeof(UDINT);

        //--- name -------------------------------------------------------------------------------------------------//
        pLen  := pData$^UDINT;                    //Zeiger auf Stringlänge merken
        pData += sizeof(UDINT);
        pData := (_StrCpy16(dst:=pData$^UINT, src:=pCreateUser^.pName, pLen))$^CHAR;      //pData wird weitergestellt
        pLen^ := pLen^ + 2;                       //Stringlänge + Endezeichen in Byte
        pSize^ += pLen^;

        //--- password ---------------------------------------------------------------------------------------------//
        pLen  := pData$^UDINT;                    //Zeiger auf Stringlänge merken
        pData += sizeof(UDINT);
        pData := (_StrCpy16(dst:=pData$^UINT, src:=pCreateUser^.pPassword, pLen))$^CHAR;  //pData wird weitergestellt
        pLen^ := pLen^ + 2;                       //Stringlänge + Endezeichen in Byte
        pSize^ += pLen^;

        //--- firstName --------------------------------------------------------------------------------------------//
        pLen  := pData$^UDINT;                    //Zeiger auf Stringlänge merken
        pData += sizeof(UDINT);
        pData := (_StrCpy16(dst:=pData$^UINT, src:=pCreateUser^.pFirstName, pLen))$^CHAR; //pData wird weitergestellt
        pLen^ := pLen^ + 2;                       //Stringlänge + Endezeichen in Byte
        pSize^ += pLen^;

        //--- lastName ---------------------------------------------------------------------------------------------//
        pLen  := pData$^UDINT;                    //Zeiger auf Stringlänge merken
        pData += sizeof(UDINT);
        pData := (_StrCpy16(dst:=pData$^UINT, src:=pCreateUser^.pLastName, pLen))$^CHAR;  //pData wird weitergestellt
        pLen^ := pLen^ + 2;                       //Stringlänge + Endezeichen in Byte
        pSize^ += pLen^;

        //--- numRoles + RoleID ------------------------------------------------------------------------------------//
        pData$^UDINT^ := pCreateUser^.numRoles;
        pData += sizeof(pCreateUser^.numRoles);
        pSize^ += sizeof(pCreateUser^.numRoles);

        sizeRoleID := pCreateUser^.numRoles * sizeof(pCreateUserLoc^.pRoleID^);
        _memcpy(ptr1:=pData, ptr2:=pCreateUser^.pRoleID, cntr:=sizeRoleID);
        pData += sizeRoleID;
        pSize^ += sizeRoleID;

        //--- Info -------------------------------------------------------------------------------------------------//
        pLen  := pData$^UDINT;                    //Zeiger auf Stringlänge merken
        pData += sizeof(UDINT);
        pData := (_StrCpy16(dst:=pData$^UINT, src:=pCreateUser^.pInfo, pLen))$^CHAR;      //pData wird weitergestellt
        pLen^ := pLen^ + 2;                       //Stringlänge + Endezeichen in Byte
        pSize^ += pLen^;

        //--- AccessNumberValid ------------------------------------------------------------------------------------//
        pData$^USINT^ := pCreateUser^.AccessNumberValid;
        pData += sizeof(pCreateUser^.AccessNumberValid);
        pSize^ += sizeof(pCreateUser^.AccessNumberValid);

        //--- AccessNumber -----------------------------------------------------------------------------------------//
        if pCreateUser^.AccessNumberValid then
          pData$^UDINT^ := pCreateUser^.AccessNumber;
          pData += sizeof(pCreateUser^.AccessNumber);
          pSize^ += sizeof(pCreateUser^.AccessNumber);
        end_if;


        //--- Src-Pointer weiterstellen ----------------------------------------------------------------------------//
        pCreateUser += sizeof(_DS_CreateUserCmd);
      end_for;

  	  //*--- Header für Create User aufbauen --------------------------------------------------*//
      pheader                 := pSendBuff$^_DS_Header;
      pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := CreateUserCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pheader$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#CreateUserJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION

FUNCTION DSComm::GetRespData_CreateUser
	VAR_INPUT
		pData 	: ^CHAR;
		pCreateUserRsp 	: ^_DS_CreateUserResp;
		num 	: UDINT;
	END_VAR
  VAR
    max   : UDINT;
    tmpI  : UDINT;
  END_VAR

  max := num - 1;
  for tmpI:=0 to max do
    //--- size überspringen ----------------------------------------------------------------------------------//
    pData += sizeof(UDINT);

    //--- Daten umkopieren -----------------------------------------------------------------------------------//
    pCreateUserRsp^ := pData$^_DS_CreateUserResp^;
    pData += sizeof(_DS_CreateUserResp);

    //--- Dest-Pointer weiterstellen -------------------------------------------------------------------------//
    pCreateUserRsp += sizeof(_DS_CreateUserResp);
  end_for;

END_FUNCTION


FUNCTION DSComm::_StrCpy16
	VAR_INPUT
		dst 	: ^UINT;
		src 	: ^UINT;
		pLen 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		Next 	: ^UINT;
	END_VAR
  VAR
  	StrLen  : UDINT;
  END_VAR

  StrLen := SigCLib.StrLen16(src) * 2;   //Anzahl der Bytes im uni-0-String ohne Endezeichen.
  SigCLib.StrCpy16(dst, src);

  if pLen then
    pLen^ := StrLen;
  end_if;

  Next := dst + StrLen + 2; //Next zeigt hinter das Endezeichen.
END_FUNCTION


FUNCTION GLOBAL DSComm::ChangeUserSettings
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		num 	: UDINT;
		pChangeUsrSettings 	: ^_DS_ChangeUserSettingsCmd;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff             : ^void;
  	pHeader               : ^_DS_Header;
		pChangeUsrSettingsLoc : ^_DS_ChangeUserSettingsCmd;
    pSize                 : ^UDINT;
    pLen                  : ^UDINT;
    pData                 : ^CHAR;
    pJobElmt              : ^_DS_JobInfoElmt;
    tmpI                  : UDINT;
    sizeRoleID            : UDINT;
    SendBuffSize          : UDINT;
    RetVal                : DINT;
  END_VAR

  if num = 0 | pChangeUsrSettings = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#ChangeUserSettingsJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    //Puffergröße ermitteln
    RetVal := 0;

    //Datenlänge und Puffergröße ermitteln:           size + nameLen + passwordLen + firstNameLen + lastNameLen + infoLen
    SendBuffSize := sizeof(_DS_Header) + sizeof(num) + num * 6 * sizeof(UDINT);
    pChangeUsrSettingsLoc := pChangeUsrSettings;

    for tmpI:=0 to num-1 do
      //--- userid -----------------------------------------------------------------------------------------------//
      SendBuffSize += sizeof(pChangeUsrSettingsLoc^.UserID);    

      //--- name -------------------------------------------------------------------------------------------------//
      if pChangeUsrSettingsLoc^.pName then
        if pChangeUsrSettingsLoc^.pName^ <> 0 then
          //name soll geändert werden
          SendBuffSize += (SigCLib.StrLen16(str0:=pChangeUsrSettingsLoc^.pName)+1) * 2;    //in Bytes inkl. Endezeichen
        else
          //name soll nicht geändert werden
          SendBuffSize += sizeof(UINT);         //Endezeichen in Byte
        end_if;
      else
        RetVal := ERR_WRONG_PARAMETER; //Parameterfehler
        exit;
      end_if;


      //--- password ---------------------------------------------------------------------------------------------//
      if pChangeUsrSettingsLoc^.pPassword then
        if pChangeUsrSettingsLoc^.pPassword^ <> 0 then
          //password soll geändert werden
          SendBuffSize += (SigCLib.StrLen16(str0:=pChangeUsrSettingsLoc^.pPassword)+1) * 2;  //in Bytes inkl. Endezeichen
        else
          //password soll nicht geändert werden
          SendBuffSize += sizeof(UINT);         //Endezeichen in Byte
        end_if;
      else
        RetVal := ERR_WRONG_PARAMETER; //Parameterfehler
        exit;
      end_if;


      //--- firstName --------------------------------------------------------------------------------------------//
      if pChangeUsrSettingsLoc^.pFirstName then
        if pChangeUsrSettingsLoc^.pFirstName^ <> 0 then
          //firstname soll geändert werden
          SendBuffSize += (SigCLib.StrLen16(str0:=pChangeUsrSettingsLoc^.pFirstName)+1) * 2; //in Bytes inkl. Endezeichen
        else
          //firstname soll nicht geändert werden
          SendBuffSize += sizeof(UINT);         //Endezeichen in Byte
        end_if;
      else
        RetVal := ERR_WRONG_PARAMETER; //Parameterfehler
        exit;
      end_if;


      //--- lastName ---------------------------------------------------------------------------------------------//
      if pChangeUsrSettingsLoc^.pLastName then
        if pChangeUsrSettingsLoc^.pLastName^ <> 0 then
          //lastname soll geändert werden
          SendBuffSize += (SigCLib.StrLen16(str0:=pChangeUsrSettingsLoc^.pLastName)+1) * 2;  //in Bytes inkl. Endezeichen
        else
          //lastname soll nicht geändert werden
          SendBuffSize += sizeof(UINT);         //Endezeichen in Byte
        end_if;
      else
        RetVal := ERR_WRONG_PARAMETER; //Parameterfehler
        exit;
      end_if;


      //--- RoleID -----------------------------------------------------------------------------------------------//
      if pChangeUsrSettingsLoc^.numRoles <> 0xFFFFFFFF then
        //RoleID soll geändert werden
        if pChangeUsrSettingsLoc^.pRoleID then
          SendBuffSize += pChangeUsrSettingsLoc^.numRoles * sizeof(pChangeUsrSettingsLoc^.pRoleID^);
        else
          RetVal := ERR_WRONG_PARAMETER; //Parameterfehler
          exit;
        end_if;
      end_if;
      SendBuffSize += sizeof(pChangeUsrSettingsLoc^.numRoles);


      //--- Info -------------------------------------------------------------------------------------------------//
      if pChangeUsrSettingsLoc^.pInfo then
        if pChangeUsrSettingsLoc^.pInfo^ <> 0 then
          //Info soll geändert werden
          SendBuffSize += (SigCLib.StrLen16(str0:=pChangeUsrSettingsLoc^.pInfo)+1) * 2;    //in Bytes inkl. Endezeichen
        else
          //Info soll nicht geändert werden
          SendBuffSize += sizeof(UINT);         //Endezeichen in Byte
        end_if;
      else
        RetVal := ERR_WRONG_PARAMETER; //Parameterfehler
        exit;
      end_if;

      //--- AccessNumberValid + AccessNumber ---------------------------------------------------------------------//
      if pChangeUsrSettingsLoc^.AccessNumberValid then
        SendBuffSize += sizeof(pChangeUsrSettingsLoc^.AccessNumberValid) + sizeof(pChangeUsrSettingsLoc^.AccessNumber);
      else
        //Der Eintrag <AccessNumber> existiert nicht
        SendBuffSize += sizeof(pChangeUsrSettingsLoc^.AccessNumberValid);
      end_if;

      //--- Src-Pointer weiterstellen ----------------------------------------------------------------------------//
      pChangeUsrSettingsLoc += sizeof(_DS_ChangeUserSettingsCmd);
    end_for;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#ChangeUserSettingsJobs, MessageID);
      MessageID := RetVal;
      return;
    end_if;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest

      pData$^UDINT^ := num;
      pData += sizeof(num);

      for tmpI:=0 to num-1 do
        //--- size -------------------------------------------------------------------------------------------------//
        pSize := pData$^UDINT;                    //Zeiger auf <size> merken
        pData += sizeof(UDINT);
        // <size> ermitteln: userid + nameLen + passwordLen + firstNameLen + lastNameLen + infoLen + numRoles + siehe unten
        pSize^ := 7 * sizeof(UDINT);

        //--- userid -----------------------------------------------------------------------------------------------//
        pData$^UDINT^ := pChangeUsrSettings^.UserID;
        pData += sizeof(pChangeUsrSettings^.UserID);    

        //--- name -------------------------------------------------------------------------------------------------//
        if pChangeUsrSettings^.pName^ <> 0 then
          //name soll geändert werden
          pLen  := pData$^UDINT;                    //Zeiger auf Stringlänge merken
          pData += sizeof(UDINT);
          pData := (_StrCpy16(dst:=pData$^UINT, src:=pChangeUsrSettings^.pName, pLen))$^CHAR; //pData wird weitergestellt
          pLen^ := pLen^ + sizeof(UINT);            //Stringlänge + Endezeichen in Byte
          pSize^ += pLen^;
        else
          //name soll nicht geändert werden
          pData$^UDINT^ := sizeof(UINT);            //Endezeichen in Byte
          pData += sizeof(UDINT);
          pSize^ += sizeof(UINT);

          pData$^UINT^ := 0;                        //Leerstring
          pData += sizeof(UINT);
        end_if;

        //--- password ---------------------------------------------------------------------------------------------//
        if pChangeUsrSettings^.pPassword^ <> 0 then
          //password soll geändert werden
          pLen  := pData$^UDINT;                    //Zeiger auf Stringlänge merken
          pData += sizeof(UDINT);
          pData := (_StrCpy16(dst:=pData$^UINT, src:=pChangeUsrSettings^.pPassword, pLen))$^CHAR; //pData wird weitergestellt
          pLen^ := pLen^ + sizeof(UINT);            //Stringlänge + Endezeichen in Byte
          pSize^ += pLen^;
        else
          //password soll nicht geändert werden
          pData$^UDINT^ := sizeof(UINT);            //Endezeichen in Byte
          pData += sizeof(UdINT);
          pSize^ += sizeof(UINT);

          pData$^UINT^ := 0;                        //Leerstring
          pData += sizeof(UINT);
        end_if;

        //--- firstName --------------------------------------------------------------------------------------------//
        if pChangeUsrSettings^.pFirstName^ <> 0 then
          //firstname soll geändert werden
          pLen  := pData$^UDINT;                    //Zeiger auf Stringlänge merken
          pData += sizeof(UDINT);
          pData := (_StrCpy16(dst:=pData$^UINT, src:=pChangeUsrSettings^.pFirstName, pLen))$^CHAR; //pData wird weitergestellt
          pLen^ := pLen^ + sizeof(UINT);            //Stringlänge + Endezeichen in Byte
          pSize^ += pLen^;
        else
          //firstname soll nicht geändert werden
          pData$^UDINT^ := sizeof(UINT);            //Endezeichen in Byte
          pData += sizeof(UdINT);
          pSize^ += sizeof(UINT);

          pData$^UINT^ := 0;                        //Leerstring
          pData += sizeof(UINT);
        end_if;

        //--- lastName ---------------------------------------------------------------------------------------------//
        if pChangeUsrSettings^.pLastName^ <> 0 then
          //lastname soll geändert werden
          pLen  := pData$^UDINT;                    //Zeiger auf Stringlänge merken
          pData += sizeof(UDINT);
          pData := (_StrCpy16(dst:=pData$^UINT, src:=pChangeUsrSettings^.pLastName, pLen))$^CHAR; //pData wird weitergestellt
          pLen^ := pLen^ + sizeof(UINT);            //Stringlänge + Endezeichen in Byte
          pSize^ += pLen^;
        else
          //lastname soll nicht geändert werden
          pData$^UDINT^ := sizeof(UINT);            //Endezeichen in Byte
          pData += sizeof(UdINT);
          pSize^ += sizeof(UINT);

          pData$^UINT^ := 0;                        //Leerstring
          pData += sizeof(UINT);
        end_if;

        //--- RoleID -----------------------------------------------------------------------------------------------//
        pData$^UDINT^ := pChangeUsrSettings^.numRoles;
        pData += sizeof(pChangeUsrSettings^.numRoles);

        if pChangeUsrSettings^.numRoles <> 0xFFFFFFFF then
          //RoleID soll geändert werden
          sizeRoleID := pChangeUsrSettings^.numRoles * sizeof(pChangeUsrSettings^.pRoleID^);
          _memcpy(ptr1:=pData, ptr2:=pChangeUsrSettings^.pRoleID, cntr:=sizeRoleID);
          pData += sizeRoleID;
          pSize^ += sizeRoleID;
        end_if;

        //--- Info -------------------------------------------------------------------------------------------------//
        if pChangeUsrSettings^.pInfo^ <> 0 then
          //Info soll geändert werden
          pLen  := pData$^UDINT;                    //Zeiger auf Stringlänge merken
          pData += sizeof(UDINT);
          pData := (_StrCpy16(dst:=pData$^UINT, src:=pChangeUsrSettings^.pInfo, pLen))$^CHAR; //pData wird weitergestellt
          pLen^ := pLen^ + sizeof(UINT);            //Stringlänge + Endezeichen in Byte
          pSize^ += pLen^;
        else
          //Info soll nicht geändert werden
          pData$^UDINT^ := sizeof(UINT);            //Endezeichen in Byte
          pData += sizeof(UdINT);
          pSize^ += sizeof(UINT);

          pData$^UINT^ := 0;                        //Leerstring
          pData += sizeof(UINT);
        end_if;

        //--- AccessNumberValid ------------------------------------------------------------------------------------//
        pData$^USINT^ := pChangeUsrSettings^.AccessNumberValid;
        pData += sizeof(pChangeUsrSettings^.AccessNumberValid);
        pSize^ += sizeof(pChangeUsrSettings^.AccessNumberValid);

        //--- AccessNumber -----------------------------------------------------------------------------------------//
        if pChangeUsrSettings^.AccessNumberValid then
          pData$^UDINT^ := pChangeUsrSettings^.AccessNumber;
          pData += sizeof(pChangeUsrSettings^.AccessNumber);
          pSize^ += sizeof(pChangeUsrSettings^.AccessNumber);
        end_if;

        //--- Src-Pointer weiterstellen --------------------------------------------------------------------//
        pChangeUsrSettings += sizeof(_DS_ChangeUserSettingsCmd);
      end_for;

  	  //*--- Header für Change User Settings aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := ChangeUserSettingsCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#ChangeUserSettingsJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION

FUNCTION DSComm::GetRespData_ChangeUserSettings
	VAR_INPUT
		pData 	: ^CHAR;
		pChangeUserSettingsRsp 	: ^_DS_ChangeUserSettingsResp;
		num 	: UDINT;
	END_VAR
  VAR
    max   : UDINT;
    tmpI  : UDINT;
  END_VAR

  max := num - 1;
  for tmpI:=0 to max do
    //--- size überspringen ----------------------------------------------------------------------------------//
    pData += sizeof(UDINT);

    //--- Daten umkopieren -----------------------------------------------------------------------------------//
    pChangeUserSettingsRsp^ := pData$^_DS_ChangeUserSettingsResp^;
    pData += sizeof(_DS_ChangeUserSettingsResp);

    //--- Dest-Pointer weiterstellen -------------------------------------------------------------------------//
    pChangeUserSettingsRsp += sizeof(_DS_ChangeUserSettingsResp);
  end_for;

END_FUNCTION


FUNCTION GLOBAL DSComm::DeleteUser
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		num 	: UDINT;
		pUserID 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^void;
  	pHeader     : ^_DS_Header;
    pJobElmt    : ^_DS_JobInfoElmt;
    tmpI        : UDINT;
    pData       : ^CHAR;
    DataLen     : UDINT;
    SendBuffSize: UDINT;
    RetVal      : DINT;
  END_VAR

  if num = 0 | pUserID = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#DeleteUserJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    //Puffergröße ermitteln: num * (size + Daten)
    DataLen := num * (sizeof(UDINT) + sizeof(pUserID^));
    SendBuffSize := sizeof(_DS_Header) + sizeof(num) + DataLen;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest

      pData$^UDINT^ := num;
      pData += sizeof(num);

      //User-IDs kopieren
      for tmpI:=0 to num-1 do
        //--- size -------------------------------------------------------------------------------------//
        pData$^UDINT^ := sizeof(pUserID^);  //Größe des nächsten Eintrags
        pData += sizeof(UDINT);

        //--- stationNr --------------------------------------------------------------------------------//
        pData$^UDINT^ := pUserID^;
        pData += sizeof(pUserID^);

        //-- Src-Pointer weiterstellen -----------------------------------------------------------------//
        pUserID += sizeof(pUserID^);
      end_for;

  	  //*--- Header für Delete User aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
	    pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := DeleteUserCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#DeleteUserJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION

FUNCTION DSComm::GetRespData_DeleteUser
	VAR_INPUT
		pData 	: ^CHAR;
		pDeleteUserRsp 	: ^_DS_DeleteUserResp;
		num 	: UDINT;
	END_VAR
  VAR
    max   : UDINT;
    tmpI  : UDINT;
  END_VAR

  max := num - 1;
  for tmpI:=0 to max do
    //--- size überspringen ----------------------------------------------------------------------------------//
    pData += sizeof(UDINT);

    //--- Daten umkopieren -----------------------------------------------------------------------------------//
    pDeleteUserRsp^ := pData$^_DS_DeleteUserResp^;
    pData += sizeof(_DS_DeleteUserResp);

    //--- Dest-Pointer weiterstellen -------------------------------------------------------------------------//
    pDeleteUserRsp += sizeof(_DS_DeleteUserResp);
  end_for;

END_FUNCTION


FUNCTION GLOBAL DSComm::GetUserList
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^char;
  	pHeader     : ^_DS_Header;
    pJobElmt    : ^_DS_JobInfoElmt;
    RetVal      : DINT;
  END_VAR

  if pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#GetUserListJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=GetUserList_BUFFER_SIZE, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      //*--- Header für Get User List aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := GetUserList_BUFFER_SIZE;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := GetUserListCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#GetUserListJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::GetUserDetails
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		userID 	: UDINT;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^char;
  	pHeader     : ^_DS_Header;
    pData       : ^CHAR;
    pJobElmt    : ^_DS_JobInfoElmt;
    RetVal      : DINT;
  END_VAR

  if pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#GetUserDetailsJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=GetUserDetails_BUFFER_SIZE, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      //*--- Header für Get User Details aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := GetUserDetails_BUFFER_SIZE;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := GetUserDetailsCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      pData := pSendBuff + sizeof(_DS_Header);
      pData$^UDINT^ := userID;

      RetVal := SendToCommTask(pData:=pSendBuff, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#GetUserDetailsJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION DSComm::GetRespData_GetUserList
	VAR_INPUT
		pData 	: ^CHAR;
		pGetUserListRsp 	: ^_DS_GetUserListResp;
		num 	: UDINT;
	END_VAR
  VAR
  	StringLen   : UDINT;
    max         : UDINT;
    tmpI        : UDINT;
  END_VAR

  max := num - 1;
  for tmpI:=0 to max do
    pData += sizeof(UDINT);   //size überspringen

    pGetUserListRsp^.UserID := (pData$^UDINT)^;
    pData += sizeof(pGetUserListRsp^.UserID);

    StringLen := pData$^UDINT^;                       //Anzahl der Bytes im uni-0-String mit Endezeichen.
    pData += sizeof(UDINT);

    pGetUserListRsp^.NameLen := (StringLen - 2) / 2;  //Anzahl der Zeichen im uni-0-String ohne Endezeichen.
    pGetUserListRsp^.pName   := pData$^UINT;
    pData += StringLen;                               //+ Anzahl der Bytes im uni-0-String mit Endezeichen.

    pGetUserListRsp += sizeof(_DS_GetUserListResp);
  end_for;

END_FUNCTION


FUNCTION GLOBAL DSComm::CreateRole
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		num 	: UDINT;
		pCreateRolePara 	: ^_DS_CreateRoleCmd;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff         : ^void;
  	pHeader           : ^_DS_Header;
		pCreateRoleParaLoc: ^_DS_CreateRoleCmd;
    pSize             : ^UDINT;
    pLen              : ^UDINT;
    pData             : ^CHAR;
    pJobElmt          : ^_DS_JobInfoElmt;
    tmpI              : UDINT;
    size              : UDINT;
    SendBuffSize      : UDINT;
    RetVal            : DINT;
  END_VAR

  if num = 0 | pCreateRolePara = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#CreateRoleJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    RetVal := 0;
    //Puffergröße ermitteln:                       size + roleNameLen + WriteAccessStringLen + ReadAccessStringLen + infoLen
    SendBuffSize := sizeof(_DS_Header) + sizeof(num) + num * 5 * sizeof(UDINT);
    pCreateRoleParaLoc := pCreateRolePara;

    for tmpI:=0 to num-1 do
      //--- name -------------------------------------------------------------------------------------------------//
      if pCreateRoleParaLoc^.pRoleName then
        SendBuffSize += (SigCLib.StrLen16(str0:=pCreateRoleParaLoc^.pRoleName)+1) * 2;     //in Bytes inkl. Endezeichen
      else
        RetVal := ERR_WRONG_PARAMETER; //Parameterfehler
        exit;
      end_if;

      //--- Write Access String ----------------------------------------------------------------------------------//
      if pCreateRoleParaLoc^.pWriteAccessString then
        SendBuffSize += (SigCLib.StrLen16(str0:=pCreateRoleParaLoc^.pWriteAccessString)+1) * 2; //in Bytes inkl. Endezeichen
      else
        RetVal := ERR_WRONG_PARAMETER; //Parameterfehler
        exit;
      end_if;

      //--- Read Access String -----------------------------------------------------------------------------------//
      if pCreateRoleParaLoc^.pReadAccessString then
        SendBuffSize += (SigCLib.StrLen16(str0:=pCreateRoleParaLoc^.pReadAccessString)+1) * 2; //in Bytes inkl. Endezeichen
      else
        RetVal := ERR_WRONG_PARAMETER; //Parameterfehler
        exit;
      end_if;

      //--- Privileges -------------------------------------------------------------------------------------------//
      SendBuffSize += sizeof(pCreateRoleParaLoc^.privileges);

      //--- no Operation Timeout ---------------------------------------------------------------------------------//
      SendBuffSize += sizeof(pCreateRoleParaLoc^.noOperationTimeout);

      //--- Info -------------------------------------------------------------------------------------------------//
      if pCreateRoleParaLoc^.pInfo then
        SendBuffSize += (SigCLib.StrLen16(str0:=pCreateRoleParaLoc^.pInfo)+1) * 2;         //in Bytes inkl. Endezeichen
      else
        RetVal := ERR_WRONG_PARAMETER; //Parameterfehler
        exit;
      end_if;

      //--- AccessNumberValid + AccessNumber ---------------------------------------------------------------------//
      if pCreateRoleParaLoc^.AccessNumberValid then
        SendBuffSize += sizeof(pCreateRoleParaLoc^.AccessNumberValid) + sizeof(pCreateRoleParaLoc^.AccessNumber);
      else
        //Der Eintrag <AccessNumber> existiert nicht
        SendBuffSize += sizeof(pCreateRoleParaLoc^.AccessNumberValid);
      end_if;

      //--- Src-Pointer weiterstellen ----------------------------------------------------------------------------//
      pCreateRoleParaLoc += sizeof(_DS_CreateRoleCmd);
    end_for;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#CreateRoleJobs, MessageID);
      MessageID := RetVal;
      return;
    end_if;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest

      pData$^UDINT^ := num;
      pData += sizeof(num);

      for tmpI:=0 to num-1 do
        //--- size ------------------------------------------------------------------------------------------------------//
        pSize := pData$^UDINT;                    //Zeiger auf <size> merken
        pData += sizeof(UDINT);
        // <size> ermitteln: roleNameLen + WriteAccessStringLen + ReadAccessStringLen + infoLen + siehe unten
        pSize^ := 4 * sizeof(UDINT);

        //--- name ------------------------------------------------------------------------------------------------------//
        pLen  := pData$^UDINT;                    //Zeiger auf Stringlänge merken
        pData += sizeof(UDINT);
        pData := (_StrCpy16(dst:=pData$^UINT, src:=pCreateRolePara^.pRoleName, pLen))$^CHAR;    //pData wird weitergestellt
        pLen^ := pLen^ + 2;                       //Stringlänge + Endezeichen in Byte
        pSize^ += pLen^;

        //--- Write Access String ---------------------------------------------------------------------------------------//
        pLen  := pData$^UDINT;                    //Zeiger auf Stringlänge merken
        pData += sizeof(UDINT);
        pData := (_StrCpy16(dst:=pData$^UINT, src:=pCreateRolePara^.pWriteAccessString, pLen))$^CHAR;//pData wird weitergestellt
        pLen^ := pLen^ + 2;                       //Stringlänge + Endezeichen in Byte
        pSize^ += pLen^;

        //--- Read Access String ----------------------------------------------------------------------------------------//
        pLen  := pData$^UDINT;                    //Zeiger auf Stringlänge merken
        pData += sizeof(UDINT);
        pData := (_StrCpy16(dst:=pData$^UINT, src:=pCreateRolePara^.pReadAccessString, pLen))$^char;//pData wird weitergestellt
        pLen^ := pLen^ + 2;                       //Stringlänge + Endezeichen in Byte
        pSize^ += pLen^;

        //--- Privileges ------------------------------------------------------------------------------------------------//
        size := sizeof(pCreateRoleParaLoc^.privileges);
        _memcpy(ptr1:=pData, ptr2:=#pCreateRolePara^.privileges, cntr:=size);
        pData += size;
        pSize^ += size;

        //--- no Operation Timeout --------------------------------------------------------------------------------------//
        pData$^UINT^ := pCreateRolePara^.noOperationTimeout;
        pData += sizeof(pCreateRolePara^.noOperationTimeout);
        pSize^ += sizeof(pCreateRolePara^.noOperationTimeout);

        //--- Info ------------------------------------------------------------------------------------------------------//
        pLen  := pData$^UDINT;                    //Zeiger auf Stringlänge merken
        pData += sizeof(UDINT);
        pData := (_StrCpy16(dst:=pData$^UINT, src:=pCreateRolePara^.pInfo, pLen))$^CHAR;        //pData wird weitergestellt
        pLen^ := pLen^ + 2;                       //Stringlänge + Endezeichen in Byte
        pSize^ += pLen^;

        //--- AccessNumberValid -----------------------------------------------------------------------------------------//
        pData$^USINT^ := pCreateRolePara^.AccessNumberValid;
        pData += sizeof(pCreateRolePara^.AccessNumberValid);
        pSize^ += sizeof(pCreateRolePara^.AccessNumberValid);

        //--- AccessNumber ----------------------------------------------------------------------------------------------//
        if pCreateRolePara^.AccessNumberValid then
          pData$^UDINT^ := pCreateRolePara^.AccessNumber;
          pData += sizeof(pCreateRolePara^.AccessNumber);
          pSize^ += sizeof(pCreateRolePara^.AccessNumber);
        end_if;

        //--- Src-Pointer weiterstellen ---------------------------------------------------------------------------------//
        pCreateRolePara += sizeof(_DS_CreateRoleCmd);
      end_for;

  	  //*--- Header für Create Role aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := CreateRoleCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#CreateRoleJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION

FUNCTION DSComm::GetRespData_CreateRole
	VAR_INPUT
		pData 	: ^CHAR;
		pCreateRoleRsp 	: ^_DS_CreateRoleResp;
		num 	: UDINT;
	END_VAR
  VAR
    max   : UDINT;
    tmpI  : UDINT;
  END_VAR

  max := num - 1;
  for tmpI:=0 to max do
    //--- size überspringen ----------------------------------------------------------------------------------//
    pData += sizeof(UDINT);

    //--- Daten umkopieren -----------------------------------------------------------------------------------//
    pCreateRoleRsp^ := pData$^_DS_CreateRoleResp^;
    pData += sizeof(_DS_CreateRoleResp);

    //--- Dest-Pointer weiterstellen -------------------------------------------------------------------------//
    pCreateRoleRsp += sizeof(_DS_CreateRoleResp);
  end_for;

END_FUNCTION


FUNCTION GLOBAL DSComm::ChangeRole
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		num 	: UDINT;
		pChangeRole 	: ^_DS_ChangeRoleCmd;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff     : ^void;
  	pHeader       : ^_DS_Header;
		pChangeRoleLoc: ^_DS_ChangeRoleCmd;
    pSize         : ^UDINT;
    pLen          : ^UDINT;
    pData         : ^CHAR;
    pJobElmt      : ^_DS_JobInfoElmt;
    tmpI          : UDINT;
    size          : UDINT;
    SendBuffSize  : UDINT;
    RetVal        : DINT;
  END_VAR

  if num = 0 | pChangeRole = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#ChangeRoleJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    RetVal := 0;
    //Puffergröße ermitteln:                       size + roleNameLen + WriteAccessStringLen + ReadAccessStringLen + infoLen
    SendBuffSize := sizeof(_DS_Header) + sizeof(num) + num * 5 * sizeof(UDINT);
    pChangeRoleLoc := pChangeRole;

    for tmpI:=0 to num-1 do
      //--- roleID -----------------------------------------------------------------------------------------------//
      SendBuffSize += sizeof(pChangeRoleLoc^.roleID);    

      //--- roleName ---------------------------------------------------------------------------------------------//
      if pChangeRoleLoc^.pRoleName then
        if pChangeRoleLoc^.pRoleName^ <> 0 then
          //roleName soll geändert werden
          SendBuffSize += (SigCLib.StrLen16(str0:=pChangeRoleLoc^.pRoleName)+1) * 2;   //in Bytes inkl. Endezeichen
        else
          //roleName soll nicht geändert werden
          SendBuffSize += sizeof(UINT);         //Endezeichen in Byte
        end_if;
      else
        RetVal := ERR_WRONG_PARAMETER; //Parameterfehler
        exit;
      end_if;


      //--- Info -------------------------------------------------------------------------------------------------//
      if pChangeRoleLoc^.pInfo then
        if pChangeRoleLoc^.pInfo^ <> 0 then
          //Info soll geändert werden
          SendBuffSize += (SigCLib.StrLen16(str0:=pChangeRoleLoc^.pInfo)+1) * 2;       //in Bytes inkl. Endezeichen
        else
          //Info soll nicht geändert werden
          SendBuffSize += sizeof(UINT);         //Endezeichen in Byte
        end_if;
      else
        RetVal := ERR_WRONG_PARAMETER; //Parameterfehler
        exit;
      end_if;


      //--- Write Access String ----------------------------------------------------------------------------------//
      if pChangeRoleLoc^.pWriteAccessString then
        if pChangeRoleLoc^.pWriteAccessString^ <> 0 then
          //Access String soll geändert werden
          SendBuffSize += (SigCLib.StrLen16(str0:=pChangeRoleLoc^.pWriteAccessString)+1) * 2; //in Bytes inkl. Endezeichen
        else
          //Access String soll nicht geändert werden
          SendBuffSize += sizeof(UINT);         //Endezeichen in Byte
        end_if;
      else
        RetVal := ERR_WRONG_PARAMETER; //Parameterfehler
        exit;
      end_if;


      //--- Read Access String -----------------------------------------------------------------------------------//
      if pChangeRoleLoc^.pReadAccessString then
        if pChangeRoleLoc^.pReadAccessString^ <> 0 then
          //Access String soll geändert werden
          SendBuffSize += (SigCLib.StrLen16(str0:=pChangeRoleLoc^.pReadAccessString)+1) * 2; //in Bytes inkl. Endezeichen
        else
          //Access String soll nicht geändert werden
          SendBuffSize += sizeof(UINT);         //Endezeichen in Byte
        end_if;
      else
        RetVal := ERR_WRONG_PARAMETER; //Parameterfehler
        exit;
      end_if;


      //--- Privileges -------------------------------------------------------------------------------------------//
      SendBuffSize += sizeof(pChangeRoleLoc^.privileges);


      //--- no Operation Timeout ---------------------------------------------------------------------------------//
      SendBuffSize += sizeof(pChangeRoleLoc^.noOperationTimeout);


      //--- AccessNumberValid + AccessNumber ---------------------------------------------------------------------//
      if pChangeRoleLoc^.AccessNumberValid then
        SendBuffSize += sizeof(pChangeRoleLoc^.AccessNumberValid) + sizeof(pChangeRoleLoc^.AccessNumber);
      else
        //Der Eintrag <AccessNumber> existiert nicht
        SendBuffSize += sizeof(pChangeRoleLoc^.AccessNumberValid);
      end_if;


      //--- Src-Pointer weiterstellen ----------------------------------------------------------------------------//
      pChangeRoleLoc += sizeof(_DS_ChangeRoleCmd);
    end_for;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#ChangeRoleJobs, MessageID);
      MessageID := RetVal;
      return;
    end_if;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest

      pData$^UDINT^ := num;
      pData += sizeof(num);

      for tmpI:=0 to num-1 do
        //--- size -------------------------------------------------------------------------------------------------//
        pSize := pData$^UDINT;                      //Zeiger auf <size> merken
        pData += sizeof(UDINT);
        // <size> ermitteln: roleID + roleNameLen + WriteAccessStringLen + ReadAccessStringLen + infoLen + siehe unten
        pSize^ := 5 * sizeof(UDINT);

        //--- roleID -----------------------------------------------------------------------------------------------//
        pData$^UDINT^ := pChangeRole^.roleID;
        pData += sizeof(pChangeRole^.roleID);    

        //--- roleName ---------------------------------------------------------------------------------------------//
        if pChangeRole^.pRoleName^ <> 0 then
          //roleName soll geändert werden
          pLen  := pData$^UDINT;                    //Zeiger auf Stringlänge merken
          pData += sizeof(UDINT);
          pData := (_StrCpy16(dst:=pData$^UINT, src:=pChangeRole^.pRoleName, pLen))$^CHAR; //pData wird weitergestellt
          pLen^ := pLen^ + sizeof(UINT);            //Stringlänge + Endezeichen in Byte
          pSize^ += pLen^;
        else
          //roleName soll nicht geändert werden
          pData$^UDINT^ := sizeof(UINT);            //Endezeichen in Byte
          pData += sizeof(UDINT);
          pSize^ += sizeof(UINT);

          pData$^UINT^ := 0;                        //Leerstring
          pData += sizeof(UINT);
        end_if;

        //--- Info -------------------------------------------------------------------------------------------------//
        if pChangeRole^.pInfo^ <> 0 then
          //Info soll geändert werden
          pLen  := pData$^UDINT;                    //Zeiger auf Stringlänge merken
          pData += sizeof(UDINT);
          pData := (_StrCpy16(dst:=pData$^UINT, src:=pChangeRole^.pInfo, pLen))$^CHAR; //pData wird weitergestellt
          pLen^ := pLen^ + sizeof(UINT);            //Stringlänge + Endezeichen in Byte
          pSize^ += pLen^;
        else
          //Info soll nicht geändert werden
          pData$^UDINT^ := sizeof(UINT);            //Endezeichen in Byte
          pData += sizeof(UDINT);
          pSize^ += sizeof(UINT);

          pData$^UINT^ := 0;                        //Leerstring
          pData += sizeof(UINT);
        end_if;

        //--- Write Access String ----------------------------------------------------------------------------------//
        if pChangeRole^.pWriteAccessString^ <> 0 then
          //Access String soll geändert werden
          pLen  := pData$^UDINT;                    //Zeiger auf Stringlänge merken
          pData += sizeof(UDINT);
          pData := (_StrCpy16(dst:=pData$^UINT, src:=pChangeRole^.pWriteAccessString, pLen))$^CHAR; //pData wird weitergestellt
          pLen^ := pLen^ + sizeof(UINT);            //Stringlänge + Endezeichen in Byte
          pSize^ += pLen^;
        else
          //Access String soll nicht geändert werden
          pData$^UDINT^ := sizeof(UINT);            //Endezeichen in Byte
          pData += sizeof(UDINT);
          pSize^ += sizeof(UINT);

          pData$^UINT^ := 0;                        //Leerstring
          pData += sizeof(UINT);
        end_if;

        //--- Read Access String -----------------------------------------------------------------------------------//
        if pChangeRole^.pReadAccessString^ <> 0 then
          //Access String soll geändert werden
          pLen  := pData$^UDINT;                    //Zeiger auf Stringlänge merken
          pData += sizeof(UDINT);
          pData := (_StrCpy16(dst:=pData$^UINT, src:=pChangeRole^.pReadAccessString, pLen))$^CHAR; //pData wird weitergestellt
          pLen^ := pLen^ + sizeof(UINT);            //Stringlänge + Endezeichen in Byte
          pSize^ += pLen^;
        else
          //Access String soll nicht geändert werden
          pData$^UDINT^ := sizeof(UINT);            //Endezeichen in Byte
          pData += sizeof(UDINT);
          pSize^ += sizeof(UINT);

          pData$^UINT^ := 0;                        //Leerstring
          pData += sizeof(UINT);
        end_if;

        //--- Privileges -------------------------------------------------------------------------------------------//
        size := sizeof(pChangeRole^.privileges);
        _memcpy(ptr1:=pData, ptr2:=#pChangeRole^.privileges, cntr:=size);
        pData += size;
        pSize^ += size;

        //--- no Operation Timeout ---------------------------------------------------------------------------------//
        pData$^UINT^ := pChangeRole^.noOperationTimeout;
        pData += sizeof(pChangeRole^.noOperationTimeout);
        pSize^ += sizeof(pChangeRole^.noOperationTimeout);

        //--- AccessNumberValid ------------------------------------------------------------------------------------//
        pData$^USINT^ := pChangeRole^.AccessNumberValid;
        pData += sizeof(pChangeRole^.AccessNumberValid);
        pSize^ += sizeof(pChangeRole^.AccessNumberValid);

        //--- AccessNumber -----------------------------------------------------------------------------------------//
        if pChangeRole^.AccessNumberValid then
          pData$^UDINT^ := pChangeRole^.AccessNumber;
          pData += sizeof(pChangeRole^.AccessNumber);
          pSize^ += sizeof(pChangeRole^.AccessNumber);
        end_if;

        //--- Src-Pointer weiterstellen ----------------------------------------------------------------------------//
        pChangeRole += sizeof(_DS_ChangeRoleCmd);
      end_for;

  	  //*--- Header für Change Role aufbauen -------------------------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := ChangeRoleCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#ChangeRoleJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION

FUNCTION DSComm::GetRespData_ChangeRole
	VAR_INPUT
		pData 	: ^CHAR;
		pChangeRoleRsp 	: ^_DS_ChangeRoleResp;
		num 	: UDINT;
	END_VAR
  VAR
    max   : UDINT;
    tmpI  : UDINT;
  END_VAR

  max := num - 1;
  for tmpI:=0 to max do
    //--- size überspringen ----------------------------------------------------------------------------------//
    pData += sizeof(UDINT);

    //--- Daten umkopieren -----------------------------------------------------------------------------------//
    pChangeRoleRsp^ := pData$^_DS_ChangeRoleResp^;
    pData += sizeof(_DS_ChangeRoleResp);

    //--- Dest-Pointer weiterstellen -------------------------------------------------------------------------//
    pChangeRoleRsp += sizeof(_DS_ChangeRoleResp);
  end_for;

END_FUNCTION


FUNCTION GLOBAL DSComm::DeleteRole
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		num 	: UDINT;
		pRoleID 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^void;
  	pHeader     : ^_DS_Header;
    pData       : ^CHAR;
    pJobElmt    : ^_DS_JobInfoElmt;
    tmpI        : UDINT;
    DataLen     : UDINT;
    SendBuffSize: UDINT;
    RetVal      : DINT;
  END_VAR

  if num = 0 | pRoleID = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#DeleteRoleJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    //Puffergröße ermitteln: num * (size + Daten)
    DataLen := num * (sizeof(UDINT) + sizeof(pRoleID^));
    SendBuffSize := sizeof(_DS_Header) + sizeof(num) + DataLen;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest

      pData$^UDINT^ := num;
      pData += sizeof(num);

      //RoleIDs kopieren
      for tmpI:=0 to num-1 do
        //--- size -------------------------------------------------------------------------------------//
        pData$^UDINT^ := sizeof(UDINT);  //Größe des nächsten Eintrags
        pData += sizeof(UDINT);

        //--- VarID ------------------------------------------------------------------------------------//
        pData$^UDINT^ := pRoleID^;
        pData += sizeof(pRoleID^);

        //-- Src-Pointer weiterstellen -----------------------------------------------------------------//
        pRoleID += sizeof(pRoleID^);
      end_for;

  	  //*--- Header für Delete Role aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
	    pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := DeleteRoleCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#DeleteRoleJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION

FUNCTION DSComm::GetRespData_DeleteRole
	VAR_INPUT
		pData 	: ^CHAR;
		pDeleteRoleRsp 	: ^_DS_DeleteRoleResp;
		num 	: UDINT;
	END_VAR
  VAR
    max   : UDINT;
    tmpI  : UDINT;
  END_VAR

  max := num - 1;
  for tmpI:=0 to max do
    //--- size überspringen ----------------------------------------------------------------------------------//
    pData += sizeof(UDINT);

    //--- Daten umkopieren -----------------------------------------------------------------------------------//
    pDeleteRoleRsp^ := pData$^_DS_DeleteRoleResp^;
    pData += sizeof(_DS_DeleteRoleResp);

    //--- Dest-Pointer weiterstellen -------------------------------------------------------------------------//
    pDeleteRoleRsp += sizeof(_DS_DeleteRoleResp);
  end_for;

END_FUNCTION


FUNCTION GLOBAL DSComm::GetRoleList
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^char;
  	pHeader     : ^_DS_Header;
    pJobElmt    : ^_DS_JobInfoElmt;
    RetVal      : DINT;
  END_VAR

  if pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#GetRoleListJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=GetRoleList_BUFFER_SIZE, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      //*--- Header für Get Role List aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := GetRoleList_BUFFER_SIZE;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := GetRoleListCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#GetRoleListJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION DSComm::GetRespData_GetRoleList
	VAR_INPUT
		pData 	: ^CHAR;
		pGetRoleListRsp 	: ^_DS_GetRoleListResp;
		num 	: UDINT;
	END_VAR
  VAR
  	StringLen   : UDINT;
    max         : UDINT;
    tmpI        : UDINT;
  END_VAR

  max := num - 1;
  for tmpI:=0 to max do
    pData += sizeof(UDINT);   //size überspringen

    pGetRoleListRsp^.RoleID := (pData$^UDINT)^;
    pData += sizeof(pGetRoleListRsp^.RoleID);

    StringLen := pData$^UDINT^;                     //Anzahl der Bytes im uni-0-String mit Endezeichen.
    pData += sizeof(UDINT);

    pGetRoleListRsp^.NameLen := (StringLen-2) / 2;  //Anzahl der Zeichen im uni-0-String ohne Endezeichen.
    pGetRoleListRsp^.pName   := pData$^UINT;
    pData += StringLen;                             //+ Anzahl der Bytes im uni-0-String mit Endezeichen.

    pGetRoleListRsp += sizeof(_DS_GetRoleListResp);
  end_for;

END_FUNCTION


FUNCTION GLOBAL DSComm::GetRoleDetails
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		roleID 	: UDINT;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^char;
  	pHeader     : ^_DS_Header;
    pData       : ^CHAR;
    pJobElmt    : ^_DS_JobInfoElmt;
    RetVal      : DINT;
  END_VAR

  if pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#GetRoleDetailsJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=GetRoleDetails_BUFFER_SIZE, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      //*--- Header für Get Role Details aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := GetRoleDetails_BUFFER_SIZE;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := GetRoleDetailsCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      pData := pSendBuff + sizeof(_DS_Header);
      pData$^UDINT^ := roleID;

      RetVal := SendToCommTask(pData:=pSendBuff, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#GetRoleDetailsJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION DSComm::GetRespData_GetRoleDetails
	VAR_INPUT
		pData 	: ^CHAR;
		pGetRoleDetailsRsp 	: ^_DS_GetRoleDetailsResp;
	END_VAR
  VAR
  	StringLen   : UDINT;    //Zwischenvariable ergibt kürzeren Code (ARM und Intel)
    size        : UDINT;
  END_VAR


  _memset(dest:=pGetRoleDetailsRsp, usByte:=0, cntr:=sizeof(_DS_GetRoleDetailsResp));

  //--- roleID -----------------------------------------------------------------------------------------------//
  pGetRoleDetailsRsp^.RoleID := (pData$^UDINT)^;
  pData += sizeof(pGetRoleDetailsRsp^.RoleID);

  //--- ErrorCode --------------------------------------------------------------------------------------------//
  pGetRoleDetailsRsp^.ErrorCode := (pData$^UDINT)^;
  pData += sizeof(pGetRoleDetailsRsp^.ErrorCode);

  if pGetRoleDetailsRsp^.ErrorCode then
    return;   //Im Fehlerfall endet die Nachricht hier
  end_if;

  //--- name -------------------------------------------------------------------------------------------------//
  StringLen := pData$^UDINT^;                         //Anzahl der Bytes im uni-0-String mit Endezeichen.
  pData += sizeof(UDINT);

  pGetRoleDetailsRsp^.NameLen := (StringLen-2) / 2;   //Anzahl der Zeichen im uni-0-String ohne Endezeichen.
  pGetRoleDetailsRsp^.pName   := pData$^UINT;
  pData += StringLen;                                 //+ Anzahl der Bytes im uni-0-String mit Endezeichen.

  //--- WriteAccessString ------------------------------------------------------------------------------------//
  StringLen := pData$^UDINT^;                         //Anzahl der Bytes im uni-0-String mit Endezeichen.
  pData += sizeof(UDINT);

  pGetRoleDetailsRsp^.WriteAccessStrLen := (StringLen-2) / 2;//Anzahl der Zeichen im uni-0-String ohne Endezeichen.
  pGetRoleDetailsRsp^.pWriteAccessString := pData$^UINT;
  pData += StringLen;                                 //+ Anzahl der Bytes im uni-0-String mit Endezeichen.

  //--- ReadAccessString -------------------------------------------------------------------------------------//
  StringLen := pData$^UDINT^;                         //Anzahl der Bytes im uni-0-String mit Endezeichen.
  pData += sizeof(UDINT);

  pGetRoleDetailsRsp^.ReadAccessStrLen := (StringLen-2) / 2;//Anzahl der Zeichen im uni-0-String ohne Endezeichen.
  pGetRoleDetailsRsp^.pReadAccessString := pData$^UINT;
  pData += StringLen;                                 //+ Anzahl der Bytes im uni-0-String mit Endezeichen.

  //--- Info -------------------------------------------------------------------------------------------------//
  StringLen := pData$^UDINT^;                         //Anzahl der Bytes im uni-0-String mit Endezeichen.
  pData += sizeof(UDINT);

  pGetRoleDetailsRsp^.InfoLen := (StringLen-2) / 2;   //Anzahl der Zeichen im uni-0-String ohne Endezeichen.
  pGetRoleDetailsRsp^.pInfo   := pData$^UINT;
  pData += StringLen;                                 //+ Anzahl der Bytes im uni-0-String mit Endezeichen.

  //--- privileges -------------------------------------------------------------------------------------------//
  size := sizeof(pGetRoleDetailsRsp^.privileges);
  _memcpy(ptr1:=#pGetRoleDetailsRsp^.privileges, ptr2:=pData, cntr:=size);
  pData += size;

  //--- noOperationTimeout -----------------------------------------------------------------------------------//
  pGetRoleDetailsRsp^.noOperationTimeout := (pData$^UINT)^;
  pData += sizeof(pGetRoleDetailsRsp^.noOperationTimeout);

  //--- CreatedDate ------------------------------------------------------------------------------------------//
  pGetRoleDetailsRsp^.CreatedDate := (pData$^UDINT)^;
  pData += sizeof(pGetRoleDetailsRsp^.CreatedDate);

  //--- CreatedTime ------------------------------------------------------------------------------------------//
  pGetRoleDetailsRsp^.CreatedTime := (pData$^UDINT)^;
  pData += sizeof(pGetRoleDetailsRsp^.CreatedTime);

  //--- ModifiedRoleDate -------------------------------------------------------------------------------------//
  pGetRoleDetailsRsp^.ModifiedRoleDate := (pData$^UDINT)^;
  pData += sizeof(pGetRoleDetailsRsp^.ModifiedRoleDate);

  //--- ModifiedRoleTime -------------------------------------------------------------------------------------//
  pGetRoleDetailsRsp^.ModifiedRoleTime := (pData$^UDINT)^;
  pData += sizeof(pGetRoleDetailsRsp^.ModifiedRoleTime);

  //--- WriteProtected ---------------------------------------------------------------------------------------//
  pGetRoleDetailsRsp^.WriteProtected := pData$^USINT^;
  pData += sizeof(pGetRoleDetailsRsp^.WriteProtected);

  //--- AccessNumberValid ------------------------------------------------------------------------------------//
  pGetRoleDetailsRsp^.AccessNumberValid := pData$^USINT^;
  pData += sizeof(pGetRoleDetailsRsp^.AccessNumberValid);

  //--- AccessNumber -----------------------------------------------------------------------------------------//
  if pGetRoleDetailsRsp^.AccessNumberValid then
    pGetRoleDetailsRsp^.AccessNumber := pData$^UDINT^;
//  pData += sizeof(pGetRoleDetailsRsp^.AccessNumber);
  else
    pGetRoleDetailsRsp^.AccessNumber := 0;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::GetVarIdFromName
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		num 	: UDINT;
		ppName 	: ^pChar;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff     : ^void;
  	pHeader       : ^_DS_Header;
    pData         : ^CHAR;
    ppNameLoc     : ^pChar;
    pJobElmt      : ^_DS_JobInfoElmt;
    DataLen       : UDINT;
    tmpI          : UDINT;
    StrLen        : UDINT;    //in Bytes inkl. Endezeichen
    SendBuffSize  : UDINT;
    RetVal        : DINT;
  END_VAR

  if num = 0 | ppName = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#GetVarIdFromNameJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    //Datenlänge und Puffergröße ermitteln
    DataLen   := 0;
    ppNameLoc := ppName;

    for tmpI:=0 to num-1 do
      if ppNameLoc^ then
        //--- name ---------------------------------------------------------------------------------------//
        StrLen := _strlen(src:=ppNameLoc^) + 1;
        DataLen += StrLen;
      end_if;

      //-- Src-Pointer weiterstellen ---------------------------------------------------------------------//
      ppNameLoc += sizeof(ppNameLoc^);
    end_for;
    //                                                    size + namelen
    SendBuffSize := sizeof(_DS_Header) + sizeof(num) + num*2*sizeof(UDINT) + DataLen;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest
    
      pData$^UDINT^ := num;
      pData += sizeof(num);

      for tmpI:=0 to num-1 do
        if ppName^ then
          //--- size -------------------------------------------------------------------------------------//
          StrLen := _StrLen(src:=ppName^) + 1;
          pData$^UDINT^ := sizeof(UDINT) + StrLen;  //Größe des nächsten Eintrags
          pData += sizeof(UDINT);

          //--- namelen ----------------------------------------------------------------------------------//
          pData$^UDINT^ := StrLen;                  //Länge des Namens inkl. \0
          pData += sizeof(StrLen);

          //--- name -------------------------------------------------------------------------------------//
          //Name des Datenpunkts kopieren
          _strcpy(dest:=pData, src:=ppName^);
          pData += StrLen;
        end_if;

        //-- Src-Pointer weiterstellen -------------------------------------------------------------------//
        ppName += sizeof(ppName^);
      end_for;

  	  //*--- Header für Get VarId From Name aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := GetVarIdFromNameCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#GetVarIdFromNameJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION DSComm::GetRespData_GetVarIdFromName
	VAR_INPUT
		pData 	: ^CHAR;
		pGetVarIdFromNameRsp 	: ^_DS_GetVarIdFromNameResp;
		num 	: UDINT;
	END_VAR
  VAR
  	StringLen   : UDINT;
    max         : UDINT;
    tmpI        : UDINT;
  END_VAR

  max := num - 1;
  for tmpI:=0 to max do
    //--- Size -------------------------------------------------------------------------------------------------//
    pData += sizeof(UDINT);   //Size überspringen

    //--- NameLen ----------------------------------------------------------------------------------------------//
    StringLen := pData$^UDINT^;                     //Anzahl der Zeichen im String mit Endezeichen.
    pData += sizeof(UDINT);
    pGetVarIdFromNameRsp^.NameLen := StringLen - 1; //Anzahl der Zeichen im String ohne Endezeichen.

    //--- Name -------------------------------------------------------------------------------------------------//
    pGetVarIdFromNameRsp^.pName   := pData;
    pData += StringLen;                             //weiterstellen um Anzahl der Bytes im String mit Endezeichen.

    //--- ErrorCode --------------------------------------------------------------------------------------------//
    _memcpy(ptr1:=#pGetVarIdFromNameRsp^.ErrorCode, ptr2:=pData, cntr:=sizeof(pGetVarIdFromNameRsp^.ErrorCode));
    pData += sizeof(pGetVarIdFromNameRsp^.ErrorCode);

    //--- VarID ------------------------------------------------------------------------------------------------//
    if pGetVarIdFromNameRsp^.ErrorCode = 0 then
      _memcpy(ptr1:=#pGetVarIdFromNameRsp^.VarID, ptr2:=pData, cntr:=sizeof(pGetVarIdFromNameRsp^.VarID));
      pData += sizeof(pGetVarIdFromNameRsp^.VarID);
    else
      pGetVarIdFromNameRsp^.VarID := 0;
    end_if;

    pGetVarIdFromNameRsp += sizeof(_DS_GetVarIdFromNameResp);
  end_for;

END_FUNCTION


FUNCTION GLOBAL DSComm::GetVarIdFromLasalId
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		num 	: UDINT;
		pLasalId 	: ^_DS_GetVarIdFromLasalIdCmd;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff     : ^void;
  	pHeader       : ^_DS_Header;
    pData         : ^CHAR;
    pJobElmt      : ^_DS_JobInfoElmt;
    DataLen       : UDINT;
    tmpI          : UDINT;
    SendBuffSize  : UDINT;
    RetVal        : DINT;
  END_VAR

  if num = 0 | pLasalId = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#GetVarIdFromLasalIdJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    //Datenlänge und Puffergröße ermitteln: num * (size + Daten)
    DataLen := num * (sizeof(UDINT) + sizeof(pLasalId^));

    SendBuffSize := sizeof(_DS_Header) + sizeof(num) + DataLen;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest
    
      pData$^UDINT^ := num;
      pData += sizeof(num);
    
      //LasalIDs der Datenpunkte kopieren
      for tmpI:=0 to num-1 do
        //--- size -------------------------------------------------------------------------------------//
        pData$^UDINT^ := sizeof(_DS_GetVarIdFromLasalIdCmd);  //Größe des nächsten Eintrags
        pData += sizeof(UDINT);

        //--- lasalId + StationNr ----------------------------------------------------------------------//
        pData$^_DS_GetVarIdFromLasalIdCmd^ := pLasalId^;
        pData += sizeof(_DS_GetVarIdFromLasalIdCmd);

        //-- Src-Pointer weiterstellen -----------------------------------------------------------------//
        pLasalId += sizeof(_DS_GetVarIdFromLasalIdCmd);
      end_for;

  	  //*--- Header für Get VarId From LasalId aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := GetVarIdFromLasalIdCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#GetVarIdFromLasalIdJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION DSComm::GetRespData_GetVarIdFromLasalId
	VAR_INPUT
		pData 	: ^CHAR;
		pGetVarIdFromLasalIdRsp 	: ^_DS_GetVarIdFromLasalIdResp;
		num 	: UDINT;
	END_VAR
  VAR
    max   : UDINT;
    tmpI  : UDINT;
  END_VAR

  max := num - 1;
  for tmpI:=0 to max do
    pData += sizeof(UDINT);   //Size überspringen

    pGetVarIdFromLasalIdRsp^.LasalID := (pData$^UDINT)^;
    pData += sizeof(pGetVarIdFromLasalIdRsp^.LasalID);

    pGetVarIdFromLasalIdRsp^.StationNo := (pData$^UDINT)^;
    pData += sizeof(pGetVarIdFromLasalIdRsp^.StationNo);

    pGetVarIdFromLasalIdRsp^.ErrorCode := (pData$^UDINT)^;
    pData += sizeof(pGetVarIdFromLasalIdRsp^.ErrorCode);

    if pGetVarIdFromLasalIdRsp^.ErrorCode = 0 then
      pGetVarIdFromLasalIdRsp^.VarID := (pData$^UDINT)^;
      pData += sizeof(pGetVarIdFromLasalIdRsp^.VarID);
    else
      pGetVarIdFromLasalIdRsp^.VarID := 0;
    end_if;

    pGetVarIdFromLasalIdRsp += sizeof(_DS_GetVarIdFromLasalIdResp);
  end_for;

END_FUNCTION


FUNCTION GLOBAL DSComm::GetLasalIdFromName
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		num 	: UDINT;
		ppName 	: ^pChar;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff     : ^void;
  	pHeader       : ^_DS_Header;
    pData         : ^CHAR;
    ppNameLoc     : ^pChar;
    pJobElmt      : ^_DS_JobInfoElmt;
    DataLen       : UDINT;
    tmpI          : UDINT;
    StrLen        : UDINT;    //in Bytes inkl. Endezeichen
    SendBuffSize  : UDINT;
    RetVal        : DINT;
  END_VAR

  if num = 0 | ppName = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#GetLasalIdFromNameJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    //Datenlänge und Puffergröße ermitteln
    DataLen   := 0;
    ppNameLoc := ppName;

    for tmpI:=0 to num-1 do
      if ppNameLoc^ then
        //--- name ---------------------------------------------------------------------------------------//
        StrLen := _StrLen(src:=ppNameLoc^) + 1;
        DataLen += StrLen;
      end_if;

      //-- Src-Pointer weiterstellen ---------------------------------------------------------------------//
      ppNameLoc += sizeof(ppNameLoc^);
    end_for;

    //                                                    size + namelen
    SendBuffSize := sizeof(_DS_Header) + sizeof(num) + num*2*sizeof(UDINT) + DataLen;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest
    
      pData$^UDINT^ := num;
      pData += sizeof(num);

      for tmpI:=0 to num-1 do
        if ppName^ then
          //--- size -------------------------------------------------------------------------------------//
          StrLen := _StrLen(src:=ppName^) + 1;
          pData$^UDINT^ := sizeof(UDINT) + StrLen;  //Größe des nächsten Eintrags
          pData += sizeof(UDINT);

          //--- namelen ----------------------------------------------------------------------------------//
          pData$^UDINT^ := StrLen;                  //Länge des Namens inkl. \0
          pData += sizeof(StrLen);

          //--- name -------------------------------------------------------------------------------------//
          //Name des Datenpunkts kopieren
          _strcpy(dest:=pData, src:=ppName^);
          pData += StrLen;
        end_if;

        //-- Src-Pointer weiterstellen -------------------------------------------------------------------//
        ppName += sizeof(ppName^);
      end_for;

  	  //*--- Header für Get Lasal-Id From Name aufbauen -------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := GetLasalIdFromNameCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket,pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#GetLasalIdFromNameJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION DSComm::GetRespData_GetLasalIdFromName
	VAR_INPUT
		pData 	: ^CHAR;
		pGetLasalIdFromNameRsp 	: ^_DS_GetLasalIdFromNameResp;
		num 	: UDINT;
	END_VAR
  VAR
  	StringLen   : UDINT;
    max   : UDINT;
    tmpI        : UDINT;
  END_VAR

  max := num - 1;
  for tmpI:=0 to max do
    //--- Size -------------------------------------------------------------------------------------------------//
    pData += sizeof(UDINT);   //Size überspringen

    //--- NameLen ----------------------------------------------------------------------------------------------//
    StringLen := pData$^UDINT^;                         //Anzahl der Zeichen im String mit Endezeichen.
    pData += sizeof(UDINT);
    pGetLasalIdFromNameRsp^.NameLen := StringLen - 1;   //Anzahl der Zeichen im String ohne Endezeichen.

    //--- Name -------------------------------------------------------------------------------------------------//
    pGetLasalIdFromNameRsp^.pName := pData;
    pData += StringLen;                             //weiterstellen um Anzahl der Bytes im String mit Endezeichen.

    //--- ErrorCode --------------------------------------------------------------------------------------------//
    _memcpy(ptr1:=#pGetLasalIdFromNameRsp^.ErrorCode, ptr2:=pData, cntr:=sizeof(pGetLasalIdFromNameRsp^.ErrorCode));
    pData += sizeof(pGetLasalIdFromNameRsp^.ErrorCode);

    //--- LasalID ----------------------------------------------------------------------------------------------//
    if pGetLasalIdFromNameRsp^.ErrorCode = 0 then
      _memcpy(ptr1:=#pGetLasalIdFromNameRsp^.LasalId, ptr2:=pData, cntr:=sizeof(pGetLasalIdFromNameRsp^.LasalId));
      pData += sizeof(pGetLasalIdFromNameRsp^.LasalId);
    else
      pGetLasalIdFromNameRsp^.LasalId := 0;
    end_if;

    pGetLasalIdFromNameRsp += sizeof(_DS_GetLasalIdFromNameResp);
  end_for;

END_FUNCTION


FUNCTION GLOBAL DSComm::GetLasalIdFromVarId
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		num 	: UDINT;
		pVarId 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff     : ^void;
  	pHeader : ^_DS_Header;
    pData   : ^CHAR;
    DataLen : UDINT;
    pJobElmt      : ^_DS_JobInfoElmt;
    tmpI          : UDINT;
    SendBuffSize  : UDINT;
    RetVal        : DINT;
  END_VAR

  if num = 0 | pVarId = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#GetLasalIdFromVarIdJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    //Datenlänge und Puffergröße ermitteln: num * (size + Daten)
    DataLen := num * (sizeof(UDINT) + sizeof(pVarId^));

    SendBuffSize := sizeof(_DS_Header) + sizeof(num) + DataLen;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest
    
      pData$^UDINT^ := num;
      pData += sizeof(num);
    
      //VarIDs der Datenpunkte kopieren
      for tmpI:=0 to num-1 do
        //--- size -------------------------------------------------------------------------------------//
        pData$^UDINT^ := sizeof(UDINT);  //Größe des nächsten Eintrags
        pData += sizeof(UDINT);

        //--- VarID ------------------------------------------------------------------------------------//
        pData$^UDINT^ := pVarId^;
        pData += sizeof(pVarId^);

        //-- Src-Pointer weiterstellen -----------------------------------------------------------------//
        pVarId += sizeof(pVarId^);
      end_for;

	  //*--- Header für Get LasalId From VarId aufbauen --------------------------------------------------*//
      pheader                 := pSendBuff$^_DS_Header;
      pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := GetLasalIdFromVarIdCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pheader$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#GetLasalIdFromVarIdJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION DSComm::GetRespData_GetLasalIdIdFromVarId
	VAR_INPUT
		pData 	: ^CHAR;
		pGetLasalIdIdFromVarIdRsp 	: ^_DS_GetLasalIdIdFromVarIdResp;
		num 	: UDINT;
	END_VAR
  VAR
    max   : UDINT;
    tmpI        : UDINT;
  END_VAR

  max := num - 1;
  for tmpI:=0 to max do
    pData += sizeof(UDINT);   //Size überspringen

    pGetLasalIdIdFromVarIdRsp^.VarID := (pData$^UDINT)^;
    pData += sizeof(pGetLasalIdIdFromVarIdRsp^.VarID);

    pGetLasalIdIdFromVarIdRsp^.ErrorCode := (pData$^UDINT)^;
    pData += sizeof(pGetLasalIdIdFromVarIdRsp^.ErrorCode);

    if pGetLasalIdIdFromVarIdRsp^.ErrorCode = 0 then
      pGetLasalIdIdFromVarIdRsp^.LasalID := (pData$^UDINT)^;
      pData += sizeof(pGetLasalIdIdFromVarIdRsp^.LasalID);
    else
      pGetLasalIdIdFromVarIdRsp^.LasalID := 0;
    end_if;


    pGetLasalIdIdFromVarIdRsp += sizeof(_DS_GetLasalIdIdFromVarIdResp);
  end_for;

END_FUNCTION


FUNCTION GLOBAL DSComm::GetNameFromVarId
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		num 	: UDINT;
		pVarId 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff     : ^void;
  	pHeader       : ^_DS_Header;
    pData         : ^CHAR;
    pJobElmt      : ^_DS_JobInfoElmt;
    tmpI          : UDINT;
    DataLen       : UDINT;
    SendBuffSize  : UDINT;
    RetVal        : DINT;
  END_VAR

  if num = 0 | pVarId = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#GetNameFromVarIdJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    //Datenlänge und Puffergröße ermitteln: num * (size + Daten)
    DataLen := num * (sizeof(UDINT) + sizeof(pVarId^));

    SendBuffSize := sizeof(_DS_Header) + sizeof(num) + DataLen;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest
    
      pData$^UDINT^ := num;
      pData += sizeof(num);
    
      //VarIDs der Datenpunkte kopieren
      for tmpI:=0 to num-1 do
        //--- size -------------------------------------------------------------------------------------//
        pData$^UDINT^ := sizeof(UDINT);  //Größe des nächsten Eintrags
        pData += sizeof(UDINT);

        //--- VarID ------------------------------------------------------------------------------------//
        pData$^UDINT^ := pVarId^;
        pData += sizeof(pVarId^);

        //-- Src-Pointer weiterstellen -----------------------------------------------------------------//
        pVarId += sizeof(pVarId^);
      end_for;

	  //*--- Header für Get Name From VarId aufbauen --------------------------------------------------*//
      pheader                 := pSendBuff$^_DS_Header;
      pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := GetNameFromVarIdCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pheader$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#GetNameFromVarIdJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION DSComm::GetRespData_GetNameFromVarId
	VAR_INPUT
		pData 	: ^CHAR;
		pGetNameFromVarIdRsp 	: ^_DS_GetNameFromVarIdResp;
		num 	: UDINT;
	END_VAR
  VAR
  	StringLen   : UDINT;    //Zwischenvariable ergibt kürzeren Code (ARM und Intel)
    max   : UDINT;
    tmpI        : UDINT;
  END_VAR

  max := num - 1;
  for tmpI:=0 to max do
    //--- size -------------------------------------------------------------------------------------------------//
    pData += sizeof(UDINT);           //size überspringen

    //--- VarId ------------------------------------------------------------------------------------------------//
    _memcpy(ptr1:=#pGetNameFromVarIdRsp^.VarID, ptr2:=pData, cntr:=sizeof(pGetNameFromVarIdRsp^.VarID));
    pData += sizeof(pGetNameFromVarIdRsp^.VarID);

    //--- ErrorCode --------------------------------------------------------------------------------------------//
    _memcpy(ptr1:=#pGetNameFromVarIdRsp^.ErrorCode, ptr2:=pData, cntr:=sizeof(pGetNameFromVarIdRsp^.ErrorCode));
    pData += sizeof(pGetNameFromVarIdRsp^.ErrorCode);

    //--- nameLen ----------------------------------------------------------------------------------------------//
    StringLen := pData$^UDINT^;                     //Anzahl der Bytes im String mit Endezeichen.   
    pData += sizeof(UDINT);

    //--- name -------------------------------------------------------------------------------------------------//
    if pGetNameFromVarIdRsp^.ErrorCode = 0 then
      pGetNameFromVarIdRsp^.NameLen := StringLen-1; //Anzahl der Zeichen im String ohne Endezeichen.
      pGetNameFromVarIdRsp^.pName   := pData;
      pData += StringLen;                           //Anzahl der Bytes im String mit Endezeichen.
    else
      pGetNameFromVarIdRsp^.NameLen := 0;
      pGetNameFromVarIdRsp^.pName   := nil;
    end_if;

    pGetNameFromVarIdRsp += sizeof(_DS_GetNameFromVarIdResp);
  end_for;

END_FUNCTION


FUNCTION GLOBAL DSComm::GetNameFromLasalId
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		num 	: UDINT;
		pLasalId 	: ^_DS_GetNameFromLasalIdCmd;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff     : ^void;
  	pHeader       : ^_DS_Header;
    pData         : ^CHAR;
    pJobElmt      : ^_DS_JobInfoElmt;
    tmpI          : UDINT;
    DataLen       : UDINT;
    SendBuffSize  : UDINT;
    RetVal        : DINT;
  END_VAR

  if num = 0 | pLasalId = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#GetNameFromLasalIdJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    //Datenlänge und Puffergröße ermitteln: num * (size + Daten)
    DataLen := num * (sizeof(UDINT) + sizeof(_DS_GetNameFromLasalIdCmd));

    SendBuffSize := sizeof(_DS_Header) + sizeof(num) + DataLen;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest
    
      pData$^UDINT^ := num;
      pData += sizeof(num);
    
      //LasalIDs der Datenpunkte kopieren
      for tmpI:=0 to num-1 do
        //--- size -------------------------------------------------------------------------------------//
        pData$^UDINT^ := sizeof(pLasalId^);  //Größe des nächsten Eintrags
        pData += sizeof(UDINT);

        //--- lasalId + StationNr ----------------------------------------------------------------------//
        pData$^_DS_GetNameFromLasalIdCmd^ := pLasalId^;
        pData += sizeof(pLasalId^);

        //-- Src-Pointer weiterstellen -----------------------------------------------------------------//
        pLasalId += sizeof(pLasalId^);
      end_for;

	  //*--- Header für Get Name From Lasal-ID aufbauen --------------------------------------------------*//
      pheader                 := pSendBuff$^_DS_Header;
      pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := GetNameFromLasalIdCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pheader$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#GetNameFromLasalIdJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION DSComm::GetRespData_GetNameFromLasalId
	VAR_INPUT
		pData 	: ^CHAR;
		pGetNameFromLasalIdRsp 	: ^_DS_GetNameFromLasalIdResp;
		num 	: UDINT;
	END_VAR
  VAR
  	StringLen   : UDINT;    //Zwischenvariable ergibt kürzeren Code (ARM und Intel)
    max   : UDINT;
    tmpI        : UDINT;
  END_VAR

  max := num - 1;
  for tmpI:=0 to max do
    //--- size -------------------------------------------------------------------------------------------------//
    pData += sizeof(UDINT);           //size überspringen

    //--- LasalId ----------------------------------------------------------------------------------------------//
    _memcpy(ptr1:=#pGetNameFromLasalIdRsp^.LasalID, ptr2:=pData, cntr:=sizeof(pGetNameFromLasalIdRsp^.LasalID));
    pData += sizeof(pGetNameFromLasalIdRsp^.LasalID);

    //--- StationNo --------------------------------------------------------------------------------------------//
    _memcpy(ptr1:=#pGetNameFromLasalIdRsp^.StationNo, ptr2:=pData, cntr:=sizeof(pGetNameFromLasalIdRsp^.StationNo));
    pData += sizeof(pGetNameFromLasalIdRsp^.StationNo);

    //--- ErrorCode --------------------------------------------------------------------------------------------//
    _memcpy(ptr1:=#pGetNameFromLasalIdRsp^.ErrorCode, ptr2:=pData, cntr:=sizeof(pGetNameFromLasalIdRsp^.ErrorCode));
    pData += sizeof(pGetNameFromLasalIdRsp^.ErrorCode);

    //--- nameLen ----------------------------------------------------------------------------------------------//
    StringLen := pData$^UDINT^;                       //Anzahl der Bytes im String mit Endezeichen.   
    pData += sizeof(UDINT);

    //--- name -------------------------------------------------------------------------------------------------//
    if pGetNameFromLasalIdRsp^.ErrorCode = 0 then
      pGetNameFromLasalIdRsp^.NameLen := StringLen-1; //Anzahl der Zeichen im String ohne Endezeichen.
      pGetNameFromLasalIdRsp^.pName   := pData;
      pData += StringLen;                             //Anzahl der Bytes im String mit Endezeichen.
    else
      pGetNameFromLasalIdRsp^.NameLen := 0;
      pGetNameFromLasalIdRsp^.pName   := nil;
    end_if;

    pGetNameFromLasalIdRsp += sizeof(_DS_GetNameFromLasalIdResp);
  end_for;

END_FUNCTION


FUNCTION GLOBAL DSComm::RefListAdd
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		channel 	: UDINT;
		num 	: UDINT;
		pDpId 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pChannelInfo    : ^_DS_ChannelInfo;
    pSendBuff       : ^void;
  	pHeader         : ^_DS_Header;
    pData           : ^CHAR;
    pJobElmt        : ^_DS_JobInfoElmt;
    tmpI            : UDINT;
    DataLen         : UDINT;
    SendBuffSize    : UDINT;
    RetVal          : DINT;
  END_VAR

  if num = 0 | pDpId = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;
  
  if channel > DS_MAX_CHANNEL then
    MessageID := ERR_INVALID_CHANNEL; //Falsche Kanalnummer
    return;
  end_if;

  pChannelInfo := #ChannelInfo[channel];
  //  Section.SectionStart(); // *********************

  //Neuen Kanal anlegen oder zu einem bestehenden Kanal Datenpunkte hinzufügen.
  pChannelInfo^.pThis := pThis;

  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#RefListAddJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    //Datenlänge und Puffergröße ermitteln: num * (size + Daten)
    DataLen := num * (sizeof(UDINT) + sizeof(pDpId^));
    SendBuffSize := sizeof(_DS_Header) + sizeof(channel) + sizeof(num) + DataLen;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest

      pData$^UDINT^ := channel;
      pData   += sizeof(channel);

      pData$^UDINT^ := num;
      pData   += sizeof(num);

      //IDs der Datenpunkte kopieren
      for tmpI:=0 to num-1 do
        //--- size -------------------------------------------------------------------------------------//
        pData$^UDINT^ := sizeof(pDpId^);  //Größe des nächsten Eintrags
        pData += sizeof(UDINT);

        //--- dpId ..........---------------------------------------------------------------------------//
        pData$^UDINT^ := pDpId^;
        pData += sizeof(pDpId^);

        //-- Src-Pointer weiterstellen -----------------------------------------------------------------//
        pDpId += sizeof(pDpId^);
      end_for;

  	  //*--- Header für Ref List Add aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := RefListAddCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#RefListAddJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION DSComm::GetRespData_RefListAdd
	VAR_INPUT
		pData 	: ^CHAR;
		pRefListAddRsp 	: ^_DS_RefListAddResp;
		num 	: UDINT;
	END_VAR
  VAR
    max         : UDINT;
    tmpI        : UDINT;
  END_VAR

  max := num - 1;
  for tmpI:=0 to max do
    pData += sizeof(UDINT);           //size überspringen

    pRefListAddRsp^.dpID := (pData$^UDINT)^;
    pData += sizeof(pRefListAddRsp^.dpID);

    pRefListAddRsp^.ErrorCode := (pData$^UDINT)^;
    pData += sizeof(pRefListAddRsp^.ErrorCode);

    pRefListAddRsp += sizeof(_DS_RefListAddResp);
  end_for;

END_FUNCTION


FUNCTION GLOBAL DSComm::RefListSub
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		channel 	: UDINT;
		num 	: UDINT;
		pDpId 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff     : ^void;
  	pHeader       : ^_DS_Header;
    pData         : ^CHAR;
    pJobElmt      : ^_DS_JobInfoElmt;
    tmpI          : UDINT;
    DataLen       : UDINT;
    SendBuffSize  : UDINT;
    RetVal        : DINT;
  END_VAR

  if num = 0 | pDpId = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#RefListSubJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    //Datenlänge und Puffergröße ermitteln: num * (size + Daten)
    DataLen := num * (sizeof(UDINT) + sizeof(pDpId^));
    SendBuffSize := sizeof(_DS_Header) + sizeof(channel) + sizeof(num) + DataLen;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest

      pData$^UDINT^ := channel;
      pData   += sizeof(channel);

      pData$^UDINT^ := num;
      pData   += sizeof(num);

      //IDs der Datenpunkte kopieren
      for tmpI:=0 to num-1 do
        //--- size -------------------------------------------------------------------------------------//
        pData$^UDINT^ := sizeof(pDpId^);  //Größe des nächsten Eintrags
        pData += sizeof(UDINT);

        //--- dpId ..........---------------------------------------------------------------------------//
        pData$^UDINT^ := pDpId^;
        pData += sizeof(pDpId^);

        //-- Src-Pointer weiterstellen -----------------------------------------------------------------//
        pDpId += sizeof(pDpId^);
      end_for;

  	  //*--- Header für Ref List Sub aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := RefListSubCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#RefListSubJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION DSComm::GetRespData_RefListSub
	VAR_INPUT
		pData 	: ^CHAR;
		pRefListSubRsp 	: ^_DS_RefListSubResp;
		num 	: UDINT;
	END_VAR
  VAR
    max         : UDINT;
    tmpI        : UDINT;
  END_VAR

  max := num - 1;
  for tmpI:=0 to max do
    pData += sizeof(UDINT);           //size überspringen

    pRefListSubRsp^.dpID := (pData$^UDINT)^;
    pData += sizeof(pRefListSubRsp^.dpID);

    pRefListSubRsp^.ErrorCode := (pData$^UDINT)^;
    pData += sizeof(pRefListSubRsp^.ErrorCode);

    pRefListSubRsp += sizeof(_DS_RefListSubResp);
  end_for;

END_FUNCTION


FUNCTION DSComm::NewResponse
	VAR_INPUT
		pHeader 	: ^_DS_Header;
		pFragHeader 	: ^_DS_FragmentHeader;
		pRecvBuffer 	: ^CHAR;
		pDataBuffer 	: ^CHAR;
    ErrorNo           : DINT;
	END_VAR
  VAR
		pJobElmt 	        : ^_DS_JobInfoElmt;
    DataLength	      : UDINT;
    num               : UDINT;
    TotalNumLoc       : UDINT;
    Station           : UDINT;
    channel           : UDINT;
    LastPacket        : BOOL;
    DS_ErrorNo        : DINT;
    pChannel          : ^_DS_ChannelInfo;
    pProgressInfo     : ^_DS_ProgressInfo;
    pGetProjectInfoRsp: ^_DS_GetProjectInfoResp;
    pSubscribeStateRsp    : ^_DS_SubscribeStateResp;
    pUnsubscribeStateRsp  : ^_DS_UnsubscribeStateResp;
    pGetStateRsp          : ^_DS_GetStateResp;
    pRecipeLoadRsp    : ^_DS_RecipeLoadResp;
    pRecipeLoadRspInt : ^_DS_RecipeLoadRespInt;
    pRecipeSaveRsp    : ^_DS_RecipeSaveResp;
    pRecipeSaveRspInt : ^_DS_RecipeSaveRespInt;
    pGetValueRsp      : ^_DS_GetValueResp;
    pGetStringRsp     : ^_DS_GetStringResp;
    pSetValueRsp      : ^_DS_SetValueResp;
    pSetStringRsp     : ^_DS_SetStringResp;
    pGetUserListRsp   : ^_DS_GetUserListResp;
    pCreateRoleRsp    : ^_DS_CreateRoleResp;
    pChangeRoleRsp    : ^_DS_ChangeRoleResp;
    pDeleteRoleRsp    : ^_DS_DeleteRoleResp;
    pGetRoleListRsp   : ^_DS_GetRoleListResp;
    pResetDataserviceRsp      : ^_DS_ResetDataserviceResp;
    pRestartDataserviceRsp    : ^_DS_RestartDataserviceResp;
    pGetLocalClientListRsp    : ^_DS_GetLocalClientListResp;
    pGetLocalClientDetailsRsp : ^_DS_GetLocalClientDetailsResp;
//    pGetLocalClientByIDRsp    : ^_DS_GetLocalClientDetailsResp;
    pCheckAccessLevelRsp      : ^_DS_CheckAccessLevelResp;
    pCreateUserRsp            : ^_DS_CreateUserResp;
    pChangeUserSettingsRsp    : ^_DS_ChangeUserSettingsResp;
    pDeleteUserRsp            : ^_DS_DeleteUserResp;
    pGetVarIdFromNameRsp      : ^_DS_GetVarIdFromNameResp;
    pGetVarIdFromLasalIdRsp   : ^_DS_GetVarIdFromLasalIdResp;
    pGetLasalIdFromNameRsp    : ^_DS_GetLasalIdFromNameResp;
    pGetLasalIdIdFromVarIdRsp : ^_DS_GetLasalIdIdFromVarIdResp;
    pGetNameFromVarIdRsp      : ^_DS_GetNameFromVarIdResp;
    pGetNameFromLasalIdRsp    : ^_DS_GetNameFromLasalIdResp;
    pGetDpListRsp     : ^_DS_GetDpListResp;
    pGetDpInfoRsp     : ^_DS_GetDpInfoResp;
    pGetVarIdFromCRCRsp       : ^_DS_GetVarIdFromCRCResp;
    pGetCRCfromVarIdRsp       : ^_DS_GetCRCfromVarIdResp;
    pRefListAddRsp    : ^_DS_RefListAddResp;
    pRefListSubRsp    : ^_DS_RefListSubResp;
    pRefListUpd       : ^_DS_RefListUpdate;
    pRefListUpdString : ^_DS_RefListUpdateString;
    pStationListRsp   : ^_DS_StationListResp;
    pStationStatusRsp : ^_DS_StationStatusResp;
    pProgressStatus   : ^_DS_ProgressStatus;
    pFileOpenRsp      : ^_DS_FileOpenResp;
    pFileReadRsp      : ^_DS_FileReadResp;
    pFileGetRsp       : ^_DS_FileGetResp;
    pFileContentRsp   : ^_DS_FileContentResp;
    pDirCreateRsp     : ^_DS_DirCreateResp;
    pDirReadRsp       : ^_DS_DirReadResp;
    pGetDriveListRsp  : ^_DS_GetDriveListResp;
    pUserEvent        : ^_DS_UsrEvntMinorID;
    pEventjournalAddRsp : ^_DS_EventjournalAddResp;
    pEventjournalGetRsp : ^_DS_EventjournalGetResp;
    pEventjournalDelRsp : ^_DS_EventjournalDelResp;
    pEventjournalQuitAlarmRsp : ^_DS_EventjournalQuitAlarmResp;
    pEventjournalQuitAllRsp   : ^_DS_EventjournalQuitAllResp;
    pAlarmListUpdAdd  : ^_DS_AlarmListUpdateAddResp;
    pAlarmListUpdSub  : ^_DS_AlarmListUpdateSubResp;
    pAlarmListUpdate  : ^_DS_AlarmListUpdate;
    pHotAlarmAdd      : ^_DS_HotAlarmAddResp;
    pHotAlarmSub      : ^_DS_HotAlarmSubResp;
    pHotAlarmUpdate   : ^_DS_HotAlarmUpdate;
    pAlarmDeleteRsp   : ^_DS_AlarmDeleteResp;
    pAlarmDeleteUpd   : ^_DS_AlarmDeleteUpdate;
  END_VAR

	//*--- Daten auswerten ----------------------------------------------------------------*//
  case pHeader^.MajorID of
    SIGMATEK_PROTOKOLL:
      case pHeader^.MinorID of
        AliveTriggerRsp:
//          AliveTrigger();


        CancelCmdRsp:
          pJobElmt := FindJob(pJobInfo:=#CancelCommandJobs, pHeader^.MessageID);
          if pJobElmt then
            pJobElmt^.pThis^.CancelCommandResp(pHeader^.MessageID, ErrorNo, pRecvBuffer$^DSComm::_DS_CancelResp);
            RemoveJob(pJobInfo:=#CancelCommandJobs, pHeader^.MessageID);
          end_if;


        GetVersionRsp:
          pJobElmt := FindJob(pJobInfo:=#GetVersionJobs, pHeader^.MessageID);

          if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
            DS_Version := (pRecvBuffer$^UDINT)^;
            DS_BuildNo := ((pRecvBuffer+sizeof(DS_Version))$^UDINT)^;
          end_if;

          if pJobElmt then
            pJobElmt^.pThis^.GetVersionResp(pHeader^.MessageID, ErrorNo, pRecvBuffer$^DSComm::_DS_GetVersionResp);
            RemoveJob(pJobInfo:=#GetVersionJobs, pHeader^.MessageID);
          end_if;


        GetProjectInfoRsp:
          pJobElmt := FindJob(pJobInfo:=#GetProjectInfoJobs, pHeader^.MessageID);
          if pJobElmt then
            pGetProjectInfoRsp := pDataBuffer$^_DS_GetProjectInfoResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              GetRespData_GetProjectInfo(pRecvBuffer, pGetProjectInfoRsp);
            end_if;

            pJobElmt^.pThis^.GetProjectInfoResp(pHeader^.MessageID, ErrorNo, pGetProjectInfoRsp);
            RemoveJob(pJobInfo:=#GetProjectInfoJobs, pHeader^.MessageID);
          end_if;

        //Antwort auf SendUserEvent()
        SendUserEventRsp:
          pJobElmt := FindJob(pJobInfo:=#SendUserEventJobs, pHeader^.MessageID);
          if pJobElmt then
            pJobElmt^.pThis^.SendUserEventResp(pHeader^.MessageID, ErrorNo, pRecvBuffer$^DSComm::_DS_UserEventResp);
            RemoveJob(pJobInfo:=#SendUserEventJobs, pHeader^.MessageID);
          end_if;
        

        SendFragmentRsp:
          DBG_FragRespCount += 1;


        SubscribeStateRsp:
          pJobElmt := FindJob(pJobInfo:=#SubscribeStateJobs, pHeader^.MessageID);

          if pJobElmt then
            pSubscribeStateRsp := pRecvBuffer$^_DS_SubscribeStateResp;
            if pSubscribeStateRsp^.ErrorCode <> 0 then
              //Pointer löschen, wenn beim DS nicht angemeldet.
              pThis_UpdateState := nil;
            end_if;

            pJobElmt^.pThis^.SubscribeStateResp(pHeader^.MessageID, ErrorNo, pSubscribeStateRsp);
            RemoveJob(pJobInfo:=#SubscribeStateJobs, pHeader^.MessageID);
          end_if;


        UnsubscribeStateRsp:
          pJobElmt := FindJob(pJobInfo:=#UnsubscribeStateJobs, pHeader^.MessageID);

          if pJobElmt then
            pUnsubscribeStateRsp := pRecvBuffer$^_DS_UnsubscribeStateResp;
            if pUnsubscribeStateRsp^.ErrorCode = 0 then
              //Pointer erst löschen, wenn abmelden vom DS bestätigt wird.
              pThis_UpdateState := nil;
            end_if;

            pJobElmt^.pThis^.UnsubscribeStateResp(pHeader^.MessageID, ErrorNo, pUnsubscribeStateRsp);
            RemoveJob(pJobInfo:=#UnsubscribeStateJobs, pHeader^.MessageID);
          end_if;


        UpdateStatePsh:
          if pThis_UpdateState then
            pGetStateRsp := pDataBuffer$^_DS_GetStateResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              GetRespData_GetState(pRecvBuffer, pGetStateRsp);
            end_if;

            pThis_UpdateState^.UpdateStatePush(pGetStateRsp);
          end_if;


        GetStateRsp:
          pJobElmt := FindJob(pJobInfo:=#GetStateJobs, pHeader^.MessageID);
          if pJobElmt then
            pGetStateRsp  := pDataBuffer$^_DS_GetStateResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              GetRespData_GetState(pRecvBuffer, pGetStateRsp);
            end_if;

            pJobElmt^.pThis^.Get_StateResp(pHeader^.MessageID, ErrorNo, pGetStateRsp);
            RemoveJob(pJobInfo:=#GetStateJobs, pHeader^.MessageID);
          end_if;


        LoopRsp:
          pJobElmt := FindJob(pJobInfo:=#LoopJobs, pHeader^.MessageID);
          if pJobElmt then
            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              Station := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(Station);

              DataLength := pHeader^.Length - sizeof(_DS_Header);
            else
              Station := 0;
              DataLength := 0;
            end_if;

            pJobElmt^.pThis^.LoopResp(pHeader^.MessageID, ErrorNo, Station, pRecvBuffer, DataLength);
            RemoveJob(pJobInfo:=#LoopJobs, pHeader^.MessageID);
          end_if;


        ProgressStatusPsh:
          if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
            pProgressStatus := pRecvBuffer$^DSComm::_DS_ProgressStatus;

            pProgressInfo := GetpProgressInfo(pProgressStatus^.HandleID$DINT);
            if pProgressInfo then
              if pProgressInfo^.pThis then
                pProgressInfo^.pThis^.ProgressStatusPush(pProgressStatus);
              end_if;

              if pProgressStatus^.State = 2 then
                ErrorNo := DeletepProgressInfo(pProgressStatus^.HandleID$DINT);
              end_if;
            end_if;
          end_if;


        RecipeLoadRsp:
          pJobElmt := FindJob(pJobInfo:=#RecipeLoadJobs, pHeader^.MessageID);
          if pJobElmt then
            pRecipeLoadRsp  := pDataBuffer$^_DS_RecipeLoadResp;
            pRecipeLoadRspInt := pRecvBuffer$^_DS_RecipeLoadRespInt;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              GetRespData_RecipeLoad(pRecipeLoadRspInt, pRecipeLoadRsp);
            end_if;

            pJobElmt^.pThis^.RecipeLoadResp(pHeader^.MessageID, ErrorNo, pRecipeLoadRsp);
            RemoveJob(pJobInfo:=#RecipeLoadJobs, pHeader^.MessageID);
          end_if;


        RecipeSaveRsp:
          pJobElmt := FindJob(pJobInfo:=#RecipeSaveJobs, pHeader^.MessageID);
          if pJobElmt then
            pRecipeSaveRsp  := pDataBuffer$^_DS_RecipeSaveResp;
            pRecipeSaveRspInt := pRecvBuffer$^_DS_RecipeSaveRespInt;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              GetRespData_RecipeSave(pRecipeSaveRspInt, pRecipeSaveRsp);
            end_if;

            pJobElmt^.pThis^.RecipeSaveResp(pHeader^.MessageID, ErrorNo, pRecipeSaveRsp);
            RemoveJob(pJobInfo:=#RecipeSaveJobs, pHeader^.MessageID);
          end_if;


        SendToAllRsp:
          pJobElmt := FindJob(pJobInfo:=#SendToAllJobs, pHeader^.MessageID);
          if pJobElmt then
            pJobElmt^.pThis^.SendToAllResp(pHeader^.MessageID, ErrorNo);
            RemoveJob(pJobInfo:=#SendToAllJobs, pHeader^.MessageID);
          end_if;


        SendToAllPsh:
          if SendToAllpThis then
            DataLength := pHeader^.Length - sizeof(_DS_Header);
            SendToAllpThis^.SendToAllPush(pHeader^.MessageID, ErrorNo, pRecvBuffer, DataLength);
          end_if;


        ResetDataserviceRsp:
          pJobElmt := FindJob(pJobInfo:=#ResetDataserviceJobs, pHeader^.MessageID);

          if pJobElmt then
            pResetDataserviceRsp := pRecvBuffer$^_DS_ResetDataserviceResp;
            if pResetDataserviceRsp^.ErrorCode = 0 then
              DS_Reset := TRUE;
            end_if;

            pJobElmt^.pThis^.ResetDataserviceResp(pHeader^.MessageID, ErrorNo, pResetDataserviceRsp);
            RemoveJob(pJobInfo:=#ResetDataserviceJobs, pHeader^.MessageID);
          end_if;


        RestartDataserviceRsp:
          pJobElmt := FindJob(pJobInfo:=#RestartDataserviceJobs, pHeader^.MessageID);

          if pJobElmt then
            pRestartDataserviceRsp := pRecvBuffer$^_DS_RestartDataserviceResp;
            if pRestartDataserviceRsp^.ErrorCode = 0 then
              DS_Reset := FALSE;
            end_if;

            pJobElmt^.pThis^.RestartDataserviceResp(pHeader^.MessageID, ErrorNo, pRestartDataserviceRsp);
            RemoveJob(pJobInfo:=#RestartDataserviceJobs, pHeader^.MessageID);
          end_if;


        AddLocalClientRsp:
          pJobElmt := FindJob(pJobInfo:=#AddLocalClientJobs, pHeader^.MessageID);
          if pJobElmt then
            pJobElmt^.pThis^.AddLocalClientResp(pHeader^.MessageID, ErrorNo, pRecvBuffer$^DSComm::_DS_AddLocalClientResp);
            RemoveJob(pJobInfo:=#AddLocalClientJobs, pHeader^.MessageID);
          end_if;


        AddLocalClientRangeRsp:
          pJobElmt := FindJob(pJobInfo:=#AddLocalClientRangeJobs, pHeader^.MessageID);
          if pJobElmt then
            pJobElmt^.pThis^.AddLocalClientRangeResp(pHeader^.MessageID, ErrorNo, pRecvBuffer$^DSComm::_DS_AddLocalClientRangeResp);
            RemoveJob(pJobInfo:=#AddLocalClientRangeJobs, pHeader^.MessageID);
          end_if;


        RemoveThisLocalClientRsp:
          pJobElmt := FindJob(pJobInfo:=#RemoveThisLocalClientJobs, pHeader^.MessageID);
          if pJobElmt then
            pJobElmt^.pThis^.RemoveThisLocalClientResp(pHeader^.MessageID, ErrorNo, pRecvBuffer$^DSComm::_DS_RemoveThisLocalClientResp);
            RemoveJob(pJobInfo:=#RemoveThisLocalClientJobs, pHeader^.MessageID);
          end_if;


        RemoveLocalClientRsp:
          pJobElmt := FindJob(pJobInfo:=#RemoveLocalClientJobs, pHeader^.MessageID);
          if pJobElmt then
            pJobElmt^.pThis^.RemoveLocalClientResp(pHeader^.MessageID, ErrorNo, pRecvBuffer$^DSComm::_DS_RemoveLocalClientResp);
            RemoveJob(pJobInfo:=#RemoveLocalClientJobs, pHeader^.MessageID);
          end_if;


        RemoveLocalClientRangeRsp:
          pJobElmt := FindJob(pJobInfo:=#RemoveLocalClientRangeJobs, pHeader^.MessageID);
          if pJobElmt then
            pJobElmt^.pThis^.RemoveLocalClientRangeResp(pHeader^.MessageID, ErrorNo, pRecvBuffer$^DSComm::_DS_RemoveLocalClientRangeResp);
            RemoveJob(pJobInfo:=#RemoveLocalClientRangeJobs, pHeader^.MessageID);
          end_if;


        ClearLocalClientListRsp:
          pJobElmt := FindJob(pJobInfo:=#ClearLocalClientListJobs, pHeader^.MessageID);
          if pJobElmt then
            pJobElmt^.pThis^.ClearLocalClientListResp(pHeader^.MessageID, ErrorNo, pRecvBuffer$^DSComm::_DS_ClearLocalClientListResp);
            RemoveJob(pJobInfo:=#ClearLocalClientListJobs, pHeader^.MessageID);
          end_if;


        GetCurrentIDRsp:
          pJobElmt := FindJob(pJobInfo:=#GetCurrentIDJobs, pHeader^.MessageID);
          if pJobElmt then
            pJobElmt^.pThis^.GetCurrentIDResp(pHeader^.MessageID, ErrorNo, pRecvBuffer$^DSComm::_DS_GetCurrentIDResp);
            RemoveJob(pJobInfo:=#GetCurrentIDJobs, pHeader^.MessageID);
          end_if;


        GetLocalClientListRsp:
          pJobElmt := FindJob(pJobInfo:=#GetLocalClientListJobs, pHeader^.MessageID);
          if pJobElmt then
            pGetLocalClientListRsp := pDataBuffer$^_DS_GetLocalClientListResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);

              if num then
                GetRespData_GetLocalClientList(pRecvBuffer, pGetLocalClientListRsp, num);
              end_if;
            else
              num := 0;
            end_if;

            pJobElmt^.pThis^.GetLocalClientListResp(pHeader^.MessageID, ErrorNo, num, pGetLocalClientListRsp);
            RemoveJob(pJobInfo:=#GetLocalClientListJobs, pHeader^.MessageID);
          end_if;


        GetLocalClientListDetailsRsp:
          pJobElmt := FindJob(pJobInfo:=#GetLocalClientListDetailsJobs, pHeader^.MessageID);
          if pJobElmt then
            pGetLocalClientDetailsRsp := pDataBuffer$^_DS_GetLocalClientDetailsResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);

              if num then
                GetRespData_GetLocalClientListDetails(pRecvBuffer, pGetLocalClientDetailsRsp, num, TRUE);
              end_if;
            else
              num := 0;
            end_if;

            pJobElmt^.pThis^.GetLocalClientListDetailsResp(pHeader^.MessageID, ErrorNo, num, pGetLocalClientDetailsRsp);
            RemoveJob(pJobInfo:=#GetLocalClientListDetailsJobs, pHeader^.MessageID);
          end_if;


        GetLocalClientByIDRsp:
          pJobElmt := FindJob(pJobInfo:=#GetLocalClientByIDJobs, pHeader^.MessageID);
          if pJobElmt then
            pGetLocalClientDetailsRsp := pDataBuffer$^_DS_GetLocalClientDetailsResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              GetRespData_GetLocalClientListDetails(pRecvBuffer, pGetLocalClientDetailsRsp, 1, FALSE);
            end_if;

            pJobElmt^.pThis^.GetLocalClientByIDResp(pHeader^.MessageID, ErrorNo, pGetLocalClientDetailsRsp);
            RemoveJob(pJobInfo:=#GetLocalClientByIDJobs, pHeader^.MessageID);
          end_if;


        UserLoginRsp:
          pJobElmt := FindJob(pJobInfo:=#UserLoginJobs, pHeader^.MessageID);
          if pJobElmt then
            SendToAllpThis := pJobElmt^.pThis;    //Ptr zum Aufruf von SendToAllPush()

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              GetRespData_UserLogin(pRecvBuffer, #UserLoginData);
              UserIDLogin := UserLoginData.UserID;  //Benutzer merken, UserLoginData wird durch GetUserDetails() überschrieben.
            end_if;

            pJobElmt^.pThis^.UserLoginResp(pHeader^.MessageID, ErrorNo, #UserLoginData);
            RemoveJob(pJobInfo:=#UserLoginJobs, pHeader^.MessageID);
          end_if;


        UserLogoutRsp:
          pJobElmt := FindJob(pJobInfo:=#UserLogoutJobs, pHeader^.MessageID);
          if pJobElmt then
            SendToAllpThis := nil;    //SendToAllPush() nicht mehr aufrufen
            UserIDLogin := 0;         //Kein Benutzer angemeldet.
            pJobElmt^.pThis^.UserLogoutResp(pHeader^.MessageID, ErrorNo);
            RemoveJob(pJobInfo:=#UserLogoutJobs, pHeader^.MessageID);
          end_if;


        UserPasswordChangeRsp:
          pJobElmt := FindJob(pJobInfo:=#UserPwdChangeJobs, pHeader^.MessageID);
          if pJobElmt then
            pJobElmt^.pThis^.UserPasswordChangeResp(pHeader^.MessageID, ErrorNo, pRecvBuffer$^_DS_UserPasswordChangeResp);
            RemoveJob(pJobInfo:=#UserPwdChangeJobs, pHeader^.MessageID);
          end_if;


        CheckAccessLevelRsp:
          pJobElmt := FindJob(pJobInfo:=#CheckAccessLevelJobs, pHeader^.MessageID);
          if pJobElmt then
            pCheckAccessLevelRsp := pDataBuffer$^_DS_CheckAccessLevelResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);

              if num then
                GetRespData_CheckAccessLevel(pRecvBuffer, pCheckAccessLevelRsp, num);
              end_if;
            else
              num := 0;
            end_if;

            pJobElmt^.pThis^.CheckAccessLevelResp(pHeader^.MessageID, ErrorNo, num, pCheckAccessLevelRsp);
            RemoveJob(pJobInfo:=#CheckAccessLevelJobs, pHeader^.MessageID);
          end_if;


        CreateUserRsp:
          pJobElmt := FindJob(pJobInfo:=#CreateUserJobs, pHeader^.MessageID);
          if pJobElmt then
            pCreateUserRsp := pDataBuffer$^_DS_CreateUserResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);

              if num then
                GetRespData_CreateUser(pRecvBuffer, pCreateUserRsp, num);
              end_if;
            else
              num := 0;
            end_if;

            pJobElmt^.pThis^.CreateUserResp(pHeader^.MessageID, ErrorNo, num, pCreateUserRsp);
            RemoveJob(pJobInfo:=#CreateUserJobs, pHeader^.MessageID);
          end_if;


        ChangeUserSettingsRsp:
          pJobElmt := FindJob(pJobInfo:=#ChangeUserSettingsJobs, pHeader^.MessageID);
          if pJobElmt then
            pChangeUserSettingsRsp := pDataBuffer$^_DS_ChangeUserSettingsResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);

              if num then
                GetRespData_ChangeUserSettings(pRecvBuffer, pChangeUserSettingsRsp, num);
              end_if;
            else
              num := 0;
            end_if;

            pJobElmt^.pThis^.ChangeUserSettingsResp(pHeader^.MessageID, ErrorNo, num, pChangeUserSettingsRsp);
            RemoveJob(pJobInfo:=#ChangeUserSettingsJobs, pHeader^.MessageID);
          end_if;


        DeleteUserRsp:
          pJobElmt := FindJob(pJobInfo:=#DeleteUserJobs, pHeader^.MessageID);
          if pJobElmt then
            pDeleteUserRsp := pDataBuffer$^_DS_DeleteUserResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);

              if num then
                GetRespData_DeleteUser(pRecvBuffer, pDeleteUserRsp, num);
              end_if;
            else
              num := 0;
            end_if;

            pJobElmt^.pThis^.DeleteUserResp(pHeader^.MessageID, ErrorNo, num, pDeleteUserRsp);
            RemoveJob(pJobInfo:=#DeleteUserJobs, pHeader^.MessageID);
          end_if;


        GetUserListRsp:
          pJobElmt := FindJob(pJobInfo:=#GetUserListJobs, pHeader^.MessageID);
          if pJobElmt then
            pGetUserListRsp := pDataBuffer$^_DS_GetUserListResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);

              if num then
                GetRespData_GetUserList(pRecvBuffer, pGetUserListRsp, num);
              end_if;
            else
              num := 0;
            end_if;

            pJobElmt^.pThis^.GetUserListResp(pHeader^.MessageID, ErrorNo, num, pGetUserListRsp);
            RemoveJob(pJobInfo:=#GetUserListJobs, pHeader^.MessageID);
          end_if;


        GetUserDetailsRsp:
          pJobElmt := FindJob(pJobInfo:=#GetUserDetailsJobs, pHeader^.MessageID);
          if pJobElmt then
            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              GetRespData_UserLogin(pRecvBuffer, #UserLoginData);
            end_if;

            pJobElmt^.pThis^.GetUserDetailsResp(pHeader^.MessageID, ErrorNo, #UserLoginData);
            RemoveJob(pJobInfo:=#GetUserDetailsJobs, pHeader^.MessageID);
          end_if;


        CreateRoleRsp:
          pJobElmt := FindJob(pJobInfo:=#CreateRoleJobs, pHeader^.MessageID);
          if pJobElmt then
            pCreateRoleRsp := pDataBuffer$^_DS_CreateRoleResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);

              if num then
                GetRespData_CreateRole(pRecvBuffer, pCreateRoleRsp, num);
              end_if;
            else
              num := 0;
            end_if;

            pJobElmt^.pThis^.CreateRoleResp(pHeader^.MessageID, ErrorNo, num, pCreateRoleRsp);
            RemoveJob(pJobInfo:=#CreateRoleJobs, pHeader^.MessageID);
          end_if;


        ChangeRoleRsp:
          pJobElmt := FindJob(pJobInfo:=#ChangeRoleJobs, pHeader^.MessageID);
          if pJobElmt then
            pChangeRoleRsp := pDataBuffer$^_DS_ChangeRoleResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);

              if num then
                GetRespData_ChangeRole(pRecvBuffer, pChangeRoleRsp, num);
              end_if;
            else
              num := 0;
            end_if;

            pJobElmt^.pThis^.ChangeRoleResp(pHeader^.MessageID, ErrorNo, num, pChangeRoleRsp);
            RemoveJob(pJobInfo:=#ChangeRoleJobs, pHeader^.MessageID);
          end_if;


        DeleteRoleRsp:
          pJobElmt := FindJob(pJobInfo:=#DeleteRoleJobs, pHeader^.MessageID);
          if pJobElmt then
            pDeleteRoleRsp := pDataBuffer$^_DS_DeleteRoleResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);

              if num then
                GetRespData_DeleteRole(pRecvBuffer, pDeleteRoleRsp, num);
              end_if;
            else
              num := 0;
            end_if;

            pJobElmt^.pThis^.DeleteRoleResp(pHeader^.MessageID, ErrorNo, num, pDeleteRoleRsp);
            RemoveJob(pJobInfo:=#DeleteRoleJobs, pHeader^.MessageID);
          end_if;


        GetRoleListRsp:
          pJobElmt := FindJob(pJobInfo:=#GetRoleListJobs, pHeader^.MessageID);
          if pJobElmt then
            pGetRoleListRsp := pDataBuffer$^_DS_GetRoleListResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);

              if num then
                GetRespData_GetRoleList(pRecvBuffer, pGetRoleListRsp, num);
              end_if;
            else
              num := 0;
            end_if;

            pJobElmt^.pThis^.GetRoleListResp(pHeader^.MessageID, ErrorNo, num, pGetRoleListRsp);
            RemoveJob(pJobInfo:=#GetRoleListJobs, pHeader^.MessageID);
          end_if;


        GetRoleDetailsRsp:
          pJobElmt := FindJob(pJobInfo:=#GetRoleDetailsJobs, pHeader^.MessageID);
          if pJobElmt then
            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              GetRespData_GetRoleDetails(pRecvBuffer, #RoleDetails);
            end_if;

            pJobElmt^.pThis^.GetRoleDetailsResp(pHeader^.MessageID, ErrorNo, #RoleDetails);
            RemoveJob(pJobInfo:=#GetRoleDetailsJobs, pHeader^.MessageID);
          end_if;


        GetVarIdFromNameRsp:
          pJobElmt := FindJob(pJobInfo:=#GetVarIdFromNameJobs, pHeader^.MessageID);
          if pJobElmt then
            pGetVarIdFromNameRsp := pDataBuffer$^_DS_GetVarIdFromNameResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);

              if num then
                GetRespData_GetVarIdFromName(pRecvBuffer, pGetVarIdFromNameRsp, num);
              end_if;
            else
              num := 0;
            end_if;

            pJobElmt^.pThis^.GetVarIdFromNameResp(pHeader^.MessageID, ErrorNo, num, pGetVarIdFromNameRsp);
            RemoveJob(pJobInfo:=#GetVarIdFromNameJobs, pHeader^.MessageID);
          end_if;


        GetVarIdFromLasalIdRsp:
          pJobElmt := FindJob(pJobInfo:=#GetVarIdFromLasalIdJobs, pHeader^.MessageID);
          if pJobElmt then
            pGetVarIdFromLasalIdRsp := pDataBuffer$^_DS_GetVarIdFromLasalIdResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);

              if num then
                GetRespData_GetVarIdFromLasalId(pRecvBuffer, pGetVarIdFromLasalIdRsp, num);
              end_if;
            else
              num := 0;
            end_if;

            pJobElmt^.pThis^.GetVarIdFromLasalIdResp(pHeader^.MessageID, ErrorNo, num, pGetVarIdFromLasalIdRsp);
            RemoveJob(pJobInfo:=#GetVarIdFromLasalIdJobs, pHeader^.MessageID);
          end_if;


        GetLasalIdFromNameRsp:
          pJobElmt := FindJob(pJobInfo:=#GetLasalIdFromNameJobs, pHeader^.MessageID);
          if pJobElmt then
            pGetLasalIdFromNameRsp := pDataBuffer$^_DS_GetLasalIdFromNameResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);

              if num then
                GetRespData_GetLasalIdFromName(pRecvBuffer, pGetLasalIdFromNameRsp, num);
              end_if;
            else
              num := 0;
            end_if;

            pJobElmt^.pThis^.GetLasalIdFromNameResp(pHeader^.MessageID, ErrorNo, num, pGetLasalIdFromNameRsp);
            RemoveJob(pJobInfo:=#GetLasalIdFromNameJobs, pHeader^.MessageID);
          end_if;


        GetLasalIdFromVarIdRsp:
          pJobElmt := FindJob(pJobInfo:=#GetLasalIdFromVarIdJobs, pHeader^.MessageID);
          if pJobElmt then
            pGetLasalIdIdFromVarIdRsp := pDataBuffer$^_DS_GetLasalIdIdFromVarIdResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);

              if num then
                GetRespData_GetLasalIdIdFromVarId(pRecvBuffer, pGetLasalIdIdFromVarIdRsp, num);
              end_if;
            else
              num := 0;
            end_if;

            pJobElmt^.pThis^.GetLasalIdFromVarIdResp(pHeader^.MessageID, ErrorNo, num, pGetLasalIdIdFromVarIdRsp);
            RemoveJob(pJobInfo:=#GetLasalIdFromVarIdJobs, pHeader^.MessageID);
          end_if;


        GetNameFromVarIdRsp:
          pJobElmt := FindJob(pJobInfo:=#GetNameFromVarIdJobs, pHeader^.MessageID);
          if pJobElmt then
            pGetNameFromVarIdRsp := pDataBuffer$^_DS_GetNameFromVarIdResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);

              if num then
                GetRespData_GetNameFromVarId(pRecvBuffer, pGetNameFromVarIdRsp, num);
              end_if;
            else
              num := 0;
            end_if;

            pJobElmt^.pThis^.GetNameFromVarIdResp(pHeader^.MessageID, ErrorNo, num, pGetNameFromVarIdRsp);
            RemoveJob(pJobInfo:=#GetNameFromVarIdJobs, pHeader^.MessageID);
          end_if;


        GetNameFromLasalIdRsp:
          pJobElmt := FindJob(pJobInfo:=#GetNameFromLasalIdJobs, pHeader^.MessageID);
          if pJobElmt then
            pGetNameFromLasalIdRsp := pDataBuffer$^_DS_GetNameFromLasalIdResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);

              if num then
                GetRespData_GetNameFromLasalId(pRecvBuffer, pGetNameFromLasalIdRsp, num);
              end_if;
            else
              num := 0;
            end_if;

            pJobElmt^.pThis^.GetNameFromLasalIdResp(pHeader^.MessageID, ErrorNo, num, pGetNameFromLasalIdRsp);
            RemoveJob(pJobInfo:=#GetNameFromLasalIdJobs, pHeader^.MessageID);
          end_if;


        GetDpListRsp:
          pJobElmt := FindJob(pJobInfo:=#GetDpListJobs, pHeader^.MessageID);
          if pJobElmt then
            pGetDpListRsp := pDataBuffer$^_DS_GetDpListResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              TotalNumLoc := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(TotalNumLoc);

              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);

              TotalNumIncr += num;
              if TotalNumIncr = TotalNumLoc then
                LastPacket := TRUE;
              else
                LastPacket := FALSE;
              end_if;

              if num then
                GetRespData_GetDpList(pRecvBuffer, pGetDpListRsp, num);
              end_if;
            else
              TotalNumLoc := 0;
              num         := 0;
              LastPacket  := TRUE;
            end_if;

            pJobElmt^.pThis^.GetDpListResp(pHeader^.MessageID, ErrorNo, TotalNumLoc, num, LastPacket, pGetDpListRsp);

            if LastPacket <> FALSE then
              //Letztes Paket empfangen
              TotalNumIncr := 0;
              RemoveJob(pJobInfo:=#GetDpListJobs, pHeader^.MessageID);
            end_if;
          end_if;


        GetDpInfoRsp:
          pJobElmt := FindJob(pJobInfo:=#GetDpInfoJobs, pHeader^.MessageID);
          if pJobElmt then
            pGetDpInfoRsp := pDataBuffer$^_DS_GetDpInfoResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);

              if num then
                GetRespData_GetDpInfo(pRecvBuffer, pGetDpInfoRsp, num);
              end_if;
            else
              num := 0;
            end_if;

            pJobElmt^.pThis^.GetDpInfoResp(pHeader^.MessageID, ErrorNo, num, pGetDpInfoRsp);
            RemoveJob(pJobInfo:=#GetDpInfoJobs, pHeader^.MessageID);
          end_if;


        GetVarIdFromCRCRsp:
          pJobElmt := FindJob(pJobInfo:=#GetVarIdFromCRCJobs, pHeader^.MessageID);
          if pJobElmt then
            pGetVarIdFromCRCRsp := pDataBuffer$^_DS_GetVarIdFromCRCResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);

              if num then
                GetRespData_GetVarIdFromCRC(pRecvBuffer, pGetVarIdFromCRCRsp, num);
              end_if;
            else
              num := 0;
            end_if;

            pJobElmt^.pThis^.GetVarIdFromCrcResp(pHeader^.MessageID, ErrorNo, num, pGetVarIdFromCRCRsp);
            RemoveJob(pJobInfo:=#GetVarIdFromCRCJobs, pHeader^.MessageID);
          end_if;


        GetCRCfromVarIdRsp:
          pJobElmt := FindJob(pJobInfo:=#GetCRCfromVarIdJobs, pHeader^.MessageID);
          if pJobElmt then
            pGetCRCfromVarIdRsp := pDataBuffer$^_DS_GetCRCfromVarIdResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);

              if num then
                GetRespData_GetCRCfromVarId(pRecvBuffer, pGetCRCfromVarIdRsp, num);
              end_if;
            else
              num := 0;
            end_if;

            pJobElmt^.pThis^.GetCRCfromVarIdResp(pHeader^.MessageID, ErrorNo, num, pGetCRCfromVarIdRsp);
            RemoveJob(pJobInfo:=#GetCRCfromVarIdJobs, pHeader^.MessageID);
          end_if;


        GetValueRsp:
          pJobElmt := FindJob(pJobInfo:=#GetValueJobs, pHeader^.MessageID);
          if pJobElmt then
            pGetValueRsp := pDataBuffer$^_DS_GetValueResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);

              if num then
                GetRespData_GetValue(pRecvBuffer, pGetValueRsp, num);
              end_if;
            else
              num := 0;
            end_if;

            pJobElmt^.pThis^.GetValueResp(pHeader^.MessageID, ErrorNo, num, pGetValueRsp);
            RemoveJob(pJobInfo:=#GetValueJobs, pHeader^.MessageID);
          end_if;


        GetStringRsp:
          pJobElmt := FindJob(pJobInfo:=#GetStringJobs, pHeader^.MessageID);
          if pJobElmt then
            pGetStringRsp := pDataBuffer$^_DS_GetStringResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);

              if num then
                GetRespData_GetString(pRecvBuffer, pGetStringRsp, num);
              end_if;
            else
              num := 0;
            end_if;

            pJobElmt^.pThis^.GetStringResp(pHeader^.MessageID, ErrorNo, num, pGetStringRsp);
            RemoveJob(pJobInfo:=#GetStringJobs, pHeader^.MessageID);
          end_if;


        SetValueRsp:
          pJobElmt := FindJob(pJobInfo:=#SetValueJobs, pHeader^.MessageID);
          if pJobElmt then
            pSetValueRsp := pDataBuffer$^_DS_SetValueResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);

              if num then
                GetRespData_SetValue(pRecvBuffer, pSetValueRsp, num);
              end_if;
            else
              num := 0;
            end_if;

            pJobElmt^.pThis^.SetValueResp(pHeader^.MessageID, ErrorNo, num, pSetValueRsp);
            RemoveJob(pJobInfo:=#SetValueJobs, pHeader^.MessageID);
          end_if;


        SetStringRsp:
          pJobElmt := FindJob(pJobInfo:=#SetStringJobs, pHeader^.MessageID);
          if pJobElmt then
            pSetStringRsp := pDataBuffer$^_DS_SetStringResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);

              if num then
                GetRespData_SetString(pRecvBuffer, pSetStringRsp, num);
              end_if;
            else
              num := 0;
            end_if;

            pJobElmt^.pThis^.SetStringResp(pHeader^.MessageID, ErrorNo, num, pSetStringRsp);
            RemoveJob(pJobInfo:=#SetStringJobs, pHeader^.MessageID);
          end_if;


        IncValueRsp:
          pJobElmt := FindJob(pJobInfo:=#IncValueJobs, pHeader^.MessageID);
          if pJobElmt then
            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);
            else
              num := 0;
            end_if;

            pJobElmt^.pThis^.IncValueResp(pHeader^.MessageID, ErrorNo, num, pRecvBuffer$^_DS_IncDecValueResp);
            RemoveJob(pJobInfo:=#IncValueJobs, pHeader^.MessageID);
          end_if;


        DecValueRsp:
          pJobElmt := FindJob(pJobInfo:=#DecValueJobs, pHeader^.MessageID);
          if pJobElmt then
            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);
            else
              num := 0;
            end_if;

            pJobElmt^.pThis^.DecValueResp(pHeader^.MessageID, ErrorNo, num, pRecvBuffer$^_DS_IncDecValueResp);
            RemoveJob(pJobInfo:=#DecValueJobs, pHeader^.MessageID);
          end_if;


        RefListAddRsp:
          pJobElmt := FindJob(pJobInfo:=#RefListAddJobs, pHeader^.MessageID);
          if pJobElmt then
            pRefListAddRsp := pDataBuffer$^_DS_RefListAddResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              channel := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(channel);

              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);

              if num then
                GetRespData_RefListAdd(pRecvBuffer, pRefListAddRsp, num);
              end_if;
            else
              channel := 0;
              num := 0;
            end_if;

            pJobElmt^.pThis^.RefListAddResp(pHeader^.MessageID, ErrorNo, channel, num, pRefListAddRsp);
            RemoveJob(pJobInfo:=#RefListAddJobs, pHeader^.MessageID);
          end_if;


        RefListSubRsp:
          pJobElmt := FindJob(pJobInfo:=#RefListSubJobs, pHeader^.MessageID);
          if pJobElmt then
            pRefListSubRsp := pDataBuffer$^_DS_RefListSubResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              channel := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(channel);

              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);

              if num then
                GetRespData_RefListSub(pRecvBuffer, pRefListSubRsp, num);
              end_if;
            else
              channel := 0;
              num := 0;
            end_if;

            pJobElmt^.pThis^.RefListSubResp(pHeader^.MessageID, ErrorNo, channel, num, pRefListSubRsp);
            RemoveJob(pJobInfo:=#RefListSubJobs, pHeader^.MessageID);
          end_if;


        RefListUpdatePsh:
          if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
            channel := (pRecvBuffer$^UDINT)^;
            pRecvBuffer += sizeof(channel);

            num := (pRecvBuffer$^UDINT)^;
            pRecvBuffer += sizeof(num);

            pChannel := #ChannelInfo[channel];
            if pChannel^.pThis then
              pRefListUpd := pDataBuffer$^_DS_RefListUpdate;

              if num then
                GetRespData_RefListUpdate(pRecvBuffer, pRefListUpd, num);
              end_if;
              pChannel^.pThis^.RefListUpdatePush(ErrorNo, channel, num, pRefListUpd);
            end_if;
          end_if;


        RefListUpdateStringPsh:
          if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
            channel := (pRecvBuffer$^UDINT)^;
            pRecvBuffer += sizeof(channel);

            num := (pRecvBuffer$^UDINT)^;
            pRecvBuffer += sizeof(num);

            pChannel := #ChannelInfo[channel];
            if pChannel^.pThis then
              pRefListUpdString := pDataBuffer$^_DS_RefListUpdateString;

              if num then
                GetRespData_RefListUpdateString(pRecvBuffer, pRefListUpdString, num);
              end_if;
              pChannel^.pThis^.RefListUpdateStringPush(ErrorNo, channel, num, pRefListUpdString);
            end_if;
          end_if;


        GetStationListRsp:
          pJobElmt := FindJob(pJobInfo:=#GetStationListJobs, pHeader^.MessageID);
          if pJobElmt then
            pStationListRsp := pDataBuffer$^_DS_StationListResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);

              if num then
                GetRespData_StationList(pRecvBuffer, pStationListRsp, num);
              end_if;
            else
              num := 0;
            end_if;

            pJobElmt^.pThis^.GetStationListResp(pHeader^.MessageID, ErrorNo, num, pStationListRsp);
            RemoveJob(pJobInfo:=#GetStationListJobs, pHeader^.MessageID);
          end_if;


        GetStationStatusRsp:
          pJobElmt := FindJob(pJobInfo:=#GetStationStatusJobs, pHeader^.MessageID);
          if pJobElmt then
            pStationStatusRsp := pDataBuffer$^_DS_StationStatusResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);

              if num then
                GetRespData_StationStatus(pRecvBuffer, pStationStatusRsp, num);
              end_if;
            else
              num := 0;
            end_if;

            pJobElmt^.pThis^.GetStationStatusResp(pHeader^.MessageID, ErrorNo, num, pStationStatusRsp);
            RemoveJob(pJobInfo:=#GetStationStatusJobs, pHeader^.MessageID);
          end_if;


        FileOpenRsp:
          pJobElmt := FindJob(pJobInfo:=#FileOpenJobs, pHeader^.MessageID);
          if pJobElmt then
            pFileOpenRsp := pDataBuffer$^_DS_FileOpenResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              GetRespData_FileOpen(pRecvBuffer, pFileOpenRsp);
            end_if;

            pJobElmt^.pThis^.FileOpenResp(pHeader^.MessageID, ErrorNo, pFileOpenRsp);
            RemoveJob(pJobInfo:=#FileOpenJobs, pHeader^.MessageID);
          end_if;


        FileCloseRsp:
          pJobElmt := FindJob(pJobInfo:=#FileCloseJobs, pHeader^.MessageID);
          if pJobElmt then
            pJobElmt^.pThis^.FileCloseResp(pHeader^.MessageID, ErrorNo, pRecvBuffer$^_DS_FileCloseResp);
            RemoveJob(pJobInfo:=#FileCloseJobs, pHeader^.MessageID);
          end_if;


        FileSeekRsp:
          pJobElmt := FindJob(pJobInfo:=#FileSeekJobs, pHeader^.MessageID);
          if pJobElmt then
            pJobElmt^.pThis^.FileSeekResp(pHeader^.MessageID, ErrorNo, pRecvBuffer$^_DS_FileSeekResp);
            RemoveJob(pJobInfo:=#FileSeekJobs, pHeader^.MessageID);
          end_if;


        FileTellRsp:
          pJobElmt := FindJob(pJobInfo:=#FileTellJobs, pHeader^.MessageID);
          if pJobElmt then
            pJobElmt^.pThis^.FileTellResp(pHeader^.MessageID, ErrorNo, pRecvBuffer$^_DS_FileTellResp);
            RemoveJob(pJobInfo:=#FileTellJobs, pHeader^.MessageID);
          end_if;


        FileReadRsp:
          pJobElmt := FindJob(pJobInfo:=#FileReadJobs, pHeader^.MessageID);
          if pJobElmt then
            pFileReadRsp := pDataBuffer$^_DS_FileReadResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
             GetRespData_FileRead(pRecvBuffer, pFileReadRsp);
            end_if;

            pJobElmt^.pThis^.FileReadResp(pHeader^.MessageID, ErrorNo, pFileReadRsp);
            RemoveJob(pJobInfo:=#FileReadJobs, pHeader^.MessageID);
          end_if;


        FileWriteRsp:
          pJobElmt := FindJob(pJobInfo:=#FileWriteJobs, pHeader^.MessageID);
          if pJobElmt then
            pJobElmt^.pThis^.FileWriteResp(pHeader^.MessageID, ErrorNo, pRecvBuffer$^_DS_FileWriteResp);
            RemoveJob(pJobInfo:=#FileWriteJobs, pHeader^.MessageID);
          end_if;


        FileGetRsp:
          pJobElmt := FindJob(pJobInfo:=#FileGetJobs, pHeader^.MessageID);
          if pJobElmt then
            pFileGetRsp := pDataBuffer$^_DS_FileGetResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              GetRespData_FileGet(pRecvBuffer, pFileGetRsp);
            end_if;

            pJobElmt^.pThis^.FileGetResp(pHeader^.MessageID, ErrorNo, pFileGetRsp);
            RemoveJob(pJobInfo:=#FileGetJobs, pHeader^.MessageID);
          end_if;


        FilePutRsp:
          pJobElmt := FindJob(pJobInfo:=#FilePutJobs, pHeader^.MessageID);
          if pJobElmt then
            pJobElmt^.pThis^.FilePutResp(pHeader^.MessageID, ErrorNo, pRecvBuffer$^_DS_FilePutResp);
            RemoveJob(pJobInfo:=#FilePutJobs, pHeader^.MessageID);
          end_if;


        FileLengthRsp:
          pJobElmt := FindJob(pJobInfo:=#FileLengthJobs, pHeader^.MessageID);
          if pJobElmt then
            pJobElmt^.pThis^.FileLengthResp(pHeader^.MessageID, ErrorNo, pRecvBuffer$^_DS_FileLengthResp);
            RemoveJob(pJobInfo:=#FileLengthJobs, pHeader^.MessageID);
          end_if;


        FileContentRsp:
          pJobElmt := FindJob(pJobInfo:=#FileContentJobs, pHeader^.MessageID);
          if pJobElmt then
            pJobElmt^.StartTime := ops.tAbsolute;

            pFileContentRsp := pDataBuffer$^_DS_FileContentResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              if pFragHeader then
                GetRespData_FileContent_1(pRecvBuffer, pFragHeader, pFileContentRsp);
              else
                GetRespData_FileContent_2(pRecvBuffer, pFileContentRsp);
              end_if;

              if pFileContentRsp^.paketOffset.Low32 + pFileContentRsp^.dataLength >= pFileContentRsp^.fileLength.Low32 then
                LastPacket := TRUE;
              else
                LastPacket := FALSE;
              end_if;
            else
              LastPacket := TRUE;
            end_if;

            pJobElmt^.pThis^.FileContentResp(pHeader^.MessageID, ErrorNo, LastPacket, pFileContentRsp);
            if LastPacket then
              //Letztes Paket empfangen
              RemoveJob(pJobInfo:=#FileContentJobs, pHeader^.MessageID);
            end_if;
          end_if;


        DirCreateRsp:
          pJobElmt := FindJob(pJobInfo:=#DirCreateJobs, pHeader^.MessageID);
          if pJobElmt then
            pDirCreateRsp := pDataBuffer$^_DS_DirCreateResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              GetRespData_DirCreate(pRecvBuffer, pDirCreateRsp);
            end_if;

            pJobElmt^.pThis^.DirCreateResp(pHeader^.MessageID, ErrorNo, pDirCreateRsp);
            RemoveJob(pJobInfo:=#DirCreateJobs, pHeader^.MessageID);
          end_if;


        DirReadRsp:
          pJobElmt := FindJob(pJobInfo:=#DirReadJobs, pHeader^.MessageID);
          if pJobElmt then
            pJobElmt^.StartTime := ops.tAbsolute;
            pDirReadRsp := pDataBuffer$^_DS_DirReadResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              DS_ErrorNo := (pRecvBuffer$^DINT)^;
              pRecvBuffer += sizeof(DS_ErrorNo);

              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);

              //Response-Daten > 16KB werden fragmentiert übertragen und am Ende gesammelt übergeben.
              //LastPacket ist daher immer TRUE.
              LastPacket := TRUE;

              if num then
                GetRespData_DirRead(pRecvBuffer, pDirReadRsp, num);
              end_if;
            else
              DS_ErrorNo := 0;
              num        := 0;
              LastPacket := TRUE;
            end_if;

            pJobElmt^.pThis^.DirReadResp(pHeader^.MessageID, ErrorNo, DS_ErrorNo, num, LastPacket, pDirReadRsp);
            if LastPacket then
              //Letztes Paket empfangen
              RemoveJob(pJobInfo:=#DirReadJobs, pHeader^.MessageID);
            end_if;
          end_if;


        FileRemoveRsp:
          pJobElmt := FindJob(pJobInfo:=#FileRemoveJobs, pHeader^.MessageID);
          if pJobElmt then
            pJobElmt^.pThis^.FileRemoveResp(pHeader^.MessageID, ErrorNo, pRecvBuffer$^_DS_FileRemoveResp);
            RemoveJob(pJobInfo:=#FileRemoveJobs, pHeader^.MessageID);
          end_if;


        FileCopyRsp:
          pJobElmt := FindJob(pJobInfo:=#FileCopyJobs, pHeader^.MessageID);
          if pJobElmt then
            pJobElmt^.pThis^.FileCopyResp(pHeader^.MessageID, ErrorNo, pRecvBuffer$^_DS_FileCopyResp);
            RemoveJob(pJobInfo:=#FileCopyJobs, pHeader^.MessageID);
          end_if;


        FileInfoRsp:
          pJobElmt := FindJob(pJobInfo:=#FileInfoJobs, pHeader^.MessageID);
          if pJobElmt then
            pJobElmt^.pThis^.FileInfoResp(pHeader^.MessageID, ErrorNo, pRecvBuffer$^_DS_FileInfoResp);
            RemoveJob(pJobInfo:=#FileInfoJobs, pHeader^.MessageID);
          end_if;


        FileRenameRsp:
          pJobElmt := FindJob(pJobInfo:=#FileRenameJobs, pHeader^.MessageID);
          if pJobElmt then
            pJobElmt^.pThis^.FileRenameResp(pHeader^.MessageID, ErrorNo, pRecvBuffer$^_DS_FileRenameResp);
            RemoveJob(pJobInfo:=#FileRenameJobs, pHeader^.MessageID);
          end_if;


        FileSetAttributeRsp:
          pJobElmt := FindJob(pJobInfo:=#FileSetAttributeJobs, pHeader^.MessageID);
          if pJobElmt then
            pJobElmt^.pThis^.FileSetAttributeResp(pHeader^.MessageID, ErrorNo, pRecvBuffer$^_DS_FileSetAttributeResp);
            RemoveJob(pJobInfo:=#FileSetAttributeJobs, pHeader^.MessageID);
          end_if;


        GetDriveListRsp:
          pJobElmt := FindJob(pJobInfo:=#GetDriveListJobs, pHeader^.MessageID);
          if pJobElmt then
            pGetDriveListRsp := pDataBuffer$^_DS_GetDriveListResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              GetRespData_GetDriveList(pRecvBuffer, pGetDriveListRsp);
            end_if;

            pJobElmt^.pThis^.GetDriveListResp(pHeader^.MessageID, ErrorNo, pGetDriveListRsp);
            RemoveJob(pJobInfo:=#GetDriveListJobs, pHeader^.MessageID);
          end_if;


        FileMoveRsp:
          pJobElmt := FindJob(pJobInfo:=#FileMoveJobs, pHeader^.MessageID);
          if pJobElmt then
            pJobElmt^.pThis^.FileMoveResp(pHeader^.MessageID, ErrorNo, pRecvBuffer$^_DS_FileMoveResp);
            RemoveJob(pJobInfo:=#FileMoveJobs, pHeader^.MessageID);
          end_if;


        else
          //Fehler: unbekannte MinorID
      end_case;



    SIGMATEK_EVENT_JOURNAL_PROTOKOLL:
      case pHeader^.MinorID of
        EventjournalAddRsp:
          pJobElmt := FindJob(pJobInfo:=#EventjournalAddJobs, pHeader^.MessageID);
          if pJobElmt then
            pEventjournalAddRsp := pDataBuffer$^_DS_EventjournalAddResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);

              if num then
                GetRespData_EventjournalAdd(pRecvBuffer, pEventjournalAddRsp, num);
              end_if;
            else
              num := 0;
            end_if;

            pJobElmt^.pThis^.EventjournalAddResp(pHeader^.MessageID, ErrorNo, num, pEventjournalAddRsp);
            RemoveJob(pJobInfo:=#EventjournalAddJobs, pHeader^.MessageID);
          end_if;


        EventjournalGetRsp:
          pJobElmt := FindJob(pJobInfo:=#EventjournalGetJobs, pHeader^.MessageID);
          if pJobElmt then
            pEventjournalGetRsp := pDataBuffer$^_DS_EventjournalGetResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);

              if num then
                GetRespData_EventjournalGet(pRecvBuffer, pEventjournalGetRsp, num);
              end_if;
            else
              num := 0;            
            end_if;

            pJobElmt^.pThis^.EventjournalGetResp(pHeader^.MessageID, ErrorNo, num, pEventjournalGetRsp);
            RemoveJob(pJobInfo:=#EventjournalGetJobs, pHeader^.MessageID);
          end_if;


        EventjournalGetAllRsp:
          pJobElmt := FindJob(pJobInfo:=#EventjournalGetAllJobs, pHeader^.MessageID);
          if pJobElmt then
            pEventjournalGetRsp := pDataBuffer$^_DS_EventjournalGetResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);

              if num and 0x80000000 then
                LastPacket := TRUE;
                num := num and 0x7FFFFFFF;
              else
                LastPacket := FALSE;
              end_if;

              if num then
                GetRespData_EventjournalGet(pRecvBuffer, pEventjournalGetRsp, num);
              end_if;
            else
              num := 0;
              LastPacket := TRUE;
            end_if;

            pJobElmt^.pThis^.EventjournalGetAllResp(pHeader^.MessageID, ErrorNo, num, LastPacket, pEventjournalGetRsp);
            if LastPacket then
              //Letztes Paket empfangen
              RemoveJob(pJobInfo:=#EventjournalGetAllJobs, pHeader^.MessageID);
            end_if;
          end_if;


        EventjournalDelRsp:
          pJobElmt := FindJob(pJobInfo:=#EventjournalDelJobs, pHeader^.MessageID);
          if pJobElmt then
            pEventjournalDelRsp := pDataBuffer$^_DS_EventjournalDelResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);

              if num then
                GetRespData_EventjournalDel(pRecvBuffer, pEventjournalDelRsp, num);
              end_if;
            else
              num := 0;
            end_if;

            pJobElmt^.pThis^.EventjournalDelResp(pHeader^.MessageID, ErrorNo, num, pEventjournalDelRsp);
            RemoveJob(pJobInfo:=#EventjournalDelJobs, pHeader^.MessageID);
          end_if;


        EventjournalDelAllRsp:
          pJobElmt := FindJob(pJobInfo:=#EventjournalDelAllJobs, pHeader^.MessageID);
          if pJobElmt then
            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);
            else
              num := 0;
            end_if;

            pJobElmt^.pThis^.EventjournalDelAllResp(pHeader^.MessageID, ErrorNo, num, pRecvBuffer$^_DS_EventjournalDelAllResp);
            RemoveJob(pJobInfo:=#EventjournalDelAllJobs, pHeader^.MessageID);
          end_if;


        EventjournalUpdatePsh:
          if pThis_EventJournalUpdate then
            pEventjournalGetRsp := pDataBuffer$^_DS_EventjournalGetResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);

              if num then
                GetRespData_EventjournalGet(pRecvBuffer, pEventjournalGetRsp, num);
              end_if;
            else
              num := 0;
            end_if;

            pThis_EventJournalUpdate^.EventjournalUpdatePush(pHeader^.MessageID, ErrorNo, num, pEventjournalGetRsp);
          end_if;


        EventjournalQuitAlarmRsp:
          pJobElmt := FindJob(pJobInfo:=#EventjournalQuitAlarmJobs, pHeader^.MessageID);
          if pJobElmt then
            pEventjournalQuitAlarmRsp := pDataBuffer$^_DS_EventjournalQuitAlarmResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);

              if num then
                GetRespData_EventjournalQuitAlarm(pRecvBuffer, pEventjournalQuitAlarmRsp, num);
              end_if;
            else
              num := 0;
            end_if;

            pJobElmt^.pThis^.EventjournalQuitAlarmResp(pHeader^.MessageID, ErrorNo, num, pEventjournalQuitAlarmRsp);
            RemoveJob(pJobInfo:=#EventjournalQuitAlarmJobs, pHeader^.MessageID);
          end_if;


        EventjournalQuitAllRsp:
          pJobElmt := FindJob(pJobInfo:=#EventjournalQuitAllJobs, pHeader^.MessageID);
          if pJobElmt then
            pEventjournalQuitAllRsp := pDataBuffer$^_DS_EventjournalQuitAllResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);

              if num then
                GetRespData_EventjournalQuitAll(pRecvBuffer, pEventjournalQuitAllRsp, num);
              end_if;
            else
              num := 0;
            end_if;

            pJobElmt^.pThis^.EventjournalQuitAllResp(pHeader^.MessageID, ErrorNo, num, pEventjournalQuitAllRsp);
            RemoveJob(pJobInfo:=#EventjournalQuitAllJobs, pHeader^.MessageID);
          end_if;


        AlarmListUpdateAddRsp:
          pJobElmt := FindJob(pJobInfo:=#AlarmListUpdateAddJobs, pHeader^.MessageID);

          if pJobElmt then
            pAlarmListUpdAdd := pRecvBuffer$^_DS_AlarmListUpdateAddResp;
            if pAlarmListUpdAdd^.ErrorCode <> 0 then
              //Pointer löschen, wenn beim DS nicht angemeldet.
              pThis_AlarmListUpdate := nil;
            end_if;

            pJobElmt^.pThis^.SubscribeAlarmListUpdateResp(pHeader^.MessageID, ErrorNo, pAlarmListUpdAdd);
            RemoveJob(pJobInfo:=#AlarmListUpdateAddJobs, pHeader^.MessageID);
          end_if;


        AlarmListUpdateSubRsp:
          pJobElmt := FindJob(pJobInfo:=#AlarmListUpdateSubJobs, pHeader^.MessageID);

          if pJobElmt then
            pAlarmListUpdSub := pRecvBuffer$^_DS_AlarmListUpdateSubResp;
            if pAlarmListUpdSub^.ErrorCode = 0 then
              //Pointer erst löschen, wenn abmelden vom DS bestätigt wird.
              pThis_AlarmListUpdate := nil;
            end_if;

            pJobElmt^.pThis^.UnsubscribeAlarmListUpdateResp(pHeader^.MessageID, ErrorNo, pAlarmListUpdSub);
            RemoveJob(pJobInfo:=#AlarmListUpdateSubJobs, pHeader^.MessageID);
          end_if;


        AlarmListUpdatePsh:
          if pThis_AlarmListUpdate then
            pAlarmListUpdate := pDataBuffer$^_DS_AlarmListUpdate;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);

              if num then
                GetRespData_AlarmListUpdate(pRecvBuffer, pAlarmListUpdate, num);
              end_if;
            else
              num := 0;
            end_if;

            pThis_AlarmListUpdate^.AlarmListUpdatePush(ErrorNo, num, pAlarmListUpdate);
          end_if;


        HotAlarmUpdateAddRsp:
          pJobElmt := FindJob(pJobInfo:=#HotAlarmUpdateAddJobs, pHeader^.MessageID);

          if pJobElmt then
            pHotAlarmAdd := pRecvBuffer$^_DS_HotAlarmAddResp;
            if pHotAlarmAdd^.ErrorCode <> 0 then
              //Pointer löschen, wenn beim DS nicht angemeldet.
              pThis_HotAlarmUpdate := nil;
            end_if;

            pJobElmt^.pThis^.SubscribeHotAlarmUpdateResp(pHeader^.MessageID, ErrorNo, pHotAlarmAdd);
            RemoveJob(pJobInfo:=#HotAlarmUpdateAddJobs, pHeader^.MessageID);
          end_if;


        HotAlarmUpdateSubRsp:
          pJobElmt := FindJob(pJobInfo:=#HotAlarmUpdateSubJobs, pHeader^.MessageID);

          if pJobElmt then
            pHotAlarmSub := pRecvBuffer$^_DS_HotAlarmSubResp;
            if pHotAlarmSub^.ErrorCode = 0 then
              //Pointer erst löschen, wenn abmelden vom DS bestätigt wird.
              pThis_HotAlarmUpdate := nil;
            end_if;

            pJobElmt^.pThis^.UnsubscribeHotAlarmUpdateResp(pHeader^.MessageID, ErrorNo, pHotAlarmSub);
            RemoveJob(pJobInfo:=#HotAlarmUpdateSubJobs, pHeader^.MessageID);
          end_if;


        HotAlarmUpdatePsh:
          if pThis_HotAlarmUpdate then
            pHotAlarmUpdate := pDataBuffer$^_DS_HotAlarmUpdate;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);

              if num then
                GetRespData_HotAlarmUpdate(pRecvBuffer, pHotAlarmUpdate, num);
              end_if;
            else
              num := 0;
            end_if;

            pThis_HotAlarmUpdate^.HotAlarmUpdatePush(ErrorNo, num, pHotAlarmUpdate);
          end_if;


        AlarmDeleteRsp:
          pJobElmt := FindJob(pJobInfo:=#AlarmDeleteJobs, pHeader^.MessageID);
          if pJobElmt then
            pAlarmDeleteRsp := pDataBuffer$^_DS_AlarmDeleteResp;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);

              if num then
                GetRespData_AlarmDelete(pRecvBuffer, pAlarmDeleteRsp, num);
              end_if;
            else
              num := 0;
            end_if;

            pJobElmt^.pThis^.AlarmDeleteResp(pHeader^.MessageID, ErrorNo, num, pAlarmDeleteRsp);
            RemoveJob(pJobInfo:=#AlarmDeleteJobs, pHeader^.MessageID);
          end_if;


        AlarmDeleteAllRsp:
          pJobElmt := FindJob(pJobInfo:=#AlarmDeleteAllJobs, pHeader^.MessageID);

          if pJobElmt then
            pJobElmt^.pThis^.AlarmDeleteAllResp(pHeader^.MessageID, ErrorNo, pRecvBuffer$^_DS_AlarmDeleteAllResp);
            RemoveJob(pJobInfo:=#AlarmDeleteAllJobs, pHeader^.MessageID);
          end_if;


        AlarmDeleteUpdPsh:
          if pThis_AlarmListUpdate then
            pAlarmDeleteUpd := pDataBuffer$^_DS_AlarmDeleteUpdate;

            if ErrorNo <> ERR_MALLOC_RECV_BUFFER then
              num := (pRecvBuffer$^UDINT)^;
              pRecvBuffer += sizeof(num);

              if num then
                GetRespData_AlarmDeleteUpdate(pRecvBuffer, pAlarmDeleteUpd, num);
              end_if;
            else
              num := 0;
            end_if;

            pThis_AlarmListUpdate^.AlarmDeleteUpdatePush(ErrorNo, num, pAlarmDeleteUpd);
          end_if;
        else
          //Fehler: Unbekannte MinorID, Nachricht verwerfen ?
          UnknownMinorIDCount += 1;
      end_case;

    else
      //Unbekannte MajorID: nach registriertem User Event suchen
      pUserEvent := GetpUserEvent(pHeader^.MajorID, pHeader^.MinorID);

      if pUserEvent then
        DataLength := pHeader^.Length - sizeof(_DS_Header);

        pUserEvent^.pThis^.UserEventReceive(pHeader^.MajorID, pHeader^.MinorID, pHeader^.MessageID, ErrorNo, pRecvBuffer, DataLength);
      else
        //Unbekannte MajorID und kein User Event gefunden, Nachricht verwerfen ?
        UnknownMajorIDCount += 1;
      end_if;
  end_case;

END_FUNCTION


FUNCTION GLOBAL DSComm::GetDpInfo
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		num 	: UDINT;
		pVarId 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff     : ^void;
  	pHeader       : ^_DS_Header;
    pData         : ^CHAR;
    pJobElmt      : ^_DS_JobInfoElmt;
    tmpI          : UDINT;
    DataLen       : UDINT;
    SendBuffSize  : UDINT;
    RetVal        : DINT;
  END_VAR

  if num = 0 | pVarId = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#GetDpInfoJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    //Datenlänge und Puffergröße ermitteln: num * (size + Daten)
    DataLen := num * (sizeof(UDINT) + sizeof(pVarId^));

    SendBuffSize := sizeof(_DS_Header) + sizeof(num) + DataLen;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest
    
      pData$^UDINT^ := num;
      pData += sizeof(num);
    
      //VarIDs der Datenpunkte kopieren
      for tmpI:=0 to num-1 do
        //--- size -------------------------------------------------------------------------------------//
        pData$^UDINT^ := sizeof(UDINT);  //Größe des nächsten Eintrags
        pData += sizeof(UDINT);

        //--- VarID ------------------------------------------------------------------------------------//
        pData$^UDINT^ := pVarId^;
        pData += sizeof(pVarId^);

        //-- Src-Pointer weiterstellen -----------------------------------------------------------------//
        pVarId += sizeof(pVarId^);
      end_for;

	  //*--- Header für Get Dp Info aufbauen --------------------------------------------------*//
      pheader                 := pSendBuff$^_DS_Header;
      pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := GetDpInfoCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pheader$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#GetDpInfoJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION DSComm::GetRespData_GetDpInfo
	VAR_INPUT
		pData 	: ^CHAR;
		pGetDpInfoRsp 	: ^_DS_GetDpInfoResp;
		num 	: UDINT;
	END_VAR
  VAR
  	StringLen   : UDINT;    //Zwischenvariable ergibt kürzeren Code (ARM und Intel)
    max   : UDINT;
    tmpI        : UDINT;
  END_VAR

  _memset(dest:=pGetDpInfoRsp, usByte:=0, cntr:=num * sizeof(_DS_GetDpInfoResp));

  max := num - 1;
  for tmpI:=0 to max do
    //--- size ---------------------------------------------------------------------------------------------------//
    pData += sizeof(UDINT);           //size überspringen

    //--- VarId --------------------------------------------------------------------------------------------------//
    _memcpy(ptr1:=#pGetDpInfoRsp^.VarID, ptr2:=pData, cntr:=sizeof(pGetDpInfoRsp^.VarID));
    pData += sizeof(pGetDpInfoRsp^.VarID);

    //--- ErrorCode ----------------------------------------------------------------------------------------------//
    _memcpy(ptr1:=#pGetDpInfoRsp^.ErrorCode, ptr2:=pData, cntr:=sizeof(pGetDpInfoRsp^.ErrorCode));
    pData += sizeof(pGetDpInfoRsp^.ErrorCode);


    if pGetDpInfoRsp^.ErrorCode = 0 then
      //--- LasalId ----------------------------------------------------------------------------------------------//
      _memcpy(ptr1:=#pGetDpInfoRsp^.LasalID, ptr2:=pData, cntr:=sizeof(pGetDpInfoRsp^.LasalID));
      pData += sizeof(pGetDpInfoRsp^.LasalID);

      //--- nameLen ----------------------------------------------------------------------------------------------//
      StringLen := pData$^UDINT^;                     //Anzahl der Bytes im String mit Endezeichen.   
      pData += sizeof(UDINT);

      //--- name -------------------------------------------------------------------------------------------------//
      pGetDpInfoRsp^.NameLen := StringLen - 1;      //Anzahl der Zeichen im String ohne Endezeichen.
      pGetDpInfoRsp^.pName   := pData;
      pData += StringLen;                           //Anzahl der Bytes im String mit Endezeichen.

      //--- Station ----------------------------------------------------------------------------------------------//
      _memcpy(ptr1:=#pGetDpInfoRsp^.Station, ptr2:=pData, cntr:=sizeof(pGetDpInfoRsp^.Station));
      pData += sizeof(pGetDpInfoRsp^.Station);

      //--- Scope ------------------------------------------------------------------------------------------------//
      _memcpy(ptr1:=#pGetDpInfoRsp^.Scope, ptr2:=pData, cntr:=sizeof(pGetDpInfoRsp^.Scope));
      pData += sizeof(pGetDpInfoRsp^.Scope);

      //--- AccNo ------------------------------------------------------------------------------------------------//
      _memcpy(ptr1:=#pGetDpInfoRsp^.AccNo, ptr2:=pData, cntr:=sizeof(pGetDpInfoRsp^.AccNo));
      pData += sizeof(pGetDpInfoRsp^.AccNo);

      //--- LimitLow Typ -----------------------------------------------------------------------------------------//
      _memcpy(ptr1:=#pGetDpInfoRsp^.LimitLowTyp, ptr2:=pData, cntr:=sizeof(pGetDpInfoRsp^.LimitLowTyp));
      pData += sizeof(pGetDpInfoRsp^.LimitLowTyp);

      //--- LimitLow ---------------------------------------------------------------------------------------------//
      _memcpy(ptr1:=#pGetDpInfoRsp^.LimitLow, ptr2:=pData, cntr:=sizeof(pGetDpInfoRsp^.LimitLow));
      pData += sizeof(pGetDpInfoRsp^.LimitLow);

      //--- LimitHigh Typ ----------------------------------------------------------------------------------------//
      _memcpy(ptr1:=#pGetDpInfoRsp^.LimitHighTyp, ptr2:=pData, cntr:=sizeof(pGetDpInfoRsp^.LimitHighTyp));
      pData += sizeof(pGetDpInfoRsp^.LimitHighTyp);

      //--- LimitHigh --------------------------------------------------------------------------------------------//
      _memcpy(ptr1:=#pGetDpInfoRsp^.LimitHigh, ptr2:=pData, cntr:=sizeof(pGetDpInfoRsp^.LimitHigh));
      pData += sizeof(pGetDpInfoRsp^.LimitHigh);

      //--- RefTime ----------------------------------------------------------------------------------------------//
      _memcpy(ptr1:=#pGetDpInfoRsp^.RefTime, ptr2:=pData, cntr:=sizeof(pGetDpInfoRsp^.RefTime));
      pData += sizeof(pGetDpInfoRsp^.RefTime);

      //--- UserDefBits ------------------------------------------------------------------------------------------//
      _memcpy(ptr1:=#pGetDpInfoRsp^.UserDefBits, ptr2:=pData, cntr:=sizeof(pGetDpInfoRsp^.UserDefBits));
      pData += sizeof(pGetDpInfoRsp^.UserDefBits);

      //--- AccessType -------------------------------------------------------------------------------------------//
      _memcpy(ptr1:=#pGetDpInfoRsp^.AccessType, ptr2:=pData, cntr:=sizeof(pGetDpInfoRsp^.AccessType));
      pData += sizeof(pGetDpInfoRsp^.AccessType);
    end_if;

    pGetDpInfoRsp += sizeof(_DS_GetDpInfoResp);
  end_for;

END_FUNCTION


FUNCTION GLOBAL DSComm::GetDpList
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		pFilterIncl 	: ^DSComm::_DS_UnsLongLongInt;
		pFilterExcl 	: ^DSComm::_DS_UnsLongLongInt;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff     : ^void;
  	pHeader       : ^_DS_Header;
    pData         : ^CHAR;
    pJobElmt      : ^_DS_JobInfoElmt;
    RetVal        : DINT;
  END_VAR

  if pThis = nil | pFilterIncl = nil | pFilterExcl = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#GetDpListJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=GetDpList_BUFFER_SIZE, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData     := pSendBuff + sizeof(_DS_Header); //dest

      _memcpy(ptr1:=pData, ptr2:=pFilterIncl, cntr:=sizeof(pFilterIncl^));
      pData += sizeof(pFilterIncl^);
      
      _memcpy(ptr1:=pData, ptr2:=pFilterExcl, cntr:=sizeof(pFilterExcl^));
//      pData += sizeof(pFilterExcl^);

      //*--- Header für Get Dp List aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := GetDpList_BUFFER_SIZE;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := GetDpListCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#GetDpListJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION DSComm::GetRespData_GetDpList
	VAR_INPUT
		pData 	: ^CHAR;
		pGetDpListRsp 	: ^_DS_GetDpListResp;
		num 	: UDINT;
	END_VAR
  VAR
    max   : UDINT;
    tmpI  : UDINT;
  END_VAR

  _memset(dest:=pGetDpListRsp, usByte:=0, cntr:=num * sizeof(_DS_GetDpListResp));

  max := num - 1;
  for tmpI:=0 to max do
    //--- size ---------------------------------------------------------------------------------------------------//
    pData += sizeof(UDINT);           //size überspringen

    //--- VarId --------------------------------------------------------------------------------------------------//
    pGetDpListRsp^.VarID := pData$^UDINT^;
    pData += sizeof(pGetDpListRsp^.VarID);

    pGetDpListRsp += sizeof(_DS_GetDpListResp);
  end_for;
END_FUNCTION


FUNCTION GLOBAL DSComm::FileOpen
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		pDpne 	: ^CHAR;
		pMode 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^void;
  	pHeader     : ^_DS_Header;
    pData       : ^CHAR;
    pJobElmt    : ^_DS_JobInfoElmt;
    StrLenDpne  : UDINT;
    StrLenMode  : UDINT;
    SendBuffSize: UDINT;
    RetVal      : DINT;
  END_VAR

  if pDpne = nil | pMode = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#FileOpenJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    StrLenDpne := _StrLen(src:=pDpne) + 1;  //Länge des UTF8-Strings in Bytes mit \0
    StrLenMode := _StrLen(src:=pMode) + 1;  //Länge des ASCII-Strings in Bytes mit \0
    //                                  dpnelen + modeLen
    SendBuffSize := sizeof(_DS_Header) + 2*sizeof(UDINT) + StrLenDpne + StrLenMode;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest
    
      //Länge des Strings in den Sendepuffer
      pData$^UDINT^ := StrLenDpne;
      pData += sizeof(StrLenDpne);

      //String in den Sendepuffer kopieren
      pData := SigCLib.StrCpy(dst0:=pData, src0:=pDpne);
      pData += StrLenDpne;

      //Länge des Strings in den Sendepuffer
      pData$^UDINT^ := StrLenMode;
      pData += sizeof(StrLenMode);

      //String in den Sendepuffer kopieren
      pData := SigCLib.StrCpy(dst0:=pData, src0:=pMode);
//      pData += StrLenMode;

  	  //*--- Header für File Open aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
	    pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := FileOpenCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#FileOpenJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION DSComm::GetRespData_FileOpen
	VAR_INPUT
		pData 	: ^CHAR;
		pFileOpenRsp 	: ^_DS_FileOpenResp;
	END_VAR
  VAR
  	StringLen   : UDINT;    //Zwischenvariable ergibt kürzeren Code (ARM und Intel)
  END_VAR

  //--- handle -----------------------------------------------------------------------------------------------//
  pFileOpenRsp^.handle := (pData$^UDINT)^;
  pData += sizeof(pFileOpenRsp^.handle);

  //--- ErrorCode --------------------------------------------------------------------------------------------//
  pFileOpenRsp^.ErrorCode := (pData$^UDINT)^;
  pData += sizeof(pFileOpenRsp^.ErrorCode);

  //--- DpneLen + dpne ---------------------------------------------------------------------------------------//
  StringLen := pData$^UDINT^;                 //Anzahl der Bytes im UTF8-String mit Endezeichen.
  pData += sizeof(UDINT);

  pFileOpenRsp^.DpneLen := StringLen - 1;     //Anzahl der Bytes im UTF8-String ohne Endezeichen.
  pFileOpenRsp^.pDpne   := pData;

END_FUNCTION


FUNCTION GLOBAL DSComm::FileClose
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		handle 	: UDINT;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^void;
  	pHeader     : ^_DS_Header;
    pData       : ^CHAR;
    pJobElmt    : ^_DS_JobInfoElmt;
    RetVal      : DINT;
  END_VAR

  if pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#FileCloseJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=FileClose_BUFFER_SIZE, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData     := pSendBuff + sizeof(_DS_Header); //dest

      pData$^UDINT^ := handle;
//      pData   += sizeof(handle);

      //*--- Header für File Close aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := FileClose_BUFFER_SIZE;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := FileCloseCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#FileCloseJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::FileSeek
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		handle 	: UDINT;
		start 	: UDINT;
		offset 	: UDINT;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^void;
  	pHeader     : ^_DS_Header;
    pData       : ^CHAR;
    pJobElmt    : ^_DS_JobInfoElmt;
    RetVal      : DINT;
  END_VAR

  if pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#FileSeekJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=FileSeek_BUFFER_SIZE, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData     := pSendBuff + sizeof(_DS_Header); //dest

      pData$^UDINT^ := handle;
      pData   += sizeof(handle);

      pData$^UDINT^ := start;
      pData   += sizeof(start);

      pData$^UDINT^ := offset;
//      pData   += sizeof(offset);

      //*--- Header für File Seek aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := FileSeek_BUFFER_SIZE;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := FileSeekCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#FileSeekJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::FileTell
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		handle 	: UDINT;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^void;
  	pHeader     : ^_DS_Header;
    pData       : ^CHAR;
    pJobElmt    : ^_DS_JobInfoElmt;
    RetVal      : DINT;
  END_VAR

  if pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#FileTellJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=FileTell_BUFFER_SIZE, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData     := pSendBuff + sizeof(_DS_Header); //dest

      pData$^UDINT^ := handle;
//      pData   += sizeof(handle);

      //*--- Header für File Tell aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := FileTell_BUFFER_SIZE;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := FileTellCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#FileTellJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::FileRead
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		handle 	: UDINT;
		length 	: UDINT;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^void;
  	pHeader     : ^_DS_Header;
    pData       : ^CHAR;
    pJobElmt    : ^_DS_JobInfoElmt;
    RetVal      : DINT;
  END_VAR

  if pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#FileReadJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=FileRead_BUFFER_SIZE, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData     := pSendBuff + sizeof(_DS_Header); //dest

      pData$^UDINT^ := handle;
      pData   += sizeof(handle);

      pData$^UDINT^ := length;
//      pData   += sizeof(length);

      //*--- Header für File Read aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := FileRead_BUFFER_SIZE;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := FileReadCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#FileReadJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION DSComm::GetRespData_FileRead
	VAR_INPUT
		pData 	: ^CHAR;
		pFileReadRsp 	: ^_DS_FileReadResp;
	END_VAR

  //--- handle -----------------------------------------------------------------------------------------------//
  pFileReadRsp^.handle := (pData$^UDINT)^;
  pData += sizeof(pFileReadRsp^.handle);

  //--- ErrorCode --------------------------------------------------------------------------------------------//
  pFileReadRsp^.ErrorCode := (pData$^UDINT)^;
  pData += sizeof(pFileReadRsp^.ErrorCode);

  //--- length -----------------------------------------------------------------------------------------------//
  pFileReadRsp^.length := (pData$^UDINT)^;
  pData += sizeof(pFileReadRsp^.length);

  //--- pData ------------------------------------------------------------------------------------------------//
  pFileReadRsp^.pData := pData;

END_FUNCTION


FUNCTION GLOBAL DSComm::FileWrite
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		handle 	: UDINT;
		length 	: UDINT;
		pWriteData 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^void;
  	pHeader     : ^_DS_Header;
    pData       : ^CHAR;
    pJobElmt    : ^_DS_JobInfoElmt;
    SendBuffSize: UDINT;
    RetVal      : DINT;
  END_VAR

  if pWriteData = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#FileWriteJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    SendBuffSize := sizeof(_DS_Header) + sizeof(handle) + sizeof(length) + length;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest

      pData$^UDINT^ := handle;
      pData   += sizeof(handle);

      pData$^UDINT^ := length;
      pData   += sizeof(length);

      //Anwenderdaten in den Sendepuffer kopieren
      _memcpy(ptr1:=pData, ptr2:=pWriteData, cntr:=length);

  	  //*--- Header für File Write aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
	    pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := FileWriteCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#FileWriteJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::FileGet
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		handle 	: UDINT;
		length 	: UDINT;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^void;
  	pHeader     : ^_DS_Header;
    pData       : ^CHAR;
    pJobElmt    : ^_DS_JobInfoElmt;
    RetVal      : DINT;
  END_VAR

  if pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#FileGetJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=FileGet_BUFFER_SIZE, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData     := pSendBuff + sizeof(_DS_Header); //dest

      pData$^UDINT^ := handle;
      pData   += sizeof(handle);

      pData$^UDINT^ := length;
//      pData   += sizeof(length);

      //*--- Header für File Get aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := FileGet_BUFFER_SIZE;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := FileGetCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#FileGetJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION DSComm::GetRespData_FileGet
	VAR_INPUT
		pData 	: ^CHAR;
		pFileGetRsp 	: ^_DS_FileGetResp;
	END_VAR

  //--- handle -----------------------------------------------------------------------------------------------//
  pFileGetRsp^.handle := (pData$^UDINT)^;
  pData += sizeof(pFileGetRsp^.handle);

  //--- ErrorCode --------------------------------------------------------------------------------------------//
  pFileGetRsp^.ErrorCode := (pData$^UDINT)^;
  pData += sizeof(pFileGetRsp^.ErrorCode);

  //--- length -----------------------------------------------------------------------------------------------//
  pFileGetRsp^.length := (pData$^UDINT)^;
  pData += sizeof(pFileGetRsp^.length);

  //--- pData ------------------------------------------------------------------------------------------------//
  pFileGetRsp^.pData := pData;

END_FUNCTION


FUNCTION GLOBAL DSComm::FilePut
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		handle 	: UDINT;
		pString 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^void;
  	pHeader     : ^_DS_Header;
    pData       : ^CHAR;
    pJobElmt    : ^_DS_JobInfoElmt;
    StrLen      : UDINT;
    SendBuffSize: UDINT;
    RetVal      : DINT;
  END_VAR

  if pString = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#FilePutJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    StrLen := _strlen(pString) + 1;   //Länge des ASCII-Strings in Bytes mit \0
    //                                                      stringLen
    SendBuffSize := sizeof(_DS_Header) + sizeof(handle) + sizeof(UDINT) + StrLen;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest

      pData$^UDINT^ := handle;
      pData   += sizeof(handle);

      //Länge des Strings in den Sendepuffer
      pData$^UDINT^ := StrLen;
      pData += sizeof(StrLen);

      //String in den Sendepuffer kopieren
      _memcpy(ptr1:=pData, ptr2:=pString, cntr:=StrLen);

  	  //*--- Header für File Put aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
	    pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := FilePutCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#FilePutJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::FileLength
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		handle 	: UDINT;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^void;
  	pHeader     : ^_DS_Header;
    pData       : ^CHAR;
    pJobElmt    : ^_DS_JobInfoElmt;
    RetVal      : DINT;
  END_VAR

  if pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#FileLengthJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=FileLength_BUFFER_SIZE, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData     := pSendBuff + sizeof(_DS_Header); //dest

      pData$^UDINT^ := handle;
//      pData   += sizeof(handle);

      //*--- Header für File Length aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := FileLength_BUFFER_SIZE;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := FileLengthCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#FileLengthJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::FileContent
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		pDpne 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^void;
  	pHeader     : ^_DS_Header;
    pData       : ^CHAR;
    pJobElmt    : ^_DS_JobInfoElmt;
    StrLen      : UDINT;
    SendBuffSize: UDINT;
    RetVal      : DINT;
  END_VAR

  if pDpne = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  DBG_PaketCount := 0;    //===TEST

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#FileContentJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    StrLen := _StrLen(src:=pDpne) + 1;    //Länge des UTF8-Strings in Bytes mit \0
    //                                      dpnelen
    SendBuffSize := sizeof(_DS_Header) + sizeof(UDINT) + StrLen;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest
    
      //Länge des Strings in den Sendepuffer
      pData$^UDINT^ := StrLen;
      pData += sizeof(StrLen);

      //String in den Sendepuffer kopieren
      pData := SigCLib.StrCpy(dst0:=pData, src0:=pDpne);
//      pData += StrLen2;

  	  //*--- Header für File Content aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
	    pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := FileContentCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#FileContentJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION DSComm::GetRespData_FileContent_1
	VAR_INPUT
		pData 	: ^CHAR;
		pFragHdr 	: ^_DS_FragmentHeader;
		pFileContentRsp 	: ^_DS_FileContentResp;
	END_VAR


  //--- fileLength -------------------------------------------------------------------------------------------//
  _memcpy(ptr1:=#pFileContentRsp^.fileLength, ptr2:=#pFragHdr^.gesLength, cntr:=sizeof(pFileContentRsp^.fileLength));

  //File length = gesLength - sizeof(_DS_FragmentHeader)
  pFileContentRsp^.fileLength.Low32 -= sizeof(_DS_FragmentHeader);

  //--- dataLength = length (Länge dieses Pakets) ------------------------------------------------------------//
  pFileContentRsp^.dataLength := pFragHdr^.length;

  //--- paketOffset ------------------------------------------------------------------------------------------//
  _memcpy(ptr1:=#pFileContentRsp^.paketOffset, ptr2:=#pFragHdr^.offset, cntr:=sizeof(pFileContentRsp^.paketOffset));

  if pFileContentRsp^.paketOffset.Low32 = 0 then
    //Sonderfall 1. Paket
    //--- ErrorCode ------------------------------------------------------------------------------------------//
    pFileContentRsp^.ErrorCode := (pData$^UDINT)^;
    pData += sizeof(pFileContentRsp^.ErrorCode);

    //--- pData ----------------------------------------------------------------------------------------------//
    pFileContentRsp^.pData := pData + sizeof(_DS_UnsLongLongInt);   //fileLength überspringen

    //Nur beim ersten fragmentierten Paket: Paketlänge korrigieren:
    //                                                             Original-Header         error             filelength
    pFileContentRsp^.dataLength := pFileContentRsp^.dataLength - sizeof(_DS_Header) - sizeof(UDINT) - sizeof(_DS_UnsLongLongInt);
  else
    //Alle weiteren Pakete
    pFileContentRsp^.ErrorCode := 0;
    pFileContentRsp^.pData := pData;
  end_if;

END_FUNCTION


FUNCTION DSComm::GetRespData_FileContent_2
	VAR_INPUT
		pData 	: ^CHAR;
		pFileContentRsp 	: ^_DS_FileContentResp;
	END_VAR

  //--- ErrorCode ------------------------------------------------------------------------------------------//
  pFileContentRsp^.ErrorCode := (pData$^UDINT)^;
  pData += sizeof(pFileContentRsp^.ErrorCode);

  //--- fileLength -------------------------------------------------------------------------------------------//
  _memcpy(ptr1:=#pFileContentRsp^.fileLength, ptr2:=pData, cntr:=sizeof(pFileContentRsp^.fileLength));
  pData += sizeof(pFileContentRsp^.fileLength);

  //--- dataLength = length (Länge dieses Pakets) ------------------------------------------------------------//
  pFileContentRsp^.dataLength := pFileContentRsp^.fileLength.Low32;

  //--- paketOffset ------------------------------------------------------------------------------------------//
  pFileContentRsp^.paketOffset.Low32 := 0;
  pFileContentRsp^.paketOffset.High32:= 0;

  //--- pData ----------------------------------------------------------------------------------------------//
  pFileContentRsp^.pData := pData;

END_FUNCTION


FUNCTION GLOBAL DSComm::DirCreate
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		pDp 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^void;
  	pHeader     : ^_DS_Header;
    pData       : ^CHAR;
    pJobElmt    : ^_DS_JobInfoElmt;
    StrLen      : UDINT;
    SendBuffSize: UDINT;
    RetVal      : DINT;
  END_VAR

  if pDp = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#DirCreateJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    StrLen := _StrLen(src:=pDp) + 1;      //Länge des UTF8-Strings in Bytes mit \0
    //                                      dpnelen
    SendBuffSize := sizeof(_DS_Header) + sizeof(UDINT) + StrLen;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest
    
      //Länge des Strings in den Sendepuffer
      pData$^UDINT^ := StrLen;
      pData += sizeof(StrLen);

      //String in den Sendepuffer kopieren
      pData := SigCLib.StrCpy(dst0:=pData, src0:=pDp);
//      pData += StrLen2;

  	  //*--- Header für Dir Create aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
	    pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := DirCreateCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#DirCreateJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION DSComm::GetRespData_DirCreate
	VAR_INPUT
		pData 	: ^CHAR;
		pDirCreateRsp 	: ^_DS_DirCreateResp;
	END_VAR
  VAR
  	StringLen   : UDINT;    //Zwischenvariable ergibt kürzeren Code (ARM und Intel)
  END_VAR

  //--- ErrorCode --------------------------------------------------------------------------------------------//
  pDirCreateRsp^.ErrorCode := (pData$^UDINT)^;
  pData += sizeof(pDirCreateRsp^.ErrorCode);

  //--- dp ..-------------------------------------------------------------------------------------------------//
  StringLen := pData$^UDINT^;                 //Anzahl der Bytes im UTF8-String mit Endezeichen.
  pData += sizeof(UDINT);

  pDirCreateRsp^.DpLen := StringLen - 1;      //Anzahl der Bytes im UTF8-String ohne Endezeichen.
  pDirCreateRsp^.pDp   := pData;

END_FUNCTION


FUNCTION GLOBAL DSComm::DirRead
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		FilterIncl 	: UDINT;
		FilterExcl 	: UDINT;
		pDp 	: ^CHAR;
		pNe 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^void;
  	pHeader     : ^_DS_Header;
    pData       : ^CHAR;
    pJobElmt    : ^_DS_JobInfoElmt;
    StrLenDp    : UDINT;
    StrLenNe    : UDINT;
    SendBuffSize: UDINT;
    RetVal      : DINT;
  END_VAR

  if pDp = nil | pNe = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#DirReadJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    StrLenDp := _StrLen(src:=pDp) + 1;
    StrLenNe := _StrLen(src:=pNe) + 1;
    //                                                                              dplen + neLen
    SendBuffSize := sizeof(_DS_Header) + sizeof(FilterIncl) + sizeof(FilterExcl) + 2*sizeof(UDINT) + StrLenDp + StrLenNe;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest
    
      pData$^UDINT^ := FilterIncl;
      pData += sizeof(FilterIncl);

      pData$^UDINT^ := FilterExcl;
      pData += sizeof(FilterExcl);

      //Länge des Strings in den Sendepuffer
      pData$^UDINT^ := StrLenDp;
      pData += sizeof(StrLenDp);

      //String in den Sendepuffer kopieren
      pData := SigCLib.StrCpy(dst0:=pData, src0:=pDp);
      pData += StrLenDp;

      //Länge des Strings in den Sendepuffer
      pData$^UDINT^ := StrLenNe;
      pData += sizeof(StrLenNe);

      //String in den Sendepuffer kopieren
      pData := SigCLib.StrCpy(dst0:=pData, src0:=pNe);
//      pData += StrLenNe;

  	  //*--- Header für Dir Read aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
	    pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := DirReadCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#DirReadJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION DSComm::GetRespData_DirRead
	VAR_INPUT
		pData 	: ^CHAR;
		pDirReadRsp 	: ^_DS_DirReadResp;
		num 	: UDINT;
	END_VAR
  VAR
    max   : UDINT;
    tmpI        : UDINT;
  	StringLen   : UDINT;    //Zwischenvariable ergibt kürzeren Code (ARM und Intel)
  END_VAR

  max := num - 1;
  for tmpI:=0 to max do
    //--- size überspringen ------------------------------------------------------------------------------------//
    pData += sizeof(UDINT);

    //--- Attribute --------------------------------------------------------------------------------------------//
    _memcpy(ptr1:=#pDirReadRsp^.Attribute, ptr2:=pData, cntr:=sizeof(pDirReadRsp^.Attribute));
    pData += sizeof(pDirReadRsp^.Attribute);

    //--- Length -----------------------------------------------------------------------------------------------//
    _memcpy(ptr1:=#pDirReadRsp^.Length, ptr2:=pData, cntr:=sizeof(pDirReadRsp^.Length));
    pData += sizeof(pDirReadRsp^.Length);

    //--- AccessDate -------------------------------------------------------------------------------------------//
    _memcpy(ptr1:=#pDirReadRsp^.AccessDate, ptr2:=pData, cntr:=sizeof(pDirReadRsp^.AccessDate));
    pData += sizeof(pDirReadRsp^.AccessDate);

    //--- AccessTime -------------------------------------------------------------------------------------------//
    _memcpy(ptr1:=#pDirReadRsp^.AccessTime, ptr2:=pData, cntr:=sizeof(pDirReadRsp^.AccessTime));
    pData += sizeof(pDirReadRsp^.AccessTime);

    //--- ModifiedDate -----------------------------------------------------------------------------------------//
    _memcpy(ptr1:=#pDirReadRsp^.ModifiedDate, ptr2:=pData, cntr:=sizeof(pDirReadRsp^.ModifiedDate));
    pData += sizeof(pDirReadRsp^.ModifiedDate);

    //--- ModifiedTime -----------------------------------------------------------------------------------------//
    _memcpy(ptr1:=#pDirReadRsp^.ModifiedTime, ptr2:=pData, cntr:=sizeof(pDirReadRsp^.ModifiedTime));
    pData += sizeof(pDirReadRsp^.ModifiedTime);

    //--- CreatedDate ------------------------------------------------------------------------------------------//
    _memcpy(ptr1:=#pDirReadRsp^.CreatedDate, ptr2:=pData, cntr:=sizeof(pDirReadRsp^.CreatedDate));
    pData += sizeof(pDirReadRsp^.CreatedDate);

    //--- CreatedTime ------------------------------------------------------------------------------------------//
    _memcmp(ptr1:=#pDirReadRsp^.CreatedTime, ptr2:=pData, cntr:=sizeof(pDirReadRsp^.CreatedTime));
    pData += sizeof(pDirReadRsp^.CreatedTime);

    //--- ne ---------------------------------------------------------------------------------------------------//
    StringLen := pData$^UDINT^;                 //Anzahl der Bytes im UTF8-String mit Endezeichen.
    pData += sizeof(UDINT);

    pDirReadRsp^.NeLen := StringLen - 1;        //Anzahl der Zeichen im UTF8-String ohne Endezeichen.
    pDirReadRsp^.pNe   := pData;
    pData += StringLen;                         //+ Anzahl der Bytes im UTF8-String mit Endezeichen.

    pDirReadRsp += sizeof(_DS_DirReadResp);
  end_for;

END_FUNCTION


FUNCTION GLOBAL DSComm::FileRemove
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		pDpne 	: ^CHAR;
		updateProgress 	: BOOL;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^void;
  	pHeader     : ^_DS_Header;
    pData       : ^CHAR;
    pJobElmt    : ^_DS_JobInfoElmt;
    StrLenDpne  : UDINT;
    SendBuffSize: UDINT;
    RetVal      : DINT;
  END_VAR

  if pDpne = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#FileRemoveJobs, MessageID, pThis, #pJobElmt);
  StoreProgressInfo(MessageID, pThis);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    StrLenDpne := _StrLen(src:=pDpne) + 1;  //Länge des UTF8-Strings in Bytes mit \0
    //                                updateProgress+dpnelen
    SendBuffSize := sizeof(_DS_Header) + 2 * sizeof(UDINT) + StrLenDpne;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest
    
      if updateProgress then
        pData$^UDINT^ := TRUE;
      else
        pData$^UDINT^ := FALSE;
      end_if;
      pData += sizeof(UDINT);

      //Länge des Strings in den Sendepuffer
      pData$^UDINT^ := StrLenDpne;
      pData += sizeof(StrLenDpne);

      //String in den Sendepuffer kopieren
      pData := SigCLib.StrCpy(dst0:=pData, src0:=pDpne);
//      pData += StrLenDpne;

  	  //*--- Header für File Remove aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
	    pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := FileRemoveCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#FileRemoveJobs, MessageID);
      DeletepProgressInfo(MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::FileCopy
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		pDpneSrc 	: ^CHAR;
		pDpneDest 	: ^CHAR;
		updateProgress 	: BOOL;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff     : ^void;
  	pHeader       : ^_DS_Header;
    pData         : ^CHAR;
    pJobElmt      : ^_DS_JobInfoElmt;
    StrLenDpneSrc : UDINT;
    StrLenDpneDest: UDINT;
    SendBuffSize  : UDINT;
    RetVal        : DINT;
  END_VAR

  if pDpneSrc = nil | pDpneDest = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // ********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#FileCopyJobs, MessageID, pThis, #pJobElmt);
  StoreProgressInfo(MessageID, pThis);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    StrLenDpneSrc  := _StrLen(src:=pDpneSrc) + 1;     //Länge des UTF8-Strings in Bytes mit \0
    StrLenDpneDest := _StrLen(src:=pDpneDest) + 1;    //Länge des UTF8-Strings in Bytes mit \0
    //                            updateProgress+destDpneLen+SrcDpneLen
    SendBuffSize := sizeof(_DS_Header) + 3 * sizeof(UDINT) + StrLenDpneSrc + StrLenDpneDest;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest
    
      if updateProgress then
        pData$^UDINT^ := TRUE;
      else
        pData$^UDINT^ := FALSE;
      end_if;
      pData += sizeof(UDINT);

      //Länge des Strings in den Sendepuffer
      pData$^UDINT^ := StrLenDpneDest;
      pData += sizeof(StrLenDpneDest);

      //String in den Sendepuffer kopieren
      pData := SigCLib.StrCpy(dst0:=pData, src0:=pDpneDest);
      pData += StrLenDpneDest;

      //Länge des Strings in den Sendepuffer
      pData$^UDINT^ := StrLenDpneSrc;
      pData += sizeof(StrLenDpneSrc);

      //String in den Sendepuffer kopieren
      pData := SigCLib.StrCpy(dst0:=pData, src0:=pDpneSrc);
//      pData += StrLenDpneSrc;

  	  //*--- Header für File Copy aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
	    pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := FileCopyCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#FileCopyJobs, MessageID);
      DeletepProgressInfo(MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::FileInfo
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		pDpne 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^void;
  	pHeader     : ^_DS_Header;
    pData       : ^CHAR;
    pJobElmt    : ^_DS_JobInfoElmt;
    StrLenDpne  : UDINT;
    SendBuffSize: UDINT;
    RetVal      : DINT;
  END_VAR

  if pDpne = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#FileInfoJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    StrLenDpne := _StrLen(src:=pDpne) + 1;  //Länge des UTF8-Strings in Bytes mit \0
    //                                      dpnelen
    SendBuffSize := sizeof(_DS_Header) + sizeof(UDINT) + StrLenDpne;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest

      //Länge des Strings in den Sendepuffer
      pData$^UDINT^ := StrLenDpne;
      pData += sizeof(StrLenDpne);

      //String in den Sendepuffer kopieren
      pData := SigCLib.StrCpy(dst0:=pData, src0:=pDpne);
//      pData += StrLenDpne;

  	  //*--- Header für File Info aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
	    pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := FileInfoCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#FileInfoJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION

FUNCTION GLOBAL DSComm::FileRename
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		pDpneOld 	: ^CHAR;
		pDpneNew 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff     : ^void;
  	pHeader       : ^_DS_Header;
    pData         : ^CHAR;
    pJobElmt      : ^_DS_JobInfoElmt;
    StrLenDpneOld : UDINT;
    StrLenDpneNew : UDINT;
    SendBuffSize  : UDINT;
    RetVal        : DINT;
  END_VAR

  if pDpneOld = nil | pDpneNew = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#FileRenameJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    StrLenDpneOld := _StrLen(src:=pDpneOld) + 1;  //Länge des UTF8-Strings in Bytes mit \0
    StrLenDpneNew := _StrLen(src:=pDpneNew) + 1;  //Länge des UTF8-Strings in Bytes mit \0
    //                                 dpneNewLen+dpneOldLen
    SendBuffSize := sizeof(_DS_Header) + 2 * sizeof(UDINT) + StrLenDpneOld + StrLenDpneNew;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest

      //Länge des Strings in den Sendepuffer
      pData$^UDINT^ := StrLenDpneNew;
      pData += sizeof(StrLenDpneNew);

      //String in den Sendepuffer kopieren
      pData := SigCLib.StrCpy(dst0:=pData, src0:=pDpneNew);
      pData += StrLenDpneNew;

      //Länge des Strings in den Sendepuffer
      pData$^UDINT^ := StrLenDpneOld;
      pData += sizeof(StrLenDpneOld);

      //String in den Sendepuffer kopieren
      pData := SigCLib.StrCpy(dst0:=pData, src0:=pDpneOld);
//      pData += StrLenDpneOld;

  	  //*--- Header für File Rename aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
	    pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := FileRenameCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#FileRenameJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::FileSetAttribute
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		pDpne 	: ^CHAR;
		AttributeToSet 	: UDINT;
		AttributeToReset 	: UDINT;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^void;
  	pHeader     : ^_DS_Header;
    pData       : ^CHAR;
    pJobElmt    : ^_DS_JobInfoElmt;
    StrLenDpne  : UDINT;
    SendBuffSize: UDINT;
    RetVal      : DINT;
  END_VAR

  if pDpne = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#FileSetAttributeJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    StrLenDpne := _StrLen(src:=pDpne) + 1;  //Länge des UTF8-Strings in Bytes mit \0
    //                                                                                          dpnelen
    SendBuffSize := sizeof(_DS_Header) + sizeof(AttributeToSet) + sizeof(AttributeToReset) + sizeof(UDINT) + StrLenDpne;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest
    
      pData$^UDINT^ := AttributeToSet;
      pData += sizeof(AttributeToSet);

      pData$^UDINT^ := AttributeToReset;
      pData += sizeof(AttributeToReset);

      //Länge des Strings in den Sendepuffer
      pData$^UDINT^ := StrLenDpne;
      pData += sizeof(StrLenDpne);

      //String in den Sendepuffer kopieren
      pData := SigCLib.StrCpy(dst0:=pData, src0:=pDpne);
//      pData += StrLenDpne;

  	  //*--- Header für File Set Attribute aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
	    pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := FileSetAttributeCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#FileSetAttributeJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::GetDriveList
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^void;
  	pHeader     : ^_DS_Header;
    pJobElmt    : ^_DS_JobInfoElmt;
    RetVal      : DINT;
  END_VAR

  if pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#GetDriveListJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=GetDriveList_BUFFER_SIZE, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      //*--- Header für Get Drive List aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := GetDriveList_BUFFER_SIZE;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := GetDriveListCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#GetDriveListJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION DSComm::GetRespData_GetDriveList
	VAR_INPUT
		pData 	: ^CHAR;
		pGetDriveListRsp 	: ^_DS_GetDriveListResp;
	END_VAR
  VAR
  	StringLen   : UDINT;    //Zwischenvariable ergibt kürzeren Code (ARM und Intel)
  END_VAR

  //--- pDrives -------------------------------------------------------------------------------------------------//
  StringLen := pData$^UDINT^;                   //Anzahl der Bytes (Zeichen) im ASCII-String mit Endezeichen.
  pData += sizeof(UDINT);

  pGetDriveListRsp^.DrivesLen := StringLen - 1; //Anzahl der Bytes (Zeichen) im ASCII-String ohne Endezeichen.
  pGetDriveListRsp^.pDrives   := pData;

END_FUNCTION


FUNCTION GLOBAL DSComm::FileMove
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		pDpneSrc 	: ^CHAR;
		pDpneDest 	: ^CHAR;
		updateProgress 	: BOOL;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff     : ^void;
  	pHeader       : ^_DS_Header;
    pData         : ^CHAR;
    pJobElmt      : ^_DS_JobInfoElmt;
    StrLenDpneSrc : UDINT;
    StrLenDpneDest: UDINT;
    SendBuffSize  : UDINT;
    RetVal        : DINT;
  END_VAR

  if pDpneSrc = nil | pDpneDest = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#FileMoveJobs, MessageID, pThis, #pJobElmt);
  StoreProgressInfo(MessageID, pThis);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    StrLenDpneSrc  := _StrLen(src:=pDpneSrc) + 1;     //Länge des UTF8-Strings in Bytes mit \0
    StrLenDpneDest := _StrLen(src:=pDpneDest) + 1;    //Länge des UTF8-Strings in Bytes mit \0
    //                            updateProgress+destDpneLen+SrcDpneLen
    SendBuffSize := sizeof(_DS_Header) + 3 * sizeof(UDINT) + StrLenDpneSrc + StrLenDpneDest;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest
    
      if updateProgress then
        pData$^UDINT^ := TRUE;
      else
        pData$^UDINT^ := FALSE;
      end_if;
      pData += sizeof(UDINT);

      //Länge des Strings in den Sendepuffer
      pData$^UDINT^ := StrLenDpneDest;
      pData += sizeof(StrLenDpneDest);

      //String in den Sendepuffer kopieren
      pData := SigCLib.StrCpy(dst0:=pData, src0:=pDpneDest);
      pData += StrLenDpneDest;

      //Länge des Strings in den Sendepuffer
      pData$^UDINT^ := StrLenDpneSrc;
      pData += sizeof(StrLenDpneSrc);

      //String in den Sendepuffer kopieren
      pData := SigCLib.StrCpy(dst0:=pData, src0:=pDpneSrc);
//      pData += StrLenDpneSrc;

  	  //*--- Header für File Move aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
	    pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := FileMoveCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#FileMoveJobs, MessageID);
      DeletepProgressInfo(MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::EventjournalAdd
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		num 	: UDINT;
		pEventjournalAdd 	: ^_DS_EventjournalAddCmd;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^void;
  	pHeader     : ^_DS_Header;
    pEventjournalAddLoc :^_DS_EventjournalAddCmd;
    pData       : ^CHAR;
    pJobElmt    : ^_DS_JobInfoElmt;
    tmpI        : UDINT;
    SendBuffSize: UDINT;
    RetVal      : DINT;
  END_VAR

  if num = 0 | pEventjournalAdd = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#EventjournalAddJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    RetVal := 0;

    //Datenlänge und Puffergröße ermitteln
    SendBuffSize := sizeof(_DS_Header) + sizeof(num);

    pEventjournalAddLoc := pEventjournalAdd;

    for tmpI:=0 to num-1 do
      pEventjournalAddLoc^.Size += AddEventJournalHeaderSize;
      SendBuffSize        += pEventjournalAddLoc^.Size;
      pEventjournalAddLoc += sizeof(_DS_EventjournalAddCmd);
    end_for;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest

      pData$^UDINT^ := num;
      pData += sizeof(num);

      for tmpI:=0 to num-1 do
        //--- Header von Size bis SessionId umkopieren -------------------------------------------------------------//
        _memcpy(ptr1:=pData, ptr2:=pEventjournalAdd, cntr:=AddEventJournalHeaderSize);
        pData += AddEventJournalHeaderSize;

        //--- Data -------------------------------------------------------------------------------------------------//
        _memcpy(ptr1:=pData, ptr2:=pEventjournalAdd^.pData, cntr:=pEventjournalAdd^.Size - AddEventJournalHeaderSize);
        pData += pEventjournalAdd^.Size - AddEventJournalHeaderSize;

        //--- Src-Pointer weiterstellen ----------------------------------------------------------------------------//
        pEventjournalAdd += sizeof(_DS_EventjournalAddCmd);
      end_for;

  	  //*--- Header für Eventjournal Add aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_EVENT_JOURNAL_PROTOKOLL;
      pheader^.MinorID        := EventjournalAddCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#EventjournalAddJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION DSComm::GetRespData_EventjournalAdd
	VAR_INPUT
		pData 	: ^CHAR;
		pEventjournalAddRsp 	: ^_DS_EventjournalAddResp;
		num 	: UDINT;
	END_VAR
  VAR
    max   : UDINT;
    tmpI  : UDINT;
  END_VAR

  max := num - 1;
  for tmpI:=0 to max do
    //--- size überspringen ----------------------------------------------------------------------------------//
    pData += sizeof(UDINT);

    //--- Daten umkopieren -----------------------------------------------------------------------------------//
    pEventjournalAddRsp^ := pData$^_DS_EventjournalAddResp^;
    pData += sizeof(_DS_EventjournalAddResp);

    //--- Dest-Pointer weiterstellen -------------------------------------------------------------------------//
    pEventjournalAddRsp += sizeof(_DS_EventjournalAddResp);
  end_for;

END_FUNCTION


FUNCTION GLOBAL DSComm::EventjournalGet
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		num 	: UDINT;
		pJournalId 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff     : ^void;
  	pHeader       : ^_DS_Header;
    pData         : ^CHAR;
    pJobElmt      : ^_DS_JobInfoElmt;
    tmpI          : UDINT;
    DataLen       : UDINT;
    SendBuffSize  : UDINT;
    RetVal        : DINT;
  END_VAR

  if num = 0 | pJournalId = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#EventjournalGetJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    //Datenlänge und Puffergröße ermitteln: num * (size + Daten)
    DataLen := num * (sizeof(UDINT) + sizeof(pJournalId^));
    SendBuffSize := sizeof(_DS_Header) + sizeof(num) + DataLen;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest

      pData$^UDINT^ := num;
      pData   += sizeof(num);

      //Journal-IDs kopieren
      for tmpI:=0 to num-1 do
        //--- size -------------------------------------------------------------------------------------//
        pData$^UDINT^ := sizeof(pJournalId^);  //Größe des nächsten Eintrags
        pData += sizeof(UDINT);

        //--- Journal-ID -------------------------------------------------------------------------------//
        pData$^UDINT^ := pJournalId^;
        pData += sizeof(pJournalId^);

        //-- Src-Pointer weiterstellen -----------------------------------------------------------------//
        pJournalId += sizeof(pJournalId^);
      end_for;

  	  //*--- Header für Eventjournal Get aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_EVENT_JOURNAL_PROTOKOLL;
      pheader^.MinorID        := EventjournalGetCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#EventjournalGetJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION DSComm::GetRespData_EventjournalGet
	VAR_INPUT
		pData 	: ^CHAR;
		pEventjournalGetRsp 	: ^_DS_EventjournalGetResp;
		num 	: UDINT;
	END_VAR
  VAR
    max   : UDINT;
    tmpI  : UDINT;
  END_VAR

  max := num - 1;
  for tmpI:=0 to max do
    //--- size überspringen ----------------------------------------------------------------------------------//
    pData += sizeof(UDINT);

    //--- Daten von crc bis SessionId umkopieren -------------------------------------------------------------//
    _memcpy(ptr1:=pEventjournalGetRsp, ptr2:=pData, cntr:=GetEventJournalHeaderSize1);

    if pEventjournalGetRsp^.valid = EvtJournalEntryValid then
      //--- Event Journal Eintrag ist gültig -----------------------------------------------------------------//
      pData += GetEventJournalHeaderSize1;

      //DataLen um die Länge von Id bis SessionId korrigieren, weil Teil von _DS_EventjournalGetResp statt
      //Teil der Daten
      pEventjournalGetRsp^.DataLen -= GetEventJournalHeaderSize2;

      //--- pData = Zeiger auf die Daten ---------------------------------------------------------------------//
      pEventjournalGetRsp^.pData := pData;
      pData += pEventjournalGetRsp^.DataLen;
    else
      //--- Event Journal Eintrag ist ungültig ---------------------------------------------------------------//
      pEventjournalGetRsp^.ID        := 0;
      pEventjournalGetRsp^.nc        := 0;
      pEventjournalGetRsp^.EvtTime   := 0;
      pEventjournalGetRsp^.EvtDate   := 0;
      pEventjournalGetRsp^.SessionID := 0;

      pData += GetEventJournalHeaderSize3;

      //Keine Daten vorhanden
      pEventjournalGetRsp^.pData := nil;
    end_if;

    //--- Dest-Pointer weiterstellen -------------------------------------------------------------------------//
    pEventjournalGetRsp += sizeof(_DS_EventjournalGetResp);
  end_for;

END_FUNCTION


FUNCTION GLOBAL DSComm::EventjournalGetAll
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff     : ^void;
  	pHeader       : ^_DS_Header;
    pJobElmt      : ^_DS_JobInfoElmt;
    RetVal        : DINT;
  END_VAR

  if pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#EventjournalGetAllJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=EventjournalGetAll_BUFFER_SIZE, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      //*--- Header für Eventjournal Get All aufbauen -----------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := EventjournalGetAll_BUFFER_SIZE;
      pheader^.MajorID        := SIGMATEK_EVENT_JOURNAL_PROTOKOLL;
      pheader^.MinorID        := EventjournalGetAllCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#EventjournalGetAllJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::EventjournalDel
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		num 	: UDINT;
		pJournalId 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff     : ^void;
  	pHeader       : ^_DS_Header;
    pData         : ^CHAR;
    pJobElmt      : ^_DS_JobInfoElmt;
    tmpI          : UDINT;
    DataLen       : UDINT;
    SendBuffSize  : UDINT;
    RetVal        : DINT;
  END_VAR

  if num = 0 | pJournalId = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#EventjournalDelJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    //Datenlänge und Puffergröße ermitteln: num * (size + Daten)
    DataLen := num * (sizeof(UDINT) + sizeof(pJournalId^));
    SendBuffSize := sizeof(_DS_Header) + sizeof(num) + DataLen;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest

      pData$^UDINT^ := num;
      pData   += sizeof(num);

      //Journal Ids kopieren
      for tmpI:=0 to num-1 do
        //--- size -------------------------------------------------------------------------------------//
        pData$^UDINT^ := sizeof(pJournalId^);  //Größe des nächsten Eintrags
        pData += sizeof(UDINT);

        //--- JournalId --------------------------------------------------------------------------------//
        pData$^UDINT^ := pJournalId^;
        pData += sizeof(pJournalId^);

        //-- Src-Pointer weiterstellen -----------------------------------------------------------------//
        pJournalId += sizeof(pJournalId^);
      end_for;

  	  //*--- Header für Eventjournal Del aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_EVENT_JOURNAL_PROTOKOLL;
      pheader^.MinorID        := EventjournalDelCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#EventjournalDelJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION DSComm::GetRespData_EventjournalDel
	VAR_INPUT
		pData 	: ^CHAR;
		pEventjournalDelRsp 	: ^_DS_EventjournalDelResp;
		num 	: UDINT;
	END_VAR
  VAR
    max   : UDINT;
    tmpI  : UDINT;
  END_VAR

  max := num - 1;
  for tmpI:=0 to max do
    //--- size überspringen ----------------------------------------------------------------------------------//
    pData += sizeof(UDINT);

    //--- Daten umkopieren -----------------------------------------------------------------------------------//
    pEventjournalDelRsp^ := pData$^_DS_EventjournalDelResp^;
    pData += sizeof(_DS_EventjournalDelResp);

    //--- Dest-Pointer weiterstellen -------------------------------------------------------------------------//
    pEventjournalDelRsp += sizeof(_DS_EventjournalDelResp);
  end_for;

END_FUNCTION


FUNCTION GLOBAL DSComm::EventjournalDelAll
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff     : ^void;
  	pHeader       : ^_DS_Header;
    pJobElmt      : ^_DS_JobInfoElmt;
    RetVal        : DINT;
  END_VAR

  if pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#EventjournalDelAllJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=EventjournalDelAll_BUFFER_SIZE, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      //*--- Header für Eventjournal Del All aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := EventjournalDelAll_BUFFER_SIZE;
      pheader^.MajorID        := SIGMATEK_EVENT_JOURNAL_PROTOKOLL;
      pheader^.MinorID        := EventjournalDelAllCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#EventjournalDelAllJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::EventjournalQuitAlarm
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		num 	: UDINT;
		pAlarmId 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff     : ^void;
  	pHeader       : ^_DS_Header;
    pData         : ^CHAR;
    pJobElmt      : ^_DS_JobInfoElmt;
    tmpI          : UDINT;
    DataLen       : UDINT;
    SendBuffSize  : UDINT;
    RetVal        : DINT;
  END_VAR

  if num = 0 | pAlarmId = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#EventjournalQuitAlarmJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    //Datenlänge und Puffergröße ermitteln: num * (size + Daten)
    DataLen := num * (sizeof(UDINT) + sizeof(pAlarmId^));
    SendBuffSize := sizeof(_DS_Header) + sizeof(num) + DataLen;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest

      pData$^UDINT^ := num;
      pData   += sizeof(num);

      //Alarm Ids kopieren
      for tmpI:=0 to num-1 do
        //--- size -------------------------------------------------------------------------------------//
        pData$^UDINT^ := sizeof(pAlarmId^);  //Größe des nächsten Eintrags
        pData += sizeof(UDINT);

        //--- AlarmId ----------------------------------------------------------------------------------//
        pData$^UDINT^ := pAlarmId^;
        pData += sizeof(pAlarmId^);

        //-- Src-Pointer weiterstellen -----------------------------------------------------------------//
        pAlarmId += sizeof(pAlarmId^);
      end_for;

  	  //*--- Header für Eventjournal Quit Alarm aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_EVENT_JOURNAL_PROTOKOLL;
      pheader^.MinorID        := EventjournalQuitAlarmCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#EventjournalQuitAlarmJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION DSComm::GetRespData_EventjournalQuitAlarm
	VAR_INPUT
		pData 	: ^CHAR;
		pEventjournalQuitAlarmRsp 	: ^_DS_EventjournalQuitAlarmResp;
		num 	: UDINT;
	END_VAR
  VAR
    max   : UDINT;
    tmpI  : UDINT;
  END_VAR

  max := num - 1;
  for tmpI:=0 to max do
    //--- size überspringen ----------------------------------------------------------------------------------//
    pData += sizeof(UDINT);

    //--- Daten umkopieren -----------------------------------------------------------------------------------//
    pEventjournalQuitAlarmRsp^ := pData$^_DS_EventjournalQuitAlarmResp^;
    pData += sizeof(_DS_EventjournalQuitAlarmResp);

    //--- Dest-Pointer weiterstellen -------------------------------------------------------------------------//
    pEventjournalQuitAlarmRsp += sizeof(_DS_EventjournalQuitAlarmResp);
  end_for;

END_FUNCTION


FUNCTION GLOBAL DSComm::EventjournalQuitAll
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff     : ^void;
  	pHeader       : ^_DS_Header;
    pJobElmt      : ^_DS_JobInfoElmt;
    RetVal        : DINT;
  END_VAR

  if pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#EventjournalQuitAllJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=EventjournalQuitAll_BUFFER_SIZE, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      //*--- Header für Eventjournal Quit All aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := EventjournalQuitAll_BUFFER_SIZE;
      pheader^.MajorID        := SIGMATEK_EVENT_JOURNAL_PROTOKOLL;
      pheader^.MinorID        := EventjournalQuitAllCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#EventjournalQuitAllJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION

FUNCTION DSComm::GetRespData_EventjournalQuitAll
	VAR_INPUT
		pData 	: ^CHAR;
		pEventjournalQuitAllRsp 	: ^_DS_EventjournalQuitAllResp;
		num 	: UDINT;
	END_VAR
  VAR
    max   : UDINT;
    tmpI  : UDINT;
  END_VAR

  max := num - 1;
  for tmpI:=0 to max do
    //--- size überspringen ----------------------------------------------------------------------------------//
    pData += sizeof(UDINT);

    //--- Daten umkopieren -----------------------------------------------------------------------------------//
    pEventjournalQuitAllRsp^ := pData$^_DS_EventjournalQuitAllResp^;
    pData += sizeof(_DS_EventjournalQuitAllResp);

    //--- Dest-Pointer weiterstellen -------------------------------------------------------------------------//
    pEventjournalQuitAllRsp += sizeof(_DS_EventjournalQuitAllResp);
  end_for;

END_FUNCTION


FUNCTION GLOBAL DSComm::ResetDataservice
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^char;
  	pHeader     : ^_DS_Header;
    pJobElmt    : ^_DS_JobInfoElmt;
    RetVal      : DINT;
  END_VAR

  if pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#ResetDataserviceJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=ResetDataservice_BUFFER_SIZE, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      //*--- Header für Reset Dataservice aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := ResetDataservice_BUFFER_SIZE;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := ResetDataserviceCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#ResetDataserviceJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::RestartDataservice
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^char;
  	pHeader     : ^_DS_Header;
    pJobElmt    : ^_DS_JobInfoElmt;
    RetVal      : DINT;
    DS_ResetSave: BOOL;
  END_VAR

  if pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  DS_ResetSave := DS_Reset;
  DS_Reset := FALSE;
  RetVal := SaveJobInfo(pJobInfo:=#RestartDataserviceJobs, MessageID, pThis, #pJobElmt);
  DS_Reset := DS_ResetSave;
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=RestartDataservice_BUFFER_SIZE, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      //*--- Header für Restart Dataservice aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := RestartDataservice_BUFFER_SIZE;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := RestartDataserviceCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#RestartDataserviceJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::GetStationStatus
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		num 	: UDINT;
		pStationNo 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff     : ^void;
  	pHeader       : ^_DS_Header;
    pData         : ^CHAR;
    pJobElmt      : ^_DS_JobInfoElmt;
    tmpI          : UDINT;
    DataLen       : UDINT;
    SendBuffSize  : UDINT;
    RetVal        : DINT;
  END_VAR

  if num = 0 | pStationNo = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#GetStationStatusJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    //Datenlänge und Puffergröße ermitteln: num * (size + Daten)
    DataLen := num * (sizeof(UDINT) + sizeof(pStationNo^));
    SendBuffSize := sizeof(_DS_Header) + sizeof(num) + DataLen;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest

      pData$^UDINT^ := num;
      pData   += sizeof(num);

      //Stationsnummern kopieren
      for tmpI:=0 to num-1 do
        //--- size -------------------------------------------------------------------------------------//
        pData$^UDINT^ := sizeof(pStationNo^);  //Größe des nächsten Eintrags
        pData += sizeof(UDINT);

        //--- stationNr --------------------------------------------------------------------------------//
        pData$^UDINT^ := pStationNo^;
        pData += sizeof(pStationNo^);

        //-- Src-Pointer weiterstellen -----------------------------------------------------------------//
        pStationNo += sizeof(pStationNo^);
      end_for;

  	  //*--- Header für Get Station Status aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := GetStationStatusCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#GetStationStatusJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION

FUNCTION DSComm::GetRespData_StationStatus
	VAR_INPUT
		pData 	: ^CHAR;
		pStationStatusRsp 	: ^_DS_StationStatusResp;
		num 	: UDINT;
	END_VAR
  VAR
    max         : UDINT;
    tmpI        : UDINT;
  END_VAR

  max := num - 1;
  for tmpI:=0 to max do
    pData += sizeof(UDINT);           //size überspringen

    pStationStatusRsp^ := (pData$^_DS_StationStatusResp)^;
    pData += sizeof(pStationStatusRsp^);

    pStationStatusRsp += sizeof(_DS_StationStatusResp);
  end_for;

END_FUNCTION

FUNCTION GLOBAL DSComm::GetVarIdFromCRC
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		num 	: UDINT;
		pCRC 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff     : ^void;
  	pHeader       : ^_DS_Header;
    pData         : ^CHAR;
    pJobElmt      : ^_DS_JobInfoElmt;
    tmpI          : UDINT;
    DataLen       : UDINT;
    SendBuffSize  : UDINT;
    RetVal        : DINT;
  END_VAR

  if num = 0 | pCRC = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#GetVarIdFromCRCJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    //Datenlänge und Puffergröße ermitteln: num * (size + Daten)
    DataLen := num * (sizeof(UDINT) + sizeof(pCRC^));

    SendBuffSize := sizeof(_DS_Header) + sizeof(num) + DataLen;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest
    
      pData$^UDINT^ := num;
      pData += sizeof(num);
    
      //CRCs der Datenpunkte kopieren
      for tmpI:=0 to num-1 do
        //--- size -------------------------------------------------------------------------------------//
        pData$^UDINT^ := sizeof(UDINT);  //Größe des nächsten Eintrags
        pData += sizeof(UDINT);

        //--- CRC --------------------------------------------------------------------------------------//
        pData$^UDINT^ := pCRC^;
        pData += sizeof(pCRC^);

        //-- Src-Pointer weiterstellen -----------------------------------------------------------------//
        pCRC += sizeof(pCRC^);
      end_for;

  	  //*--- Header für Get VarId from CRC aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := GetVarIdFromCrcCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#GetVarIdFromCRCJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION DSComm::GetRespData_GetVarIdFromCRC
	VAR_INPUT
		pData 	: ^CHAR;
		pGetVarIdFromCRCRsp 	: ^_DS_GetVarIdFromCRCResp;
		num 	: UDINT;
	END_VAR
  VAR
    tmpI  : UDINT;
  END_VAR


  for tmpI:=0 to num-1 do
    pData += sizeof(UDINT);   //Size überspringen

    pGetVarIdFromCRCRsp^.CRC := (pData$^UDINT)^;
    pData += sizeof(pGetVarIdFromCRCRsp^.CRC);

    pGetVarIdFromCRCRsp^.ErrorCode := (pData$^UDINT)^;
    pData += sizeof(pGetVarIdFromCRCRsp^.ErrorCode);

    if pGetVarIdFromCRCRsp^.ErrorCode = 0 then
      pGetVarIdFromCRCRsp^.VarID := (pData$^UDINT)^;
      pData += sizeof(pGetVarIdFromCRCRsp^.VarID);
    else
      pGetVarIdFromCRCRsp^.VarID := 0;
    end_if;

    pGetVarIdFromCRCRsp += sizeof(_DS_GetVarIdFromCRCResp);
  end_for;

END_FUNCTION


FUNCTION GLOBAL DSComm::GetCRCfromVarId
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		num 	: UDINT;
		pVarId 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff     : ^void;
  	pHeader       : ^_DS_Header;
    pData         : ^CHAR;
    pJobElmt      : ^_DS_JobInfoElmt;
    tmpI          : UDINT;
    DataLen       : UDINT;
    SendBuffSize  : UDINT;
    RetVal        : DINT;
  END_VAR

  if num = 0 | pVarId = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#GetCRCfromVarIdJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    //Datenlänge und Puffergröße ermitteln: num * (size + Daten)
    DataLen := num * (sizeof(UDINT) + sizeof(pVarId^));

    SendBuffSize := sizeof(_DS_Header) + sizeof(num) + DataLen;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest
    
      pData$^UDINT^ := num;
      pData += sizeof(num);
    
      //VarIds der Datenpunkte kopieren
      for tmpI:=0 to num-1 do
        //--- size -------------------------------------------------------------------------------------//
        pData$^UDINT^ := sizeof(UDINT);  //Größe des nächsten Eintrags
        pData += sizeof(UDINT);

        //--- VarID ------------------------------------------------------------------------------------//
        pData$^UDINT^ := pVarId^;
        pData += sizeof(pVarId^);

        //-- Src-Pointer weiterstellen -----------------------------------------------------------------//
        pVarId += sizeof(pVarId^);
      end_for;

  	  //*--- Header für Get CRC from VarId aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := GetCRCfromVarIdCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#GetCRCfromVarIdJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION DSComm::GetRespData_GetCRCfromVarId
	VAR_INPUT
		pData 	: ^CHAR;
		pGetCRCfromVarIdRsp 	: ^_DS_GetCRCfromVarIdResp;
		num 	: UDINT;
	END_VAR
  VAR
    tmpI  : UDINT;
  END_VAR


  for tmpI:=0 to num-1 do
    pData += sizeof(UDINT);   //Size überspringen

    pGetCRCfromVarIdRsp^.VarID := (pData$^UDINT)^;
    pData += sizeof(pGetCRCfromVarIdRsp^.VarID);

    pGetCRCfromVarIdRsp^.ErrorCode := (pData$^UDINT)^;
    pData += sizeof(pGetCRCfromVarIdRsp^.ErrorCode);

    if pGetCRCfromVarIdRsp^.ErrorCode = 0 then
      pGetCRCfromVarIdRsp^.CRC := (pData$^UDINT)^;
      pData += sizeof(pGetCRCfromVarIdRsp^.CRC);
    else
      pGetCRCfromVarIdRsp^.CRC := 0;
    end_if;

    pGetCRCfromVarIdRsp += sizeof(_DS_GetCRCfromVarIdResp);
  end_for;

END_FUNCTION


FUNCTION DSComm::GetRespData_RecipeLoad
	VAR_INPUT
		pRecipeLoadRspInt 	: ^_DS_RecipeLoadRespInt;
		pRecipeLoadRsp 	: ^DSComm::_DS_RecipeLoadResp;
	END_VAR

  pRecipeLoadRsp^.ErrorCode := pRecipeLoadRspInt^.ErrorCode;
  pRecipeLoadRsp^.DpneLen   := pRecipeLoadRspInt^.DpneLen - 1;  //Anzahl der Zeichen im UTF8-String ohne Endezeichen.
  pRecipeLoadRsp^.pDpne     := #pRecipeLoadRspInt^.Dpne[0];

END_FUNCTION


FUNCTION DSComm::GetRespData_RecipeSave
	VAR_INPUT
		pRecipeSaveRspInt 	: ^_DS_RecipeSaveRespInt;
		pRecipeSaveRsp 	: ^DSComm::_DS_RecipeSaveResp;
	END_VAR

  pRecipeSaveRsp^.ErrorCode := pRecipeSaveRspInt^.ErrorCode;
  pRecipeSaveRsp^.DpneLen   := pRecipeSaveRspInt^.DpneLen - 1;  //Anzahl der Zeichen im UTF8-String ohne Endezeichen.
  pRecipeSaveRsp^.pDpne     := #pRecipeSaveRspInt^.Dpne[0];

END_FUNCTION


FUNCTION GLOBAL DSComm::IsConnected
	VAR_OUTPUT
		OutParam 	: BOOL;
	END_VAR

  OutParam := to_bool(Online);
END_FUNCTION


FUNCTION GLOBAL DSComm::GetLoginInfo
	VAR_OUTPUT
		userID 	: UDINT;
	END_VAR

  userID := UserIDLogin;
END_FUNCTION


FUNCTION DSComm::GenerateMessageID
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR

//  MessageID$UDINT := sigclib_atomic_incU32(#_MessageID) and 0x7FFFFFFF;
  MessageID$UDINT := sigclib_atomic_incU32(#_MessageID$UDINT) and 0x7FFFFFFF;
END_FUNCTION


FUNCTION DSComm::GetRespData_RefListUpdate
	VAR_INPUT
		pData 	: ^CHAR;
		pRefListUpdate 	: ^_DS_RefListUpdate;
		num 	: UDINT;
	END_VAR
  VAR
    max         : UDINT;
    tmpI        : UDINT;
  END_VAR

  max := num - 1;
  for tmpI:=0 to max do
    pData += sizeof(UDINT);   //Size überspringen

    pRefListUpdate^.dpID := (pData$^UDINT)^;
    pData += sizeof(pRefListUpdate^.dpID);

    pRefListUpdate^.Value := pData$^LREAL^;
    pData += sizeof(pRefListUpdate^.Value);

    pRefListUpdate += sizeof(_DS_RefListUpdate);
  end_for;

END_FUNCTION


FUNCTION DSComm::GetRespData_RefListUpdateString
	VAR_INPUT
		pData 	: ^CHAR;
		pRefListUpdateString 	: ^_DS_RefListUpdateString;
		num 	: UDINT;
	END_VAR
  VAR
  	StringLen   : UDINT;
    max         : UDINT;
    tmpI        : UDINT;
  END_VAR

  max := num - 1;
  for tmpI:=0 to max do
    pData += sizeof(UDINT);   //Size überspringen

    pRefListUpdateString^.dpID := (pData$^UDINT)^;
    pData += sizeof(pRefListUpdateString^.dpID);

    StringLen := pData$^UDINT^;                         //Anzahl der Bytes im uni-0-String mit Endezeichen.
    pData += sizeof(UDINT);

    pRefListUpdateString^.StringLen := (StringLen-2)/2; //Anzahl der Zeichen im uni-0-String ohne Endezeichen.
    pRefListUpdateString^.pString   := pData$^UINT;
    pData += StringLen;                                 //+ Anzahl der Bytes im uni-0-String mit Endezeichen.

    pRefListUpdateString += sizeof(_DS_RefListUpdateString);
  end_for;

END_FUNCTION



FUNCTION DSComm::GetpProgressInfo
	VAR_INPUT
		HandleID 	: DINT;
	END_VAR
	VAR_OUTPUT
		pProgressInfo 	: ^DSComm::_DS_ProgressInfo;
	END_VAR
  VAR
		pProgressInfoLoc 	: ^DSCOMM::_DS_ProgressInfo;
  	index     : DINT;
    MaxIndex  : DINT;
    tmpI      : DINT;
  END_VAR

  //index als Hash der HandleID mit Lücken der Größe DS_PROGRESS_INFO_DIST-1 dazwischen.
  //In diesen Lücken wird gespeichert, wenn es zu Kollisionen der Indices kommt.
  MaxIndex := DS_PROGRESS_INFO_ELMT_CNT / DS_PROGRESS_INFO_DIST;
  index := (HandleID mod MaxIndex) * DS_PROGRESS_INFO_DIST;
  
  pProgressInfo := #ProgressInfo[index];

  if pProgressInfo^.HandleID = HandleID then
    return;
  else
    pProgressInfo    := nil;
    pProgressInfoLoc := #ProgressInfo[index+1];

    MaxIndex := index + DS_PROGRESS_INFO_DIST - 1;

    for tmpI := index+1 to MaxIndex do
      if pProgressInfoLoc^.HandleID = HandleID then
        pProgressInfo := pProgressInfoLoc;
        return;
      end_if;
      pProgressInfoLoc += sizeof(_DS_ProgressInfo);
    end_for;
  end_if;

END_FUNCTION


FUNCTION DSComm::StoreProgressInfo
	VAR_INPUT
		HandleID 	: DINT;
		pThis 	: ^DSComm_Interface;
	END_VAR
	VAR_OUTPUT
		ErrorNo 	: DINT;
	END_VAR
  VAR
    pProgressInfo     : ^_DS_ProgressInfo;
  END_VAR

  SectionStart(); // *********************
  pProgressInfo := GetFreeProgressInfo(HandleID);
  
  if pProgressInfo then
    pProgressInfo^.HandleID := HandleID;
    pProgressInfo^.pThis    := pThis;
    ErrorNo := 0;
  else
    ErrorNo := ERR_PROGRESS_INFO_FULL;
  end_if;
  SectionStop(); // *********************

END_FUNCTION


FUNCTION DSComm::GetFreeProgressInfo
	VAR_INPUT
		HandleID 	: DINT;
	END_VAR
	VAR_OUTPUT
		pProgressInfo 	: ^DSComm::_DS_ProgressInfo;
	END_VAR
  VAR
		pProgressInfoLoc 	: ^DSCOMM::_DS_ProgressInfo;
  	index     : DINT;
    MaxIndex  : DINT;
    tmpI      : DINT;
  END_VAR

  //index als Hash der HandleID mit Lücken der Größe DS_PROGRESS_INFO_DIST-1 dazwischen.
  //In diesen Lücken wird gespeichert, wenn es zu Kollisionen der Indices kommt.
  MaxIndex := DS_PROGRESS_INFO_ELMT_CNT / DS_PROGRESS_INFO_DIST;
  index := (HandleID mod MaxIndex) * DS_PROGRESS_INFO_DIST;
  
  pProgressInfo := #ProgressInfo[index];

  if pProgressInfo^.HandleID = DS_HANDLE_ID_FREE then
    return;
  else
    pProgressInfo    := nil;
    pProgressInfoLoc := #ProgressInfo[index+1];

    MaxIndex := index + DS_PROGRESS_INFO_DIST - 1;

    for tmpI := index+1 to MaxIndex do
      if pProgressInfoLoc^.HandleID = DS_HANDLE_ID_FREE then
        pProgressInfo := pProgressInfoLoc;
        return;
      end_if;
      pProgressInfoLoc += sizeof(_DS_ProgressInfo);
    end_for;
  end_if;

END_FUNCTION


FUNCTION DSComm::DeletepProgressInfo
	VAR_INPUT
		HandleID 	: DINT;
	END_VAR
	VAR_OUTPUT
		ErrorNo 	: DINT;
	END_VAR
  VAR
		pProgressInfo 	: ^DSCOMM::_DS_ProgressInfo;
  END_VAR

  pProgressInfo := GetpProgressInfo(HandleID);

  if pProgressInfo then
    pProgressInfo^.pThis    := nil;
    pProgressInfo^.HandleID := DS_HANDLE_ID_FREE;
    ErrorNo := 0;
  else
    ErrorNo := ERR_HANDLE_ID_NOT_FOUND;
  end_if;

END_FUNCTION


FUNCTION DSComm::GetpUserEvent
	VAR_INPUT
		MajorID 	: UINT;
		MinorID 	: UINT;
	END_VAR
	VAR_OUTPUT
		pUserEvent 	: ^DSComm::_DS_UsrEvntMinorID;
	END_VAR
  VAR
		pMajorIDLoc : ^DSComm::_DS_UsrEvntMajorID;
  END_VAR

  pUserEvent := nil;

  //MajorID suchen
  pMajorIDLoc := GetpMajorID(pMajorID, MajorID);

  if pMajorIDLoc & pMajorIDLoc^.pMinorID <> nil then
    if pMajorIDLoc^.Flags.Listed_MinorIDs_invalid then
      //Der Puffer für die MinorIDs enthält alle MinorIDs die nicht gültig sind (Unsubscribe()).
      //MinorID suchen
      pUserEvent := GetpMinorID(pMajorIDLoc^.pMinorID, MinorID);
      if pUserEvent & pUserEvent^.pThis = nil then
        //Lücke gefunden
        pUserEvent := nil;
      end_if;

      if pUserEvent = nil then
        //Die MinorID wurde nicht gefunden (oder Lücke gefunden) ==> User Event an die Applikation übergeben.
        pUserEvent := pMajorIDLoc^.pMinorID;      //Zeiger auf das erste Elmt im Puffer
      else
        //Die MinorID wurde gefunden ==> User Event nicht an die Applikation übergeben.
        pUserEvent := nil;
      end_if;
    elsif pMajorIDLoc^.Flags.All_MinorIDs_valid then
      //Alle MinorIDs einer MajorID sind gültig
      pUserEvent := pMajorIDLoc^.pMinorID;      //Zeiger auf das erste Elmt im Puffer
    else
      //Der Puffer für die MinorIDs enthält alle MinorIDs die gültig sind.
      //MinorID suchen
      pUserEvent := GetpMinorID(pMajorIDLoc^.pMinorID, MinorID);
      if pUserEvent & pUserEvent^.pThis = nil then
        //Lücke gefunden
        pUserEvent := nil;
      end_if;
    end_if;
  end_if;

END_FUNCTION


FUNCTION DSComm::GetpMajorID
	VAR_INPUT
		pMajorIDIn 	: ^DSComm::_DS_UsrEvntMajorID;
		MajorID 	: UINT;
	END_VAR
	VAR_OUTPUT
		pMajorIDOut 	: ^DSComm::_DS_UsrEvntMajorID;
	END_VAR
  VAR
		pMajorIDLoc : ^DSComm::_DS_UsrEvntMajorID;
  	index     : UDINT;
    MaxIndex  : UDINT;
    tmpI      : UDINT;
  END_VAR

  //index als Hash der MajorID mit Lücken der Größe DS_MAJOR_ID_DIST-1 dazwischen.
  //In diesen Lücken wird gespeichert, wenn es zu Kollisionen der Indices kommt.
  MaxIndex := DS_MAJOR_ID_ELMT_CNT / DS_MAJOR_ID_DIST;
  index := (MajorID mod MaxIndex) * DS_MAJOR_ID_DIST;
  
  pMajorIDOut := pMajorIDIn + index * sizeof(DSComm::_DS_UsrEvntMajorID);

  if pMajorIDOut^.MajorID = MajorID | pMajorIDOut^.pMinorID = nil then
    //Gesuchte MajorID gefunden oder freien Eintrag gefunden.
    return;
  else
    pMajorIDLoc := pMajorIDOut + sizeof(DSComm::_DS_UsrEvntMajorID);
    pMajorIDOut := nil;

    MaxIndex := index + DS_MAJOR_ID_DIST - 1;

    for tmpI := index+1 to MaxIndex do
      if pMajorIDLoc^.MajorID = MajorID | pMajorIDLoc^.pMinorID = nil then
        //Gesuchte MajorID gefunden oder freien Eintrag gefunden.
        pMajorIDOut := pMajorIDLoc;
        return;
      end_if;
      pMajorIDLoc += sizeof(DSComm::_DS_UsrEvntMajorID);
    end_for;
  end_if;

END_FUNCTION


FUNCTION DSComm::GetpMinorID
	VAR_INPUT
		pMinorIDIn 	: ^DSComm::_DS_UsrEvntMinorID;
		MinorID 	: UINT;
	END_VAR
	VAR_OUTPUT
		pMinorIDOut 	: ^DSComm::_DS_UsrEvntMinorID;
	END_VAR
  VAR
		pMinorIDLoc : ^DSComm::_DS_UsrEvntMinorID;
  	index     : UDINT;
    MaxIndex  : UDINT;
    tmpI      : UDINT;
  END_VAR

  //index als Hash der MinorID mit Lücken der Größe DS_MINOR_ID_DIST-1 dazwischen.
  //In diesen Lücken wird gespeichert, wenn es zu Kollisionen der Indices kommt.
  MaxIndex := DS_MINOR_ID_ELMT_CNT / DS_MINOR_ID_DIST;
  index := (MinorID mod MaxIndex) * DS_MINOR_ID_DIST;
  
  //Index 0 wird verwendet wenn alle MinorIDs einer MajorID gültig sind.
  index += 1;

  pMinorIDOut := pMinorIDIn + index * sizeof(DSComm::_DS_UsrEvntMinorID);

  if pMinorIDOut^.MinorID = MinorID | pMinorIDOut^.pThis = nil then
    return;
  else
    pMinorIDLoc := pMinorIDOut + sizeof(DSComm::_DS_UsrEvntMinorID);
    pMinorIDOut := nil;

    MaxIndex := index + DS_MINOR_ID_DIST - 1;

    for tmpI := index+1 to MaxIndex do
      if pMinorIDLoc^.MinorID = MinorID | pMinorIDLoc^.pThis = nil then
        pMinorIDOut := pMinorIDLoc;
        return;
      end_if;
      pMinorIDLoc += sizeof(DSComm::_DS_UsrEvntMinorID);
    end_for;
  end_if;

END_FUNCTION


FUNCTION DSComm::StoreUserEvent
	VAR_INPUT
		MajorID 	: UINT;
		MinorID 	: UINT;
		pThis 	: ^DSComm_Interface;
	END_VAR
	VAR_OUTPUT
		ErrorNo 	: DINT;
	END_VAR
  VAR
		pMajorIDLoc : ^DSComm::_DS_UsrEvntMajorID;
		pMinorIDLoc : ^DSComm::_DS_UsrEvntMinorID;
  END_VAR

  ErrorNo := 0;

  SectionStart(); // *********************
  pMajorIDLoc := GetpMajorID(pMajorID, MajorID);

  if pMajorIDLoc & pMajorIDLoc^.pMinorID = nil then
    //MajorID noch nicht vorhanden. Puffer für die MinorIDs anlegen. Dabei wird Platz für ein Element mehr angefordert, denn
    //Index 0 wird verwendet wenn alle MinorIDs einer MajorID gültig sind. 
    pMajorIDLoc^.pMinorID$^void := sigclib_mallocV1(size:=(DS_MINOR_ID_ELMT_CNT + 1) * sizeof(DSComm::_DS_UsrEvntMinorID), id:=MEM_Mark_DS_Comm);
    if pMajorIDLoc^.pMinorID then
      _memset(dest:=pMajorIDLoc^.pMinorID, usByte:=0, cntr:=(DS_MINOR_ID_ELMT_CNT + 1) * sizeof(DSComm::_DS_UsrEvntMinorID));

      if MinorID <> DS_ALL_MINOR_IDs_VALID then
        //Freien Platz im Puffer suchen. Es muss ein freier Platz vorhanden sein.
        pMinorIDLoc := GetpMinorID(pMajorIDLoc^.pMinorID, MinorID);
        pMinorIDLoc^.MinorID := MinorID;
        pMinorIDLoc^.pThis   := pThis;

        pMajorIDLoc^.MinorIDCnt := 1;
      else
        //Bei DS_ALL_MINOR_IDs_VALID sind alle MinorIDs gültig. Im ersten Element des Puffers speichern.
        pMajorIDLoc^.pMinorID^.MinorID := MinorID;
        pMajorIDLoc^.pMinorID^.pThis   := pThis;
        
        pMajorIDLoc^.Flags.All_MinorIDs_valid := 1;
        pMajorIDLoc^.MinorIDCnt := 0;
      end_if;

      pMajorIDLoc^.MajorID := MajorID;
      MajorIDCount += 1;
    else    
      ErrorNo := ERR_MEM_ALLOC;
    end_if;

  elsif pMajorIDLoc then
    //MajorID schon vorhanden.
    if MinorID = DS_ALL_MINOR_IDs_VALID then
      //Bei DS_ALL_MINOR_IDs_VALID sind alle MinorIDs gültig. Im ersten Element des Puffers speichern.
      //Vorher noch alle MinorIds im Puffer löschen, denn ab jetzt werden im Puffer jene MinorIDs gespeichert welche ungültig sind.
      _memset(pMajorIDLoc^.pMinorID, usByte:=0, cntr:=(DS_MINOR_ID_ELMT_CNT + 1) * sizeof(DSComm::_DS_UsrEvntMinorID));

      pMajorIDLoc^.pMinorID^.MinorID := MinorID;
      pMajorIDLoc^.pMinorID^.pThis   := pThis;

      pMajorIDLoc^.Flags.All_MinorIDs_valid      := 1;
      pMajorIDLoc^.Flags.Listed_MinorIDs_invalid := 0;

      pMajorIDLoc^.MinorIDCnt := 0;
    elsif pMajorIDLoc^.Flags.Listed_MinorIDs_invalid then
      //Das Flag "Listed_MinorIDs_invalid" besagt, dass der MinorID-Puffer jene MinorIDs enthält welche ungültig sind.
      //Ev. kann jetzt eine dieser MinorIds entfernt werden. Wenn alle ungültigen MinorIds entfernt wurden, dann wird 
      //das Flag "Listed_MinorIDs_invalid" gelöscht und der Puffer wird dann wieder mit gültigen MinorIDs gefüllt.
      //Der Puffer ist zwar leer, aber das Flag "All_MinorIDs_valid" muss noch gesetzt sein.
      ErrorNo := DeleteMinorID(pMajorIDLoc^.pMinorID, MinorID);
      if ErrorNo = 0 then
        pMajorIDLoc^.MinorIDCnt -= 1;
        if pMajorIDLoc^.MinorIDCnt = 0 then
          pMajorIDLoc^.Flags.Listed_MinorIDs_invalid := 0;
        end_if;
      else
        //Wenn die MinorID nicht vorhanden ist, d.h. nicht ungültig ist, wird kein Fehler gemeldet.
        ErrorNo := 0;
      end_if;
    elsif pMajorIDLoc^.Flags.All_MinorIDs_valid then
      ErrorNo := 0;
    else
      //MinorID oder freien Platz im Puffer suchen.
      pMinorIDLoc := GetpMinorID(pMajorIDLoc^.pMinorID, MinorID);
      if pMinorIDLoc then
        if pMinorIDLoc^.pThis = nil then
          pMinorIDLoc^.MinorID := MinorID;
          pMinorIDLoc^.pThis   := pThis;
          
          pMajorIDLoc^.MinorIDCnt += 1;
        elsif pMinorIDLoc^.pThis <> pThis then
          //Die Kombination MajorID-MinorID ist schon vorhanden und pThis ist ungleich.
          //Wenn pThis gleich ist, wird das User Event ignoriert und kein Fehler gemeldet. 
          ErrorNo := ERR_USER_EVENT_EXISTS;
        end_if;
      else
        //MinorID nicht vorhanden und im Puffer für die MinorID ist kein Platz mehr frei.
        ErrorNo := ERR_USER_EVENT_FULL;
      end_if;
    end_if;
  else
    //MajorID nicht vorhanden und im Puffer für die MajorID ist kein Platz mehr frei.
    ErrorNo := ERR_USER_EVENT_FULL;
  end_if;

  SectionStop(); // *********************

END_FUNCTION


FUNCTION DSComm::DeleteUserEvent
	VAR_INPUT
		MajorID 	: UINT;
		MinorID 	: UINT;
		pThis 	: ^DSComm_Interface;
	END_VAR
	VAR_OUTPUT
		ErrorNo 	: DINT;
	END_VAR
  VAR
		pMajorIDLoc : ^DSComm::_DS_UsrEvntMajorID;
		pMinorIDLoc : ^DSComm::_DS_UsrEvntMinorID;
  END_VAR

  ErrorNo := 0;

  SectionStart(); // *********************
  pMajorIDLoc := GetpMajorID(pMajorID, MajorID);

  if pMajorIDLoc & pMajorIDLoc^.pMinorID <> nil then
    //MajorID vorhanden.
    if MinorID = DS_ALL_MINOR_IDs_VALID then
      //Alle MinorIDs löschen. Puffer freigeben.
      sigclib_free(pMajorIDLoc^.pMinorID);
      DeleteMajorID(pMajorID, MajorID);
      MajorIDCount -= 1;
    elsif pMajorIDLoc^.Flags.All_MinorIDs_valid then
      //Das Flag "All_MinorIDs_valid" besagt, dass alle MinorIDs gültig sind.
      //In den Puffer für die MinorIDs werden die ungültigen MinorIDs eingetragen.
      //MinorID oder freien Platz im Puffer suchen.
      pMinorIDLoc := GetpMinorID(pMajorIDLoc^.pMinorID, MinorID);
      if pMinorIDLoc & pMinorIDLoc^.pThis = nil then
        //Freien Platz gefunden.
        //Wenn die MinorID schon vorhanden ist (pThis <> nil), dann wird kein Fehler gemeldet.
        pMinorIDLoc^.MinorID := MinorID;
        pMinorIDLoc^.pThis   := pThis;
        
        pMajorIDLoc^.Flags.Listed_MinorIDs_invalid := 1;
        pMajorIDLoc^.MinorIDCnt += 1;
      elsif pMinorIDLoc = nil then
        //MinorID nicht vorhanden und im Puffer für die MinorID ist kein Platz mehr frei.
        ErrorNo := ERR_USER_EVENT_FULL;
      end_if;
    else
      ErrorNo := DeleteMinorID(pMajorIDLoc^.pMinorID, MinorID);
      if ErrorNo = 0 then
        pMajorIDLoc^.MinorIDCnt -= 1;
        if pMajorIDLoc^.MinorIDCnt = 0 then
          //Letzte MinorID gelöscht. Puffer freigeben.
          sigclib_free(pMajorIDLoc^.pMinorID);
          DeleteMajorID(pMajorID, MajorID);
          MajorIDCount -= 1;
        end_if;
      end_if;
    end_if;
  else
    //MajorID nicht vorhanden.
    ErrorNo := ERR_USER_EVENT_NOT_FOUND;
  end_if;

  SectionStop(); // *********************
  
END_FUNCTION


FUNCTION DSComm::DeleteMajorID
	VAR_INPUT
		pMajorIDIn 	: ^DSComm::_DS_UsrEvntMajorID;
		MajorID 	: UINT;
	END_VAR
	VAR_OUTPUT
		ErrorNo 	: DINT;
	END_VAR
  VAR
		pMajorIDLoc : ^DSComm::_DS_UsrEvntMajorID;
		pMajorIDLoc1: ^DSComm::_DS_UsrEvntMajorID;
  	index     : UDINT;
    MaxIndex  : UDINT;
    tmpI      : UDINT;
  END_VAR

  ErrorNo := 0;

  //index als Hash der MajorID mit Lücken der Größe DS_MAJOR_ID_DIST-1 dazwischen.
  //In diesen Lücken wird gespeichert, wenn es zu Kollisionen der Indices kommt.
  MaxIndex := DS_MAJOR_ID_ELMT_CNT / DS_MAJOR_ID_DIST;
  index := (MajorID mod MaxIndex) * DS_MAJOR_ID_DIST;
  
  pMajorIDLoc := pMajorIDIn + index * sizeof(DSComm::_DS_UsrEvntMajorID);
  
  MaxIndex := index + DS_MAJOR_ID_DIST - 1;

  if pMajorIDLoc^.MajorID <> MajorID then
    pMajorIDLoc += sizeof(DSComm::_DS_UsrEvntMajorID);

    for tmpI := index+1 to MaxIndex do
      if pMajorIDLoc^.MajorID = MajorID then
        exit;
      end_if;
      pMajorIDLoc += sizeof(DSComm::_DS_UsrEvntMajorID);
    end_for;
    if tmpI > MaxIndex then
      ErrorNo := ERR_USER_EVENT_NOT_FOUND;
      return;
    end_if;
  end_if;

  pMajorIDLoc^.MinorIDCnt := 0;
  pMajorIDLoc^.pMinorID   := nil;
  pMajorIDLoc^.Flags.All_MinorIDs_valid      := 0;
  pMajorIDLoc^.Flags.Listed_MinorIDs_invalid := 0;

  pMajorIDLoc1 := pMajorIDIn + MaxIndex * sizeof(DSComm::_DS_UsrEvntMajorID);

  //Beim Löschen der MajorID entsteht ev. eine Lücke.
  //Diese wird hier geschlossen.
  for tmpI := MaxIndex to index by -1 do
    if pMajorIDLoc1 = pMajorIDLoc then
      exit;
    elsif pMajorIDLoc1^.pMinorID <> nil then
      pMajorIDLoc^ := pMajorIDLoc1^;

      pMajorIDLoc1^.MinorIDCnt := 0;
      pMajorIDLoc1^.pMinorID   := nil;
      pMajorIDLoc1^.Flags.All_MinorIDs_valid      := 0;
      pMajorIDLoc1^.Flags.Listed_MinorIDs_invalid := 0;
      exit;
    end_if;
    pMajorIDLoc1 -= sizeof(DSComm::_DS_UsrEvntMajorID);
  end_for;

END_FUNCTION


FUNCTION DSComm::DeleteMinorID
	VAR_INPUT
		pMinorIDIn 	: ^DSComm::_DS_UsrEvntMinorID;
		MinorID 	: UINT;
	END_VAR
	VAR_OUTPUT
		ErrorNo 	: DINT;
	END_VAR
  VAR
		pMinorIDLoc : ^DSComm::_DS_UsrEvntMinorID;
		pMinorIDLoc1: ^DSComm::_DS_UsrEvntMinorID;
  	index     : UDINT;
    MaxIndex  : UDINT;
    tmpI      : UDINT;
  END_VAR

  ErrorNo := 0;

  //index als Hash der MinorID mit Lücken der Größe DS_MINOR_ID_DIST-1 dazwischen.
  //In diesen Lücken wird gespeichert, wenn es zu Kollisionen der Indices kommt.
  MaxIndex := DS_MINOR_ID_ELMT_CNT / DS_MINOR_ID_DIST;
  index := (MinorID mod MaxIndex) * DS_MINOR_ID_DIST;
  
  //Index 0 wird verwendet wenn alle MinorIDs einer MajorID gültig sind.
  index += 1;

  pMinorIDLoc := pMinorIDIn + index * sizeof(DSComm::_DS_UsrEvntMinorID);

  MaxIndex := index + DS_MINOR_ID_DIST - 1;

  if pMinorIDLoc^.MinorID <> MinorID then
    pMinorIDLoc += sizeof(DSComm::_DS_UsrEvntMinorID);

    for tmpI := index+1 to MaxIndex do
      if pMinorIDLoc^.MinorID = MinorID then
        exit;
      end_if;
      pMinorIDLoc += sizeof(DSComm::_DS_UsrEvntMinorID);
    end_for;
    if tmpI > MaxIndex then
      ErrorNo := ERR_USER_EVENT_NOT_FOUND;
      return;
    end_if;
  end_if;

  pMinorIDLoc^.pThis := nil;
  pMinorIDLoc1 := pMinorIDIn + MaxIndex * sizeof(DSComm::_DS_UsrEvntMinorID);

  //Beim Löschen der MinorID entsteht ev. eine Lücke.
  //Diese wird hier geschlossen.
  for tmpI := MaxIndex to index by -1 do
    if pMinorIDLoc1 = pMinorIDLoc then
      exit;
    elsif pMinorIDLoc1^.pThis <> nil then
      pMinorIDLoc^        := pMinorIDLoc1^;
      pMinorIDLoc1^.pThis := nil;
      exit;
    end_if;
    pMinorIDLoc1 -= sizeof(DSComm::_DS_UsrEvntMinorID);
  end_for;

END_FUNCTION


FUNCTION DSComm::TimeoutCheck
  VAR
		pJobElmt    : ^_DS_JobInfoElmt;
  	tmpI        : UDINT;
    max         : UDINT;
  END_VAR

  TimeNow := ops.tAbsolute;
  
  //Hängengebliebene Aufträge aus den Auftragsverwaltungen entfernen.
  case _Step of
    0:
    if CancelCommandJobs.Capacity <> CancelCommandJobs.Free then
      pJobElmt := CancelCommandJobs.pJobs;
      max      := CancelCommandJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.CancelCommandResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#CancelCommandJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeoutLong then
            pJobElmt^.pThis^.CancelCommandResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#CancelCommandJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if CancelCommandJobs.Capacity = CancelCommandJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 5;
    return;

    5:
    if GetVersionJobs.Capacity <> GetVersionJobs.Free then
      pJobElmt := GetVersionJobs.pJobs;
      max      := GetVersionJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.GetVersionResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#GetVersionJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.GetVersionResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#GetVersionJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if GetVersionJobs.Capacity = GetVersionJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;
    
    _Step := 15;
    return;

    15:
    if GetProjectInfoJobs.Capacity <> GetProjectInfoJobs.Free then
      pJobElmt := GetProjectInfoJobs.pJobs;
      max      := GetProjectInfoJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.GetProjectInfoResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#GetProjectInfoJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.GetProjectInfoResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#GetProjectInfoJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if GetProjectInfoJobs.Capacity = GetProjectInfoJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;
    
    _Step := 16;
    return;

    16:
    if SubscribeStateJobs.Capacity <> SubscribeStateJobs.Free then
      pJobElmt := SubscribeStateJobs.pJobs;
      max      := SubscribeStateJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.SubscribeStateResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#SubscribeStateJobs.Free);
            pJobElmt^.StartTime := 0;
            pThis_UpdateState := nil;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.SubscribeStateResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#SubscribeStateJobs.Free);
            pJobElmt^.StartTime := 0;
            pThis_UpdateState := nil;
          end_if;
        end_if;

        if SubscribeStateJobs.Capacity = SubscribeStateJobs.Free then
          exit;
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;

      end_for;
    end_if;

    _Step := 17;
    return;

    17:
    if UnsubscribeStateJobs.Capacity <> UnsubscribeStateJobs.Free then
      pJobElmt := UnsubscribeStateJobs.pJobs;
      max      := UnsubscribeStateJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.UnsubscribeStateResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#UnsubscribeStateJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.UnsubscribeStateResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#UnsubscribeStateJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if UnsubscribeStateJobs.Capacity = UnsubscribeStateJobs.Free then
          exit;
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;

      end_for;
    end_if;

    _Step := 18;
    return;

    18:
    if GetStateJobs.Capacity <> GetStateJobs.Free then
      pJobElmt := GetStateJobs.pJobs;
      max      := GetStateJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.Get_StateResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#GetStateJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.Get_StateResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#GetStateJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if GetStateJobs.Capacity = GetStateJobs.Free then
          exit;
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;

      end_for;
    end_if;

    _Step := 20;
    return;

    20:
    if LoopJobs.Capacity <> LoopJobs.Free then
      pJobElmt := LoopJobs.pJobs;
      max      := LoopJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.LoopResp(pJobElmt^.MessageID, pJobElmt^.Error, 0, nil, 0);
            sigclib_atomic_incU32(#LoopJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.LoopResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, 0, nil, 0);
            sigclib_atomic_incU32(#LoopJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if LoopJobs.Capacity = LoopJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 25;
    return;

    25:
    if RecipeLoadJobs.Capacity <> RecipeLoadJobs.Free then
      pJobElmt := RecipeLoadJobs.pJobs;
      max      := RecipeLoadJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.RecipeLoadResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#RecipeLoadJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeoutLong then
            pJobElmt^.pThis^.RecipeLoadResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#RecipeLoadJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if RecipeLoadJobs.Capacity = RecipeLoadJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 30;
    return;

    30:
    if RecipeSaveJobs.Capacity <> RecipeSaveJobs.Free then
      pJobElmt := RecipeSaveJobs.pJobs;
      max      := RecipeSaveJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.RecipeSaveResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#RecipeSaveJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeoutLong then
            pJobElmt^.pThis^.RecipeSaveResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#RecipeSaveJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if RecipeSaveJobs.Capacity = RecipeSaveJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 35;
    return;

    35:
    if SendToAllJobs.Capacity <> SendToAllJobs.Free then
      pJobElmt := SendToAllJobs.pJobs;
      max      := SendToAllJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.SendToAllResp(pJobElmt^.MessageID, pJobElmt^.Error);
            sigclib_atomic_incU32(#SendToAllJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.SendToAllResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT);
            sigclib_atomic_incU32(#SendToAllJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if SendToAllJobs.Capacity = SendToAllJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 40;
    return;

    40:
    if ResetDataserviceJobs.Capacity <> ResetDataserviceJobs.Free then
      pJobElmt := ResetDataserviceJobs.pJobs;
      max      := ResetDataserviceJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.ResetDataserviceResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#ResetDataserviceJobs.Free);
            pJobElmt^.StartTime := 0;
//        elsif pJobElmt^.StartTime & TimeNow - pJobElmt^.StartTime > RespTimeout then
          elsif TimeNow - pJobElmt^.StartTime > RespTimeoutLong then
            pJobElmt^.pThis^.ResetDataserviceResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#ResetDataserviceJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if ResetDataserviceJobs.Capacity = ResetDataserviceJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 41;
    return;

    41:
    if RestartDataserviceJobs.Capacity <> RestartDataserviceJobs.Free then
      pJobElmt := RestartDataserviceJobs.pJobs;
      max      := RestartDataserviceJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.RestartDataserviceResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#RestartDataserviceJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.RestartDataserviceResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#RestartDataserviceJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if RestartDataserviceJobs.Capacity = RestartDataserviceJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 42;
    return;

    42:
    if AddLocalClientJobs.Capacity <> AddLocalClientJobs.Free then
      pJobElmt := AddLocalClientJobs.pJobs;
      max      := AddLocalClientJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.AddLocalClientResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#AddLocalClientJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.AddLocalClientResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#AddLocalClientJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if AddLocalClientJobs.Capacity = AddLocalClientJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 43;
    return;

    43:
    if AddLocalClientRangeJobs.Capacity <> AddLocalClientRangeJobs.Free then
      pJobElmt := AddLocalClientRangeJobs.pJobs;
      max      := AddLocalClientRangeJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.AddLocalClientRangeResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#AddLocalClientRangeJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.AddLocalClientRangeResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#AddLocalClientRangeJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if AddLocalClientRangeJobs.Capacity = AddLocalClientRangeJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 44;
    return;

    44:
    if RemoveThisLocalClientJobs.Capacity <> RemoveThisLocalClientJobs.Free then
      pJobElmt := RemoveThisLocalClientJobs.pJobs;
      max      := RemoveThisLocalClientJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.RemoveThisLocalClientResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#RemoveThisLocalClientJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.RemoveThisLocalClientResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#RemoveThisLocalClientJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if RemoveThisLocalClientJobs.Capacity = RemoveThisLocalClientJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 45;
    return;

    45:
    if RemoveLocalClientJobs.Capacity <> RemoveLocalClientJobs.Free then
      pJobElmt := RemoveLocalClientJobs.pJobs;
      max      := RemoveLocalClientJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.RemoveLocalClientResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#RemoveLocalClientJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.RemoveLocalClientResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#RemoveLocalClientJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if RemoveLocalClientJobs.Capacity = RemoveLocalClientJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 46;
    return;

    46:
    if RemoveLocalClientRangeJobs.Capacity <> RemoveLocalClientRangeJobs.Free then
      pJobElmt := RemoveLocalClientRangeJobs.pJobs;
      max      := RemoveLocalClientRangeJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.RemoveLocalClientRangeResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#RemoveLocalClientRangeJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.RemoveLocalClientRangeResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#RemoveLocalClientRangeJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if RemoveLocalClientRangeJobs.Capacity = RemoveLocalClientRangeJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 47;
    return;

    47:
    if ClearLocalClientListJobs.Capacity <> ClearLocalClientListJobs.Free then
      pJobElmt := ClearLocalClientListJobs.pJobs;
      max      := ClearLocalClientListJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.ClearLocalClientListResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#ClearLocalClientListJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.ClearLocalClientListResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#ClearLocalClientListJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if ClearLocalClientListJobs.Capacity = ClearLocalClientListJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 48;
    return;

    48:
    if GetCurrentIDJobs.Capacity <> GetCurrentIDJobs.Free then
      pJobElmt := GetCurrentIDJobs.pJobs;
      max      := GetCurrentIDJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.GetCurrentIDResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#GetCurrentIDJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.GetCurrentIDResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#GetCurrentIDJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if GetCurrentIDJobs.Capacity = GetCurrentIDJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 49;
    return;

    49:
    if GetLocalClientListJobs.Capacity <> GetLocalClientListJobs.Free then
      pJobElmt := GetLocalClientListJobs.pJobs;
      max      := GetLocalClientListJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.GetLocalClientListResp(pJobElmt^.MessageID, pJobElmt^.Error, 0, nil);
            sigclib_atomic_incU32(#GetLocalClientListJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.GetLocalClientListResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, 0, nil);
            sigclib_atomic_incU32(#GetLocalClientListJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if GetLocalClientListJobs.Capacity = GetLocalClientListJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 50;
    return;

    50:
    if GetLocalClientListDetailsJobs.Capacity <> GetLocalClientListDetailsJobs.Free then
      pJobElmt := GetLocalClientListDetailsJobs.pJobs;
      max      := GetLocalClientListDetailsJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.GetLocalClientListDetailsResp(pJobElmt^.MessageID, pJobElmt^.Error, 0, nil);
            sigclib_atomic_incU32(#GetLocalClientListDetailsJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.GetLocalClientListDetailsResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, 0, nil);
            sigclib_atomic_incU32(#GetLocalClientListDetailsJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if GetLocalClientListDetailsJobs.Capacity = GetLocalClientListDetailsJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 51;
    return;

    51:
    if GetLocalClientByIDJobs.Capacity <> GetLocalClientByIDJobs.Free then
      pJobElmt := GetLocalClientByIDJobs.pJobs;
      max      := GetLocalClientByIDJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.GetLocalClientByIDResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#GetLocalClientByIDJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.GetLocalClientByIDResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#GetLocalClientByIDJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if GetLocalClientByIDJobs.Capacity = GetLocalClientByIDJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 54;
    return;

    54:
    if UserLoginJobs.Capacity <> UserLoginJobs.Free then
      pJobElmt := UserLoginJobs.pJobs;
      max      := UserLoginJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.UserLoginResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#UserLoginJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.UserLoginResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#UserLoginJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if UserLoginJobs.Capacity = UserLoginJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 55;
    return;

    55:
    if UserLogoutJobs.Capacity <> UserLogoutJobs.Free then
      pJobElmt := UserLogoutJobs.pJobs;
      max      := UserLogoutJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.UserLogoutResp(pJobElmt^.MessageID, pJobElmt^.Error);
            sigclib_atomic_incU32(#UserLogoutJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.UserLogoutResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT);
            sigclib_atomic_incU32(#UserLogoutJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if UserLogoutJobs.Capacity = UserLogoutJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 60;
    return;

    60:
    if UserPwdChangeJobs.Capacity <> UserPwdChangeJobs.Free then
      pJobElmt := UserPwdChangeJobs.pJobs;
      max      := UserPwdChangeJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.UserPasswordChangeResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#UserPwdChangeJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.UserPasswordChangeResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#UserPwdChangeJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if UserPwdChangeJobs.Capacity = UserPwdChangeJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 65;
    return;

    65:
    if CheckAccessLevelJobs.Capacity <> CheckAccessLevelJobs.Free then
      pJobElmt := CheckAccessLevelJobs.pJobs;
      max      := CheckAccessLevelJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.CheckAccessLevelResp(pJobElmt^.MessageID, pJobElmt^.Error, 0, nil);
            sigclib_atomic_incU32(#CheckAccessLevelJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.CheckAccessLevelResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, 0, nil);
            sigclib_atomic_incU32(#CheckAccessLevelJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if CheckAccessLevelJobs.Capacity = CheckAccessLevelJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 70;
    return;

    70:
    if CreateUserJobs.Capacity <> CreateUserJobs.Free then
      pJobElmt := CreateUserJobs.pJobs;
      max      := CreateUserJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.CreateUserResp(pJobElmt^.MessageID, pJobElmt^.Error, 0, nil);
            sigclib_atomic_incU32(#CreateUserJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.CreateUserResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, 0, nil);
            sigclib_atomic_incU32(#CreateUserJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if CreateUserJobs.Capacity = CreateUserJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 75;
    return;

    75:
    if ChangeUserSettingsJobs.Capacity <> ChangeUserSettingsJobs.Free then
      pJobElmt := ChangeUserSettingsJobs.pJobs;
      max      := ChangeUserSettingsJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.ChangeUserSettingsResp(pJobElmt^.MessageID, pJobElmt^.Error, 0, nil);
            sigclib_atomic_incU32(#ChangeUserSettingsJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.ChangeUserSettingsResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, 0, nil);
            sigclib_atomic_incU32(#ChangeUserSettingsJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if ChangeUserSettingsJobs.Capacity = ChangeUserSettingsJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 80;
    return;

    80:
    if DeleteUserJobs.Capacity <> DeleteUserJobs.Free then
      pJobElmt := DeleteUserJobs.pJobs;
      max      := DeleteUserJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.DeleteUserResp(pJobElmt^.MessageID, pJobElmt^.Error, 0, nil);
            sigclib_atomic_incU32(#DeleteUserJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.DeleteUserResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, 0, nil);
            sigclib_atomic_incU32(#DeleteUserJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if DeleteUserJobs.Capacity = DeleteUserJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 85;
    return;

    85:
    if GetUserListJobs.Capacity <> GetUserListJobs.Free then
      pJobElmt := GetUserListJobs.pJobs;
      max      := GetUserListJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.GetUserListResp(pJobElmt^.MessageID, pJobElmt^.Error, 0, nil);
            sigclib_atomic_incU32(#GetUserListJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.GetUserListResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, 0, nil);
            sigclib_atomic_incU32(#GetUserListJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if GetUserListJobs.Capacity = GetUserListJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 90;
    return;

    90:
    if GetUserDetailsJobs.Capacity <> GetUserDetailsJobs.Free then
      pJobElmt := GetUserDetailsJobs.pJobs;
      max      := GetUserDetailsJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.GetUserDetailsResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#GetUserDetailsJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.GetUserDetailsResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#GetUserDetailsJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if GetUserDetailsJobs.Capacity = GetUserDetailsJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 95;
    return;

    95:
    if CreateRoleJobs.Capacity <> CreateRoleJobs.Free then
      pJobElmt := CreateRoleJobs.pJobs;
      max      := CreateRoleJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.CreateRoleResp(pJobElmt^.MessageID, pJobElmt^.Error, 0, nil);
            sigclib_atomic_incU32(#CreateRoleJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.CreateRoleResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, 0, nil);
            sigclib_atomic_incU32(#CreateRoleJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if CreateRoleJobs.Capacity = CreateRoleJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 100;
    return;

    100:
    if ChangeRoleJobs.Capacity <> ChangeRoleJobs.Free then
      pJobElmt := ChangeRoleJobs.pJobs;
      max      := ChangeRoleJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.ChangeRoleResp(pJobElmt^.MessageID, pJobElmt^.Error, 0, nil);
            sigclib_atomic_incU32(#ChangeRoleJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.ChangeRoleResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, 0, nil);
            sigclib_atomic_incU32(#ChangeRoleJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if ChangeRoleJobs.Capacity = ChangeRoleJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 105;
    return;

    105:
    if DeleteRoleJobs.Capacity <> DeleteRoleJobs.Free then
      pJobElmt := DeleteRoleJobs.pJobs;
      max      := DeleteRoleJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.DeleteRoleResp(pJobElmt^.MessageID, pJobElmt^.Error, 0, nil);
            sigclib_atomic_incU32(#DeleteRoleJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.DeleteRoleResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, 0, nil);
            sigclib_atomic_incU32(#DeleteRoleJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if DeleteRoleJobs.Capacity = DeleteRoleJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 110;
    return;

    110:
    if GetRoleListJobs.Capacity <> GetRoleListJobs.Free then
      pJobElmt := GetRoleListJobs.pJobs;
      max      := GetRoleListJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.GetRoleListResp(pJobElmt^.MessageID, pJobElmt^.Error, 0, nil);
            sigclib_atomic_incU32(#GetRoleListJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.GetRoleListResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, 0, nil);
            sigclib_atomic_incU32(#GetRoleListJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if GetRoleListJobs.Capacity = GetRoleListJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 115;
    return;

    115:
    if GetRoleDetailsJobs.Capacity <> GetRoleDetailsJobs.Free then
      pJobElmt := GetRoleDetailsJobs.pJobs;
      max      := GetRoleDetailsJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.GetRoleDetailsResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#GetRoleDetailsJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.GetRoleDetailsResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#GetRoleDetailsJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if GetRoleDetailsJobs.Capacity = GetRoleDetailsJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 120;
    return;

    120:
    if GetVarIdFromNameJobs.Capacity <> GetVarIdFromNameJobs.Free then
      pJobElmt := GetVarIdFromNameJobs.pJobs;
      max      := GetVarIdFromNameJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.GetVarIdFromNameResp(pJobElmt^.MessageID, pJobElmt^.Error, 0, nil);
            sigclib_atomic_incU32(#GetVarIdFromNameJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.GetVarIdFromNameResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, 0, nil);
            sigclib_atomic_incU32(#GetVarIdFromNameJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if GetVarIdFromNameJobs.Capacity = GetVarIdFromNameJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 125;
    return;

    125:
    if GetVarIdFromLasalIdJobs.Capacity <> GetVarIdFromLasalIdJobs.Free then
      pJobElmt := GetVarIdFromLasalIdJobs.pJobs;
      max      := GetVarIdFromLasalIdJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.GetVarIdFromLasalIdResp(pJobElmt^.MessageID, pJobElmt^.Error, 0, nil);
            sigclib_atomic_incU32(#GetVarIdFromLasalIdJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.GetVarIdFromLasalIdResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, 0, nil);
            sigclib_atomic_incU32(#GetVarIdFromLasalIdJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if GetVarIdFromLasalIdJobs.Capacity = GetVarIdFromLasalIdJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 130;
    return;

    130:
    if GetLasalIdFromNameJobs.Capacity <> GetLasalIdFromNameJobs.Free then
      pJobElmt := GetLasalIdFromNameJobs.pJobs;
      max      := GetLasalIdFromNameJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.GetLasalIdFromNameResp(pJobElmt^.MessageID, pJobElmt^.Error, 0, nil);
            sigclib_atomic_incU32(#GetLasalIdFromNameJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.GetLasalIdFromNameResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, 0, nil);
            sigclib_atomic_incU32(#GetLasalIdFromNameJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if GetLasalIdFromNameJobs.Capacity = GetLasalIdFromNameJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 135;
    return;

    135:
    if GetLasalIdFromVarIdJobs.Capacity <> GetLasalIdFromVarIdJobs.Free then
      pJobElmt := GetLasalIdFromVarIdJobs.pJobs;
      max      := GetLasalIdFromVarIdJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.GetLasalIdFromVarIdResp(pJobElmt^.MessageID, pJobElmt^.Error, 0, nil);
            sigclib_atomic_incU32(#GetLasalIdFromVarIdJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.GetLasalIdFromVarIdResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, 0, nil);
            sigclib_atomic_incU32(#GetLasalIdFromVarIdJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if GetLasalIdFromVarIdJobs.Capacity = GetLasalIdFromVarIdJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 140;
    return;

    140:
    if GetNameFromVarIdJobs.Capacity <> GetNameFromVarIdJobs.Free then
      pJobElmt := GetNameFromVarIdJobs.pJobs;
      max      := GetNameFromVarIdJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.GetNameFromVarIdResp(pJobElmt^.MessageID, pJobElmt^.Error, 0, nil);
            sigclib_atomic_incU32(#GetNameFromVarIdJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.GetNameFromVarIdResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, 0, nil);
            sigclib_atomic_incU32(#GetNameFromVarIdJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if GetNameFromVarIdJobs.Capacity = GetNameFromVarIdJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 145;
    return;

    145:
    if GetNameFromLasalIdJobs.Capacity <> GetNameFromLasalIdJobs.Free then
      pJobElmt := GetNameFromLasalIdJobs.pJobs;
      max      := GetNameFromLasalIdJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.GetNameFromLasalIdResp(pJobElmt^.MessageID, pJobElmt^.Error, 0, nil);
            sigclib_atomic_incU32(#GetNameFromLasalIdJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.GetNameFromLasalIdResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, 0, nil);
            sigclib_atomic_incU32(#GetNameFromLasalIdJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if GetNameFromLasalIdJobs.Capacity = GetNameFromLasalIdJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 150;
    return;

    150:
    if GetDpListJobs.Capacity <> GetDpListJobs.Free then
      pJobElmt := GetDpListJobs.pJobs;
      max      := GetDpListJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.GetDpListResp(pJobElmt^.MessageID, pJobElmt^.Error, 0, 0, FALSE, nil);
            sigclib_atomic_incU32(#GetDpListJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.GetDpListResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, 0, 0, FALSE, nil);
            sigclib_atomic_incU32(#GetDpListJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if GetDpListJobs.Capacity = GetDpListJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 155;
    return;

    155:
    if GetDpInfoJobs.Capacity <> GetDpInfoJobs.Free then
      pJobElmt := GetDpInfoJobs.pJobs;
      max      := GetDpInfoJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.GetDpInfoResp(pJobElmt^.MessageID, pJobElmt^.Error, 0, nil);
            sigclib_atomic_incU32(#GetDpInfoJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.GetDpInfoResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, 0, nil);
            sigclib_atomic_incU32(#GetDpInfoJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if GetDpInfoJobs.Capacity = GetDpInfoJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 160;
    return;

    160:
    if GetVarIdFromCRCJobs.Capacity <> GetVarIdFromCRCJobs.Free then
      pJobElmt := GetVarIdFromCRCJobs.pJobs;
      max      := GetVarIdFromCRCJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.GetVarIdFromCRCResp(pJobElmt^.MessageID, pJobElmt^.Error, 0, nil);
            sigclib_atomic_incU32(#GetVarIdFromCRCJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.GetVarIdFromCRCResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, 0, nil);
            sigclib_atomic_incU32(#GetVarIdFromCRCJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if GetVarIdFromCRCJobs.Capacity = GetVarIdFromCRCJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 165;
    return;

    165:
    if GetCRCfromVarIdJobs.Capacity <> GetCRCfromVarIdJobs.Free then
      pJobElmt := GetCRCfromVarIdJobs.pJobs;
      max      := GetCRCfromVarIdJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.GetCRCfromVarIdResp(pJobElmt^.MessageID, pJobElmt^.Error, 0, nil);
            sigclib_atomic_incU32(#GetCRCfromVarIdJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.GetCRCfromVarIdResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, 0, nil);
            sigclib_atomic_incU32(#GetCRCfromVarIdJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if GetCRCfromVarIdJobs.Capacity = GetCRCfromVarIdJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 170;
    return;

    170:
    if GetValueJobs.Capacity <> GetValueJobs.Free then
      pJobElmt := GetValueJobs.pJobs;
      max      := GetValueJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.GetValueResp(pJobElmt^.MessageID, pJobElmt^.Error, 0, nil);
            sigclib_atomic_incU32(#GetValueJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeoutLong then
            pJobElmt^.pThis^.GetValueResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, 0, nil);
            sigclib_atomic_incU32(#GetValueJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if GetValueJobs.Capacity = GetValueJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 175;
    return;

    175:
    if GetStringJobs.Capacity <> GetStringJobs.Free then
      pJobElmt := GetStringJobs.pJobs;
      max      := GetStringJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.GetStringResp(pJobElmt^.MessageID, pJobElmt^.Error, 0, nil);
            sigclib_atomic_incU32(#GetStringJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeoutLong then
            pJobElmt^.pThis^.GetStringResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, 0, nil);
            sigclib_atomic_incU32(#GetStringJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if GetStringJobs.Capacity = GetStringJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 180;
    return;

    180:
    if SetValueJobs.Capacity <> SetValueJobs.Free then
      pJobElmt := SetValueJobs.pJobs;
      max      := SetValueJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.SetValueResp(pJobElmt^.MessageID, pJobElmt^.Error, 0, nil);
            sigclib_atomic_incU32(#SetValueJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeoutLong then
            pJobElmt^.pThis^.SetValueResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, 0, nil);
            sigclib_atomic_incU32(#SetValueJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if SetValueJobs.Capacity = SetValueJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 185;
    return;

    185:
    if SetStringJobs.Capacity <> SetStringJobs.Free then
      pJobElmt := SetStringJobs.pJobs;
      max      := SetStringJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.SetStringResp(pJobElmt^.MessageID, pJobElmt^.Error, 0, nil);
            sigclib_atomic_incU32(#SetStringJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeoutLong then
            pJobElmt^.pThis^.SetStringResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, 0, nil);
            sigclib_atomic_incU32(#SetStringJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if SetStringJobs.Capacity = SetStringJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 190;
    return;

    190:
    if IncValueJobs.Capacity <> IncValueJobs.Free then
      pJobElmt := IncValueJobs.pJobs;
      max      := IncValueJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.IncValueResp(pJobElmt^.MessageID, pJobElmt^.Error, 0, nil);
            sigclib_atomic_incU32(#IncValueJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeoutLong then
            pJobElmt^.pThis^.IncValueResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, 0, nil);
            sigclib_atomic_incU32(#IncValueJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if IncValueJobs.Capacity = IncValueJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 195;
    return;

    195:
    if DecValueJobs.Capacity <> DecValueJobs.Free then
      pJobElmt := DecValueJobs.pJobs;
      max      := DecValueJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.DecValueResp(pJobElmt^.MessageID, pJobElmt^.Error, 0, nil);
            sigclib_atomic_incU32(#DecValueJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeoutLong then
            pJobElmt^.pThis^.DecValueResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, 0, nil);
            sigclib_atomic_incU32(#DecValueJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if DecValueJobs.Capacity = DecValueJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 200;
    return;

    200:
    if RefListAddJobs.Capacity <> RefListAddJobs.Free then
      pJobElmt := RefListAddJobs.pJobs;
      max      := RefListAddJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.RefListAddResp(pJobElmt^.MessageID, pJobElmt^.Error, 0, 0, nil);
            sigclib_atomic_incU32(#RefListAddJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeoutLong then
            pJobElmt^.pThis^.RefListAddResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, 0, 0, nil);
            sigclib_atomic_incU32(#RefListAddJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if RefListAddJobs.Capacity = RefListAddJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 205;
    return;

    205:
    if RefListSubJobs.Capacity <> RefListSubJobs.Free then
      pJobElmt := RefListSubJobs.pJobs;
      max      := RefListSubJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.RefListSubResp(pJobElmt^.MessageID, pJobElmt^.Error, 0, 0, nil);
            sigclib_atomic_incU32(#RefListSubJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeoutLong then
            pJobElmt^.pThis^.RefListSubResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, 0, 0, nil);
            sigclib_atomic_incU32(#RefListSubJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if RefListSubJobs.Capacity = RefListSubJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 210;
    return;

    210:
    if GetStationListJobs.Capacity <> GetStationListJobs.Free then
      pJobElmt := GetStationListJobs.pJobs;
      max      := GetStationListJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.GetStationListResp(pJobElmt^.MessageID, pJobElmt^.Error, 0, nil);
            sigclib_atomic_incU32(#GetStationListJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.GetStationListResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, 0, nil);
            sigclib_atomic_incU32(#GetStationListJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if GetStationListJobs.Capacity = GetStationListJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 215;
    return;

    215:
    if GetStationStatusJobs.Capacity <> GetStationStatusJobs.Free then
      pJobElmt := GetStationStatusJobs.pJobs;
      max      := GetStationStatusJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.GetStationStatusResp(pJobElmt^.MessageID, pJobElmt^.Error, 0, nil);
            sigclib_atomic_incU32(#GetStationStatusJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.GetStationStatusResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, 0, nil);
            sigclib_atomic_incU32(#GetStationStatusJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if GetStationStatusJobs.Capacity = GetStationStatusJobs.Free then
          exit;    
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 220;
    return;

    220:
    if FileOpenJobs.Capacity <> FileOpenJobs.Free then
      pJobElmt := FileOpenJobs.pJobs;
      max      := FileOpenJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.FileOpenResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#FileOpenJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.FileOpenResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#FileOpenJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if FileOpenJobs.Capacity = FileOpenJobs.Free then
          exit;      
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 225;
    return;

    225:
    if FileCloseJobs.Capacity <> FileCloseJobs.Free then
      pJobElmt := FileCloseJobs.pJobs;
      max      := FileCloseJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.FileCloseResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#FileCloseJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.FileCloseResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#FileCloseJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if FileCloseJobs.Capacity = FileCloseJobs.Free then
          exit;      
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 230;
    return;

    230:
    if FileSeekJobs.Capacity <> FileSeekJobs.Free then
      pJobElmt := FileSeekJobs.pJobs;
      max      := FileSeekJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.FileSeekResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#FileSeekJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.FileSeekResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#FileSeekJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if FileSeekJobs.Capacity = FileSeekJobs.Free then
          exit;      
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 235;
    return;

    235:
    if FileTellJobs.Capacity <> FileTellJobs.Free then
      pJobElmt := FileTellJobs.pJobs;
      max      := FileTellJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.FileTellResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#FileTellJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.FileTellResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#FileTellJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if FileTellJobs.Capacity = FileTellJobs.Free then
          exit;      
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 240;
    return;

    240:
    if FileReadJobs.Capacity <> FileReadJobs.Free then
      pJobElmt := FileReadJobs.pJobs;
      max      := FileReadJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.FileReadResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#FileReadJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.FileReadResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#FileReadJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if FileReadJobs.Capacity = FileReadJobs.Free then
          exit;      
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 245;
    return;

    245:
    if FileWriteJobs.Capacity <> FileWriteJobs.Free then
      pJobElmt := FileWriteJobs.pJobs;
      max      := FileWriteJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.FileWriteResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#FileWriteJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.FileWriteResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#FileWriteJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if FileWriteJobs.Capacity = FileWriteJobs.Free then
          exit;      
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 250;
    return;

    250:
    if FileGetJobs.Capacity <> FileGetJobs.Free then
      pJobElmt := FileGetJobs.pJobs;
      max      := FileGetJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.FileGetResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#FileGetJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.FileGetResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#FileGetJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if FileGetJobs.Capacity = FileGetJobs.Free then
          exit;      
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 255;
    return;

    255:
    if FilePutJobs.Capacity <> FilePutJobs.Free then
      pJobElmt := FilePutJobs.pJobs;
      max      := FilePutJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.FilePutResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#FilePutJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.FilePutResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#FilePutJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if FilePutJobs.Capacity = FilePutJobs.Free then
          exit;      
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 260;
    return;

    260:
    if FileLengthJobs.Capacity <> FileLengthJobs.Free then
      pJobElmt := FileLengthJobs.pJobs;
      max      := FileLengthJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.FileLengthResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#FileLengthJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.FileLengthResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#FileLengthJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if FileLengthJobs.Capacity = FileLengthJobs.Free then
          exit;      
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 265;
    return;

    265:
    if FileContentJobs.Capacity <> FileContentJobs.Free then
      pJobElmt := FileContentJobs.pJobs;
      max      := FileContentJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.FileContentResp(pJobElmt^.MessageID, pJobElmt^.Error, FALSE, nil);
            sigclib_atomic_incU32(#FileContentJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout*4 then
//        if pJobElmt^.StartTime & TimeNow - pJobElmt^.StartTime > RespTimeoutLong then   //===TEST===
            pJobElmt^.pThis^.FileContentResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, FALSE, nil);
            sigclib_atomic_incU32(#FileContentJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if FileContentJobs.Capacity = FileContentJobs.Free then
          exit;      
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 270;
    return;

    270:
    if DirCreateJobs.Capacity <> DirCreateJobs.Free then
      pJobElmt := DirCreateJobs.pJobs;
      max      := DirCreateJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.DirCreateResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#DirCreateJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.DirCreateResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#DirCreateJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if DirCreateJobs.Capacity = DirCreateJobs.Free then
          exit;      
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 275;
    return;

    275:
    if DirReadJobs.Capacity <> DirReadJobs.Free then
      pJobElmt := DirReadJobs.pJobs;
      max      := DirReadJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.DirReadResp(pJobElmt^.MessageID, pJobElmt^.Error, 0, 0, FALSE, nil);
            sigclib_atomic_incU32(#DirReadJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.DirReadResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, 0, 0, FALSE, nil);
            sigclib_atomic_incU32(#DirReadJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if DirReadJobs.Capacity = DirReadJobs.Free then
          exit;      
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 280;
    return;

    280:
    if FileRemoveJobs.Capacity <> FileRemoveJobs.Free then
      pJobElmt := FileRemoveJobs.pJobs;
      max      := FileRemoveJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.FileRemoveResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#FileRemoveJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.FileRemoveResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#FileRemoveJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if FileRemoveJobs.Capacity = FileRemoveJobs.Free then
          exit;      
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 285;
    return;

    285:
    if FileCopyJobs.Capacity <> FileCopyJobs.Free then
      pJobElmt := FileCopyJobs.pJobs;
      max      := FileCopyJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.FileCopyResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#FileCopyJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeoutLong then
            pJobElmt^.pThis^.FileCopyResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#FileCopyJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if FileCopyJobs.Capacity = FileCopyJobs.Free then
          exit;      
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 290;
    return;

    290:
    if FileInfoJobs.Capacity <> FileInfoJobs.Free then
      pJobElmt := FileInfoJobs.pJobs;
      max      := FileInfoJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.FileInfoResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#FileInfoJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.FileInfoResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#FileInfoJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if FileInfoJobs.Capacity = FileInfoJobs.Free then
          exit;      
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 295;
    return;

    295:
    if FileRenameJobs.Capacity <> FileRenameJobs.Free then
      pJobElmt := FileRenameJobs.pJobs;
      max      := FileRenameJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.FileRenameResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#FileRenameJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.FileRenameResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#FileRenameJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if FileRenameJobs.Capacity = FileRenameJobs.Free then
          exit;      
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 300;
    return;

    300:
    if FileSetAttributeJobs.Capacity <> FileSetAttributeJobs.Free then
      pJobElmt := FileSetAttributeJobs.pJobs;
      max      := FileSetAttributeJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.FileSetAttributeResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#FileSetAttributeJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.FileSetAttributeResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#FileSetAttributeJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if FileSetAttributeJobs.Capacity = FileSetAttributeJobs.Free then
          exit;      
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 305;
    return;

    305:
    if GetDriveListJobs.Capacity <> GetDriveListJobs.Free then
      pJobElmt := GetDriveListJobs.pJobs;
      max      := GetDriveListJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.GetDriveListResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#GetDriveListJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.GetDriveListResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#GetDriveListJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if GetDriveListJobs.Capacity = GetDriveListJobs.Free then
          exit;      
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 310;
    return;

    310:
    if FileMoveJobs.Capacity <> FileMoveJobs.Free then
      pJobElmt := FileMoveJobs.pJobs;
      max      := FileMoveJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.FileMoveResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#FileMoveJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeoutLong then
            pJobElmt^.pThis^.FileMoveResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#FileMoveJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if FileMoveJobs.Capacity = FileMoveJobs.Free then
          exit;        
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 315;
    return;

    315:
    if SendUserEventJobs.Capacity <> SendUserEventJobs.Free then
      pJobElmt := SendUserEventJobs.pJobs;
      max      := SendUserEventJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.SendUserEventResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#SendUserEventJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.SendUserEventResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#SendUserEventJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if SendUserEventJobs.Capacity = SendUserEventJobs.Free then
          exit;
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 320;
    return;



    320:
    if EventjournalAddJobs.Capacity <> EventjournalAddJobs.Free then
      pJobElmt := EventjournalAddJobs.pJobs;
      max      := EventjournalAddJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.EventjournalAddResp(pJobElmt^.MessageID, pJobElmt^.Error, 0, nil);
            sigclib_atomic_incU32(#EventjournalAddJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.EventjournalAddResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, 0, nil);
            sigclib_atomic_incU32(#EventjournalAddJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if EventjournalAddJobs.Capacity = EventjournalAddJobs.Free then
          exit;        
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 325;
    return;

    325:
    if EventjournalGetJobs.Capacity <> EventjournalGetJobs.Free then
      pJobElmt := EventjournalGetJobs.pJobs;
      max      := EventjournalGetJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.EventjournalGetResp(pJobElmt^.MessageID, pJobElmt^.Error, 0, nil);
            sigclib_atomic_incU32(#EventjournalGetJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.EventjournalGetResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, 0, nil);
            sigclib_atomic_incU32(#EventjournalGetJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if EventjournalGetJobs.Capacity = EventjournalGetJobs.Free then
          exit;        
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 330;
    return;

    330:
    if EventjournalGetAllJobs.Capacity <> EventjournalGetAllJobs.Free then
      pJobElmt := EventjournalGetAllJobs.pJobs;
      max      := EventjournalGetAllJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.EventjournalGetAllResp(pJobElmt^.MessageID, pJobElmt^.Error, 0, FALSE, nil);
            sigclib_atomic_incU32(#EventjournalGetAllJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.EventjournalGetAllResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, 0, FALSE, nil);
            sigclib_atomic_incU32(#EventjournalGetAllJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if EventjournalGetAllJobs.Capacity = EventjournalGetAllJobs.Free then
          exit;        
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 335;
    return;

    335:
    if EventjournalDelJobs.Capacity <> EventjournalDelJobs.Free then
      pJobElmt := EventjournalDelJobs.pJobs;
      max      := EventjournalDelJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.EventjournalDelResp(pJobElmt^.MessageID, pJobElmt^.Error, 0, nil);
            sigclib_atomic_incU32(#EventjournalDelJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.EventjournalDelResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, 0, nil);
            sigclib_atomic_incU32(#EventjournalDelJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if EventjournalDelJobs.Capacity = EventjournalDelJobs.Free then
          exit;        
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 340;
    return;

    340:
    if EventjournalDelAllJobs.Capacity <> EventjournalDelAllJobs.Free then
      pJobElmt := EventjournalDelAllJobs.pJobs;
      max      := EventjournalDelAllJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.EventjournalDelAllResp(pJobElmt^.MessageID, pJobElmt^.Error, 0, nil);
            sigclib_atomic_incU32(#EventjournalDelAllJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.EventjournalDelAllResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, 0, nil);
            sigclib_atomic_incU32(#EventjournalDelAllJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if EventjournalDelAllJobs.Capacity = EventjournalDelAllJobs.Free then
          exit;        
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 345;
    return;

    345:
    if EventjournalQuitAlarmJobs.Capacity <> EventjournalQuitAlarmJobs.Free then
      pJobElmt := EventjournalQuitAlarmJobs.pJobs;
      max      := EventjournalQuitAlarmJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.EventjournalQuitAlarmResp(pJobElmt^.MessageID, pJobElmt^.Error, 0, nil);
            sigclib_atomic_incU32(#EventjournalQuitAlarmJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.EventjournalQuitAlarmResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, 0, nil);
            sigclib_atomic_incU32(#EventjournalQuitAlarmJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if EventjournalQuitAlarmJobs.Capacity = EventjournalQuitAlarmJobs.Free then
          exit;        
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 350;
    return;

    350:
    if EventjournalQuitAllJobs.Capacity <> EventjournalQuitAllJobs.Free then
      pJobElmt := EventjournalQuitAllJobs.pJobs;
      max      := EventjournalQuitAllJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.EventjournalQuitAllResp(pJobElmt^.MessageID, pJobElmt^.Error, 0, nil);
            sigclib_atomic_incU32(#EventjournalQuitAllJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.EventjournalQuitAllResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, 0, nil);
            sigclib_atomic_incU32(#EventjournalQuitAllJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if EventjournalQuitAllJobs.Capacity = EventjournalQuitAllJobs.Free then
          exit;        
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 355;
    return;

    355:
    if AlarmListUpdateAddJobs.Capacity <> AlarmListUpdateAddJobs.Free then
      pJobElmt := AlarmListUpdateAddJobs.pJobs;
      max      := AlarmListUpdateAddJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.SubscribeAlarmListUpdateResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#AlarmListUpdateAddJobs.Free);
            pJobElmt^.StartTime := 0;
            pThis_AlarmListUpdate := nil;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.SubscribeAlarmListUpdateResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#AlarmListUpdateAddJobs.Free);
            pJobElmt^.StartTime := 0;
            pThis_AlarmListUpdate := nil;
          end_if;
        end_if;

        if AlarmListUpdateAddJobs.Capacity = AlarmListUpdateAddJobs.Free then
          exit;        
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 360;
    return;

    360:
    if AlarmListUpdateSubJobs.Capacity <> AlarmListUpdateSubJobs.Free then
      pJobElmt := AlarmListUpdateSubJobs.pJobs;
      max      := AlarmListUpdateSubJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.UnsubscribeAlarmListUpdateResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#AlarmListUpdateSubJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.UnsubscribeAlarmListUpdateResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#AlarmListUpdateSubJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if AlarmListUpdateSubJobs.Capacity = AlarmListUpdateSubJobs.Free then
          exit;        
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 365;
    return;

    365:
    if HotAlarmUpdateAddJobs.Capacity <> HotAlarmUpdateAddJobs.Free then
      pJobElmt := HotAlarmUpdateAddJobs.pJobs;
      max      := HotAlarmUpdateAddJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.SubscribeHotAlarmUpdateResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#HotAlarmUpdateAddJobs.Free);
            pJobElmt^.StartTime := 0;
            pThis_HotAlarmUpdate := nil;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.SubscribeHotAlarmUpdateResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#HotAlarmUpdateAddJobs.Free);
            pJobElmt^.StartTime := 0;
            pThis_HotAlarmUpdate := nil;
          end_if;
        end_if;

        if HotAlarmUpdateAddJobs.Capacity = HotAlarmUpdateAddJobs.Free then
          exit;        
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 370;
    return;

    370:
    if HotAlarmUpdateSubJobs.Capacity <> HotAlarmUpdateSubJobs.Free then
      pJobElmt := HotAlarmUpdateSubJobs.pJobs;
      max      := HotAlarmUpdateSubJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.UnsubscribeHotAlarmUpdateResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#HotAlarmUpdateSubJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.UnsubscribeHotAlarmUpdateResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#HotAlarmUpdateSubJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if HotAlarmUpdateSubJobs.Capacity = HotAlarmUpdateSubJobs.Free then
          exit;        
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 375;
    return;

    375:
    if AlarmDeleteJobs.Capacity <> AlarmDeleteJobs.Free then
      pJobElmt := AlarmDeleteJobs.pJobs;
      max      := AlarmDeleteJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.AlarmDeleteResp(pJobElmt^.MessageID, pJobElmt^.Error, 0, nil);
            sigclib_atomic_incU32(#AlarmDeleteJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.AlarmDeleteResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, 0, nil);
            sigclib_atomic_incU32(#AlarmDeleteJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if AlarmDeleteJobs.Capacity = AlarmDeleteJobs.Free then
          exit;        
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 380;
    return;

    380:
    if AlarmDeleteAllJobs.Capacity <> AlarmDeleteAllJobs.Free then
      pJobElmt := AlarmDeleteAllJobs.pJobs;
      max      := AlarmDeleteAllJobs.Capacity - 1;

      for tmpI:=0 to max do
        if pJobElmt^.StartTime then
          if pJobElmt^.Error then
            pJobElmt^.pThis^.AlarmDeleteAllResp(pJobElmt^.MessageID, pJobElmt^.Error, nil);
            sigclib_atomic_incU32(#AlarmDeleteAllJobs.Free);
            pJobElmt^.StartTime := 0;
          elsif TimeNow - pJobElmt^.StartTime > RespTimeout then
            pJobElmt^.pThis^.AlarmDeleteAllResp(pJobElmt^.MessageID, ERR_JOB_TIMEOUT, nil);
            sigclib_atomic_incU32(#AlarmDeleteAllJobs.Free);
            pJobElmt^.StartTime := 0;
          end_if;
        end_if;

        if AlarmDeleteAllJobs.Capacity = AlarmDeleteAllJobs.Free then
          exit;        
        else
          pJobElmt += sizeof(_DS_JobInfoElmt);
        end_if;
      end_for;
    end_if;

    _Step := 0;
    return;

  end_case;

END_FUNCTION


FUNCTION GLOBAL DSComm::GetStationList
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^char;
  	pHeader     : ^_DS_Header;
    pJobElmt    : ^_DS_JobInfoElmt;
    RetVal      : DINT;
  END_VAR

  if pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#GetStationListJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=GetStationList_BUFFER_SIZE, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      //*--- Header für Get Station List aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := GetStationList_BUFFER_SIZE;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := GetStationListCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#GetStationListJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION

FUNCTION DSComm::GetRespData_StationList
	VAR_INPUT
		pData 	: ^CHAR;
		pStationListRsp 	: ^_DS_StationListResp;
		num 	: UDINT;
	END_VAR
  VAR
    max         : UDINT;
    tmpI        : UDINT;
  END_VAR

  max := num - 1;
  for tmpI:=0 to max do
    pData += sizeof(UDINT);           //size überspringen

    pStationListRsp^ := (pData$^_DS_StationListResp)^;
    pData += sizeof(pStationListRsp^);

    pStationListRsp += sizeof(_DS_StationListResp);
  end_for;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL DSComm::Taskname::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR

	Taskname := ThreadName.Data.Read();
	output := Taskname;

END_FUNCTION


FUNCTION GLOBAL DSComm::SendUserEvent
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		MajorID 	: UINT;
		MinorID 	: UINT;
		SessionID 	: UINT;
		pDataSrc 	: pVoid;
		DataLen 	: UDINT;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^void;
  	pHeader     : ^_DS_Header;
    pData       : ^CHAR;
    pJobElmt    : ^_DS_JobInfoElmt;
    SendBuffSize: UDINT;
    RetVal      : DINT;
  END_VAR

  if (DataLen & pDataSrc = nil) | pThis = nil | MajorID >= MAJOR_ID_SYSTEM_LOW then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#SendUserEventJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    SendBuffSize := sizeof(_DS_Header) + DataLen;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest
      _memcpy(ptr1:=pData, ptr2:=pDataSrc, cntr:=DataLen);
    
  	  //*--- Header für Send User Event aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
	    pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := MajorID;
      pheader^.MinorID        := MinorID;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= SessionID;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#SendUserEventJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::SubscribeEventjournalUpdates
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
	END_VAR

  pThis_EventJournalUpdate := pThis;

END_FUNCTION


FUNCTION GLOBAL DSComm::UnsubscribeEventjournalUpdates

  pThis_EventJournalUpdate := nil;

END_FUNCTION


FUNCTION GLOBAL DSComm::SubscribeUserEvents
	VAR_INPUT
		MajorID 	: UINT;
		MinorID 	: UINT;
		pThis 	: ^DSComm_Interface;
	END_VAR
	VAR_OUTPUT
		ErrorNo 	: DINT;
	END_VAR

  if MajorID >= MAJOR_ID_SYSTEM_LOW then
    ErrorNo := ERR_WRONG_PARAMETER; //Parameterfehler
  else
    ErrorNo := StoreUserEvent(MajorID, MinorID, pThis);
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::UnsubscribeUserEvents
	VAR_INPUT
		MajorID 	: UINT;
		MinorID 	: UINT;
		pThis 	: ^DSComm_Interface;
	END_VAR
	VAR_OUTPUT
		ErrorNo 	: DINT;
	END_VAR

  if MajorID >= MAJOR_ID_SYSTEM_LOW then
    ErrorNo := ERR_WRONG_PARAMETER; //Parameterfehler
  else
    ErrorNo := DeleteUserEvent(MajorID, MinorID, pThis);
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::StartTCPComm

  if eComSteps = TCPCom_DoNothing then
    StartConnectTime := 0;
    ClassState   := 0;
    ErrorSend    := 0;
    ErrorReceive := 0;
    eComSteps    := TCPCom_StartConnecting;
  end_if;

END_FUNCTION

FUNCTION DSComm::BufferCreate
	VAR_INPUT
		statbuff 	: pVoid;
		statbuff_size 	: UDINT;
		expected_size 	: UDINT;
    MemMark         : USINT;
	END_VAR
	VAR_OUTPUT
		RetPtr 	: pVoid;
	END_VAR
  //                                                                              Sicherheitspuffer
  expected_size := expected_size + sizeof(_DS_Header) + sizeof(_DS_FragmentHeader) + 1024;

  if expected_size > statbuff_size then
    RetPtr := sigclib_mallocV1(expected_size, MemMark);
  else  
    RetPtr := statbuff;
  end_if;

  if RetPtr then
    RetPtr := RetPtr + sizeof(_DS_Header) + sizeof(_DS_FragmentHeader); //dest ist hinter den Headern
  end_if;
END_FUNCTION


FUNCTION DSComm::BufferDestroy
	VAR_INPUT
    statbuff  : pVoid;
    buffer    : pVoid;
	END_VAR

  if buffer then
    buffer := buffer - sizeof(_DS_Header) - sizeof(_DS_FragmentHeader);
  end_if;

  if buffer <> statbuff then
    if buffer <> nil then
      sigclib_free(buffer);
    end_if;
  end_if;
END_FUNCTION


FUNCTION DSComm::SectionStart
  VAR
    mutexname : array[0..32] of char;
  END_VAR

  if(MuxHdl = 0) then
    sigclib_mutex_name(#mutexname[0], "DSComm", this);
    MuxHdl := sigclib_mutex_create(#mutexname[0]);
  end_if;
  
  sigclib_mutex_section_start(MuxHdl);
END_FUNCTION

FUNCTION DSComm::SectionStop

  sigclib_mutex_section_stop(MuxHdl);

END_FUNCTION


FUNCTION GLOBAL DSComm::IncValue
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		num 	: UDINT;
		pDpId 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff       : ^void;
  	pHeader         : ^_DS_Header;
    pData           : ^CHAR;
    pJobElmt        : ^_DS_JobInfoElmt;
    DataLen         : UDINT;
    SendBuffSize    : UDINT;
    RetVal          : DINT;
  END_VAR

  if num = 0 | pDpId = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#RefListAddJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    //Datenlänge und Puffergröße ermitteln
    DataLen := num * sizeof(pDpId^);
    SendBuffSize := sizeof(_DS_Header) + sizeof(num) + DataLen;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest

      pData$^UDINT^ := num;
      pData   += sizeof(num);

      //IDs der Datenpunkte kopieren
      _memcpy(ptr1:=pData, ptr2:=pDpId, cntr:=DataLen);
//    pData += DataLen;

  	  //*--- Header für Inc Value aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := IncValueCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#RefListAddJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::DecValue
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		num 	: UDINT;
		pDpId 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff       : ^void;
  	pHeader         : ^_DS_Header;
    pData           : ^CHAR;
    pJobElmt        : ^_DS_JobInfoElmt;
    DataLen         : UDINT;
    SendBuffSize    : UDINT;
    RetVal          : DINT;
  END_VAR

  if num = 0 | pDpId = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#RefListAddJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    //Datenlänge und Puffergröße ermitteln
    DataLen := num * sizeof(pDpId^);
    SendBuffSize := sizeof(_DS_Header) + sizeof(num) + DataLen;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest

      pData$^UDINT^ := num;
      pData   += sizeof(num);

      //IDs der Datenpunkte kopieren
      _memcpy(ptr1:=pData, ptr2:=pDpId, cntr:=DataLen);
//    pData += DataLen;

  	  //*--- Header für Dec Value aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := DecValueCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#RefListAddJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::AddLocalClient
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		pLocalClient 	: ^_DS_AddLocalClientCmd;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff     : ^void;
  	pHeader       : ^_DS_Header;
    pData         : ^char;
    pJobElmt      : ^_DS_JobInfoElmt;
    DataLen       : UDINT;
    StrLen        : UDINT;
    SendBuffSize  : UDINT;
    RetVal        : DINT;
  END_VAR

  if pLocalClient = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#AddLocalClientJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    //Datenlänge und Puffergröße ermitteln
    StrLen := sigclib_strlen(str:=pLocalClient^.pIdentifier)+1;   //in Bytes inkl. Endezeichen
    //                                                                         identifierLen
    DataLen := sizeof(pLocalClient^.Typ) + StrLen + sizeof(pLocalClient^.ID) + sizeof(UDINT);
    SendBuffSize := sizeof(_DS_Header) + DataLen;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest
      pData$^USINT^ := pLocalClient^.Typ;
      pData += sizeof(pLocalClient^.Typ);

      pData$^UDINT^ := StrLen;  //identifierLen
      pData += sizeof(StrLen);

      pData := sigclib_strcpy(dst0:=pData, src0:=pLocalClient^.pIdentifier);
      pData += StrLen;

      pData$^UDINT^ := pLocalClient^.ID;
//      pData += sizeof(pLocalClient^.ID);
    
  	  //*--- Header für Add Local Client aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
	    pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := AddLocalClientCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#AddLocalClientJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::AddLocalClientRange
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		pLocalClientRange 	: ^_DS_AddLocalClientRangeCmd;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff     : ^void;
  	pHeader       : ^_DS_Header;
    pData         : ^char;
    pJobElmt      : ^_DS_JobInfoElmt;
    DataLen       : UDINT;
    StrLenFrom    : UDINT;
    StrLenTo      : UDINT;
    SendBuffSize  : UDINT;
    RetVal        : DINT;
  END_VAR

  if pLocalClientRange = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#AddLocalClientRangeJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    //Datenlänge und Puffergröße ermitteln
    StrLenFrom := sigclib_strlen(str:=pLocalClientRange^.pFrom)+1;  //in Bytes inkl. Endezeichen
    StrLenTo   := sigclib_strlen(str:=pLocalClientRange^.pTo)+1;    //in Bytes inkl. Endezeichen
    //                                                                                                            FromLen + ToLen
    DataLen := sizeof(pLocalClientRange^.Typ) + sizeof(pLocalClientRange^.onDuplicate) + StrLenFrom + StrLenTo + 2 * sizeof(UDINT) + sizeof(pLocalClientRange^.ID);
    SendBuffSize := sizeof(_DS_Header) + DataLen;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest
      pData$^USINT^ := pLocalClientRange^.Typ;
      pData += sizeof(pLocalClientRange^.Typ);

      pData$^USINT^ := pLocalClientRange^.onDuplicate;
      pData += sizeof(pLocalClientRange^.onDuplicate);

      pData$^UDINT^ := StrLenFrom;  //FromLen
      pData += sizeof(StrLenFrom);
      
      pData := sigclib_strcpy(dst0:=pData, src0:=pLocalClientRange^.pFrom);
      pData += StrLenFrom;

      pData$^UDINT^ := StrLenTo;  //ToLen
      pData += sizeof(StrLenTo);

      pData := sigclib_strcpy(dst0:=pData, src0:=pLocalClientRange^.pTo);
      pData += StrLenTo;

      pData$^UDINT^ := pLocalClientRange^.ID;
//      pData += sizeof(pLocalClientRange^.ID);
    
  	  //*--- Header für Add Local Client Range aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
	    pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := AddLocalClientRangeCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#AddLocalClientRangeJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::RemoveThisLocalClient
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^char;
  	pHeader     : ^_DS_Header;
    pJobElmt    : ^_DS_JobInfoElmt;
    RetVal      : DINT;
  END_VAR

  if pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

//  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#RemoveThisLocalClientJobs, MessageID, pThis, #pJobElmt);
//  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=RemoveThisLocalClient_BUFFER_SIZE, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      //*--- Header für Remove This Local Client aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := RemoveThisLocalClient_BUFFER_SIZE;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := RemoveThisLocalClientCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#RemoveThisLocalClientJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::RemoveLocalClient
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		pLocalClient 	: ^_DS_RemoveLocalClientCmd;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff     : ^void;
  	pHeader       : ^_DS_Header;
    pData         : ^char;
    pJobElmt      : ^_DS_JobInfoElmt;
    SendBuffSize  : UDINT;
    RetVal        : DINT;
  END_VAR

  if pLocalClient = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#RemoveLocalClientJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    //Datenlänge und Puffergröße ermitteln
    SendBuffSize := sizeof(_DS_Header) + sizeof(pLocalClient^.ID);

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest

      pData$^UDINT^ := pLocalClient^.ID;
//      pData += sizeof(pLocalClient^.ID);
    
  	  //*--- Header für Remove Local Client aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
	    pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := RemoveLocalClientCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#RemoveLocalClientJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::RemoveLocalClientRange
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		pLocalClientRange 	: ^_DS_RemoveLocalClientRangeCmd;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff     : ^void;
  	pHeader       : ^_DS_Header;
    pData         : ^char;
    pJobElmt      : ^_DS_JobInfoElmt;
    DataLen       : UDINT;
    StrLenFrom    : UDINT;
    StrLenTo      : UDINT;
    SendBuffSize  : UDINT;
    RetVal        : DINT;
  END_VAR

  if pLocalClientRange = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#RemoveLocalClientRangeJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    //Datenlänge und Puffergröße ermitteln
    StrLenFrom := sigclib_strlen(str:=pLocalClientRange^.pFrom)+1;    //in Bytes inkl. Endezeichen
    StrLenTo   := sigclib_strlen(str:=pLocalClientRange^.pTo)+1;      //in Bytes inkl. Endezeichen
    //                                                                  FromLen + ToLen
    DataLen := sizeof(pLocalClientRange^.Typ) + StrLenFrom + StrLenTo + 2*sizeof(UDINT);
    SendBuffSize := sizeof(_DS_Header) + DataLen;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest
      pData$^USINT^ := pLocalClientRange^.Typ;
      pData += sizeof(pLocalClientRange^.Typ);

      pData$^UDINT^ := StrLenFrom;  //FromLen
      pData += sizeof(StrLenFrom);
      
      pData := sigclib_strcpy(dst0:=pData, src0:=pLocalClientRange^.pFrom);
      pData += StrLenFrom;

      pData$^UDINT^ := StrLenTo;  //ToLen
      pData += sizeof(StrLenTo);

      pData := sigclib_strcpy(dst0:=pData, src0:=pLocalClientRange^.pTo);
//      pData += StrLenTo;
    
  	  //*--- Header für Remove Local Client Range aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
	    pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := RemoveLocalClientRangeCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#RemoveLocalClientRangeJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::ClearLocalClientList
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^char;
  	pHeader     : ^_DS_Header;
    pJobElmt    : ^_DS_JobInfoElmt;
    RetVal      : DINT;
  END_VAR

  if pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

//  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#ClearLocalClientListJobs, MessageID, pThis, #pJobElmt);
//  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=ClearLocalClientList_BUFFER_SIZE, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      //*--- Header für Clear Local Client List aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := ClearLocalClientList_BUFFER_SIZE;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := ClearLocalClientListCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#ClearLocalClientListJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::GetCurrentID
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^char;
  	pHeader     : ^_DS_Header;
    pJobElmt    : ^_DS_JobInfoElmt;
    RetVal      : DINT;
  END_VAR

  if pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

//  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#GetCurrentIDJobs, MessageID, pThis, #pJobElmt);
//  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=GetCurrentID_BUFFER_SIZE, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      //*--- Header für Get Current ID aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := GetCurrentID_BUFFER_SIZE;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := GetCurrentIDCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#GetCurrentIDJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::GetLocalClientList
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^char;
  	pHeader     : ^_DS_Header;
    pJobElmt    : ^_DS_JobInfoElmt;
    RetVal      : DINT;
  END_VAR

  if pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

//  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#GetLocalClientListJobs, MessageID, pThis, #pJobElmt);
//  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=GetLocalClientList_BUFFER_SIZE, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      //*--- Header für Get Local Client List aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := GetLocalClientList_BUFFER_SIZE;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := GetLocalClientListCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#GetLocalClientListJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::GetLocalClientListDetails
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^char;
  	pHeader     : ^_DS_Header;
    pJobElmt    : ^_DS_JobInfoElmt;
    RetVal      : DINT;
  END_VAR

  if pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

//  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#GetLocalClientListDetailsJobs, MessageID, pThis, #pJobElmt);
//  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=GetLocalClientListDetails_BUFFER_SIZE, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      //*--- Header für Get Local Client List Details aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := GetLocalClientListDetails_BUFFER_SIZE;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := GetLocalClientListDetailsCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#GetLocalClientListDetailsJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::GetLocalClientByID
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		pLocalClient 	: ^_DS_GetLocalClientByIDCmd;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff     : ^void;
  	pHeader       : ^_DS_Header;
    pData         : ^char;
    pJobElmt      : ^_DS_JobInfoElmt;
    SendBuffSize  : UDINT;
    RetVal        : DINT;
  END_VAR

  if pLocalClient = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#GetLocalClientByIDJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    //Datenlänge und Puffergröße ermitteln
    SendBuffSize := sizeof(_DS_Header) + sizeof(pLocalClient^.ID);

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest

      pData$^UDINT^ := pLocalClient^.ID;
//      pData += sizeof(pLocalClient^.ID);
    
  	  //*--- Header für Get Local Client By ID aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
	    pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := GetLocalClientByIDCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#GetLocalClientByIDJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION DSComm::GetRespData_GetLocalClientList
	VAR_INPUT
		pData 	: ^CHAR;
		pGetLocalClientListRsp 	: ^_DS_GetLocalClientListResp;
		num 	: UDINT;
	END_VAR
  VAR
    max         : UDINT;
    tmpI        : UDINT;
  END_VAR

  max := num - 1;
  for tmpI:=0 to max do
    //--- Size -------------------------------------------------------------------------------------------------//
    pData += sizeof(UDINT);   //Size überspringen

    //--- ID ---------------------------------------------------------------------------------------------------//
    _memcpy(ptr1:=#pGetLocalClientListRsp^.ID, ptr2:=pData, cntr:=sizeof(pGetLocalClientListRsp^.ID));
    pData += sizeof(pGetLocalClientListRsp^.ID);

    //--- ErrorCode --------------------------------------------------------------------------------------------//
    _memcpy(ptr1:=#pGetLocalClientListRsp^.ErrorCode, ptr2:=pData, cntr:=sizeof(pGetLocalClientListRsp^.ErrorCode));
    pData += sizeof(pGetLocalClientListRsp^.ErrorCode);
    
    pGetLocalClientListRsp += sizeof(_DS_GetLocalClientListResp);
  end_for;
END_FUNCTION


FUNCTION DSComm::GetRespData_GetLocalClientListDetails
	VAR_INPUT
		pData 	: ^CHAR;
		pGetLocalClientListDetailsRsp 	: ^DSComm::_DS_GetLocalClientDetailsResp;
		num 	: UDINT;
		SkipSize 	: BOOL;
	END_VAR
  VAR
    max         : UDINT;
    tmpI        : UDINT;
  	StringLen   : UDINT;
  END_VAR

  max := num - 1;
  for tmpI:=0 to max do
    //--- Size -------------------------------------------------------------------------------------------------//
    if SkipSize then
      pData += sizeof(UDINT);   //Size überspringen
    end_if;

    //--- ID ---------------------------------------------------------------------------------------------------//
    _memcpy(ptr1:=#pGetLocalClientListDetailsRsp^.ID, ptr2:=pData, cntr:=sizeof(pGetLocalClientListDetailsRsp^.ID));
    pData += sizeof(pGetLocalClientListDetailsRsp^.ID);

    //--- ErrorCode --------------------------------------------------------------------------------------------//
    _memcpy(ptr1:=#pGetLocalClientListDetailsRsp^.ErrorCode, ptr2:=pData, cntr:=sizeof(pGetLocalClientListDetailsRsp^.ErrorCode));
    pData += sizeof(pGetLocalClientListDetailsRsp^.ErrorCode);
    
    //--- Type -------------------------------------------------------------------------------------------------//
    _memcpy(ptr1:=#pGetLocalClientListDetailsRsp^.Typ, ptr2:=pData, cntr:=sizeof(pGetLocalClientListDetailsRsp^.Typ));
    pData += sizeof(pGetLocalClientListDetailsRsp^.Typ);

    //--- onDuplicate ------------------------------------------------------------------------------------------//
    _memcpy(ptr1:=#pGetLocalClientListDetailsRsp^.onDuplicate, ptr2:=pData, cntr:=sizeof(pGetLocalClientListDetailsRsp^.onDuplicate));
    pData += sizeof(pGetLocalClientListDetailsRsp^.onDuplicate);

    //--- FromRangeLen -----------------------------------------------------------------------------------------//
    pData += sizeof(UDINT);   //FromRangeLen überspringen

    //--- FromRange --------------------------------------------------------------------------------------------//
    StringLen := SigCLib.StrLen(str:=pData);   //Anzahl der Zeichen im String ohne Endezeichen.
    pGetLocalClientListDetailsRsp^.FromLen  := StringLen;
    pGetLocalClientListDetailsRsp^.pFrom := pData;
    pData += StringLen+1;

    //--- ToRangeLen -------------------------------------------------------------------------------------------//
    pData += sizeof(UDINT);   //ToRangeLen überspringen

    //--- ToRange ----------------------------------------------------------------------------------------------//
    StringLen := SigCLib.StrLen(str:=pData);   //Anzahl der Zeichen im String ohne Endezeichen.
    pGetLocalClientListDetailsRsp^.ToLen  := StringLen;
    pGetLocalClientListDetailsRsp^.pTo := pData;
    pData += StringLen+1;

    pGetLocalClientListDetailsRsp += sizeof(_DS_GetLocalClientDetailsResp);
  end_for;
END_FUNCTION


FUNCTION DSComm::SendFragmentResponse
	VAR_INPUT
		UID 	: UDINT;
		ErrorCode 	: UDINT;
	END_VAR
	VAR_OUTPUT
		RetVal 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^char;
  	pHeader     : ^_DS_Header;
    pData       : ^CHAR;
    SendBuffer  : array[0..SendFragmentResponse_BUFFER_SIZE] of char; 
  END_VAR

  pSendBuff := #SendBuffer[0];
  pData := pSendBuff + sizeof(_DS_Header); //dest
    
  pData$^UDINT^ := UID;
  pData += sizeof(UID);

  pData$^UDINT^ := ErrorCode;
//  pData += sizeof(ErrorCode);

  //*--- Header für Send Fragment Response aufbauen --------------------------------------------------*//
  pheader := pSendBuff$^_DS_Header;
  pheader^.Length         := SendFragmentResponse_BUFFER_SIZE;
  pheader^.MajorID        := SIGMATEK_PROTOKOLL;
  pheader^.MinorID        := SendFragmentRsp;
  pHeader^.TransactionSrc := TransactSrc;
  pHeader^.TransactionDest:= TransactDest;
  pheader^.MessageID      := 0;

  RetVal := SendDataTCP(pData:=pSendBuff, TCPparameter.Socket);

END_FUNCTION


FUNCTION DSComm::GetFreeBufferHdlEntry
	VAR_OUTPUT
		Idx 	: DINT;
	END_VAR
  VAR
    tmpI  : DINT;
  END_VAR

  idx := -1;
  for tmpI:=0 to MaxBuffers-1 do
    if BufferHandling[tmpI].pRecvBufferStart = nil then
      Idx := tmpI;
      exit;
    end_if;
  end_for;

END_FUNCTION

FUNCTION DSComm::GetBufferHdlEntry
	VAR_INPUT
		UID 	: UDINT;
	END_VAR
	VAR_OUTPUT
		Idx 	: DINT;
	END_VAR
  VAR
    tmpI  : DINT;
  END_VAR

  idx := -1;
  for tmpI:=0 to MaxBuffers-1 do
    if BufferHandling[tmpI].pRecvBufferStart & BufferHandling[tmpI].UID = UID then
      Idx := tmpI;
      exit;
    end_if;
  end_for;

END_FUNCTION


FUNCTION DSComm::FreeBufferHdlEntry
	VAR_INPUT
		idx 	: DINT;
	END_VAR
  BufferHandling[idx].pRecvBufferStart := nil;
END_FUNCTION


FUNCTION GLOBAL DSComm::SubscribeAlarmListUpdate
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^char;
  	pHeader     : ^_DS_Header;
    pJobElmt    : ^_DS_JobInfoElmt;
    RetVal      : DINT;
  END_VAR

  if pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#AlarmListUpdateAddJobs, MessageID, pThis, #pJobElmt);

  if RetVal >= 0 then
    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=AlarmListUpdate_BUFFER_SIZE, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      //*--- Header für AlarmList Update Add aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := AlarmListUpdate_BUFFER_SIZE;
      pheader^.MajorID        := SIGMATEK_EVENT_JOURNAL_PROTOKOLL;
      pheader^.MinorID        := AlarmListUpdateAddCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#AlarmListUpdateAddJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  else
    //Pointer schon jetzt eintragen und im Fehlerfall wieder löschen (NewResponse()).
    //Grund: der DS sendet Updates schon vor dem AlarmListUpdateAddRsp. Diese gingen
    //verloren, wenn der Pointer erst beim AlarmListUpdateAddRsp eingetragen würde.
    pThis_AlarmListUpdate := pThis;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::UnsubscribeAlarmListUpdate
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^char;
  	pHeader     : ^_DS_Header;
    pJobElmt    : ^_DS_JobInfoElmt;
    RetVal      : DINT;
  END_VAR

  if pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#AlarmListUpdateSubJobs, MessageID, pThis, #pJobElmt);

  if RetVal >= 0 then
    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=AlarmListUpdate_BUFFER_SIZE, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      //*--- Header für AlarmList Update Sub aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := AlarmListUpdate_BUFFER_SIZE;
      pheader^.MajorID        := SIGMATEK_EVENT_JOURNAL_PROTOKOLL;
      pheader^.MinorID        := AlarmListUpdateSubCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#AlarmListUpdateSubJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION DSComm::GetRespData_AlarmListUpdate
	VAR_INPUT
		pData 	: ^CHAR;
		pAlarmListUpdate 	: ^_DS_AlarmListUpdate;
		num 	: UDINT;
	END_VAR
  VAR
    max   : UDINT;
    tmpI  : UDINT;
    size  : UDINT;
  END_VAR

  max := num - 1;
  for tmpI:=0 to max do
    //--- size überspringen ----------------------------------------------------------------------------------//
    pData += sizeof(UDINT);

    //--- VarNo bis nc eines Eintrags umkopieren -------------------------------------------------------------//
    size := sizeof(_DS_AlarmListUpdate.VarID) + sizeof(_DS_AlarmListUpdate.Group) + sizeof(_DS_AlarmListUpdate.Config) +
            sizeof(_DS_AlarmListUpdate.State) + sizeof(_DS_AlarmListUpdate.GroupBit) + sizeof(_DS_AlarmListUpdate.ParameterNo) +
            sizeof(_DS_AlarmListUpdate.nc);
    _memcpy(ptr1:=pAlarmListUpdate, ptr2:=pData, cntr:=size);
    pData += size;

    //--- Pointer auf die Parameter --------------------------------------------------------------------------//
    if pAlarmListUpdate^.ParameterNo then
      pAlarmListUpdate^.pParameter := pData$^_DS_AlarmParameter;
      pData := pData + pAlarmListUpdate^.ParameterNo * sizeof(_DS_AlarmParameter);
    else    
      pAlarmListUpdate^.pParameter := nil;
    end_if;

    //--- Pointer auf die Zeitstempel ------------------------------------------------------------------------//
    pAlarmListUpdate^.pTimestamps := pData$^_DS_AlarmTimestamps;
    pData += sizeof(_DS_AlarmTimestamps);

    pAlarmListUpdate^.num_appeared := pData$^UDINT^;
    pData += sizeof(_DS_AlarmListUpdate.num_appeared);

    //--- Dest-Pointer weiterstellen -------------------------------------------------------------------------//
    pAlarmListUpdate += sizeof(_DS_AlarmListUpdate);
  end_for;
END_FUNCTION

FUNCTION GLOBAL DSComm::SubscribeHotAlarmUpdate
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		pHotAlarm 	: ^_DS_HotAlarmAddCmd;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^char;
  	pHeader     : ^_DS_Header;
    pData       : ^char;
    pJobElmt    : ^_DS_JobInfoElmt;
    RetVal      : DINT;
  END_VAR

  if pThis = nil | pHotAlarm = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#HotAlarmUpdateAddJobs, MessageID, pThis, #pJobElmt);

  if RetVal >= 0 then
    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=HotAlarmUpdate_BUFFER_SIZE, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest
      pData$^USINT^ := pHotAlarm^.Typ;
//      pData += sizeof(pLocalClient^.ID);

      //*--- Header für HotAlarm Update Add aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := HotAlarmUpdate_BUFFER_SIZE;
      pheader^.MajorID        := SIGMATEK_EVENT_JOURNAL_PROTOKOLL;
      pheader^.MinorID        := HotAlarmUpdateAddCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#HotAlarmUpdateAddJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  else
    //Pointer schon jetzt eintragen und im Fehlerfall wieder löschen (NewResponse()).
    //Grund: der DS sendet Updates schon vor dem HotAlarmUpdateAddRsp. Diese gingen
    //verloren, wenn der Pointer erst beim HotAlarmUpdateAddRsp eingetragen würde.
    pThis_HotAlarmUpdate := pThis;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::UnsubscribeHotAlarmUpdate
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		pHotAlarm 	: ^_DS_HotAlarmSubCmd;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^char;
  	pHeader     : ^_DS_Header;
    pData       : ^char;
    pJobElmt    : ^_DS_JobInfoElmt;
    RetVal      : DINT;
  END_VAR

  if pThis = nil | pHotAlarm = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#HotAlarmUpdateSubJobs, MessageID, pThis, #pJobElmt);

  if RetVal >= 0 then
    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=HotAlarmUpdate_BUFFER_SIZE, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest
      pData$^USINT^ := pHotAlarm^.Typ;
//      pData += sizeof(pLocalClient^.ID);

      //*--- Header für HotAlarm Update Sub aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := HotAlarmUpdate_BUFFER_SIZE;
      pheader^.MajorID        := SIGMATEK_EVENT_JOURNAL_PROTOKOLL;
      pheader^.MinorID        := HotAlarmUpdateSubCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#HotAlarmUpdateSubJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION DSComm::GetRespData_HotAlarmUpdate
	VAR_INPUT
		pData 	: ^CHAR;
		pHotAlarmUpdate 	: ^_DS_HotAlarmUpdate;
		num 	: UDINT;
	END_VAR
  VAR
    max   : UDINT;
    tmpI  : UDINT;
    size  : UDINT;
  END_VAR

  max := num - 1;
  for tmpI:=0 to max do
    //--- size überspringen ----------------------------------------------------------------------------------//
    pData += sizeof(UDINT);

    //--- Typ bis nc eines Eintrags umkopieren ---------------------------------------------------------------//
    size := sizeof(_DS_HotAlarmUpdate.Typ) + sizeof(_DS_HotAlarmUpdate.VarID) + sizeof(_DS_HotAlarmUpdate.Group) + sizeof(_DS_HotAlarmUpdate.Config) +
            sizeof(_DS_HotAlarmUpdate.State) + sizeof(_DS_HotAlarmUpdate.GroupBit) + sizeof(_DS_HotAlarmUpdate.ParameterNo) +
            sizeof(_DS_HotAlarmUpdate.nc);
    _memcpy(ptr1:=pHotAlarmUpdate, ptr2:=pData, cntr:=size);
    pData += size;

    //--- Pointer auf die Parameter --------------------------------------------------------------------------//
    if pHotAlarmUpdate^.ParameterNo then
      pHotAlarmUpdate^.pParameter := pData$^_DS_AlarmParameter;
      pData := pData + pHotAlarmUpdate^.ParameterNo * sizeof(_DS_AlarmParameter);
    else
      pHotAlarmUpdate^.pParameter := nil;
    end_if;

    //--- Pointer auf die Zeitstempel ------------------------------------------------------------------------//
    pHotAlarmUpdate^.pTimestamps := pData$^_DS_AlarmTimestamps;
    pData += sizeof(_DS_AlarmTimestamps);

    pHotAlarmUpdate^.num_appeared := pData$^UDINT^;
    pData += sizeof(_DS_HotAlarmUpdate.num_appeared);

    //--- Dest-Pointer weiterstellen -------------------------------------------------------------------------//
    pHotAlarmUpdate += sizeof(_DS_HotAlarmUpdate);
  end_for;
END_FUNCTION


FUNCTION GLOBAL DSComm::AlarmDelete
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		num 	: UDINT;
		toDelState 	: USINT;
		pAlarmID 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^void;
  	pHeader     : ^_DS_Header;
    pData       : ^CHAR;
    pJobElmt    : ^_DS_JobInfoElmt;
    tmpI        : UDINT;
    DataLen     : UDINT;
    SendBuffSize: UDINT;
    RetVal      : DINT;
  END_VAR

  if num = 0 | pAlarmID = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#AlarmDeleteJobs, MessageID, pThis, #pJobElmt);

  if RetVal >= 0 then
    //Puffergröße ermitteln: num * (size + Daten)
    DataLen := num * (sizeof(UDINT) + sizeof(pAlarmID^));
    SendBuffSize := sizeof(_DS_Header) + sizeof(num) + sizeof(toDelState) + DataLen;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest

      pData$^UDINT^ := num;
      pData += sizeof(num);

      pData$^USINT^ := toDelState;
      pData += sizeof(toDelState);

      //Alarm Ids kopieren
      for tmpI:=0 to num-1 do
        //--- size -------------------------------------------------------------------------------------//
        pData$^UDINT^ := sizeof(pAlarmId^);  //Größe des nächsten Eintrags
        pData += sizeof(UDINT);

        //--- AlarmId ----------------------------------------------------------------------------------//
        pData$^UDINT^ := pAlarmId^;
        pData += sizeof(pAlarmId^);

        //-- Src-Pointer weiterstellen -----------------------------------------------------------------//
        pAlarmId += sizeof(pAlarmId^);
      end_for;

  	  //*--- Header für Alarm Delete aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
	    pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_EVENT_JOURNAL_PROTOKOLL;
      pheader^.MinorID        := AlarmDeleteCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#AlarmDeleteJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION

FUNCTION DSComm::GetRespData_AlarmDelete
	VAR_INPUT
		pData 	: ^CHAR;
		pAlarmDeleteRsp 	: ^_DS_AlarmDeleteResp;
		num 	: UDINT;
	END_VAR
  VAR
    max   : UDINT;
    tmpI  : UDINT;
  END_VAR

  max := num - 1;
  for tmpI:=0 to max do
    //--- size überspringen ----------------------------------------------------------------------------------//
    pData += sizeof(UDINT);

    //--- Daten umkopieren -----------------------------------------------------------------------------------//
    pAlarmDeleteRsp^ := pData$^_DS_AlarmDeleteResp^;
    pData += sizeof(_DS_AlarmDeleteResp);

    //--- Dest-Pointer weiterstellen -------------------------------------------------------------------------//
    pAlarmDeleteRsp += sizeof(_DS_AlarmDeleteResp);
  end_for;

END_FUNCTION

FUNCTION DSComm::GetRespData_AlarmDeleteUpdate
	VAR_INPUT
		pData 	: ^CHAR;
		pAlarmDeleteUpd 	: ^_DS_AlarmDeleteUpdate;
		num 	: UDINT;
	END_VAR
  VAR
    max   : UDINT;
    tmpI  : UDINT;
  END_VAR

  max := num - 1;
  for tmpI:=0 to max do
    //--- size überspringen ----------------------------------------------------------------------------------//
    pData += sizeof(UDINT);

    //--- Daten umkopieren -----------------------------------------------------------------------------------//
    pAlarmDeleteUpd^ := pData$^_DS_AlarmDeleteUpdate^;
    pData += sizeof(_DS_AlarmDeleteUpdate);

    //--- Dest-Pointer weiterstellen -------------------------------------------------------------------------//
    pAlarmDeleteUpd += sizeof(_DS_AlarmDeleteUpdate);
  end_for;

END_FUNCTION


FUNCTION GLOBAL DSComm::AlarmDeleteAll
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		toDelState 	: USINT;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^char;
  	pHeader     : ^_DS_Header;
    pData       : ^CHAR;
    pJobElmt    : ^_DS_JobInfoElmt;
    RetVal      : DINT;
  END_VAR

  if pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#AlarmDeleteAllJobs, MessageID, pThis, #pJobElmt);

  if RetVal >= 0 then
    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=AlarmDeleteAll_BUFFER_SIZE, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest

      pData$^USINT^ := toDelState;
//      pData += sizeof(toDelState);

      //*--- Header für Alarm Delete All aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
      pheader^.Length         := AlarmDeleteAll_BUFFER_SIZE;
      pheader^.MajorID        := SIGMATEK_EVENT_JOURNAL_PROTOKOLL;
      pheader^.MinorID        := AlarmDeleteAllCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#AlarmDeleteAllJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION

FUNCTION GLOBAL DSComm::StrLenUtf8
	VAR_INPUT
		Str_Utf8 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR
  VAR
  	ps        : ^char;
    chr       : UINT;
    follow    : UDINT;
  END_VAR

  retcode := 0;
  ps := Str_Utf8;
  
  while (ps^) do
    chr := ps^;
    ps += 1;

    if(chr and 0x0080) then
      follow := 0;
      if((chr and 0x00E0) = 0x00C0) then
        follow := 1; // 1 folgebyte
      elsif((chr and 0x00F0) = 0x00E0) then
        follow := 2; // 2 folgebytes
      elsif((chr and 0x00F8) = 0x00F0) then
        follow := 3; // 3 folgebytes
      end_if;

      while(follow) do
        follow -= 1;
        if((ps^ and 0xC0) = 0x80) then
          ps += 1;
          if(follow = 0) then
            retcode += 1;
          end_if;
        end_if;
      end_while;
    else
      retcode += 1;
    end_if;
  end_while;

END_FUNCTION


FUNCTION GLOBAL DSComm::SubscribeState
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		pCmdData 	: ^_DS_SubscribeStateCmd;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^char;
  	pHeader     : ^_DS_Header;
    pData       : ^char;
    pJobElmt    : ^_DS_JobInfoElmt;
    SendBuffSize: UDINT;
    RetVal      : DINT;
  END_VAR

  if pThis = nil | pCmdData = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#SubscribeStateJobs, MessageID, pThis, #pJobElmt);

  if RetVal >= 0 then
    //Datenlänge und Puffergröße ermitteln
    SendBuffSize := sizeof(_DS_Header) + sizeof(pCmdData^.Target) + sizeof(pCmdData^.Typ);

    case pCmdData^.Typ of
      Lasal_ID_List:
      SendBuffSize += sizeof(_DS_SubscribeStateCmd_1);
  
      else
        MessageID := ERR_WRONG_PARAMETER; //Parameterfehler: Typ unbekannt
    end_case;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest

      pData$^UDINT^ := pCmdData^.Target;
      pData += sizeof(pCmdData^.Target);

      pData$^_DS_StateType^ := pCmdData^.Typ;
      pData += sizeof(pCmdData^.Typ);

      case pCmdData^.Typ of
        Lasal_ID_List:
        _memcpy(ptr1:=pData, ptr2:=pCmdData^.pData, cntr:=sizeof(_DS_SubscribeStateCmd_1));
      end_case;

  	  //*--- Header für Subscribe State aufbauen ----------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
	    pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := SubscribeStateCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#SubscribeStateJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  else
    //Pointer schon jetzt eintragen und im Fehlerfall wieder löschen (NewResponse()).
    //Grund: der DS sendet Updates ev. schon vor den Response-Daten. Diese gingen
    //verloren, wenn der Pointer erst beim Empfang der Response-Daten eingetragen würde.
    pThis_UpdateState := pThis;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::UnsubscribeState
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		pCmdData 	: ^_DS_UnsubscribeStateCmd;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff   : ^char;
  	pHeader     : ^_DS_Header;
    pData       : ^char;
    pJobElmt    : ^_DS_JobInfoElmt;
    SendBuffSize: UDINT;
    RetVal      : DINT;
  END_VAR

  if pThis = nil | pCmdData = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler
    return;
  end_if;

  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#UnsubscribeStateJobs, MessageID, pThis, #pJobElmt);

  if RetVal >= 0 then
    //Datenlänge und Puffergröße ermitteln
    SendBuffSize := sizeof(_DS_Header) + sizeof(pCmdData^.Target) + sizeof(pCmdData^.Typ);

    case pCmdData^.Typ of
      Lasal_ID_List:
      SendBuffSize += sizeof(_DS_SubscribeStateCmd_1);
  
      else
        MessageID := ERR_WRONG_PARAMETER; //Parameterfehler: Typ unbekannt
    end_case;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest

      pData$^UDINT^ := pCmdData^.Target;
      pData += sizeof(pCmdData^.Target);

      pData$^_DS_StateType^ := pCmdData^.Typ;
      pData += sizeof(pCmdData^.Typ);

      case pCmdData^.Typ of
        Lasal_ID_List:
        _memcpy(ptr1:=pData, ptr2:=pCmdData^.pData, cntr:=sizeof(_DS_SubscribeStateCmd_1));
      end_case;

  	  //*--- Header für Subscribe State aufbauen ----------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
	    pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := UnsubscribeStateCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#UnsubscribeStateJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DSComm::Get_State
	VAR_INPUT
		pThis 	: ^DSComm_Interface;
		pCmdData 	: ^_DS_GetStateCmd;
	END_VAR
	VAR_OUTPUT
		MessageID 	: DINT;
	END_VAR
  VAR
    pSendBuff     : ^void;
  	pHeader       : ^_DS_Header;
    pData         : ^char;
    pJobElmt      : ^_DS_JobInfoElmt;
    SendBuffSize  : UDINT;
    RetVal        : DINT;
  END_VAR

  if pCmdData = nil | pThis = nil then
    MessageID := ERR_WRONG_PARAMETER; //Parameterfehler: invalid pointer
    return;
  end_if;

  //  Section.SectionStart(); // *********************
  MessageID := GenerateMessageID();
  RetVal := SaveJobInfo(pJobInfo:=#GetStateJobs, MessageID, pThis, #pJobElmt);
  //  Section.SectionStop(); // *********************

  if RetVal >= 0 then
    //Datenlänge und Puffergröße ermitteln
    SendBuffSize := sizeof(_DS_Header) + sizeof(pCmdData^.Target) + sizeof(pCmdData^.Typ);

    case pCmdData^.Typ of
      Lasal_ID_List:
      SendBuffSize += sizeof(_DS_GetStateCmd_1);
  
      else
        MessageID := ERR_WRONG_PARAMETER; //Parameterfehler: Typ unbekannt
    end_case;

    pSendBuff := (BufferCreate(statbuff:=nil, statbuff_size:=0, expected_size:=SendBuffSize, MemMark:=MEM_Mark_DS_Comm))$^char;
    if pSendBuff then
      pData := pSendBuff + sizeof(_DS_Header); //dest

      pData$^UDINT^ := pCmdData^.Target;
      pData += sizeof(pCmdData^.Target);

      pData$^_DS_StateType^ := pCmdData^.Typ;
      pData += sizeof(pCmdData^.Typ);

      case pCmdData^.Typ of
        Lasal_ID_List:
        _memcpy(ptr1:=pData, ptr2:=pCmdData^.pData, cntr:=sizeof(_DS_GetStateCmd_1));
      end_case;

  	  //*--- Header für Get State aufbauen --------------------------------------------------*//
      pheader := pSendBuff$^_DS_Header;
	    pheader^.Length         := SendBuffSize;
      pheader^.MajorID        := SIGMATEK_PROTOKOLL;
      pheader^.MinorID        := GetStateCmd;
      pHeader^.TransactionSrc := TransactSrc;
      pHeader^.TransactionDest:= TransactDest;
      pheader^.MessageID      := MessageID;

      RetVal := SendToCommTask(pData:=pSendBuff$^char, TCPparameter.Socket, pJobElmt);
    else
      RetVal := ERR_MALLOC_SEND_BUFFER;    //Fehler: zuwenig RAM für Sendepuffer
    end_if;

    if RetVal < 0 then
      RemoveJob(pJobInfo:=#GetStateJobs, MessageID);
    end_if;
  end_if;

  if RetVal < 0 then
    MessageID := RetVal;
  end_if;

END_FUNCTION


FUNCTION DSComm::GetRespData_GetState
	VAR_INPUT
		pData 	: ^CHAR;
		pGetStateRsp 	: ^_DS_GetStateResp;
	END_VAR

  pGetStateRsp^.Target := pData$^UDINT^;
  pData += sizeof(pGetStateRsp^.Target);

  pGetStateRsp^.Typ := pData$^_DS_StateType^;
  pData += sizeof(pGetStateRsp^.Typ);

  pGetStateRsp^.ErrorCode := pData$^UDINT^;
  pData += sizeof(pGetStateRsp^.ErrorCode);

  case pGetStateRsp^.Typ of
    Lasal_ID_List:
    pGetStateRsp^.pData := pData;
  end_case;

END_FUNCTION



FUNCTION DSComm::SendToCommTask
	VAR_INPUT
		pData 	: ^CHAR;
		SockNo 	: DINT;
		pJobElmt 	: ^_DS_JobInfoElmt;
	END_VAR
	VAR_OUTPUT
		RetVal 	: DINT;
	END_VAR
  VAR
	  CommRec : _DS_CommTask_Rec;
  END_VAR

  CommRec.pData := pData;
  CommRec.SockNo := SockNo;
  CommRec.pJobElmt := pJobElmt;

  RetVal := cPipe_Add(pPipe, #CommRec, sizeof(CommRec))$DINT;
  if RetVal then
    //Kein Fehler
    RetVal := 0;
  else
    //Fehler
    RetVal := ERR_TCPIP;  //Damit das IF zur Applikation kompatibel bleibt.
  end_if;

END_FUNCTION


FUNCTION DSComm::SendData
VAR
  CommRec : _DS_CommTask_Rec;
	RetCode : UDINT;
	Error   : DINT;
END_VAR

  RetCode := 1;
  while RetCode = 1 do
    RetCode := cPipe_Get(#CommRec, pPipe);
    
    if RetCode then
      Error := SendDataTCP(pData:=CommRec.pData$^char, SockNo:=CommRec.SockNo);
      if Error < 0 then
        CommRec.pJobElmt^.Error := Error;
      end_if;

      BufferDestroy(statbuff:=nil, buffer:=CommRec.pData);
    end_if;
  end_while;

END_FUNCTION
