//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES

#define XMLWriter_TaskName          "XML-Write_"
#define XMLWriter_TaskPrio          10
#define XMLWriter_StackSize         (16#F000 OR 16#80000000)     // 30000 Byte
#define XMLWriter_TaskDelay         1                            // delay for the parallel task
 
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "_XMLWriter"
	Revision           = "1.4"
	GUID               = "{C59FDFD6-4885-4459-8818-723B0CB934EB}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "true"
	DefBackground      = "100 ms"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(360,240)"
	Comment            = "class is used to create a simple .xml-File&#13;&#10;&#13;&#10;all input-strings have to be formatted in unicode&#13;&#10;encoding of the .xml-File will be utf-8&#13;&#10;(convertion of the strings to utf-8 will be done by the XMLWriter-Class)">
	<Channels>
		<Server Name="ClassSvr" GUID="{A765089D-9FA0-454F-864A-1559414860E9}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Server to call global methods"/>
		<Server Name="DoConvert" GUID="{31D2EE09-A545-4E44-B001-543FEECA927B}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="used to activate convertion of special characters&#13;&#10;= 0 ... no convertion will be done&#13;&#10;&lt;&gt; 0 ... special characters will be converted automatically"/>
		<Server Name="XmlError" GUID="{AD59740F-CE3E-4856-A46B-EF170E850036}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Error status of the _XMLWriter"/>
		<Server Name="XmlState" GUID="{E5BE348C-C16F-4D9B-9751-517B5264F296}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="State of the _XMLWriter"/>
		<Client Name="CheckSum" Required="true" Internal="true"/>
		<Client Name="CreateTask" Required="true" Internal="false" DefValue="0"/>
		<Client Name="FileSys" Required="false" Internal="false"/>
		<Client Name="MaxFileSize" Required="true" Internal="false" DefValue="5000" Comment="Maximum size of the XML file"/>
		<Client Name="MultiTask" Required="false" Internal="false"/>
		<Client Name="SigCLib" Required="false" Internal="false"/>
		<Client Name="StdLib" Required="false" Internal="false"/>
		<Client Name="StructCreator" Required="true" Internal="true"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="sprdie"/>
		<Dokumentation Revision="1.4" Date="2020-02-11" Author="sprdie" Company="Sigmatek" Description="Special characters (&amp;  &lt;  &gt;  &apos;  &quot;) can now automatically be converted when the .xml-File will be written.&#13;&#10;(for example &amp; will be converted to &amp;amp;)&#13;&#10;Convertion only will be done for attribute-values and texts of elements.&#13;&#10;For element-names and attribute-names these characters are not allowed"/>
		<Dokumentation Revision="1.3" Date="2018-07-25" Author="sprdie" Company="Sigmatek" Description="- BOM for UTF-8 encoding can now be inserted&#13;&#10;- its now possible to decide if the xml-string should be created in Background or User-Task&#13;&#10;- optimized CreateString-Function"/>
		<Dokumentation Revision="1.2" Date="2017-10-13" Author="sprdie" Company="Sigmatek" Description="new Methods GetXmlState &amp; GetErrorState"/>
		<Dokumentation Revision="1.1" Date="2017-05-10" Author="sprdie" Company="Sigmatek" Description="Class is now also able to handle Unicode String Inputs."/>
		<Dokumentation Revision="1.0" Date="2017-02-10" Author="sprdie" Company="Sigmatek" Description="Class created"/>
	</RevDoku>
	<Network Name="_XMLWriter">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "CheckSum"
				GUID       = "{9363090D-B723-435E-8339-601010A93922}"
				Class      = "_CheckSum"
				Position   = "(210,750)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
				</Channels>
			</Object>
			<Object
				Name       = "StructCreator"
				GUID       = "{740A7B8A-7FA1-4912-8137-0EF4A4F92E57}"
				Class      = "_XMLStructCreator"
				Position   = "(210,450)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
					<Client Name="SigCLib"/>
					<Client Name="StdLib"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.StructCreator" Destination="StructCreator.ClassSvr"/>
			<Connection Source="this.CheckSum" Destination="CheckSum.ClassSvr"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
_XMLWriter : CLASS
	TYPE
	  _XML_CMD :
	  (
	    _CMD_WAIT,
	    _CMD_CREATE,
	    _CMD_FLUSH,
	    _CMD_CLOSE
	  )$DINT;
	  _XML_ERROR_STATE :  //! <Type Public="true" Name="_XML_ERROR_STATE"/>
	  (
	    _NO_ERROR,  //! <Type Comment="No Error" Name="_XML_ERROR_STATE._NO_ERROR"/>
	    _CREATING_FAILED,  //! <Type Comment="Creating file failed" Name="_XML_ERROR_STATE._CREATING_FAILED"/>
	    _OPENING_FAILED,  //! <Type Comment="Opening file failed" Name="_XML_ERROR_STATE._OPENING_FAILED"/>
	    _WRITING_FAILED,  //! <Type Comment="Writing file failed" Name="_XML_ERROR_STATE._WRITING_FAILED"/>
	    _CLOSING_FAILED,  //! <Type Comment="Closing file failed" Name="_XML_ERROR_STATE._CLOSING_FAILED"/>
	    _MEMORY_OP_FAILED,  //! <Type Comment="A memory operation failed" Name="_XML_ERROR_STATE._MEMORY_OP_FAILED"/>
	    _CREATE_TASK_FAILED
	  )$UDINT;
	  _XML_FLUSH_STATE :
	  (
	    _XML_STRING_START,
	    _XML_STRING_CREATING,
	    _XML_STRING_CREATED,
	    _XML_FILE_OPENING,
	    _XML_FILE_OPENED,
	    _XML_FILE_WRITING,
	    _XML_FILE_WRITED,
	    _XML_MEM_FREEING,
	    _XML_MEM_FREED
	  )$UDINT;
	  _XML_STATE :  //! <Type Public="true" Name="_XML_STATE"/>
	  (
	    _XML_IDLE,  //! <Type Comment="Nothing to do" Name="_XML_STATE._XML_IDLE"/>
	    _XML_CREATING,  //! <Type Comment="File is being created" Name="_XML_STATE._XML_CREATING"/>
	    _XML_CREATED,  //! <Type Comment="File was successfully created" Name="_XML_STATE._XML_CREATED"/>
	    _XML_FLUSHING,  //! <Type Comment="Flush-process active" Name="_XML_STATE._XML_FLUSHING"/>
	    _XML_FLUSHED,  //! <Type Comment="Flush-process successfully finished" Name="_XML_STATE._XML_FLUSHED"/>
	    _XML_CLOSING,  //! <Type Comment="File is being closed" Name="_XML_STATE._XML_CLOSING"/>
	    _XML_CLOSED,  //! <Type Comment="File successfully closed" Name="_XML_STATE._XML_CLOSED"/>
	    _XML_ERROR  //! <Type Comment="An error occured" Name="_XML_STATE._XML_ERROR"/>
	  )$UDINT;
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
	XmlState 	: SvrCh__XML_STATE_PTofCls__XMLWriter;
	XmlError 	: SvrCh__XML_ERROR_STATE_PTofCls__XMLWriter;
	DoConvert 	: SvrCh_DINT;
  //Clients:
	FileSys 	: CltChCmd__FileSys;
	StdLib 	: CltChCmd__StdLib;
	MaxFileSize 	: CltCh_DINT;
	StructCreator 	: CltChCmd__XMLStructCreator;
	SigCLib 	: CltChCmd_SigCLib;
	MultiTask 	: CltChCmd__MultiTask;
	CreateTask 	: CltCh_DINT;
	CheckSum 	: CltChCmd__CheckSum;
  //Variables:
		AsyncState 	: DINT;			//! <Variable Comment="used to save retcode of Function GetAsyncState()" Name="AsyncState"/>
		asyncID 	: UDINT;
		fctRetval 	: DINT;
		FileName 	: ^USINT;			//! <Variable Comment="Name of the File to create" Name="FileName"/>
		FileText 	: ^USINT;
		FileHandle 	: DINT;
		flushAllowed 	: BOOL;
		Index 	: UDINT;
		xmlSSW 	: _XML_CMD;
		xmlStruct 	: _XML_FILE;
		iFirst 	: DINT;
		iLast 	: DINT;
		cmdStack : ARRAY [0..49] OF _XML_CMD;

		bufferEmpty 	: BOOL;
		cmdDone 	: BOOL;
		flushState 	: _XML_FLUSH_STATE;
		bFreeAfterFlush 	: BOOL;
		bWrIsUnicode 	: BOOL;
		taskHandle 	: MT_TASKHANDLE;
		doCreate 	: BOOL;
		isStringCreated 	: BOOL;
		isTaskCreated 	: BOOL;
		szTaskName : ARRAY [0..30] OF CHAR;

  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="creates a .xml-File&#13;&#10;&#13;&#10;Input for example: &quot;C:\Example.xml&quot;" Name="FileCreate"/>
	FUNCTION GLOBAL FileCreate
		VAR_INPUT
			pName 	: ^CHAR;			//! <Variable Comment="Name of the file to create" Name="FileCreate.pName"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="0 ... Success&#13;&#10;-1 ... Input NIL&#13;&#10;-2 ... Memory operation failed&#13;&#10;-3 ... _XMLWriter in state _XML_ERROR" Name="FileCreate.retcode"/>
		END_VAR;
				//! <Function Comment="creates standard xml-Header&#13;&#10;&#13;&#10;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;" Name="WriteStartDocument"/>
	FUNCTION GLOBAL WriteStartDocument
		VAR_INPUT
			pEncoding 	: ^USINT;			//! <Variable Comment="Pointer to the encoding-string (see defines)" Name="WriteStartDocument.pEncoding"/>
			insertBOM 	: BOOL := FALSE;			//! <Variable Comment="if set TRUE the BOM for UTF-8 encoding will be inserted" Name="WriteStartDocument.insertBOM"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="0 ... Success&#13;&#10;-1 ... Input NIL&#13;&#10;-2 ... Memory operation failed&#13;&#10;-3 ... _XMLWriter in state _XML_ERROR&#13;&#10;-4 ... Encoding name to long" Name="WriteStartDocument.retcode"/>
		END_VAR;
				//! <Function Comment="creates start of an element&#13;&#10;&#13;&#10;WriteStartElement(&quot;Test&quot;); -&gt; &lt;Test&gt;" Name="WriteStartElement"/>
	FUNCTION GLOBAL WriteStartElement
		VAR_INPUT
			pName 	: ^USINT;			//! <Variable Comment="Pointer to the name of the element" Name="WriteStartElement.pName"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="0 ... Success&#13;&#10;-1 ... Input NIL&#13;&#10;-2 ... Memory operation failed&#13;&#10;-3 ... _XMLWriter in state _XML_ERROR" Name="WriteStartElement.retcode"/>
		END_VAR;
				//! <Function Comment="Adds an Atribute to the recent Element&#13;&#10;&#13;&#10;recent Element ist Test&#13;&#10;WriteAttributeString(&quot;ID&quot;, &quot;100&quot;); -&gt; &lt;Test ID=&quot;100&quot;&gt;" Name="WriteAttributeString"/>
	FUNCTION GLOBAL WriteAttributeString
		VAR_INPUT
			pName 	: ^USINT;			//! <Variable Comment="Pointer to the name of the attribute" Name="WriteAttributeString.pName"/>
			pValue 	: ^USINT;			//! <Variable Comment="Pointer to the value of the attribute" Name="WriteAttributeString.pValue"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="0 ... Success&#13;&#10;-1 ... Input NIL&#13;&#10;-2 ... Memory operation failed&#13;&#10;-3 ... _XMLWriter in state _XML_ERROR" Name="WriteAttributeString.retcode"/>
		END_VAR;
				//! <Function Comment="adds an text to the actual opened element&#13;&#10;after this the next step will be WriteEndElement() because Element with text is not allowed to have children" Name="WriteTextString"/>
	FUNCTION GLOBAL WriteTextString
		VAR_INPUT
			pText 	: ^USINT;			//! <Variable Comment="Pointer to the text" Name="WriteTextString.pText"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="0 ... Success&#13;&#10;-1 ... Input NIL&#13;&#10;-2 ... Memory operation failed&#13;&#10;-3 ... _XMLWriter in state _XML_ERROR" Name="WriteTextString.retcode"/>
		END_VAR;
				//! <Function Comment="adds an single Element with Text behind&#13;&#10;&#13;&#10;WriteElementString(&quot;Text&quot;, &quot;Hello&quot;); -&gt; &lt;Text&gt;Hello&lt;/Text&gt;" Name="WriteElementString"/>
	FUNCTION GLOBAL WriteElementString
		VAR_INPUT
			pName 	: ^USINT;			//! <Variable Comment="Pointer to the name of the element" Name="WriteElementString.pName"/>
			pText 	: ^USINT;			//! <Variable Comment="Pointer to the text of the element" Name="WriteElementString.pText"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="0 ... Success&#13;&#10;-1 ... Input NIL&#13;&#10;-2 ... Memory operation failed&#13;&#10;-3 ... _XMLWriter in state _XML_ERROR&#13;&#10;-4 ... Adding text failed" Name="WriteElementString.retcode"/>
		END_VAR;
				//! <Function Comment="closes the recent Element&#13;&#10;&#13;&#10;recent Element is Test&#13;&#10;WriteEndElement(); -&gt; &lt;/Test&gt;" Name="WriteEndElement"/>
	FUNCTION GLOBAL WriteEndElement
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="0 ... Success&#13;&#10;-1 ... No Element&#13;&#10;-3 ... _XMLWriter in state _XML_ERROR" Name="WriteEndElement.retcode"/>
		END_VAR;
				//! <Function Comment="marks End of Document" Name="WriteEndDocument"/>
	FUNCTION GLOBAL WriteEndDocument
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="0 ... Success&#13;&#10;-1 ... Input NIL&#13;&#10;-2 ... No Element&#13;&#10;-3 ... _XMLWriter in state _XML_ERROR&#13;&#10;-4 ... One element successfully closed but main element still open" Name="WriteEndDocument.retcode"/>
		END_VAR;
				//! <Function Comment="writes the created xml-Struct to the File and afterwards it frees the memory" Name="Flush"/>
	FUNCTION GLOBAL Flush
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="0 ... Success&#13;&#10;-1 ... Stack full&#13;&#10;-2 ... Not allowed. Either WriteEndDocument or Setstruct not successfully executed&#13;&#10;-3 ... _XMLWriter in state _XML_ERROR" Name="Flush.retcode"/>
		END_VAR;
				//! <Function Comment="closes the opened file" Name="FileClose"/>
	FUNCTION GLOBAL FileClose
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="0 ... Success&#13;&#10;-1 ... Stack full&#13;&#10;-3 ... _XMLWriter in state _XML_ERROR" Name="FileClose.retcode"/>
		END_VAR;
				//! <Function Comment="sets struct of the class -&gt; we want to write a .xml-File with already existing struct" Name="SetStruct"/>
	FUNCTION GLOBAL SetStruct
		VAR_INPUT
			pStruct 	: ^_XML_FILE;			//! <Variable Comment="Pointer to the XML-structur" Name="SetStruct.pStruct"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="True ... Success&#13;&#10;False ... Command failed" Name="SetStruct.retcode"/>
		END_VAR;
				//! <Function Comment="in case of an error this method can be used to reset the writer&#13;&#10;&#13;&#10;every allocated memory will be freed and state will go back to _IDLE" Name="Reset"/>
	FUNCTION GLOBAL Reset;
				//! <Function Comment="method to get the state of the xml-writer class" Name="GetXmlState"/>
	FUNCTION GLOBAL GetXmlState
		VAR_OUTPUT
			state 	: _XML_STATE;			//! <Variable Comment="state of the xml-writer class" Name="GetXmlState.state"/>
		END_VAR;
				//! <Function Comment="method to get the error state of the xml-writer class" Name="GetErrorState"/>
	FUNCTION GLOBAL GetErrorState
		VAR_OUTPUT
			state 	: _XML_ERROR_STATE;			//! <Variable Comment="error state of the xml-writer" Name="GetErrorState.state"/>
		END_VAR;
				//! <Function Comment="Converts all special characters from the source-string to XML notation&#13;&#10;(for example &apos;&amp;&apos; will be converted to &quot;amp;&quot;)&#13;&#10;output-string can be longer than source-string after convertion, therefore different buffers have to be used" Name="ConvertTextToXML"/>
	FUNCTION GLOBAL ConvertTextToXML
		VAR_INPUT
			pDest 	: ^void;			//! <Variable Comment="pointer to destination where the converted string should be stored" Name="ConvertTextToXML.pDest"/>
			pSrc 	: ^void;			//! <Variable Comment="pointer to the string which should be converted" Name="ConvertTextToXML.pSrc"/>
			size 	: UINT;			//! <Variable Comment="size of one character&#13;&#10;1...ASCII&#13;&#10;2...UNICODE" Name="ConvertTextToXML.size"/>
		END_VAR
		VAR_OUTPUT
			length 	: DINT;			//! <Variable Comment="length of the converted string" Name="ConvertTextToXML.length"/>
		END_VAR;
				//! <Function Comment="creates the text out of the created xml-Struct&#13;&#10;&#13;&#10;retcode tells us the used bytes" Name="CreateXmlString"/>
	FUNCTION CreateXmlString
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION PutCMD
		VAR_INPUT
			cmd 	: _XML_CMD;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION GetCMD
		VAR_OUTPUT
			cmd 	: _XML_CMD;
		END_VAR;
	
	FUNCTION FreeXML;
	
	FUNCTION WriteStartDocumentAscii
		VAR_INPUT
			pEncoding 	: ^USINT;
			insertBOM 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION WriteStartDocumentUni
		VAR_INPUT
			pEncoding 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION CreateXmlStringAscii
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION CreateXmlStringUni
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION FileIsUnicode
		VAR_INPUT
			Param 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION XmlWriteTask;
	
	FUNCTION CreateTaskName
		VAR_INPUT
			pName 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION ConvertTextToXMLAscii
		VAR_INPUT
			pDest 	: ^CHAR;
			pSrc 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			length 	: DINT;
		END_VAR;
	
	FUNCTION ConvertTextToXMLUni
		VAR_INPUT
			pDest 	: ^UINT;
			pSrc 	: ^UINT;
		END_VAR
		VAR_OUTPUT
			length 	: DINT;
		END_VAR;
	
	FUNCTION CalculateConvertedSizeAscii
		VAR_INPUT
			pText 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			length 	: UDINT;
		END_VAR;
	
	FUNCTION CalculateConvertedSizeUni
		VAR_INPUT
			pText 	: ^UINT;
		END_VAR
		VAR_OUTPUT
			length 	: UDINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using _CheckSum
#pragma using _XMLStructCreator
#pragma usingLtd _FileSys
#pragma usingLtd _MultiTask
#pragma usingLtd _StdLib
#pragma usingLtd SigCLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _XMLWriter::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__XMLWRITER
1$UINT, 4$UINT, (SIZEOF(::_XMLWriter))$UINT, 
4$UINT, 8$UINT, 0$UINT, 
TO_UDINT(2243305547), "_XMLWriter", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::_XMLWriter.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::_XMLWriter.XmlState.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(742526690), "XmlState", 
(::_XMLWriter.XmlError.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3524026472), "XmlError", 
(::_XMLWriter.DoConvert.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2237141759), "DoConvert", 
//Clients:
(::_XMLWriter.FileSys.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1422438244), "FileSys", TO_UDINT(545279513), "_FileSys", 1$UINT, 20$UINT, 
(::_XMLWriter.StdLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(584375759), "StdLib", TO_UDINT(3689364044), "_StdLib", 0$UINT, 0$UINT, 
(::_XMLWriter.MaxFileSize.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(4166032088), "MaxFileSize", 
(::_XMLWriter.StructCreator.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3556400222), "StructCreator", TO_UDINT(2131172539), "_XMLStructCreator", 2$UINT, 0$UINT, 
(::_XMLWriter.SigCLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(77440046), "SigCLib", TO_UDINT(77440046), "SigCLib", 0$UINT, 36$UINT, 
(::_XMLWriter.MultiTask.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3505031941), "MultiTask", TO_UDINT(2641766936), "_MultiTask", 1$UINT, 1$UINT, 
(::_XMLWriter.CreateTask.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(184646452), "CreateTask", 
(::_XMLWriter.CheckSum.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(408699862), "CheckSum", TO_UDINT(916194998), "_CheckSum", 1$UINT, 0$UINT, 
END_FUNCTION


#define USER_CNT__XMLWriter 1

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__XMLWriter] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _XMLWriter::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT__XMLWriter, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	DoConvert.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF DoConvert.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION VIRTUAL GLOBAL _XMLWriter::Init

  if _FirstScan then
    
    xmlSSW := _CMD_WAIT; // we do not have to do this because init-value is 0 (_CMD_WAIT) but just to be sure
    XmlState := _XML_IDLE; // same here
    XmlError := _NO_ERROR; // and also the same here
    
    cmdDone := TRUE;
    
    // Stack-Init
    iFirst := 0;
    iLast := 0;
    bufferEmpty := TRUE;
    
    // alloc memory for FileString
    FileText$^void := StdLib.Malloc(MaxFileSize$UDINT);
    if FileText = NIL then
      XmlState := _XML_ERROR;
      XmlError := _MEMORY_OP_FAILED;
    else
      _memset(FileText, 0, MaxFileSize$UDINT);    
    end_if;
    
    if CreateTask = 1 then
      
      if CreateTaskName(#szTaskName[0]) then
        
        taskHandle := MultiTask.CREATETHREAD( #XmlWriteTask(), 
                                              XMLWRITER_TASKPRIO, 
                                              XMLWRITER_STACKSIZE, 
                                              MT_TASK_SAVETHIS, 
                                              this, 
                                              #szTaskName[0]);
        if taskHandle = NIL then
          XmlState := _XML_ERROR;
          XmlError := _CREATE_TASK_FAILED;
        end_if;
        
        isTaskCreated := TRUE;
      
      else
        
        XmlState := _XML_ERROR;
        XmlError := _CREATE_TASK_FAILED;
        
      end_if;
      
    end_if;
    
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL _XMLWriter::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		State (EAX) 	: UDINT;
	END_VAR
  
  State := READY;
  
  if (cmdDone = TRUE) & (XmlError = _NO_ERROR) then
    xmlSSW := GetCMD();
  end_if;

  case xmlSSW of
  	
    _CMD_WAIT:
  	  // just wait for a command
    
    _CMD_CREATE:
  	  // create File Async
      if XmlState = _XML_IDLE | XmlState = _XML_CLOSED then
        cmdDone := FALSE;
        asyncID$DINT := FileSys.FileCreate_A(1, FileName, 40*sizeof(USINT), 0, ATT_CREATE_ALWAYS or ATT_READ_WRITE);
        XmlState := _XML_CREATING;
      end_if;
      
      // ask 4 state
      if XmlState = _XML_CREATING then
        
        AsyncState := FileSys.GetAsyncState(asyncID, #fctRetval); 
        if AsyncState = 0 then
          // file creating finished
          cmdDone := TRUE;
          
          if fctRetval = 0 then
            // success at creating
            XmlState := _XML_CREATED;
          else
            // creating went wrong
            XmlState := _XML_ERROR;
            XmlError := _CREATING_FAILED;
          end_if;
          
        end_if;
        
      end_if;
      
    _CMD_FLUSH:
  	  // create String, open File, write to File, free Memory
      if XmlState = _XML_CREATED then
        cmdDone := FALSE;
        isStringCreated := FALSE;
        XmlState := _XML_FLUSHING;
        flushState := _XML_STRING_START;
      end_if;
      
      if XmlState = _XML_FLUSHING then
        case flushState of
          
          _XML_STRING_START:
            doCreate := TRUE;
            flushState := _XML_STRING_CREATING;
            
          _XML_STRING_CREATING:
            if isTaskCreated = TRUE then
              
              if isStringCreated = TRUE then
                flushState := _XML_STRING_CREATED;
              end_if;
            
            else
            
              if CreateXmlString() then
                flushState := _XML_STRING_CREATED;
              else
                XmlState := _XML_ERROR;
                XmlError := _CREATING_FAILED;
              end_if;
            
            end_if;     
            
          _XML_STRING_CREATED:
            // string created now open File
            asyncID$DINT := FileSys.FileOpen_A(1, FileName, ATT_READ_WRITE);
            flushState := _XML_FILE_OPENING;
            
          _XML_FILE_OPENING:
            // get state of opening the file, on success go on
            AsyncState := FileSys.GetAsyncState(asyncID, #fctRetval);
            if AsyncState = 0 then
              
              if fctRetval >= 0 then
                FileHandle := fctRetval;
                flushState := _XML_FILE_OPENED;
              else
                XmlState := _XML_ERROR;
                XmlError := _OPENING_FAILED;
              end_if;
            
            end_if;
            
          _XML_FILE_OPENED:
            // file is open so lets start writing
            asyncID$DINT := FileSys.FileWrite_A(1, FileHandle, FileText, Index*sizeof(USINT));
            
            flushState := _XML_FILE_WRITING;
            
          _XML_FILE_WRITING:
            // check state of writing-operation
            AsyncState := FileSys.GetAsyncState(asyncID, #fctRetval);
            if AsyncState = 0 then
              
              if fctRetval > 0 then
                // success
                flushState := _XML_FILE_WRITED;
              else
                XmlState := _XML_ERROR;
                XmlError := _WRITING_FAILED;
              end_if;

            end_if;
          
          _XML_FILE_WRITED:
            // just do Free Work
            if bFreeAfterFlush then
              flushState := _XML_MEM_FREEING;
            else
              cmdDone := TRUE;
              XmlState := _XML_FLUSHED;
            end_if;

          _XML_MEM_FREEING:
            FreeXML();
            flushState := _XML_MEM_FREED;
            
          _XML_MEM_FREED:
            cmdDone := TRUE;
            XmlState := _XML_FLUSHED;
        
        end_case;
      end_if;
      
    _CMD_CLOSE:
      if XmlState = _XML_FLUSHED then
        cmdDone := FALSE;
        asyncID$DINT := FileSys.FileClose_A(1, FileHandle);
        XmlState := _XML_CLOSING;
      end_if;
      
      if XmlState = _XML_CLOSING then
        
        AsyncState := FileSys.GetAsyncState(asyncID, #fctRetval);
        if (AsyncState = 0) | (AsyncState = RT_ERG_DELETED) then
          cmdDone := TRUE;
          StdLib.Free(FileName);
          XmlState := _XML_CLOSED;
        end_if;
        
      end_if;
      
  end_case;

END_FUNCTION


FUNCTION GLOBAL _XMLWriter::FileCreate
	VAR_INPUT
		pName 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
  	NameLen   : UDINT;
  END_VAR
  
  if pName = NIL then
    retcode := -1;
    return;
  end_if;

  
  NameLen := _strlen(pName) + 1;
  
  FileName$^void := StdLib.Malloc(NameLen);
  if FileName = NIL then
    retcode := -2;
    XmlState := _XML_ERROR;
    XmlError := _MEMORY_OP_FAILED;
    return;
  end_if;
  
  // save FileName 
  _strcpy(FileName, pName);
  
  
  if XmlState = _XML_ERROR then
    retcode := -3;
    return;
  end_if;
  
  // put create-cmd to stack
  retcode := PutCMD(_CMD_CREATE);
  
END_FUNCTION


FUNCTION GLOBAL _XMLWriter::WriteStartDocument
	VAR_INPUT
		pEncoding 	: ^USINT;
		insertBOM 	: BOOL;(* := FALSE *)
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
  	LenEncoding  : UDINT;
  END_VAR

  if pEncoding = NIL then
    retcode := -1;
    return;
  end_if;
  
  if XmlState = _XML_ERROR then
    retcode := -3;
    return;
  end_if;
  
  
  //check unicode  
  LenEncoding := _strlen(pEncoding);
  if LenEncoding > (XML_MAX_HEADER_LENGTH-66) then //33 bytes need ascii and 66 unicode
    XmlState := _XML_ERROR;
    XmlError := _WRITING_FAILED;
    retcode := -4;
    return;
  end_if;

  if _stricmp(pEncoding, STRING_UTF16) = 0 then
    bWrIsUnicode := TRUE;
  else
    bWrIsUnicode := FALSE;
  end_if;  
  
  if xmlStruct.Header <> NIL then
    StdLib.Free(xmlStruct.Header);
    xmlStruct.Header := NIL;
  end_if;
  
  xmlStruct.Header$^void := StdLib.Malloc(XML_MAX_HEADER_LENGTH);
  
  if xmlStruct.Header = NIL then
    retcode := -1;
    return;
  end_if;

  _memset(dest:=xmlStruct.Header, usByte:=0, cntr:=XML_MAX_HEADER_LENGTH);

  
  if bWrIsUnicode = TRUE then
    retcode := WriteStartDocumentUni(pEncoding);
  else
    retcode := WriteStartDocumentAscii(pEncoding, insertBOM);
  end_if;


END_FUNCTION


FUNCTION GLOBAL _XMLWriter::WriteStartElement
	VAR_INPUT
		pName 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  
  if XmlState = _XML_ERROR then
    retcode := -3;
    return;
  end_if;
  
  retcode := StructCreator.AddElement(pName, bWrIsUnicode);
  
END_FUNCTION


FUNCTION GLOBAL _XMLWriter::WriteAttributeString
	VAR_INPUT
		pName 	: ^USINT;
		pValue 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  
  if XmlState = _XML_ERROR then
    retcode := -3;
    return;
  end_if;
  
  retcode := StructCreator.AddAttribute(pName, pValue, bWrIsUnicode); 
    
END_FUNCTION


FUNCTION GLOBAL _XMLWriter::WriteTextString
	VAR_INPUT
		pText 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  
  if XmlState = _XML_ERROR then
    retcode := -3;
    return;
  end_if;
  
  retcode := StructCreator.AddText(pText, bWrIsUnicode);
  
END_FUNCTION


FUNCTION GLOBAL _XMLWriter::WriteElementString
	VAR_INPUT
		pName 	: ^USINT;
		pText 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  
  if XmlState = _XML_ERROR then
    retcode := -3;
    return;
  end_if;
  
  retcode := StructCreator.AddElement(pName, bWrIsUnicode); 
  
  if retcode < 0 then
    return;
  end_if;

  retcode := StructCreator.AddText(pText, bWrIsUnicode); 
  
  if retcode < 0 then
    retcode := -4;
    return;
  end_if;
  
  retcode := StructCreator.CloseElement(NIL, bWrIsUnicode); 
  
END_FUNCTION


FUNCTION GLOBAL _XMLWriter::WriteEndElement
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  
  if XmlState = _XML_ERROR then
    retcode := -3;
    return;
  end_if;
  
  retcode := StructCreator.CloseElement(NIL, bWrIsUnicode);
  
END_FUNCTION


FUNCTION GLOBAL _XMLWriter::WriteEndDocument
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  
  if XmlState = _XML_ERROR then
    retcode := -3;
    return;
  end_if;
  
  retcode := StructCreator.CloseElement(NIL, bWrIsUnicode);
  
  if retcode < 0 then
    return;
  end_if;

  if xmlStruct.MajorElement^.isClosed then
    flushAllowed := TRUE;
  else
    retcode := -4;
  end_if;

END_FUNCTION


FUNCTION GLOBAL _XMLWriter::Flush
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  
  if flushAllowed = FALSE then
    retcode := -2;
    return;
  end_if;
  
  
  if XmlState = _XML_ERROR then
    retcode := -3;
    return;
  end_if;
  //else set cmd
  retcode := PutCMD(_CMD_FLUSH);
  
END_FUNCTION


FUNCTION GLOBAL _XMLWriter::FileClose
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  
  if XmlState = _XML_ERROR then
    retcode := -3;
    return;
  end_if;
  retcode := PutCMD(_CMD_CLOSE);
  
END_FUNCTION


FUNCTION _XMLWriter::CreateXmlString
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  
  if bWrIsUnicode = TRUE then
    retcode := CreateXmlStringUni();
  else
    retcode := CreateXmlStringAscii();
  end_if;
  
END_FUNCTION


FUNCTION _XMLWriter::FreeXML
  
  // call method of XMLStructCreator
  StructCreator.FreeStruct();
  
END_FUNCTION


FUNCTION _XMLWriter::PutCMD
	VAR_INPUT
		cmd 	: _XML_CMD;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  
  // add cmd to FIFO
 
 if bufferEmpty = TRUE then
    
    // buffer is empty so add cmd and inc iLast
    cmdStack[iLast] := cmd;
    bufferEmpty := FALSE;
    retcode := 0;
    
    if iLast = 49 then
      iLast := 0; // back to beginning
    else
      iLast += 1; // one higher
    end_if;
    
  else  // bufferEmpty = FALSE
    
    // check if buffer is full
    if iLast = iFirst then
    
      retcode := -1;
    
    else
    
      // insert and increase
      cmdStack[iLast] := cmd;
      retcode := 0;
      
      if iLast = 49 then
        iLast := 0; // back to beginning
      else
        iLast += 1; // one higher
      end_if;
    
    end_if;
    
  end_if;
  
END_FUNCTION


FUNCTION _XMLWriter::GetCMD
	VAR_OUTPUT
		cmd 	: _XML_CMD;
	END_VAR
  
  // get cmd from FIFO
  
  if bufferEmpty = TRUE then
    cmd := _CMD_WAIT; // nothing to do
    return;
  end_if;
  
  cmd := cmdStack[iFirst];
  cmdStack[iFirst] := 0; // just a mark that we got the cmd out of the stack
  
  if iFirst = 49 then
    iFirst := 0;
  else
    iFirst += 1;
  end_if;
  
  //check if we got the last element
  if iFirst = iLast then
    bufferEmpty := TRUE;
  end_if;
  
END_FUNCTION


FUNCTION GLOBAL _XMLWriter::SetStruct
	VAR_INPUT
		pStruct 	: ^_XML_FILE;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  
  retcode := FALSE;
  
  if pStruct = NIL then
    XmlState := _XML_ERROR; 
    XmlError := _CREATING_FAILED;
    return;   
  end_if;

  if XmlState = _XML_ERROR then
    return;
  end_if;
  
  if xmlStruct.Header <> NIL then
    StdLib.Free(xmlStruct.Header);
    xmlStruct.Header := NIL;
  end_if;

  
  xmlStruct.Header$^void := StdLib.Malloc(XML_MAX_HEADER_LENGTH);
  
  if xmlStruct.Header = NIL then
    return;
  end_if;

  _memset(dest:=xmlStruct.Header, usByte:=0, cntr:=XML_MAX_HEADER_LENGTH);
  
  bWrisUnicode := FileIsUnicode(pStruct^.Header);
  
  if bWrIsUnicode then
  
    if ( (SigCLib.StrLen16(str0:=(pStruct^.Header)$^UINT) + 1) * 2) > XML_MAX_HEADER_LENGTH then
      StdLib.Free(xmlStruct.Header);
      xmlStruct.Header := NIL;
      XmlState := _XML_ERROR;
      XmlError := _CREATING_FAILED;
      return;
    end_if;
    SigCLib.StrCpy16(dst0:=xmlStruct.Header$^UINT, src0:=(pStruct^.Header)$^UINT);
    
  else     
  
    if (_strlen(pStruct^.Header) + 1) > XML_MAX_HEADER_LENGTH then
      StdLib.Free(xmlStruct.Header);
      xmlStruct.Header := NIL;
      XmlState := _XML_ERROR;
      XmlError := _CREATING_FAILED;
      return;
    end_if;
    _strcpy(xmlStruct.Header, pStruct^.Header);
    
  end_if;

  
  xmlStruct.MajorElement := pStruct^.MajorElement;
  
  StructCreator.SetStructPtr(#xmlStruct);
  
  bFreeAfterFlush := FALSE; // user read struct from file -> freeing will be done in XMLReader::FreeReader()
  
  flushAllowed := TRUE;
  
  retcode := TRUE;
  
END_FUNCTION


FUNCTION GLOBAL _XMLWriter::Reset
  
  // Function 4 resetting Writer if an error occured
  if XmlState = _XML_ERROR then 
    
    StructCreator.FreeStruct();
    XmlState := _XML_IDLE;
    XmlError := _NO_ERROR;
    cmdDone := TRUE;
    
    _memset(dest:=#cmdStack, usByte:=0, cntr:=sizeof(cmdStack)); 

    if FileText = NIL then
      // alloc memory for FileString
      FileText$^void := StdLib.Malloc(MaxFileSize$UDINT);
      if FileText = NIL then
        XmlState := _XML_ERROR;
        XmlError := _MEMORY_OP_FAILED;
      else
        _memset(FileText, 0, MaxFileSize$UDINT);
      end_if;      
    else
      _memset(FileText, 0, MaxFileSize$UDINT);    
    end_if;
    
  end_if;
  
END_FUNCTION


FUNCTION _XMLWriter::WriteStartDocumentAscii
	VAR_INPUT
		pEncoding 	: ^USINT;
		insertBOM 	: BOOL;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
  	LenEncoding : UDINT;
    pTempHead   : ^USINT;
  END_VAR


  flushAllowed := FALSE;
  bFreeAfterFlush := TRUE; // we created a new File -> free struct after Flush()
  
  pTempHead := xmlStruct.Header; 
  
  // sprdie: v1.3 - insert BOM -----
  if (insertBOM = TRUE) & (_strcmp(pEncoding, STRING_UTF8) = 0) then
    pTempHead^ := 16#EF;
    pTempHead += sizeof(USINT);
    pTempHead^ := 16#BB;
    pTempHead += sizeof(USINT);
    pTempHead^ := 16#BF;
    pTempHead += sizeof(USINT);
  end_if;
  // -------------------------------
  
  // user starts to "write" -> set Header and allocate memory 4 MajorElement
  _strcpy(pTempHead, "<?xml version=");
  pTempHead += 14;
  pTempHead^ := XML_QUOTMARK; (* " *)
  pTempHead += 1;
  _strcpy(pTempHead, "1.0");
  pTempHead += 3;
  pTempHead^ := XML_QUOTMARK; (* " *)
  pTempHead += 1; 
  _strcpy(pTempHead, " encoding=");
  pTempHead += 10; //byte nr 29
  pTempHead^ := XML_QUOTMARK; (* " *)
  LenEncoding := _strlen(pEncoding);
  if LenEncoding > (XML_MAX_HEADER_LENGTH-33) then
    XmlState := _XML_ERROR;
    XmlError := _WRITING_FAILED;
    retcode := -4;
    return;
  end_if;
  
  pTempHead += 1;
  _strcpy(pTempHead, pEncoding);
  pTempHead += LenEncoding;
  pTempHead^ := XML_QUOTMARK; (* " *)
  pTempHead += 1; //byte nr 31 + LenEncoding (byte 30 + LenEncoding)
  _strcpy(pTempHead, "?>");
  
  
  xmlStruct.MajorElement$^void := StdLib.Malloc(sizeof(_XML_ELEMENT));
  
  if xmlStruct.MajorElement = NIL then
    // XmlError at getting memory for Element
    XmlState := _XML_ERROR;
    XmlError := _MEMORY_OP_FAILED;
    retcode := -2;
    return;
  end_if;
  
  // set content from Element to 0
  _memset(xmlStruct.MajorElement, 0, sizeof(_XML_ELEMENT));
  
  // set struct of Struct creator
  StructCreator.SetStructPtr(#xmlStruct);
  
  retcode := 0;
  
END_FUNCTION //WriteStartDocumentAscii


FUNCTION _XMLWriter::WriteStartDocumentUni
	VAR_INPUT
		pEncoding 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
  	LenEncoding : UDINT;
    ptemppointer : ^USINT;
    ptempHead : ^USINT;
  END_VAR

  ptemppointer$^void := StdLib.Malloc(size:=XML_MAX_HEADER_LENGTH);
  if ptemppointer = NIL then
    XmlState := _XML_ERROR;
    XmlError := _MEMORY_OP_FAILED;
    retcode := -2;
    return;
  end_if;

  _memset(dest:=ptemppointer, usByte:=0, cntr:=XML_MAX_HEADER_LENGTH);
  flushAllowed := FALSE;
  bFreeAfterFlush := TRUE; // we created a new File -> free struct after Flush()
  
  ptempHead := xmlStruct.Header;
  
  _strcpy(ptemppointer, "<?xml version=");
  SigCLib.ToStr16(dst0:=pTempHead$^UINT, src0:=ptemppointer);
  // user starts to "write" -> set Header and allocate memory 4 MajorElement
  
  ptempHead += 28;
  ptempHead$^UINT^ := XML_QUOTMARK_UNI;

  _memset(dest:=ptemppointer, usByte:=0, cntr:=30);
  _strcpy(ptemppointer, "1.0");
  ptemphead += 2;
  SigCLib.ToStr16(dst0:=pTempHead$^UINT, src0:=ptemppointer);
  //_strcpy(#xmlStruct.Header[15], "1.0");
  
  ptemphead += 6;
  ptempHead$^UINT^ := XML_QUOTMARK_UNI; 
  //xmlStruct.Header[18] := XML_QUOTMARK; (* " *)
  
  
  _memset(dest:=ptemppointer, usByte:=0, cntr:=30);
  _strcpy(ptemppointer," encoding=");
  ptemphead += 2;
  SigCLib.ToStr16(dst0:=pTempHead$^UINT, src0:=ptemppointer); 
  //_strcpy(#xmlStruct.Header[19], " encoding=");
  

  ptemphead += 20;
  pTempHead$^UINT^ :=XML_QUOTMARK_UNI;   
  //xmlStruct.Header[29] := XML_QUOTMARK; (* " *)
  
  _memset(dest:=ptemppointer, usByte:=0, cntr:=30);
  _strcpy(ptemppointer, pEncoding);
  ptemphead += 2;
  SigCLib.ToStr16(dst0:=pTempHead$^UINT, src0:=ptemppointer);   
//  _strcpy(#xmlStruct.Header[30], pEncoding);  
  
  LenEncoding := SigCLib.StrLen16(pTempHead$^UINT) * 2;
  if LenEncoding > (XML_MAX_HEADER_LENGTH-66) then 
    XmlState := _XML_ERROR;
    XmlError := _WRITING_FAILED;
    retcode := -4;
    StdLib.Free(ptemppointer);
    return;
  end_if;

  ptemphead += LenEncoding; 
  ptempHead$^UINT^ := XML_QUOTMARK_UNI;
  //xmlStruct.Header[30+LenEncoding] := XML_QUOTMARK; (* " *)
  
  _memset(dest:=ptemppointer, usByte:=0, cntr:=30);
  _strcpy(ptemppointer,"?>");
  ptemphead += 2;
  SigCLib.ToStr16(dst0:=pTempHead$^UINT, src0:=ptemppointer);    
  //_strcpy(#xmlStruct.Header[31+LenEncoding], "?>");
  
  xmlStruct.MajorElement$^void := StdLib.Malloc(sizeof(_XML_ELEMENT));
  
  if xmlStruct.MajorElement = NIL then
    // XmlError at getting memory for Element
    XmlState := _XML_ERROR;
    XmlError := _MEMORY_OP_FAILED;
    retcode := -2;
    StdLib.Free(ptemppointer);
    return;
  end_if;
  
  // set content from Element to 0
  _memset(xmlStruct.MajorElement, 0, sizeof(_XML_ELEMENT));
  
  // set struct of Struct creator
  StructCreator.SetStructPtr(#xmlStruct);
  
  StdLib.Free(ptemppointer);
  
  retcode := 0;
  
END_FUNCTION //WriteStartDocumentUni


FUNCTION _XMLWriter::CreateXmlStringAscii
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	pElement      : ^_XML_ELEMENT;
    pAttrib       : ^_XML_ATTRIBUTE;
    depth         : UDINT;
    i             : UDINT;
    jumpedBack    : BOOL;
    pText         : ^USINT;
    tmpIndex      : UDINT;
  END_VAR
  
  // so here starts the most work
  // we have to create an xml file out of the structure
  // this contains adding '<', '>', '/', CR, LF & TABs
  
  retcode := FALSE;
  
  Index := 0;
  jumpedBack := FALSE;
  
  if xmlStruct.MajorElement = NIL then
    return; //no readfile was made
  end_if;
  
//  _memset(FileText, 0, MaxFileSize$UDINT);
  
  pText := FileText;
  
  Index += _strlen(xmlStruct.Header);
  if Index > MaxFileSize$UDINT then
    return;
  end_if;
  _strcpy(pText, xmlStruct.Header);
  pText := FileText + Index;
  
  pText^ := XML_CR;
  Index += 1;
  pText := FileText + Index;
  if Index > MaxFileSize$UDINT then
    return;
  end_if;
  pText^ := XML_LF;
  Index += 1;
  pText := FileText + Index;
  if Index > MaxFileSize$UDINT then
    return;
  end_if;

  // now set the pointer to the first element
  pElement := xmlStruct.MajorElement;
  depth := 0;
  
  // now we have to find the right algorithm to go through the struct and create the text
  // we start writing out the MajorElement, then go to the children
  // there we write out the next element, check for children and then we go deeper 
  // or stay on the same level (in case that the element has children or not)
  // when there are no children left and we are the last brother we have to go back to the father
  // when we reached the major element again we finished
  // on start of an element we also have to check for attributes
  // every time we go to a child we set the depth (value how much tabs we need - just for nice formatting)
  
  // <MajorElement>
  pText^ := XML_START;
  Index += 1;
  pText := FileText + Index;
  if Index > MaxFileSize$UDINT then
    return;
  end_if;
  if pElement^.Name = NIL then
    return; 
  end_if;

  Index += _strlen(pElement^.Name);
  if Index > MaxFileSize$UDINT then
    return;
  end_if;
  _strcpy(pText, pElement^.Name);
  pText := FileText + Index;  
  
  //check if MajorElement has Attributes
  if pElement^.Attributes.no <> 0 then
          
    // add Attributes
    pAttrib := pElement^.Attributes.pList;
    for i := 1 to pElement^.Attributes.no do
      
      pText^ := XML_SPACE;
      Index += 1;
      pText := FileText + Index;
      if Index > MaxFileSize$UDINT then
        return;
      end_if;
      
      Index += _strlen(pAttrib^.Name);
      if Index > MaxFileSize$UDINT then
        return;
      end_if;
      _strcpy(pText, pAttrib^.Name);
      pText := FileText + Index;
      
      pText^ := XML_EQUAL;
      Index += 1;
      pText := FileText + Index;
      if Index > MaxFileSize$UDINT then
        return;
      end_if;
      pText^ := XML_QUOTMARK;
      Index += 1;
      pText := FileText + Index;
      if Index > MaxFileSize$UDINT then
        return;
      end_if;
      
      // sprdie v1.4 - convert special characters ----------
      if (DoConvert = TRUE) then
        
        // first check if there is enough space left
        tmpIndex := Index;
        tmpIndex += CalculateConvertedSizeAscii(pAttrib^.Value);
        if (tmpIndex > MaxFileSize$UDINT) then
          return;
        end_if;
        
        // now convert and insert directly to the file-string
        Index$DINT += ConvertTextToXML(pText, pAttrib^.Value, sizeof(CHAR));
        pText := FileText + Index;
      // ---------------------------------------------------
      else
        // no convertion - do same work as before
        Index += _strlen(pAttrib^.Value);
        if Index > MaxFileSize$UDINT then
          return;
        end_if;
        _strcpy(pText, pAttrib^.Value);
        pText := FileText + Index;
      end_if;
      
      pText^ := XML_QUOTMARK;
      Index += 1;
      pText := FileText + Index;
      if Index > MaxFileSize$UDINT then
        return;
      end_if;
      
      pAttrib += sizeof(_XML_ATTRIBUTE);
      
    end_for;
    
  end_if;
  
  pText^ := XML_END;
  Index += 1;
  pText := FileText + Index;
  if Index > MaxFileSize$UDINT then
    return;
  end_if;
  
  // next Line
  pText^ := XML_CR;
  Index += 1;
  pText := FileText + Index;
  if Index > MaxFileSize$UDINT then
    return;
  end_if;
  pText^ := XML_LF;
  Index += 1;
  pText := FileText + Index;
  if Index > MaxFileSize$UDINT then
    return;
  end_if;
  
  if pElement^.pChildren <> NIL then
    // if we dont have a child after the major element we can just close the element
    // if this really happens we are finished after doing this!
    // but in this case we have at least 1 child so lets do some work !!
    
    pElement := pElement^.pChildren;
    depth += 1;
    
    while pElement <> xmlStruct.MajorElement do
      
      // add TABS
      for i := 1 to depth do
        pText^ := XML_TABULATOR;
        Index += 1;
        pText := FileText + Index;
        if Index > MaxFileSize$UDINT then
          return;
        end_if;
      end_for;
      
      if jumpedBack = FALSE then
        // now add the element
        pText^ := XML_START;
        Index += 1;
        pText := FileText + Index;
        if Index > MaxFileSize$UDINT then
          return;
        end_if;
        
        Index += _strlen(pElement^.Name);
        if Index > MaxFileSize$UDINT then
          return;
        end_if;
        _strcpy(pText, pElement^.Name);
        pText := FileText + Index;
        
        // now check if we have to add Attributes
        if pElement^.Attributes.no <> 0 then
          
          // add Attributes
          pAttrib := pElement^.Attributes.pList;
          for i := 1 to pElement^.Attributes.no do
            
            pText^ := XML_SPACE;
            Index += 1;
            pText := FileText + Index;
            if Index > MaxFileSize$UDINT then
              return;
            end_if;
            
            Index += _strlen(pAttrib^.Name);
            if Index > MaxFileSize$UDINT then
              return;
            end_if;
            _strcpy(pText, pAttrib^.Name);
            pText := FileText + Index;
           
            pText^ := XML_EQUAL;
            Index += 1;
            pText := FileText + Index;
            if Index > MaxFileSize$UDINT then
              return;
            end_if;
            pText^ := XML_QUOTMARK;
            Index += 1;
            pText := FileText + Index;
            if Index > MaxFileSize$UDINT then
              return;
            end_if;
            
            // sprdie v1.4 - convert special characters ----------
            if (DoConvert = TRUE) then
              
              // first check if there is enough space left
              tmpIndex := Index;
              tmpIndex += CalculateConvertedSizeAscii(pAttrib^.Value);
              if (tmpIndex > MaxFileSize$UDINT) then
                return;
              end_if;
              
              // now convert and insert directly to the file-string
              Index$DINT += ConvertTextToXML(pText, pAttrib^.Value, sizeof(CHAR));
              pText := FileText + Index;
            // ---------------------------------------------------
            else
              Index += _strlen(pAttrib^.Value);
              if Index > MaxFileSize$UDINT then
                return;
              end_if;
              _strcpy(pText, pAttrib^.Value);
              pText := FileText + Index;
            end_if;
            
            pText^ := XML_QUOTMARK;
            Index += 1;
            pText := FileText + Index;
            if Index > MaxFileSize$UDINT then
              return;
            end_if;
            
            pAttrib += sizeof(_XML_ATTRIBUTE);
            
          end_for;
          
        end_if;
        
        // close Element
        pText^ := XML_END;
        Index += 1;
        pText := FileText + Index;
        if Index > MaxFileSize$UDINT then
          return;
        end_if;
        
        // now check for a text behind the element
        if pElement^.pText <> NIL then
          
          // sprdie v1.4 - convert special characters ----------
          if (DoConvert = TRUE) then
            
            // first check if there is enough space left
            tmpIndex := Index;
            tmpIndex += CalculateConvertedSizeAscii(pElement^.pText);
            if (tmpIndex > MaxFileSize$UDINT) then
              return;
            end_if;
            
            // now convert and insert directly to the file-string
            Index$DINT += ConvertTextToXML(pText, pElement^.pText, sizeof(CHAR));
            pText := FileText + Index;
          // ---------------------------------------------------
          else
            // add Text
            Index += _strlen(pElement^.pText);
            if Index > MaxFileSize$UDINT then
              return;
            end_if;
            _strcpy(pText, pElement^.pText);
            pText := FileText + Index;
          end_if;
          
        end_if;
      
      else
        
        // we jumped back so we just have to add a closing Element
        pText^ := XML_START;
        Index += 1;
        pText := FileText + Index;
        if Index > MaxFileSize$UDINT then
          return;
        end_if;
        pText^ := XML_SLASH;
        Index += 1;
        pText := FileText + Index;
        if Index > MaxFileSize$UDINT then
          return;
        end_if;
        
        Index += _strlen(pElement^.Name);
        if Index > MaxFileSize$UDINT then
          return;
        end_if;
        _strcpy(pText, pElement^.Name);
        pText := FileText + Index;
        
        pText^ := XML_END;
        Index += 1;
        pText := FileText + Index;
        if Index > MaxFileSize$UDINT then
          return;
        end_if;
        
      end_if;
      
      // so now check for children but only if we have not closed the actual element
      if (pElement^.pChildren <> NIL) & (jumpedBack = FALSE) then
        
        // point to child and inc depth
        pElement := pElement^.pChildren;
        depth += 1;
        
        // new Line
        pText^ := XML_CR;
        Index += 1;
        pText := FileText + Index;
        if Index > MaxFileSize$UDINT then
          return;
        end_if;
        pText^ := XML_LF;
        Index += 1;
        pText := FileText + Index;
        if Index > MaxFileSize$UDINT then
          return;
        end_if;
        
      else
      
        // Element has no child or is already closed -> check for brother
        if pElement^.pNext <> NIL then
        
          // point to brother, but first close the Element (only if it isn't already closed)
          if jumpedBack = FALSE then
            // we have to close the Element in the same Line because it is a single Element
            // check how we have to close the Element '</Element>' or '/>'
            if pElement^.pText <> NIL then
              // </Element>
              pText^ := XML_START;
              Index += 1;
              pText := FileText + Index;
              if Index > MaxFileSize$UDINT then
                return;
              end_if;
              pText^ := XML_SLASH;
              Index += 1;
              pText := FileText + Index;
              if Index > MaxFileSize$UDINT then
                return;
              end_if;
              
              Index += _strlen(pElement^.Name);
              if Index > MaxFileSize$UDINT then
                return;
              end_if;
              _strcpy(pText, pElement^.Name);
              pText := FileText + Index;
              
              pText^ := XML_END;
              Index += 1;
              pText := FileText + Index;
              if Index > MaxFileSize$UDINT then
                return;
              end_if;
              
            else
              // />
              (pText-1)^ := XML_SLASH;
              pText^   := XML_END;
              Index += 1;
              pText := FileText + Index;
              if Index > MaxFileSize$UDINT then
                return;
              end_if;
              
            end_if;
            
            pElement := pElement^.pNext;
            
            // new Line
            pText^ := XML_CR;
            Index += 1;
            pText := FileText + Index;
            if Index > MaxFileSize$UDINT then
              return;
            end_if;
            pText^ := XML_LF;
            Index += 1;
            pText := FileText + Index;
            if Index > MaxFileSize$UDINT then
              return;
            end_if;
          
          else
            
            pElement := pElement^.pNext;
            
            // new Line
            pText^ := XML_CR;
            Index += 1;
            pText := FileText + Index;
            if Index > MaxFileSize$UDINT then
              return;
            end_if;
            pText^ := XML_LF;
            Index += 1;
            pText := FileText + Index;
            if Index > MaxFileSize$UDINT then
              return;
            end_if;
            
          end_if;
          
          jumpedBack := FALSE;
          
        else
        
          // no child or brother available
          // this means we have to go back to the father Element and then close it 
          // (also set mark that in next step we are closing the open element)
          // but first close actual element (if needed)
          if jumpedBack = FALSE then
            // we have to close the Element in the same Line because it is a single Element
            // check how we have to close the Element '</Element>' or '/>'
            if pElement^.pText <> NIL then
              // </Element>
              pText^ := XML_START;
              Index += 1;
              pText := FileText + Index;
              if Index > MaxFileSize$UDINT then
                return;
              end_if;
              pText^ := XML_SLASH;
              Index += 1;
              pText := FileText + Index;
              if Index > MaxFileSize$UDINT then
                return;
              end_if;
              
              Index += _strlen(pElement^.Name);
              if Index > MaxFileSize$UDINT then
                return;
              end_if;
              _strcpy(pText, pElement^.Name);
              pText := FileText + Index;
              
              pText^ := XML_END;
              Index += 1;
              pText := FileText + Index;
              if Index > MaxFileSize$UDINT then
                return;
              end_if;
              
            else
              // />
              (pText-1)^ := XML_SLASH;
              pText^   := XML_END;
              Index += 1;
              pText := FileText + Index;
              if Index > MaxFileSize$UDINT then
                return;
              end_if;
              
            end_if;
            
          end_if;
          
          // so now go backwards to the father
          while pElement^.pPrevious <> NIL do
            pElement := pElement^.pPrevious;
          end_while;
          
          if pElement^.pFather <> NIL then
            
            pElement := pElement^.pFather;
            
            depth -= 1; // now we are one level higher
            
            // we went back to father so all his children and children of the children (and so on...) are done
            jumpedBack := TRUE;
            
            // new Line
            pText^ := XML_CR;
            Index += 1;
            pText := FileText + Index;
            if Index > MaxFileSize$UDINT then
              return;
            end_if;
            pText^ := XML_LF;
            Index += 1;
            pText := FileText + Index;
            if Index > MaxFileSize$UDINT then
              return;
            end_if;
            
          end_if;
          
        end_if;
      
      end_if;
      
    end_while;
    
  end_if;
  
  // now close the Major Element
  pText^ := XML_START;
  Index += 1;
  pText := FileText + Index;
  if Index > MaxFileSize$UDINT then
    return;
  end_if;
  pText^ := XML_SLASH;
  Index += 1;
  pText := FileText + Index;
  if Index > MaxFileSize$UDINT then
    return;
  end_if;
  
  Index += _strlen(pElement^.Name);
  if Index > MaxFileSize$UDINT then
    return;
  end_if;
  _strcpy(pText, pElement^.Name);
  pText := FileText + Index;
  
  pText^ := XML_END;
  Index += 1;
  pText := FileText + Index;
  if Index > MaxFileSize$UDINT then
    return;
  end_if;

  // when we reached this point without any problems we created the whole .xml-File as a String - well done!
  retcode := TRUE;
  
END_FUNCTION //CreateXmlAscii


FUNCTION _XMLWriter::CreateXmlStringUni
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	pElement      : ^_XML_ELEMENT;
    pAttrib       : ^_XML_ATTRIBUTE;
    depth         : UDINT;
    i             : UDINT;
    jumpedBack    : BOOL;
    pText         : ^USINT;
    tmpIndex      : UDINT;
  END_VAR
  
  // so here starts the most work
  // we have to create an xml file out of the structure
  // this contains adding '<', '>', '/', CR, LF & TABs
  
  retcode := FALSE;
  
  Index := 0;
  jumpedBack := FALSE;
  
  if xmlStruct.MajorElement = NIL then
    return; //no readfile was made
  end_if;
  
//  _memset(FileText, 0, MaxFileSize$UDINT); // sprdie v1.3 - not really needed
  
  pText := FileText;
  
  Index += 2;
  pText^ := 16#FF;
  (pText+1)^ := 16#FE;
  pText := FileText + Index;
  
  // the beginning will be the header
  Index += SigCLib.StrLen16(xmlStruct.Header$^UINT) * 2;
  if Index > MaxFileSize$UDINT then
    return;
  end_if;
  SigCLib.StrCpy16(pText$^UINT, xmlStruct.Header$^UINT);
  pText := FileText + Index;
  
  (pText$^UINT)^ := XML_CR_UNI;
  Index += 2;
  pText := FileText + Index;
  if Index > MaxFileSize$UDINT then
    return;
  end_if;
  
  (pText$^UINT)^ := XML_LF_UNI;
  Index += 2;
  pText := FileText + Index;
  if Index > MaxFileSize$UDINT then
    return;
  end_if;

  // now set the pointer to the first element
  pElement := xmlStruct.MajorElement;
  depth := 0;
  
  // now we have to find the right algorithm to go through the struct and create the text
  // we start writing out the MajorElement, then go to the children
  // there we write out the next element, check for children and then we go deeper 
  // or stay on the same level (in case that the element has children or not)
  // when there are no children left and we are the last brother we have to go back to the father
  // when we reached the major element again we finished
  // on start of an element we also have to check for attributes
  // every time we go to a child we set the depth (value how much tabs we need - just for nice formatting)
  
  // <MajorElement>
  (pText$^UINT)^ := XML_START_UNI;
  Index += 2;
  pText := FileText + Index;
  if Index > MaxFileSize$UDINT then
    return;
  end_if;
  if pElement^.Name = NIL then
    return; 
  end_if;

  Index += SigCLib.StrLen16(pElement^.Name$^UINT) * 2;
  if Index > MaxFileSize$UDINT then
    return;
  end_if;
  SigCLib.StrCpy16(pText$^UINT, pElement^.Name$^UINT);
  pText := FileText + Index;
  
  //check if MajorElement has Attributes
  if pElement^.Attributes.no <> 0 then
          
    // add Attributes
    pAttrib := pElement^.Attributes.pList;
    for i := 1 to pElement^.Attributes.no do
      
      (pText$^UINT)^ := XML_SPACE_UNI;
      Index += 2;
      pText := FileText + Index;
      if Index > MaxFileSize$UDINT then
        return;
      end_if;
      
      Index += SigCLib.StrLen16(pAttrib^.Name$^UINT) * 2;
      if Index > MaxFileSize$UDINT then
        return;
      end_if;
      SigCLib.StrCpy16(pText$^UINT, pAttrib^.Name$^UINT); 
      pText := FileText + Index;
      
      (pText$^UINT)^ := XML_EQUAL_UNI;
      Index += 2;
      pText := FileText + Index;
      if Index > MaxFileSize$UDINT then
        return;
      end_if;
      (pText$^UINT)^ := XML_QUOTMARK_UNI;
      Index += 2;
      pText := FileText + Index;
      if Index > MaxFileSize$UDINT then
        return;
      end_if;
      
      // sprdie v1.4 - convert special characters ----------
      if (DoConvert = TRUE) then
        
        // first check if there is enough space left
        tmpIndex := Index;
        tmpIndex += CalculateConvertedSizeUni(pAttrib^.Value$^UINT)*sizeof(UINT);
        if (tmpIndex > MaxFileSize$UDINT) then
          return;
        end_if;
        
        // now convert and insert directly to the file-string
        Index$DINT += ConvertTextToXML(pText, pAttrib^.Value, sizeof(UINT))*sizeof(UINT);
        pText := FileText + Index;
      // ---------------------------------------------------
      else
        Index += SigCLib.StrLen16(pAttrib^.Value$^UINT) * 2;
        if Index > MaxFileSize$UDINT then
          return;
        end_if;
        SigCLib.StrCpy16(pText$^UINT, pAttrib^.Value$^UINT); 
        pText := FileText + Index;
      end_if;
      
      (pText$^UINT)^ := XML_QUOTMARK_UNI;
      Index += 2;
      pText := FileText + Index;
      if Index > MaxFileSize$UDINT then
        return;
      end_if;
      
      pAttrib += sizeof(_XML_ATTRIBUTE);
      
    end_for;
    
  end_if;
  
  (pText$^UINT)^ := XML_END_UNI;
  Index += 2;
  pText := FileText + Index;
  if Index > MaxFileSize$UDINT then
    return;
  end_if;
  
  // next Line
  (pText$^UINT)^ := XML_CR_UNI;
  Index += 2;
  pText := FileText + Index;
  if Index > MaxFileSize$UDINT then
    return;
  end_if;
  (pText$^UINT)^ := XML_LF_UNI;
  Index += 2;
  pText := FileText + Index;
  if Index > MaxFileSize$UDINT then
    return;
  end_if;
  
  if pElement^.pChildren <> NIL then
    // if we dont have a children after the major element we can just close the element
    // if this really happens we are finished after doing this!
    // but in this case we have at least 1 child so lets do some work !!
    
    pElement := pElement^.pChildren;
    depth += 1;
    
    while pElement <> xmlStruct.MajorElement do
      
      // add TABS
      for i := 1 to depth do
        (pText$^UINT)^ := XML_TABULATOR_UNI;
        Index += 2;
        pText := FileText + Index;
        if Index > MaxFileSize$UDINT then
          return;
        end_if;
      end_for;
      
      if jumpedBack = FALSE then
        // now add the element
        (pText$^UINT)^ := XML_START_UNI;
        Index += 2;
        pText := FileText + Index;
        if Index > MaxFileSize$UDINT then
          return;
        end_if;
        
        Index += SigCLib.StrLen16(pElement^.Name$^UINT) * 2;
        if Index > MaxFileSize$UDINT then
          return;
        end_if;
        SigCLib.StrCpy16(pText$^UINT, pElement^.Name$^UINT);
        pText := FileText + Index;
        
        // now check if we have to add Attributes
        if pElement^.Attributes.no <> 0 then
          
          // add Attributes
          pAttrib := pElement^.Attributes.pList;
          for i := 1 to pElement^.Attributes.no do
            
            (pText$^UINT)^ := XML_SPACE_UNI;
            Index += 2;
            pText := FileText + Index;
            if Index > MaxFileSize$UDINT then
              return;
            end_if;
            
            Index += SigCLib.StrLen16(pAttrib^.Name$^UINT) * 2;
            if Index > MaxFileSize$UDINT then
              return;
            end_if;
            SigCLib.StrCpy16(pText$^UINT, pAttrib^.Name$^UINT);
            pText := FileText + Index;
           
            (pText$^UINT)^ := XML_EQUAL_UNI;
            Index += 2;
            pText := FileText + Index;
            if Index > MaxFileSize$UDINT then
              return;
            end_if;
            (pText$^UINT)^ := XML_QUOTMARK_UNI;
            Index += 2;
            pText := FileText + Index;
            if Index > MaxFileSize$UDINT then
              return;
            end_if;
            
            // sprdie v1.4 - convert special characters ----------
            if (DoConvert = TRUE) then
              
              // first check if there is enough space left
              tmpIndex := Index;
              tmpIndex += CalculateConvertedSizeUni(pAttrib^.Value$^UINT)*sizeof(UINT);
              if (tmpIndex > MaxFileSize$UDINT) then
                return;
              end_if;
              
              // now convert and insert directly to the file-string
              Index$DINT += ConvertTextToXML(pText, pAttrib^.Value, sizeof(UINT))*sizeof(UINT);
              pText := FileText + Index;
            // ---------------------------------------------------
            else
              Index += SigCLib.StrLen16(pAttrib^.Value$^UINT) * 2;
              if Index > MaxFileSize$UDINT then
                return;
              end_if;
              SigCLib.StrCpy16(pText$^UINT, pAttrib^.Value$^UINT);
              pText := FileText + Index;
            end_if;
            
            (pText$^UINT)^ := XML_QUOTMARK_UNI;
            Index += 2;
            pText := FileText + Index;
            if Index > MaxFileSize$UDINT then
              return;
            end_if;
            
            pAttrib += sizeof(_XML_ATTRIBUTE);
            
          end_for;
          
        end_if;
        
        // close Element
        (pText$^UINT)^ := XML_END_UNI;
        Index += 2;
        pText := FileText + Index;
        if Index > MaxFileSize$UDINT then
          return;
        end_if;
        
        // now check for a text behind the element
        if pElement^.pText <> NIL then
          
          // sprdie v1.4 - convert special characters ----------
          if (DoConvert = TRUE) then
            
            // first check if there is enough space left
            tmpIndex := Index;
            tmpIndex += CalculateConvertedSizeUni(pElement^.pText$^UINT)*sizeof(UINT);
            if (tmpIndex > MaxFileSize$UDINT) then
              return;
            end_if;
            
            // now convert and insert directly to the file-string
            Index$DINT += ConvertTextToXML(pText, pElement^.pText, sizeof(UINT))*sizeof(UINT);
            pText := FileText + Index;
          // ---------------------------------------------------
          else
            // add Text
            Index += SigCLib.StrLen16(pElement^.pText$^UINT) * 2;
            if Index > MaxFileSize$UDINT then
              return;
            end_if;
            SigCLib.StrCpy16(pText$^UINT, pElement^.pText$^UINT);
            pText := FileText + Index;
          end_if;
          
        end_if;
      
      else
        
        // we jumped back so we just have to add a closing Element
        (pText$^UINT)^ := XML_START_UNI;
        Index += 2;
        pText := FileText + Index;
        if Index > MaxFileSize$UDINT then
          return;
        end_if;
        (pText$^UINT)^ := XML_SLASH_UNI;
        Index += 2;
        pText := FileText + Index;
        if Index > MaxFileSize$UDINT then
          return;
        end_if;
        
        Index += SigCLib.StrLen16(pElement^.Name$^UINT) * 2;
        if Index > MaxFileSize$UDINT then
          return;
        end_if;
        SigCLib.StrCpy16(pText$^UINT, pElement^.Name$^UINT);
        pText := FileText + Index;
        
        (pText$^UINT)^ := XML_END_UNI;
        Index += 2;
        pText := FileText + Index;
        if Index > MaxFileSize$UDINT then
          return;
        end_if;
        
      end_if;
      
      // so now check for children but only if we have not closed the actual element
      if (pElement^.pChildren <> NIL) & (jumpedBack = FALSE) then
        
        // point to child and inc depth
        pElement := pElement^.pChildren;
        depth += 1;
        
        // new Line
        (pText$^UINT)^ := XML_CR_UNI;
        Index += 2;
        pText := FileText + Index;
        if Index > MaxFileSize$UDINT then
          return;
        end_if;
        (pText$^UINT)^ := XML_LF_UNI;
        Index += 2;
        pText := FileText + Index;
        if Index > MaxFileSize$UDINT then
          return;
        end_if;
        
      else
      
        // Element has no child or is already closed -> check for brother
        if pElement^.pNext <> NIL then
        
          // point to brother, but first close the Element (only if it isn't already closed)
          if jumpedBack = FALSE then
            // we have to close the Element in the same Line because it is a single Element
            // check how we have to close the Element '</Element>' or '/>'
            if pElement^.pText <> NIL then
              // </Element>
              (pText$^UINT)^ := XML_START_UNI;
              Index += 2;
              pText := FileText + Index;
              if Index > MaxFileSize$UDINT then
                return;
              end_if;
              (pText$^UINT)^ := XML_SLASH_UNI;
              Index += 2;
              pText := FileText + Index;
              if Index > MaxFileSize$UDINT then
                return;
              end_if;
              
              Index += SigCLib.StrLen16(pElement^.Name$^UINT) * 2;
              if Index > MaxFileSize$UDINT then
                return;
              end_if;
              SigCLib.StrCpy16(pText$^UINT, pElement^.Name$^UINT);
              pText := FileText + Index;
              
              (pText$^UINT)^ := XML_END_UNI;
              Index += 2;
              pText := FileText + Index;
              if Index > MaxFileSize$UDINT then
                return;
              end_if;
              
            else
              // />
              (pText$^UINT-2)^$UINT := XML_SLASH_UNI;
              (pText$^UINT)^   := XML_END_UNI;
              Index += 2;
              pText := FileText + Index;
              if Index > MaxFileSize$UDINT then
                return;
              end_if;
              
            end_if;
            
            pElement := pElement^.pNext;
            
            // new Line
            (pText$^UINT)^ := XML_CR_UNI;
            Index += 2;
            pText := FileText + Index;
            if Index > MaxFileSize$UDINT then
              return;
            end_if;
            (pText$^UINT)^ := XML_LF_UNI;
            Index += 2;
            pText := FileText + Index;
            if Index > MaxFileSize$UDINT then
              return;
            end_if;
          
          else
            
            pElement := pElement^.pNext;
            
            // new Line
            (pText$^UINT)^ := XML_CR_UNI;
            Index += 2;
            pText := FileText + Index;
            if Index > MaxFileSize$UDINT then
              return;
            end_if;
            (pText$^UINT)^ := XML_LF_UNI;
            Index += 2;
            pText := FileText + Index;
            if Index > MaxFileSize$UDINT then
              return;
            end_if;
            
          end_if;
          
          jumpedBack := FALSE;
          
        else
        
          // no child or brother available
          // this means we have to go back to the father Element and then close it 
          // (also set mark that in next step we are closing the open element)
          // but first close actual element (if needed)
          if jumpedBack = FALSE then
            // we have to close the Element in the same Line because it is a single Element
            // check how we have to close the Element '</Element>' or '/>'
            if pElement^.pText <> NIL then
              // </Element>
              (pText$^UINT)^ := XML_START_UNI;
              Index += 2;
              pText := FileText + Index;
              if Index > MaxFileSize$UDINT then
                return;
              end_if;
              (pText$^UINT)^ := XML_SLASH_UNI;
              Index += 2;
              pText := FileText + Index;
              if Index > MaxFileSize$UDINT then
                return;
              end_if;
              
              Index += SigCLib.StrLen16(pElement^.Name$^UINT) * 2;
              if Index > MaxFileSize$UDINT then
                return;
              end_if;
              SigCLib.StrCpy16(pText$^UINT, pElement^.Name$^UINT);
              pText := FileText + Index;
              
              (pText$^UINT)^ := XML_END_UNI;
              Index += 2;
              pText := FileText + Index;
              if Index > MaxFileSize$UDINT then
                return;
              end_if;
              
            else
              // />
              (pText$^UINT-2)^ := XML_SLASH_UNI;
              (pText$^UINT)^   := XML_END_UNI;
              Index += 2;
              pText := FileText + Index;
              if Index > MaxFileSize$UDINT then
                return;
              end_if;
              
            end_if;
            
          end_if;
          
          // so now go backwards to the father
          while pElement^.pPrevious <> NIL do
            pElement := pElement^.pPrevious;
          end_while;
          
          if pElement^.pFather <> NIL then
            
            pElement := pElement^.pFather;
            
            depth -= 1; // now we are one level higher
            
            // we went back to father so all his children and children of the children (and so on...) are done
            jumpedBack := TRUE;
            
            // new Line
            (pText$^UINT)^ := XML_CR_UNI;
            Index += 2;
            pText := FileText + Index;
            if Index > MaxFileSize$UDINT then
              return;
            end_if;
            (pText$^UINT)^ := XML_LF_UNI;
            Index += 2;
            pText := FileText + Index;
            if Index > MaxFileSize$UDINT then
              return;
            end_if;
            
          end_if;
          
        end_if;
      
      end_if;
      
    end_while;
    
  end_if;
  
  // now close the Major Element
  (pText$^UINT)^ := XML_START_UNI;
  Index += 2;
  pText := FileText + Index;
  if Index > MaxFileSize$UDINT then
    return;
  end_if;
  (pText$^UINT)^ := XML_SLASH_UNI;
  Index += 2;
  pText := FileText + Index;
  if Index > MaxFileSize$UDINT then
    return;
  end_if;
  
  Index += SigCLib.StrLen16(pElement^.Name$^UINT) * 2;
  if Index > MaxFileSize$UDINT then
    return;
  end_if;
  SigCLib.StrCpy16(pText$^UINT, pElement^.Name$^UINT);
  pText := FileText + Index;
  
  (pText$^UINT)^ := XML_END_UNI;
  Index += 2;
  pText := FileText + Index;
  if Index > MaxFileSize$UDINT then
    return;
  end_if;

  // when we reached this point without any problems we created the whole .xml-File as a String - well done!
  retcode := TRUE;
  
END_FUNCTION //CreateXmlStringUni


FUNCTION _XMLWriter::FileIsUnicode
	VAR_INPUT
		Param 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  //returns true if encoding is unicode (ff fe in the beginning) <- (this means BOM = LittleEndian)
  if (Param^ = XML_START) & ((Param+1)^ = 16#00) then
    retcode := TRUE; 
  else
    retcode := FALSE;
  end_if;
  
END_FUNCTION


FUNCTION GLOBAL _XMLWriter::GetXmlState
	VAR_OUTPUT
		state 	: _XML_STATE;
	END_VAR
  
  state := XmlState;
  
END_FUNCTION


FUNCTION GLOBAL _XMLWriter::GetErrorState
	VAR_OUTPUT
		state 	: _XML_ERROR_STATE;
	END_VAR
  
  state := XmlError;
  
END_FUNCTION


FUNCTION _XMLWriter::XmlWriteTask

  while 1 do
    
    if doCreate = TRUE then
      
      if CreateXmlString() then
        isStringCreated := TRUE;
      else
        XmlState := _XML_ERROR;
        XmlError := _CREATING_FAILED;
      end_if;
      
      doCreate := FALSE;
      
    end_if;
    
    MultiTask.TASKDELAY(XMLWRITER_TASKDELAY);
    
  end_while;

END_FUNCTION


FUNCTION _XMLWriter::CreateTaskName
	VAR_INPUT
		pName 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	udCRC32       : UDINT;
    udStrLen      : UDINT;
    szObjectName  : ARRAY [0..255] OF CHAR;
    szCRC32       : ARRAY [0..15]  OF CHAR;
  END_VAR

  retcode := FALSE;
  
  if pName = NIL then
    return;
  end_if;
  
  SigCLib.StrCpy(dst0 := pName,
                 src0 := XMLWRITER_TASKNAME);

  _GetObjName(pThis := this,
              pName := #szObjectName[0]);

  udStrLen := SigCLib.StrLen(str := #szObjectName[0]);

  udCRC32  := CheckSum.CRC32(pBuffer  := #szObjectName[0],
                             len      := udStrLen,
                             CrcStart := 0);

  SigCLib.IToA(val  := udCRC32$DINT,
                 dst  := #szCRC32[0],
                 base := 0x10);

  SigCLib.StrCat(ps1 := pName,
                   ps2 := #szCRC32[0]);
  
  retcode := TRUE;
  
END_FUNCTION


FUNCTION GLOBAL _XMLWriter::ConvertTextToXML
	VAR_INPUT
		pDest 	: ^void;
		pSrc 	: ^void;
		size 	: UINT;
	END_VAR
	VAR_OUTPUT
		length 	: DINT;
	END_VAR
  
  if ((pDest = NIL) | (pSrc = NIL)) then
    length := -1;
    return;
  end_if;
  
  // initialise retcode with -2 (not supported char size)
  length := -2;
  
  if (size = 1) then
    length := ConvertTextToXMLAscii(pDest$^CHAR, pSrc$^CHAR);
  elsif (size = 2) then
    length := ConvertTextToXMLUni(pDest$^UINT, pSrc$^UINT);
  end_if;

  
END_FUNCTION

FUNCTION _XMLWriter::ConvertTextToXMLAscii
	VAR_INPUT
		pDest 	: ^CHAR;
		pSrc 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		length 	: DINT;
	END_VAR
  VAR
  	pSearch   : ^CHAR;  // pointer to go through the whole string
    scIndex   : DINT;   // index where we found the special character
    pInsert   : ^CHAR;  // pointer to insert the converted character
    pNewDest  : ^CHAR;  // pointer to new start of destination (used for recursive call)
    pNewSrc   : ^CHAR;  // pointer to new start of source (used for recursive call)
  END_VAR
  
  length := 0;
  
  // go through whole string and replace first sign we find
  // afterwards call method again with changed pSrc and pDest
  scIndex := 0;
  pSearch := pSrc;
  while ((pSearch^ <> 0) 
       & (pSearch^ <> XML_AMPERSAND) 
       & (pSearch^ <> XML_START) 
       & (pSearch^ <> XML_END) 
       & (pSearch^ <> XML_QUOTMARK) 
       & (pSearch^ <> XML_APOSTROPHE)) do
    
    scIndex += 1;
    pSearch += sizeof(CHAR);
  end_while;  
  
  // copy part of string to destination, where no special character was detected
  if scIndex > 0 then
    SigCLib.MemCpy(pDest, pSrc, scIndex$UDINT);
  end_if;
  
  pInsert := pDest + scIndex;
  length += scIndex;
  
  case pSearch^ of
    XML_AMPERSAND:
      SigCLib.StrCpy(pInsert, XML_CONVERT_AMPERSAND);
      length$UDINT += SigCLib.StrLen(XML_CONVERT_AMPERSAND);
      
    XML_START:
      SigCLib.StrCpy(pInsert, XML_CONVERT_LESS);
      length$UDINT += SigCLib.StrLen(XML_CONVERT_LESS);
      
    XML_END:
      SigCLib.StrCpy(pInsert, XML_CONVERT_GREATER);
      length$UDINT += SigCLib.StrLen(XML_CONVERT_GREATER);
      
    XML_QUOTMARK:
      SigCLib.StrCpy(pInsert, XML_CONVERT_QUOT);
      length$UDINT += SigCLib.StrLen(XML_CONVERT_QUOT);
      
    XML_APOSTROPHE:
      SigCLib.StrCpy(pInsert, XML_CONVERT_APOS);
      length$UDINT += SigCLib.StrLen(XML_CONVERT_APOS);
      
    // 0-termination found -> finished!
    0:
      pInsert^ := 0;
      return;
    
  end_case;
  
  pNewDest := pDest + length; // new destination is after copied stuff
  pNewSrc := pSearch + sizeof(CHAR); // new source is one character after special char
  
  // now do same work for the rest of the string
  length += ConvertTextToXMLAscii(pNewDest, pNewSrc);
  
END_FUNCTION

FUNCTION _XMLWriter::ConvertTextToXMLUni
	VAR_INPUT
		pDest 	: ^UINT;
		pSrc 	: ^UINT;
	END_VAR
	VAR_OUTPUT
		length 	: DINT;
	END_VAR
  VAR
  	pSearch   : ^UINT;  // pointer to go through the whole string
    scIndex   : DINT;   // index where we found the special character
    pInsert   : ^UINT;  // pointer to insert the converted character
    pNewDest  : ^UINT;  // pointer to new start of destination (used for recursive call)
    pNewSrc   : ^UINT;  // pointer to new start of source (used for recursive call)
    tmpStr    : ARRAY[0..9] OF UINT; //temporary array for convertion to unicode
  END_VAR
  
  length := 0;
  
  // go through whole string and replace first sign we find
  // afterwards call method again with changed pSrc and pDest
  scIndex := 0;
  pSearch := pSrc;
  while ((pSearch^ <> 0) 
       & (pSearch^ <> XML_AMPERSAND_UNI) 
       & (pSearch^ <> XML_START_UNI) 
       & (pSearch^ <> XML_END_UNI) 
       & (pSearch^ <> XML_QUOTMARK_UNI) 
       & (pSearch^ <> XML_APOSTROPHE_UNI)) do
    
    scIndex += 1;
    pSearch += sizeof(UINT);
  end_while;  
  
  // copy part of string to destination, where no special character was detected
  if scIndex > 0 then
    SigCLib.MemCpy(pDest, pSrc, (scIndex$UDINT * sizeof(UINT)));
  end_if;
  
  pInsert := pDest + (scIndex*sizeof(UINT));
  length += scIndex;
  
  _memset(#tmpStr[0], 0, 10*sizeof(UINT));
  
  case pSearch^ of
    XML_AMPERSAND_UNI:
      SigCLib.ToStr16(#tmpStr[0], XML_CONVERT_AMPERSAND);
      SigCLib.StrCpy16(pInsert, #tmpStr[0]);
      length$UDINT += SigCLib.StrLen16(#tmpStr[0]);
      
    XML_START_UNI:
      SigCLib.ToStr16(#tmpStr[0], XML_CONVERT_LESS);
      SigCLib.StrCpy16(pInsert, #tmpStr[0]);
      length$UDINT += SigCLib.StrLen16(#tmpStr[0]);
      
    XML_END_UNI:
      SigCLib.ToStr16(#tmpStr[0], XML_CONVERT_GREATER);
      SigCLib.StrCpy16(pInsert, #tmpStr[0]);
      length$UDINT += SigCLib.StrLen16(#tmpStr[0]);
      
    XML_QUOTMARK_UNI:
      SigCLib.ToStr16(#tmpStr[0], XML_CONVERT_QUOT);
      SigCLib.StrCpy16(pInsert, #tmpStr[0]);
      length$UDINT += SigCLib.StrLen16(#tmpStr[0]);
      
    XML_APOSTROPHE_UNI:
      SigCLib.ToStr16(#tmpStr[0], XML_CONVERT_APOS);
      SigCLib.StrCpy16(pInsert, #tmpStr[0]);
      length$UDINT += SigCLib.StrLen16(#tmpStr[0]);
      
    // 0-termination found -> finished!
    0:
      pInsert^ := 0;
      return;
    
  end_case;
  
  pNewDest := pDest + (length*sizeof(UINT)); // new destination is after copied stuff
  pNewSrc := pSearch + sizeof(UINT); // new source is one character after special char
  
  // now do same work for the rest of the string
  length += ConvertTextToXMLUni(pNewDest, pNewSrc);
  
END_FUNCTION


FUNCTION _XMLWriter::CalculateConvertedSizeAscii
	VAR_INPUT
		pText 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		length 	: UDINT;
	END_VAR
  VAR
  	scCounter : UDINT;
    pSearch : ^CHAR;
    signCount : UDINT;
  END_VAR
  
  length := 0;
  
  scCounter := 0;
  signCount := 0;
  pSearch := pText;
  
  while (pSearch^ <> 0) do
    
    if (pSearch^ = XML_AMPERSAND) then
      scCounter += 1;
    end_if;
    
    signCount += 1;
    pSearch += sizeof(CHAR);
  end_while;
  
  length := signCount + (5*scCounter); // maximum size of special character is 6 (-1 because special character gets replaced)
  
END_FUNCTION


FUNCTION _XMLWriter::CalculateConvertedSizeUni
	VAR_INPUT
		pText 	: ^UINT;
	END_VAR
	VAR_OUTPUT
		length 	: UDINT;
	END_VAR
  VAR
  	scCounter : UDINT;
    pSearch : ^UINT;
    signCount : UDINT;
  END_VAR
  
  length := 0;
  
  scCounter := 0;
  signCount := 0;
  pSearch := pText;
  
  while (pSearch^ <> 0) do
    
    if (pSearch^ = XML_AMPERSAND_UNI) then
      scCounter += 1;
    end_if;
    
    signCount += 1;
    pSearch += sizeof(UINT);
  end_while;
  
  length := signCount + (5*scCounter); // maximum size of special character is 6 (-1 because special character gets replaced)
  
END_FUNCTION
